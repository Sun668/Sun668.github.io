<!DOCTYPE html>
<html lang>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunra.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="React Ref">
<meta name="keywords" content="React Ref">
<meta property="og:type" content="article">
<meta property="og:title" content="React 入门系列（二）Ref">
<meta property="og:url" content="https://sunra.top/2021/03/25/react-ref/index.html">
<meta property="og:site_name" content="Origin of Ray">
<meta property="og:description" content="React Ref">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-09-03T00:51:56.807Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React 入门系列（二）Ref">
<meta name="twitter:description" content="React Ref">

<link rel="canonical" href="https://sunra.top/2021/03/25/react-ref/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>React 入门系列（二）Ref | Origin of Ray</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Origin of Ray</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://sunra.top/2021/03/25/react-ref/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
      <meta itemprop="name" content="Ray Sun">
      <meta itemprop="description" content="拨开互联网的迷雾">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Origin of Ray">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React 入门系列（二）Ref
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-25 19:47:03" itemprop="dateCreated datePublished" datetime="2021-03-25T19:47:03+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-03 08:51:56" itemprop="dateModified" datetime="2021-09-03T08:51:56+08:00">2021-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          
            <div class="post-description">React Ref</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一篇博客我大概记录了一下react官方文档中关于核心概念的一些内容和想法，很多内容都是我基于对Vue的理解基础上的猜测。</p>
<p>从这篇博客开始继续去阅读高级指引，本次博客的主题就是React中的Ref。</p>
<a id="more"></a>
<h2 id="Ref的作用"><a href="#Ref的作用" class="headerlink" title="Ref的作用"></a>Ref的作用</h2><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>
<p>在典型的 React 数据流中，<a href="https://zh-hans.reactjs.org/docs/components-and-props.html" rel="external nofollow noopener noreferrer" target="_blank">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p>
<p>上面这段话摘自官方文档，简单来说，就是正常情况下，我们只能通过修改state或者prop来触发组件的重新渲染，但是，Ref提供了一种新的方式，可以让你直接去修改自定义组件或者DOM。</p>
<h2 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h2><p>下面是几个适合使用 refs 的情况：</p>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p>
<p>举个例子，避免在 <code>Dialog</code> 组件里暴露 <code>open()</code> 和 <code>close()</code> 方法，最好传递 <code>isOpen</code> 属性。</p>
<h3 id="什么是声明式"><a href="#什么是声明式" class="headerlink" title="什么是声明式"></a>什么是声明式</h3><p>上面这段话里面提到了声明式，那么什么是声明式呢？</p>
<p>简单来说，就是一种编程范式，它和命令式变成，函数式编程，面向对象编程是同级的概念。</p>
<p>所谓的声明式，就是表明目的，但是不具体指定怎么做。</p>
<p>就像文档中的这个例子，<code>open()</code>是声明式的编程范式，它只说明了目的，而不具体指定怎么做，如果是<code>isOpen=true</code>，那就是命令式的，就是告诉怎么做了，做法就是把isOpen置为true。</p>
<p>具体的可以去看一下：<a href="https://segmentfault.com/a/1190000015924762" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000015924762</a></p>
<h2 id="勿过度使用-Refs"><a href="#勿过度使用-Refs" class="headerlink" title="勿过度使用 Refs"></a>勿过度使用 Refs</h2><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://zh-hans.reactjs.org/docs/lifting-state-up.html" rel="external nofollow noopener noreferrer" target="_blank">状态提升</a> 以获取更多有关示例。</p>
<h2 id="如何使用Ref"><a href="#如何使用Ref" class="headerlink" title="如何使用Ref"></a>如何使用Ref</h2><h3 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h3><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();  </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h3><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure>
<p>ref 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li>
</ul>
<h4 id="为-DOM-元素添加-ref"><a href="#为-DOM-元素添加-ref" class="headerlink" title="为 DOM 元素添加 ref"></a>为 DOM 元素添加 ref</h4><p>以下代码使用 <code>ref</code> 去存储 DOM 节点的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    // 创建一个 ref 来存储 textInput 的 DOM 元素</span><br><span class="line">    this.textInput = React.createRef();    </span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // 直接使用原生 API 使 text 输入框获得焦点</span><br><span class="line">    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br><span class="line">    this.textInput.current.focus();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br><span class="line">    // 构造器里创建的 `textInput` 上</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.textInput&#125; /&gt;        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<blockquote>
<p>通过这句话，我们可以大致猜测一下：</p>
<ul>
<li>在react的源码中，当通过html-parser解析到这里的时候，应该是有一段判断当前组件是否是原生DOM的逻辑，如果是，那么就把这个DOM赋值给<code>this.textInput.current</code></li>
<li>在react的组件生命周期执行序列之间，应该有一段逻辑是去更新ref的。这样才能保证<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</li>
</ul>
</blockquote>
<h4 id="为-class-组件添加-Ref"><a href="#为-class-组件添加-Ref" class="headerlink" title="为 class 组件添加 Ref"></a>为 class 组件添加 Ref</h4><p>如果我们想包装上面的 <code>CustomTextInput</code>，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 <code>focusTextInput</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.textInput.current.focusTextInput();  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，这仅在 <code>CustomTextInput</code> 声明为 class 时才有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过这个例子，我们可以回头理解刚才我们说的：当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</p>
<p>也就是说在这个<code>AutoFocusTextInput</code>组件中，我们又创建了一个新的ref，虽然还叫作<code>textInput</code>，但是这个时候的<code>textInput.current</code>指向的就是<code>CustomTextInput</code>真正挂载的实例，也就是new CustomTestInput()这个实例（这里我们可以大胆猜测下，<customtextinput>背后对应的逻辑，应该是new一个实例出来），那么好，当前我们的<code>textInput.current</code>就是我们刚创建的这个实例，我们就可以调用这个实例上的方法，也就是<code>focusTextInput()</code></customtextinput></p>
</blockquote>
<h4 id="Refs-与函数组件"><a href="#Refs-与函数组件" class="headerlink" title="Refs 与函数组件"></a>Refs 与函数组件</h4><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function MyFunctionComponent() &#123;  return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // This will *not* work!</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt;    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从这段来看，上面所说的自定义组件其实是调用了new的说法可能是有问题的。</p>
<p>以为，如果是直接调用的new，那么只有两种解释：</p>
<ul>
<li>第一，new Class和new Function不同，这一点我过一段时间回去看看class的源码再回来填坑。</li>
<li>第二，那就是react源码对于Class和Function做了不同的处理，所以Function的声明方式没有创建实例出来。</li>
</ul>
</blockquote>
<p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" rel="external nofollow noopener noreferrer" target="_blank"><code>forwardRef</code></a>（可与 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="external nofollow noopener noreferrer" target="_blank"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p>
<p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  // 这里必须声明 textInput，这样 ref 才可以引用它  const textInput = useRef(null);</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    textInput.current.focus();  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;text&quot;</span><br><span class="line">        ref=&#123;textInput&#125; /&gt;      &lt;input</span><br><span class="line">        type=&quot;button&quot;</span><br><span class="line">        value=&quot;Focus the text input&quot;</span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的forwardRef等会讲Ref转发的时候再说。</p>
</blockquote>
<h3 id="将-DOM-Refs-暴露给父组件"><a href="#将-DOM-Refs-暴露给父组件" class="headerlink" title="将 DOM Refs 暴露给父组件"></a>将 DOM Refs 暴露给父组件</h3><p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。</p>
<p>虽然你可以<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component" rel="external nofollow noopener noreferrer" target="_blank">向子组件添加 ref</a>，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数组件上无效。</p>
<p>如果你使用 16.3 或更高版本的 React, 这种情况下我们推荐使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" rel="external nofollow noopener noreferrer" target="_blank">ref 转发</a>。<strong>Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref</strong>。关于怎样对父组件暴露子组件的 DOM 节点，在 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components" rel="external nofollow noopener noreferrer" target="_blank">ref 转发文档</a>中有一个详细的例子。</p>
<p>如果你使用 16.2 或更低版本的 React，或者你需要比 ref 转发更高的灵活性，你可以使用<a href="https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509" rel="external nofollow noopener noreferrer" target="_blank">这个替代方案</a>将 ref 作为特殊名字的 prop 直接传递。</p>
<p>可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这个方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#finddomnode" rel="external nofollow noopener noreferrer" target="_blank"><code>findDOMNode()</code></a>，但在<a href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage" rel="external nofollow noopener noreferrer" target="_blank"><code>严格模式</code></a> 下已被废弃且不推荐使用。</p>
<h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p>
<p>不同于传递 <code>createRef()</code> 创建的 <code>ref</code> 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。</p>
<p>下面的例子描述了一个通用的范例：使用 <code>ref</code> 回调函数，在实例的属性中存储对 DOM 节点的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput = null;</span><br><span class="line">    this.setTextInputRef = element =&gt; &#123;      this.textInput = element;    &#125;;</span><br><span class="line">    this.focusTextInput = () =&gt; &#123;      // 使用原生 DOM API 使 text 输入框获得焦点      </span><br><span class="line">    	if (this.textInput) this.textInput.focus();    </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 组件挂载后，让文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span><br><span class="line">    // 实例上（比如 this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.setTextInputRef&#125;        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 将在组件挂载时，会调用 <code>ref</code> 回调函数并传入 DOM 元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 refs 一定是最新的。</p>
<blockquote>
<p>这里有小伙伴可能会钻牛角尖，凭什么传入一个函数，就会被调用啊。</p>
<p>答案很简单，React源码中对于ref属性肯定是有特殊处理的，如果它的值是一个函数，回去调用它。</p>
<p>如果这样猜想，那你其实传进去任何函数，他都会执行，不一定要在函数中设置ref，在ref属性传入的函数中设置一个ref，应该只是约定而已。</p>
</blockquote>
<p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 <code>React.createRef()</code> 创建的对象 refs 一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Parent</code> 把它的 refs 回调函数当作 <code>inputRef</code> props 传递给了 <code>CustomTextInput</code>，而且 <code>CustomTextInput</code> 把相同的函数作为特殊的 <code>ref</code> 属性传递给了 <code>&lt;input&gt;</code>。结果是，在 <code>Parent</code> 中的 <code>this.inputElement</code> 会被设置为与 <code>CustomTextInput</code> 中的 <code>input</code> 元素相对应的 DOM 节点。</p>
<h4 id="关于回调-refs-的说明"><a href="#关于回调-refs-的说明" class="headerlink" title="关于回调 refs 的说明"></a>关于回调 refs 的说明</h4><p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<h2 id="Ref转发"><a href="#Ref转发" class="headerlink" title="Ref转发"></a>Ref转发</h2><p>Ref 转发是一项将 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">ref</a> 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。最常见的案例如下所述。</p>
<h3 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h3><p>考虑这个渲染原生 DOM 元素 <code>button</code> 的 <code>FancyButton</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FancyButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className=&quot;FancyButton&quot;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 组件隐藏其实现细节，包括其渲染结果。其他使用 <code>FancyButton</code> 的组件<strong>通常不需要</strong>获取内部的 DOM 元素 <code>button</code> 的 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">ref</a>。这很好，因为这防止组件过度依赖其他组件的 DOM 结构。</p>
<p>虽然这种封装对类似 <code>FeedStory</code> 或 <code>Comment</code> 这样的应用级组件是理想的，但其对 <code>FancyButton</code> 或 <code>MyTextInput</code> 这样的高可复用“叶”组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规 DOM <code>button</code> 和 <code>input</code> 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。</p>
<p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong></p>
<p>在下面的示例中，<code>FancyButton</code> 使用 <code>React.forwardRef</code> 来获取传递给它的 <code>ref</code>，然后转发到它渲染的 DOM <code>button</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (  </span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;    </span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 你可以直接获取 DOM button 的 ref：</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<p>这样，使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref ，并在必要时访问，就像其直接使用 DOM <code>button</code> 一样。</p>
<p>以下是对上述示例发生情况的逐步解释：</p>
<ol>
<li>我们通过调用 <code>React.createRef</code> 创建了一个 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">React ref</a> 并将其赋值给 <code>ref</code> 变量。</li>
<li>我们通过指定 <code>ref</code> 为 JSX 属性，将其向下传递给 <code>&lt;FancyButton ref={ref}&gt;</code>。</li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code>，作为其第二个参数。</li>
<li>我们向下转发该 <code>ref</code> 参数到 <code>&lt;button ref={ref}&gt;</code>，将其指定为 JSX 属性。</li>
<li>当 ref 挂载完成，<code>ref.current</code> 将指向 <code>&lt;button&gt;</code> DOM 节点。</li>
</ol>
<blockquote>
<p>注意</p>
<p>第二个参数 <code>ref</code> 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 <code>ref</code> 参数，且 props 中也不存在 <code>ref</code>。</p>
<p>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</p>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Ray Sun
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://sunra.top/2021/03/25/react-ref/" title="React 入门系列（二）Ref">https://sunra.top/2021/03/25/react-ref/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/18/react-grammar/" rel="prev" title="React入门系列（一）语法与概念初读">
      <i class="fa fa-chevron-left"></i> React入门系列（一）语法与概念初读
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/28/es6-class-source-code/" rel="next" title="ES6 Class 源码分析">
      ES6 Class 源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref的作用"><span class="nav-number">1.</span> <span class="nav-text">Ref的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何时使用-Refs"><span class="nav-number">2.</span> <span class="nav-text">何时使用 Refs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是声明式"><span class="nav-number">2.1.</span> <span class="nav-text">什么是声明式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#勿过度使用-Refs"><span class="nav-number">3.</span> <span class="nav-text">勿过度使用 Refs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用Ref"><span class="nav-number">4.</span> <span class="nav-text">如何使用Ref</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-Refs"><span class="nav-number">4.1.</span> <span class="nav-text">创建 Refs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问-Refs"><span class="nav-number">4.2.</span> <span class="nav-text">访问 Refs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为-DOM-元素添加-ref"><span class="nav-number">4.2.1.</span> <span class="nav-text">为 DOM 元素添加 ref</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为-class-组件添加-Ref"><span class="nav-number">4.2.2.</span> <span class="nav-text">为 class 组件添加 Ref</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Refs-与函数组件"><span class="nav-number">4.2.3.</span> <span class="nav-text">Refs 与函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将-DOM-Refs-暴露给父组件"><span class="nav-number">4.3.</span> <span class="nav-text">将 DOM Refs 暴露给父组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调-Refs"><span class="nav-number">4.4.</span> <span class="nav-text">回调 Refs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于回调-refs-的说明"><span class="nav-number">4.4.1.</span> <span class="nav-text">关于回调 refs 的说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref转发"><span class="nav-number">5.</span> <span class="nav-text">Ref转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转发-refs-到-DOM-组件"><span class="nav-number">5.1.</span> <span class="nav-text">转发 refs 到 DOM 组件</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
  <p class="site-author-name" itemprop="name">Ray Sun</p>
  <div class="site-description" itemprop="description">拨开互联网的迷雾</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">252</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sun668" title="GitHub → https://github.com/Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <div class="wechat_channel" style="width: 50%;margin-left: 25%;">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src="/images/wechat_channel.png">
        <!-- <span>公众号</span> -->
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Sun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  <script src="/js/local-search.js"></script>












  

  

  

</body>
</html>
