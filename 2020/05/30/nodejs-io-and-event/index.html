<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="nodejs的两大特性，即异步IO和事件驱动。通过对***《深入浅出nodejs》***和几篇博客的阅读以后，有了大致的了解，总结一下。 注意本文的内容基于node11以上。  同步与异步，阻塞与非阻塞 “阻塞”与&quot;非阻塞&quot;与&quot;同步&quot;与“异步&quot;不能简单的从字面理解，提供一个从分布式系统角度的回答。 1.同步与异步 同步和异步关注的是消息通信机制 ("><meta property="og:type" content="article"><meta property="og:title" content="Nodejs 异步IO与事件驱动"><meta property="og:url" content="https://sunra.top/2020/05/30/nodejs-io-and-event/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="nodejs的两大特性，即异步IO和事件驱动。通过对***《深入浅出nodejs》***和几篇博客的阅读以后，有了大致的了解，总结一下。 注意本文的内容基于node11以上。  同步与异步，阻塞与非阻塞 “阻塞”与&quot;非阻塞&quot;与&quot;同步&quot;与“异步&quot;不能简单的从字面理解，提供一个从分布式系统角度的回答。 1.同步与异步 同步和异步关注的是消息通信机制 ("><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://segmentfault.com/img/remote/1460000005173228"><meta property="og:image" content="https://segmentfault.com/img/remote/1460000006792647"><meta property="article:published_time" content="2020-05-30T00:07:24.000Z"><meta property="article:modified_time" content="2024-10-18T03:09:06.700Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000005173228"><link rel="canonical" href="https://sunra.top/2020/05/30/nodejs-io-and-event/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunra.top/2020/05/30/nodejs-io-and-event/","path":"2020/05/30/nodejs-io-and-event/","title":"Nodejs 异步IO与事件驱动"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Nodejs 异步IO与事件驱动 | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.</span> <span class="nav-text">同步与异步，阻塞与非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">2.</span> <span class="nav-text">几个例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#example-1"><span class="nav-number">2.1.</span> <span class="nav-text">example 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-2"><span class="nav-number">2.2.</span> <span class="nav-text">example 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-3"><span class="nav-number">2.3.</span> <span class="nav-text">example 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-4"><span class="nav-number">2.4.</span> <span class="nav-text">example 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-5"><span class="nav-number">2.5.</span> <span class="nav-text">example 5</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5ioasynchronous-io"><span class="nav-number">3.</span> <span class="nav-text">异步IO(asynchronous I&#x2F;O)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9Eio-%E5%92%8C-%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="nav-number">3.1.</span> <span class="nav-text">阻塞I&#x2F;O 和 非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5io-%E5%92%8C-%E5%BC%82%E6%AD%A5io"><span class="nav-number">3.2.</span> <span class="nav-text">同步I&#x2F;O 和 异步I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-number">4.</span> <span class="nav-text">事件驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%A9%B1%E5%8A%A8%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-number">4.1.</span> <span class="nav-text">线程驱动和事件驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nodejs%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BC%82%E6%AD%A5io"><span class="nav-number">5.</span> <span class="nav-text">nodejs的事件驱动和异步I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">事件驱动模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFeventloop%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E4%BD%9C%E7%9A%84"><span class="nav-number">5.2.</span> <span class="nav-text">JS的事件循环(eventloop)是怎么运作的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%AD%94%E6%A1%88"><span class="nav-number">6.</span> <span class="nav-text">问题答案</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">一起探索互联网的秘密</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">317</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sunra.top/2020/05/30/nodejs-io-and-event/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="一起探索互联网的秘密"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Nodejs 异步IO与事件驱动 | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Nodejs 异步IO与事件驱动</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-30 08:07:24" itemprop="dateCreated datePublished" datetime="2020-05-30T08:07:24+08:00">2020-05-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-10-18 11:09:06" itemprop="dateModified" datetime="2024-10-18T11:09:06+08:00">2024-10-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline：</span><a title="waline" href="/2020/05/30/nodejs-io-and-event/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/2020/05/30/nodejs-io-and-event/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p><code>nodejs</code>的两大特性，即<code>异步IO</code>和<code>事件驱动</code>。通过对***《深入浅出nodejs》***和几篇博客的阅读以后，有了大致的了解，总结一下。</p><p><strong>注意本文的内容基于node11以上。</strong></p><h2 id="同步与异步阻塞与非阻塞"><a class="markdownIt-Anchor" href="#同步与异步阻塞与非阻塞"></a> 同步与异步，阻塞与非阻塞</h2><p>“阻塞”与&quot;非阻塞&quot;与&quot;同步&quot;与“异步&quot;不能简单的从字面理解，提供一个从分布式系统角度的回答。<br> <strong>1.同步与异步</strong><br> 同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br> 所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br> 换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<em><strong>调用*在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在</em>调用*发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><span id="more"></span><p>典型的异步编程模型比如Node.js</p><p>举个通俗的例子：<br> 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br> 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><p>\2. 阻塞与非阻塞<br> 阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br> 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>还是上面的例子，<br> 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br> 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><h2 id="几个例子"><a class="markdownIt-Anchor" href="#几个例子"></a> 几个例子</h2><p>在开始之前，先来看几个简单例子，这也是我在使用<code>nodejs</code>时候遇到的几个比较困惑的例子。</p><hr><h3 id="example-1"><a class="markdownIt-Anchor" href="#example-1"></a> example 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example1&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;);</span><br><span class="line">/** 运行结果</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 begin</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 end</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 timeout1</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 timeout2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>question 1</strong></p><blockquote><p>为何<code>timeout1</code>和<code>timeout2</code>的结果会在<code>end</code>后面？</p></blockquote><hr><h3 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> example 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example2&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;);</span><br><span class="line"></span><br><span class="line">while(true);</span><br><span class="line">/**  运行结果</span><br><span class="line">Sat, 21 May 2016 08:45:47 GMT example2 begin</span><br><span class="line">Sat, 21 May 2016 08:45:47 GMT example2 end</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>question 2</strong></p><blockquote><p>为何<code>timeout1</code>和<code>timeout2</code>没有输出到终端？<code>while(true)</code>到底阻塞了什么？</p></blockquote><hr><h3 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> example 3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example3&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">    while (true);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;);</span><br><span class="line">/**  运行结果</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 begin</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 end</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 timeout1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>question 3</strong></p><blockquote><p>为什么<code>timeout1</code>中回调函数会阻塞<code>timeout2</code>中的回调函数的执行？</p></blockquote><hr><h3 id="example-4"><a class="markdownIt-Anchor" href="#example-4"></a> example 4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example4&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 模拟计算密集</span><br><span class="line">     */</span><br><span class="line">    for(var i = 0 ; i &lt; 1000000 ; ++i)&#123;</span><br><span class="line">        for(var j = 0 ; j &lt; 100000 ; ++j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;);</span><br><span class="line">/**</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 begin</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 end</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 timeout1</span><br><span class="line">Sat, 21 May 2016 08:54:09 GMT example4 timeout2  //注意这里的时间晚了好久</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>question 4</strong></p><blockquote><p>和上面的问题一样，为何<code>timeout1</code>的计算密集型工作将会阻塞<code>timeout2</code>的回调函数的执行？</p></blockquote><hr><h3 id="example-5"><a class="markdownIt-Anchor" href="#example-5"></a> example 5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example5&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;package.json&#x27;,&#x27;utf-8&#x27;,function(err,data)&#123;</span><br><span class="line">    if(err)  </span><br><span class="line">        debug(err);</span><br><span class="line">    else</span><br><span class="line">        debug(&quot;get file content&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;);</span><br><span class="line">/** 运行结果</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 begin</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 end</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 timeout2</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 get file content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>question 5</strong></p><blockquote><p>为何读取文件的<code>IO</code>操作不会阻塞<code>timeout2</code>的执行？</p></blockquote><hr><p>接下来我们就带着上面几个疑惑去理解<code>nodejs</code>中的<code>异步IO</code>和<code>事件驱动</code>是如何工作的。</p><h2 id="异步ioasynchronous-io"><a class="markdownIt-Anchor" href="#异步ioasynchronous-io"></a> 异步IO(asynchronous I/O)</h2><p>首先来理解几个容易混淆的概念，<code>阻塞IO(blocking I/O)</code>和<code>非阻塞IO(non-blocking I/O)</code>，<code>同步IO(synchronous I/O)和异步IO(synchronous I/O)</code>。</p><p>博主一直天真的以为<code>非阻塞I/O</code>就是<code>异步I/O</code> T_T，<code>apue</code>一直没有读懂。</p><h3 id="阻塞io-和-非阻塞io"><a class="markdownIt-Anchor" href="#阻塞io-和-非阻塞io"></a> 阻塞I/O 和 非阻塞I/O</h3><p>简单来说，<strong>阻塞I/O</strong>就是当用户发一个读取文件描述符的操作的时候，进程就会被阻塞，直到要读取的数据全部准备好返回给用户，这时候进程才会解除<code>block</code>的状态。</p><p>那<strong>非阻塞I/O</strong>呢，就与上面的情况相反，用户发起一个读取文件描述符操作的时，函数立即返回，不作任何等待，进程继续执行。但是程序如何知道要读取的数据已经准备好了呢？最简单的方法就是轮询。</p><p>除此之外，还有一种叫做<code>IO多路复用</code>的模式，就是用一个阻塞函数同时监听多个文件描述符，当其中有一个文件描述符准备好了，就马上返回，在<code>linux</code>下，<code>select</code>,<code>poll</code>,<code>epoll</code>都提供了<code>IO多路复用</code>的功能。</p><h3 id="同步io-和-异步io"><a class="markdownIt-Anchor" href="#同步io-和-异步io"></a> 同步I/O 和 异步I/O</h3><p>那么<code>同步I/O</code>和<code>异步I/O</code>又有什么区别么？是不是只要做到<code>非阻塞IO</code>就可以实现<code>异步I/O</code>呢？</p><p>其实不然。</p><ul><li><code>同步I/O(synchronous I/O)</code>做<code>I/O operation</code>的时候会将process阻塞,所以<code>阻塞I/O</code>，<code>非阻塞I/O</code>，<code>IO多路复用I/O</code>都是<code>同步I/O</code>。</li><li><code>异步I/O(asynchronous I/O)</code>做<code>I/O opertaion</code>的时候将不会造成任何的阻塞。</li></ul><p><code>非阻塞I/O</code>都不阻塞了为什么不是<code>异步I/O</code>呢？其实当<code>非阻塞I/O</code>准备好数据以后还是要阻塞住进程去内核拿数据的。所以算不上<code>异步I/O</code>。</p><p>这里借一张图(图来自<a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&amp;utm_medium=shareLink&amp;utm_campaign=socialShare">这里</a>)来说明他们之间的区别</p><p><img src="https://segmentfault.com/img/remote/1460000005173228" alt></p><h2 id="事件驱动"><a class="markdownIt-Anchor" href="#事件驱动"></a> 事件驱动</h2><p><code>事件驱动(event-driven)</code>是<code>nodejs</code>中的第二大特性。何为<code>事件驱动</code>呢？简单来说，就是通过监听事件的状态变化来做出相应的操作。比如读取一个文件，文件读取完毕，或者文件读取错误，那么就触发对应的状态，然后调用对应的回掉函数来进行处理。</p><h3 id="线程驱动和事件驱动"><a class="markdownIt-Anchor" href="#线程驱动和事件驱动"></a> 线程驱动和事件驱动</h3><p>那么<code>线程驱动</code>编程和<code>事件驱动</code>编程之间的区别是什么呢？</p><ul><li><code>线程驱动</code>就是当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。一般存在一个线程池，线程池中有空闲的线程，会从线程池中拿取线程来进行处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程。</li><li><code>事件驱动</code>就是当进来一个新的请求的时，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。</li></ul><p>对于<code>事件驱动</code>编程来说，如果某个时间的回调函数是<code>计算密集型</code>，或者是<code>阻塞I/O</code>,那么这个回调函数将会阻塞后面所有事件回调函数的执行。这一点尤为重要。</p><h2 id="nodejs的事件驱动和异步io"><a class="markdownIt-Anchor" href="#nodejs的事件驱动和异步io"></a> nodejs的事件驱动和异步I/O</h2><h3 id="事件驱动模型"><a class="markdownIt-Anchor" href="#事件驱动模型"></a> 事件驱动模型</h3><p>上面介绍了那么多的概念，现在我们来看看<code>nodejs</code>中的<code>事件驱动</code>和<code>异步I/O</code>是如何实现的.</p><p><code>nodejs</code>是<strong>单线程(single thread)<strong>运行的，通过一个</strong>事件循环(event-loop)<strong>来循环取出</strong>消息队列(event-queue)<strong>中的消息进行处理,处理过程基本上就是去调用该</strong>消息</strong>对应的回调函数。<strong>消息队列</strong>就是当一个事件状态发生变化时，就将一个消息压入队列中。</p><p><code>nodejs</code>的时间驱动模型一般要注意下面几个点：</p><ul><li>因为是<strong>单线程</strong>的，所以当顺序执行<code>js</code>文件中的代码的时候，<strong>事件循环</strong>是被暂停的。</li><li>当<code>js</code>文件执行完以后，<strong>事件循环</strong>开始运行，并从<strong>消息队列</strong>中取出消息，开始执行回调函数</li><li>因为是<strong>单线程</strong>的，所以当回调函数被执行的时候，<strong>事件循环</strong>是被暂停的</li><li>当涉及到I/O操作的时候，<code>nodejs</code>会开一个独立的线程来进行<code>异步I/O</code>操作，操作结束以后将消息压入<strong>消息队列</strong>。</li></ul><p>下面我们从一个简单的<code>js</code>文件入手，来看看 <code>nodejs</code>是如何执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&#x27;debug&#x27;)(&#x27;example1&#x27;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;package.json&#x27;,&#x27;utf-8&#x27;,function(err,data)&#123;</span><br><span class="line">    if(err)  </span><br><span class="line">        debug(err);</span><br><span class="line">    else</span><br><span class="line">        debug(&quot;get file content&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&#x27;end&#x27;); // 运行到这里之前，事件循环是暂停的</span><br></pre></td></tr></table></figure><ol><li>同步执行<code>debug(&quot;begin&quot;)</code></li><li>异步调用<code>fs.readFile()</code>，此时会开一个新的线程去进行<code>异步I/O</code>操作</li><li>异步调用<code>setTimeout()</code>，马上将超时信息压入到<strong>消息队列</strong>中</li><li>同步调用<code>debug(&quot;end&quot;)</code></li><li>开启<strong>事件循环</strong>，弹出<strong>消息队列</strong>中的信息(目前是超时信息)</li><li>然后执行信息对应的回调函数(<strong>事件循环</strong>又被暂停)</li><li><strong>回调函数</strong>执行结束后，开始<strong>事件循环</strong>(目前<strong>消息队列</strong>中没有任何东西，文件还没读完)</li><li><code>异步I/O</code>读取文件完毕，将消息压入**消息队列(**消息中含有文件内容或者是出错信息)</li><li><strong>事件循环</strong>取得消息，执行回调</li><li>程序退出。</li></ol><p>这里借一张图来说明<code>nodejs</code>的事件驱动模型（图来自<a target="_blank" rel="external nofollow noopener noreferrer" href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/">这里</a>）<br> <img src="https://segmentfault.com/img/remote/1460000006792647" alt></p><h3 id="js的事件循环eventloop是怎么运作的"><a class="markdownIt-Anchor" href="#js的事件循环eventloop是怎么运作的"></a> JS的事件循环(eventloop)是怎么运作的？</h3><p>“先执行同步操作异步操作排在事件队列里”这样的理解其实也没有任何问题但如果深入的话会引出来很多其他概念，比如event table和event queue，我们来看运行过程：</p><ol><li>首先判断JS是同步还是异步，同步就进入主线程运行，异步就进入event table。</li><li>异步任务在event table中注册事件，当满足触发条件后（触发条件可能是延时也可能是ajax回调），被推入event queue。</li><li>同步任务进入主线程后一直执行，直到主线程空闲时，才会去event queue中查看是否有可执行的异步任务，如果有就推入主线程中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2秒到了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>我们用上面的第二条来分析一下这段脚本，setTimeout是异步操作首先进入event table，注册的事件就是他的回调，触发条件就是2秒之后，当满足条件回调被推入event queue，当主线程空闲时会去event queue里查看是否有可执行的任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) <span class="comment">// 同步任务进入主线程</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title function_">fun</span>(),<span class="number">0</span>)   <span class="comment">// 异步任务，被放入event table， 0秒之后被推入event queue里</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) <span class="comment">// 同步任务进入主线程</span></span><br></pre></td></tr></table></figure><p>1、3是同步任务马上会被执行，执行完成之后主线程空闲去event queue(事件队列)里查看是否有任务在等待执行，这就是为什么setTimeout的延迟时间是0毫秒却在最后执行的原因。</p><p>关于setTimeout有一点要注意延时的时间有时候并不是那么准确。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2秒到了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="title function_">wait</span>(<span class="number">9999999999</span>)</span><br></pre></td></tr></table></figure><p>分析运行过程：</p><ol><li>console进入Event Table并注册，计时开始。</li><li>执行sleep函数，sleep方法虽然是同步任务但sleep方法进行了大量的逻辑运算，耗时超过了2秒。</li><li>2秒到了，计时事件timeout完成，console进入Event Queue，但是sleep还没执行完，主线程还被占用，只能等着。</li><li>sleep终于执行完了，console终于从Event Queue进入了主线程执行，这个时候已经远远超过了2秒。</li></ol><p>其实延迟2秒只是表示2秒后，setTimeout里的函数被会推入event queue，而event queue(事件队列)里的任务，只有在主线程空闲时才会执行。上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为console)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于2秒。 我们还经常遇到setTimeout(fn，0)这样的代码，它的含义是，指定某个任务在主线程最早的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。但是即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p><p>关于setInterval： 以setInterval(fn，ms)为例，setInterval是循环执行的，setInterval会每隔指定的时间将注册的函数置入Event Queue，不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。需要注意的一点是，一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</p><p>上面的概念很基础也很容易理解但不幸的消息是上面讲的一切都不是绝对的正确，因为涉及到Promise、async/await、process.nextTick(node)所以要对任务有更精细的定义：</p><p><strong>我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</strong></p><p>宏任务(macro-task)：包括整体代码script、setTimeout、setInterval、MessageChannel、postMessage、setImmediate。<br> 微任务(micro-task)：Promise、process.nextTick、MutationObsever。</p><p>在划分宏任务、微任务的时候并没有提到async/await因为async/await的本质就是Promise。</p><p><em><em>事件循环机制到底是怎么样的？ <em>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同(宏任务)的Event Queue。而Promise和process.nextTick会进入相同(微任务)的Event Queue</em></em>。</em></p><ol><li>「宏任务」、「微任务」都是队列，一段代码执行时，会先执行<strong>宏任务中的同步代码</strong>。</li><li>进行<strong>第一轮事件循环的时候会把全部的js脚本当成一个宏任务</strong>来运行。</li><li>如果执行中遇到setTimeout之类宏任务，那么就把这个setTimeout内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。</li><li>如果执行中遇到 promise.then() 之类的微任务，就会推入到「<strong>当前宏任务的微任务队列</strong>」（也就是说这些微任务仍属于当前宏任务）中，在本轮宏任务的同步代码都执行完成后，依次执行所有的微任务。</li><li>第一轮事件循环中当执行完全部的同步脚本以及微任务队列中的事件，这一轮事件循环就结束了，开始第二轮事件循环。</li><li>第二轮事件循环同理<strong>先执行宏任务中的同步脚本</strong>，遇到其他宏任务代码块继续追加到「宏任务的队列」中，遇到微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行当前所有的微任务。</li><li>开始第三轮，循环往复…</li></ol><p>下面用代码来深入理解上面的机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// 同步任务</span></span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>这段代码作为宏任务，进入主线程。</li><li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。</li><li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li><li>遇到console.log()，立即执行。</li><li>整体代码script作为第一个宏任务执行结束。查看当前有没有可执行的微任务，执行then的回调。 （第一轮事件循环结束了，我们开始第二轮循环。）</li><li>从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 执行结果：`1 - 2 - 3 - 4</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)<span class="comment">// 宏任务一</span></span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// 宏任务一的微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务二</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务五</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 宏任务七</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务三</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 宏任务四</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务六</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// 宏任务一</span></span><br></pre></td></tr></table></figure><ol><li>全部的代码作为第一个宏任务进入主线程执行。</li><li>首先输出1，是同步代码。then回调作为微任务进入到宏任务一的微任务队列。</li><li>下面最外层的三个setTimeout分别是宏任务二、宏任务三、宏任务四按序排入宏任务队列。</li><li>输出2，现在宏任务一的同步代码都执行完成了接下来执行宏任务一的微任务输出3。 第一轮事件循环完成了</li><li>现在执行宏任务二输出4，后面的setTimeout作为宏任务五排入宏任务队列。</li><li>执行宏任务三输出5，执行宏任务四输出6，宏任务四里面的setTimeout作为宏任务六。</li><li>执行宏任务五输出7，8。then回调作为宏任务五的微任务排入宏任务五的微任务队列。</li><li>输出同步代码9，宏任务五的同步代码执行完了，现在执行宏任务五的微任务。</li><li>输出10，后面的setTimeout作为宏任务七排入宏任务的队列。 宏任务五执行完成了。</li><li>执行宏任务六输出11，执行宏任务七输出12。</li></ol><p>*<em>-^-*，这个案例是有点恶心，目的是让大家明白各宏任务之间执行的顺序以及宏任务和微任务的执行关系。</em></p><p>我们把主线程（执行队列）中的内容从开始执行到结束叫做一次tick，一旦主线程内容执行完成，就回去宏任务队列头部拿一个加入主线程开始一次新的tick，如果在找个tick期间有其他方法注册了新的微任务或者宏任务本身注册了微任务，则回在本次tick结束之前拿出所有的微任务执行完成。</p><ol><li>在当前tick中添加的微任务都不会留到下一个tick，而是在tick的尾部触发执行</li><li>一个事件循环中，在tick里的任务执行完毕以后，会有一个单独的步骤，叫 Perform a microtask checkpoint，即执行微任务检查点。这个操作是检查否有微任务，如果有，便将微任务队列也会当作执行队列来继续执行，完毕后将执行队列置空。</li><li>同一个tick产生的微任务总是会在宏任务之前被执行，因为本次tick结束之前注册的微任务会在微任务检查点执行，但是宏任务要等到下一次tick。</li></ol><p>（<strong>注意，这里讨论的所有的宏任务和微任务已经是进入event loop中的任务</strong>，也就是异步条件达成后从event table进入event queue的状态）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)<span class="comment">// 宏任务一</span></span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// 宏任务一的微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务二</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务五</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 宏任务七</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务三</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 宏任务四</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 宏任务六</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// 宏任务一</span></span><br></pre></td></tr></table></figure><p>如果进一步在timeout中加入延迟时间，不让他们的回调函数立即进入宏任务队列中，打印顺序又是什么呢？</p><p>先给出答案：1，2，3，6，5，4，7，8，9，10，11，12(或者1，2，3，6，5，4，11， 7，8，9，10，12)</p><blockquote><p>其实完全按照刚才我们讲的逻辑，顺序应该是1，2，3，6，5，4，11， 7，8，9，10，12</p><p>为什么会出现两种不同的可能呢？</p><p>是因为Chrome中根据 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetTimeout">mdn</a> <code>setTimeout()</code>/<code>setInterval()</code> 的每调用一次定时器的最小间隔是4ms，所以被合入了一个宏任务一起执行。宏任务五和六都是嵌套的两个setTimeOut加起来2000ms，先后问题，也有可能被合并了。</p></blockquote><p>这个例子和上面那个例子的不同之处就在于通过设置了不同的timeout时间，使得回调函数按照不同的顺序被推入宏任务队列。</p><h2 id="问题答案"><a class="markdownIt-Anchor" href="#问题答案"></a> 问题答案</h2><p>好，到目前为止，已经可以回答上面的问题了</p><hr><p><strong>question 1</strong></p><blockquote><p>为何<code>timeout1</code>和<code>timeout2</code>的结果会在end后面？</p></blockquote><p><strong>answer 1</strong></p><blockquote><p>因为此时<code>timeout1</code>和<code>timeout2</code>只是被异步函数推入到了队列中，<strong>事件循环</strong>还是暂停状态</p></blockquote><hr><p><strong>question 2</strong></p><blockquote><p>为何<code>timeout1</code>和<code>timeout2</code>没有输出到终端？<code>while(true)</code>到底阻塞了什么？</p></blockquote><p><strong>answer 2</strong></p><blockquote><p>因为此处直接阻塞了<strong>事件循环</strong>，还没开始，就已经被阻塞了</p></blockquote><hr><p><strong>question 3,4</strong></p><blockquote><ol><li>为什么<code>timeout1</code>中回调函数会阻塞<code>timeout2</code>中的回调函数的执行？</li><li>为何<code>timeout1</code>的计算密集型工作将会阻塞<code>timeout2</code>的回调函数的执行？</li></ol></blockquote><p><strong>answer 3,4</strong></p><blockquote><p>因为该回调函数执行返回<strong>事件循环</strong>才会继续执行，回调函数将会阻塞事件循环的运行</p></blockquote><hr><p><strong>question 5</strong></p><blockquote><p>为何读取文件的IO操作不会阻塞<code>timeout2</code>的执行？</p></blockquote><p><strong>answer 5</strong></p><blockquote><p>因为<code>IO</code>操作是异步的，会开启一个新的线程，不会阻塞到<strong>事件循环</strong></p></blockquote><p>参考链接：</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.zhihu.com/question/19732473">https://www.zhihu.com/question/19732473</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000005173218">https://segmentfault.com/a/1190000005173218</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.im/post/5c148ec8e51d4576e83fd836">https://juejin.im/post/5c148ec8e51d4576e83fd836</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Ray Sun</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://sunra.top/2020/05/30/nodejs-io-and-event/" title="Nodejs 异步IO与事件驱动">https://sunra.top/2020/05/30/nodejs-io-and-event/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/05/30/docker-note/" rel="prev" title="Docker 入门笔记"><i class="fa fa-chevron-left"></i> Docker 入门笔记</a></div><div class="post-nav-item"> <a href="/2020/06/02/javascript_async/" rel="next" title="JavaScript 异步编程语法">JavaScript 异步编程语法<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2020/05/30/nodejs-io-and-event/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>