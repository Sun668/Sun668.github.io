<!DOCTYPE html>
<html lang>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunra.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script>
  <meta name="description" content="Blob是什么Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。  如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），t">
<meta name="keywords" content="Blob 大文件">
<meta property="og:type" content="article">
<meta property="og:title" content="Blob 与 大文件分片上传">
<meta property="og:url" content="https://sunra.top/2020/07/24/blob/index.html">
<meta property="og:site_name" content="Origin of Ray">
<meta property="og:description" content="Blob是什么Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。  如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），t">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1595596596/js/image-20200724202124460_csorcu.png">
<meta property="og:updated_time" content="2023-05-25T07:43:35.320Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blob 与 大文件分片上传">
<meta name="twitter:description" content="Blob是什么Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。  如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），t">
<meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1595596596/js/image-20200724202124460_csorcu.png">

<link rel="canonical" href="https://sunra.top/2020/07/24/blob/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Blob 与 大文件分片上传 | Origin of Ray</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-KEJ1L66CKC');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Origin of Ray</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://sunra.top/2020/07/24/blob/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
      <meta itemprop="name" content="Ray Sun">
      <meta itemprop="description" content="拨开互联网的迷雾">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Origin of Ray">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Blob 与 大文件分片上传
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-24 20:15:35" itemprop="dateCreated datePublished" datetime="2020-07-24T20:15:35+08:00">2020-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-25 15:43:35" itemprop="dateModified" datetime="2023-05-25T15:43:35+08:00">2023-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Blob是什么"><a href="#Blob是什么" class="headerlink" title="Blob是什么"></a>Blob是什么</h2><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1595596596/js/image-20200724202124460_csorcu.png" alt="image-20200724202124460"></p>
<p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位），<code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<a id="more"></a>
<h2 id="Blob-API-简介"><a href="#Blob-API-简介" class="headerlink" title="Blob API 简介"></a>Blob API 简介</h2><p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p>
<blockquote>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p>
<p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p>
</blockquote>
<p>相关的参数说明如下：</p>
<ul>
<li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p>
</li>
<li><p>options：一个可选的对象，包含以下两个属性：</p>
</li>
<li><ul>
<li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li>
<li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>前面我们已经知道 Blob 对象包含两个属性：</p>
<ul>
<li>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</li>
<li>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</li>
<li>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</li>
<li>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</li>
<li>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</li>
</ul>
<p>这里我们需要注意的是，<strong><code>Blob</code> 对象是不可改变的</strong>。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p>
<h2 id="大文件分片上传（Vue）"><a href="#大文件分片上传（Vue）" class="headerlink" title="大文件分片上传（Vue）"></a>大文件分片上传（Vue）</h2><h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><h4 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h4><p>首先实现上传功能，上传需要做两件事</p>
<ul>
<li>对文件进行切片</li>
<li>将切片传输给服务端</li>
</ul>
<p>这里的File其实继承的就是Blob对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> @change=<span class="string">"handleFileChange"</span> /&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"handleUpload"</span>&gt;上传&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"> const SIZE = 10 * 1024 * 1024; /</span><span class="regexp">/ 切片大小</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data: () =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    container: &#123;</span></span><br><span class="line"><span class="regexp">      file: null</span></span><br><span class="line"><span class="regexp">    &#125;，</span></span><br><span class="line"><span class="regexp">   data: []</span></span><br><span class="line"><span class="regexp">  &#125;),</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    request() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    handleFileChange() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 生成文件切片</span></span><br><span class="line"><span class="regexp">    createFileChunk(file, size = SIZE) &#123;</span></span><br><span class="line"><span class="regexp">     const fileChunkList = [];</span></span><br><span class="line"><span class="regexp">      let cur = 0;</span></span><br><span class="line"><span class="regexp">      while (cur &lt; file.size) &#123;</span></span><br><span class="line"><span class="regexp">        fileChunkList.push(&#123; file: file.slice(cur, cur  size) &#125;);</span></span><br><span class="line"><span class="regexp">        cur = size;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      return fileChunkList;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">   /</span><span class="regexp">/ 上传切片</span></span><br><span class="line"><span class="regexp">    async uploadChunks() &#123;</span></span><br><span class="line"><span class="regexp">      const requestList = this.data</span></span><br><span class="line"><span class="regexp">        .map((&#123; chunk，hash &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          const formData = new FormData();</span></span><br><span class="line"><span class="regexp">          formData.append("chunk", chunk);</span></span><br><span class="line"><span class="regexp">          formData.append("hash", hash);</span></span><br><span class="line"><span class="regexp">          formData.append("filename", this.container.file.name);</span></span><br><span class="line"><span class="regexp">          return &#123; formData &#125;;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        .map(async (&#123; formData &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">          this.request(&#123;</span></span><br><span class="line"><span class="regexp">            url: "http:/</span><span class="regexp">/localhost:3000",</span></span><br><span class="line"><span class="regexp">            data: formData</span></span><br><span class="line"><span class="regexp">          &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      await Promise.all(requestList); /</span><span class="regexp">/ 并发切片</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    async handleUpload() &#123;</span></span><br><span class="line"><span class="regexp">      if (!this.container.file) return;</span></span><br><span class="line"><span class="regexp">      const fileChunkList = this.createFileChunk(this.container.file);</span></span><br><span class="line"><span class="regexp">      this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">        chunk: file,</span></span><br><span class="line"><span class="regexp">        hash: this.container.file.name  "-"  index /</span><span class="regexp">/ 文件名  数组下标</span></span><br><span class="line"><span class="regexp">      &#125;));</span></span><br><span class="line"><span class="regexp">      await this.uploadChunks();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片</p>
<p>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回</p>
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名  下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p>
<p>随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p>
<h4 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h4><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> @change=<span class="string">"handleFileChange"</span> /&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"handleUpload"</span>&gt;上传&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data: () =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    container: &#123;</span></span><br><span class="line"><span class="regexp">      file: null</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    data: []</span></span><br><span class="line"><span class="regexp">  &#125;),</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    request() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    handleFileChange() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    createFileChunk() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 上传切片，同时过滤已上传的切片</span></span><br><span class="line"><span class="regexp">    async uploadChunks() &#123;</span></span><br><span class="line"><span class="regexp">      const requestList = this.data</span></span><br><span class="line"><span class="regexp">        .map((&#123; chunk，hash &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          const formData = new FormData();</span></span><br><span class="line"><span class="regexp">          formData.append("chunk", chunk);</span></span><br><span class="line"><span class="regexp">          formData.append("hash", hash);</span></span><br><span class="line"><span class="regexp">          formData.append("filename", this.container.file.name);</span></span><br><span class="line"><span class="regexp">          return &#123; formData &#125;;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        .map(async (&#123; formData &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">          this.request(&#123;</span></span><br><span class="line"><span class="regexp">            url: "http:/</span><span class="regexp">/localhost:3000",</span></span><br><span class="line"><span class="regexp">            data: formData</span></span><br><span class="line"><span class="regexp">          &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      await Promise.all(requestList);</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 合并切片</span></span><br><span class="line"><span class="regexp">     await this.mergeRequest();</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    async mergeRequest() &#123;</span></span><br><span class="line"><span class="regexp">      await this.request(&#123;</span></span><br><span class="line"><span class="regexp">        url: "http:/</span><span class="regexp">/localhost:3000/m</span>erge<span class="string">",</span></span><br><span class="line"><span class="string">        headers: &#123;</span></span><br><span class="line"><span class="string">          "</span>content-type<span class="string">": "</span>application/json<span class="string">"</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: JSON.stringify(&#123;</span></span><br><span class="line"><span class="string">          filename: this.container.file.name</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;,    </span></span><br><span class="line"><span class="string">    async handleUpload() &#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h3><p>简单使用 http 模块搭建服务端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h4><p>使用 <code>multiparty</code> 包处理前端传来的 FormData</p>
<p>在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">"fs-extra"</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">"multiparty"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"> <span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">".."</span>, <span class="string">"target"</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line"></span><br><span class="line">  multipart.parse(req, <span class="keyword">async</span> (err, fields, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [chunk] = files.chunk;</span><br><span class="line">    <span class="keyword">const</span> [hash] = fields.hash;</span><br><span class="line">    <span class="keyword">const</span> [filename] = fields.filename;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 切片目录不存在，创建切片目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.mkdirs(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fs-extra 专用方法，类似 fs.rename 并且跨平台</span></span><br><span class="line">      <span class="comment">// fs-extra 的 rename 方法 windows 平台会有权限问题</span></span><br><span class="line">      <span class="comment">// https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span></span><br><span class="line">      <span class="keyword">await</span> fse.move(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    res.end(<span class="string">"received file chunk"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>
<p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename(由于我用的是 fs-extra，它的 rename 方法 windows 平台权限问题，所以换成了 fse.move) 移动临时文件，即移动文件切片</p>
<p>在接受文件切片时，需要先创建存储切片的文件夹，由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中</p>
<h4 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h4><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">"fs-extra"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">".."</span>, <span class="string">"target"</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> resolvePost = <span class="function"><span class="params">req</span> =&gt;</span></span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> chunk = <span class="string">""</span>;</span><br><span class="line">     req.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">       chunk = data;</span><br><span class="line">     &#125;);</span><br><span class="line">     req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">       resolve(<span class="built_in">JSON</span>.parse(chunk));</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> pipeStream = <span class="function">(<span class="params">path, writeStream</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> readStream = fse.createReadStream(path);</span><br><span class="line">    readStream.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">      fse.unlinkSync(path);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">    readStream.pipe(writeStream);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并切片</span></span><br><span class="line"> <span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, filename, size) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">  <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">  <span class="comment">// 根据切片下标进行排序</span></span><br><span class="line">  <span class="comment">// 否则直接读取目录的获得的顺序可能会错乱</span></span><br><span class="line">  chunkPaths.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.split(<span class="string">"-"</span>)[<span class="number">1</span>] - b.split(<span class="string">"-"</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    chunkPaths.map(<span class="function">(<span class="params">chunkPath, index</span>) =&gt;</span></span><br><span class="line">      pipeStream(</span><br><span class="line">        path.resolve(chunkDir, chunkPath),</span><br><span class="line">        <span class="comment">// 指定位置创建可写流</span></span><br><span class="line">        fse.createWriteStream(filePath, &#123;</span><br><span class="line">          start: index * size,</span><br><span class="line">          end: (index  <span class="number">1</span>) * size</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  fse.rmdirSync(chunkDir); <span class="comment">// 合并后删除保存切片的目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (req.url === <span class="string">"/merge"</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req);</span><br><span class="line">     <span class="keyword">const</span> &#123; filename,size &#125; = data;</span><br><span class="line">     <span class="keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="string">`<span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">     <span class="keyword">await</span> mergeFileChunk(filePath, filename);</span><br><span class="line">     res.end(</span><br><span class="line">       <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         code: <span class="number">0</span>,</span><br><span class="line">         message: <span class="string">"file merged success"</span></span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>
<p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p>
<p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名  后缀名</strong>组合而成</p>
<p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p>
<p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start/end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> mergeRequest() &#123;</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.request(&#123;</span><br><span class="line">     url: <span class="string">"http://localhost:3000/merge"</span>,</span><br><span class="line">     headers: &#123;</span><br><span class="line">       <span class="string">"content-type"</span>: <span class="string">"application/json"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      size: SIZE,</span><br><span class="line">       filename: <span class="keyword">this</span>.container.file.name</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h2><h3 id="从互联网下载数据"><a href="#从互联网下载数据" class="headerlink" title="从互联网下载数据"></a>从互联网下载数据</h3><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadBlob = <span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"> xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line"> xhr.responseType = <span class="string">'blob'</span></span><br><span class="line"> xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(xhr.response)</span><br><span class="line"> &#125;</span><br><span class="line"> xhr.send(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myImage = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line"><span class="keyword">const</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'flowers.jpg'</span>);</span><br><span class="line"></span><br><span class="line">fetch(myRequest)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">   myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p>
<h3 id="Blob-用作-URL"><a href="#Blob-用作-URL" class="headerlink" title="Blob 用作 URL"></a>Blob 用作 URL</h3><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p>
<p><strong>1.Blob URL/Object URL</strong></p>
<p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>，对应的示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob:https:<span class="comment">//example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</span></span><br></pre></td></tr></table></figure>
<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code>。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p>
<p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p>
<p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p>
<p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p>
<p><strong>2.Blob 文件下载示例</strong></p>
<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Blob 文件下载示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"downloadBtn"</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>js</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> download = <span class="function">(<span class="params">fileName, blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">  link.href = URL.createObjectURL(blob);</span><br><span class="line">  link.download = fileName;</span><br><span class="line">  link.click();</span><br><span class="line">  link.remove();</span><br><span class="line">  URL.revokeObjectURL(link.href);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downloadBtn = <span class="built_in">document</span>.querySelector(<span class="string">"#downloadBtn"</span>);</span><br><span class="line">downloadBtn.addEventListener(<span class="string">"click"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = <span class="string">"blob.txt"</span>;</span><br><span class="line">  <span class="keyword">const</span> myBlob = <span class="keyword">new</span> Blob([<span class="string">"一文彻底掌握 Blob Web API"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  download(fileName, myBlob);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p>
<h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>更多的用法可以参考  <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484522&amp;idx=1&amp;sn=7028aa65a4dec0f2d0cb847838703bc3&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">你不知道的Blob</a>。</p>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484522&amp;idx=1&amp;sn=7028aa65a4dec0f2d0cb847838703bc3&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">你不知道的Blob</a></p>
<p><a href="https://juejin.im/post/5dff8a26e51d4558105420ed" rel="external nofollow noopener noreferrer" target="_blank">大文件分片上传</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Ray Sun
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://sunra.top/2020/07/24/blob/" title="Blob 与 大文件分片上传">https://sunra.top/2020/07/24/blob/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/18/elelment-ui-note/" rel="prev" title="Element UI 笔记">
      <i class="fa fa-chevron-left"></i> Element UI 笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/31/tamper-monkey-security/" rel="next" title="TamperMonkey 对于内容的保护">
      TamperMonkey 对于内容的保护 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Blob是什么"><span class="nav-number">1.</span> <span class="nav-text">Blob是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Blob-API-简介"><span class="nav-number">2.</span> <span class="nav-text">Blob API 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大文件分片上传（Vue）"><span class="nav-number">3.</span> <span class="nav-text">大文件分片上传（Vue）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端部分"><span class="nav-number">3.1.</span> <span class="nav-text">客户端部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#上传切片"><span class="nav-number">3.1.1.</span> <span class="nav-text">上传切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送合并请求"><span class="nav-number">3.1.2.</span> <span class="nav-text">发送合并请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端部分"><span class="nav-number">3.2.</span> <span class="nav-text">服务端部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接受切片"><span class="nav-number">3.2.1.</span> <span class="nav-text">接受切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并切片"><span class="nav-number">3.2.2.</span> <span class="nav-text">合并切片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他使用场景"><span class="nav-number">4.</span> <span class="nav-text">其他使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从互联网下载数据"><span class="nav-number">4.1.</span> <span class="nav-text">从互联网下载数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blob-用作-URL"><span class="nav-number">4.2.</span> <span class="nav-text">Blob 用作 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更多用法"><span class="nav-number">4.3.</span> <span class="nav-text">更多用法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
  <p class="site-author-name" itemprop="name">Ray Sun</p>
  <div class="site-description" itemprop="description">拨开互联网的迷雾</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">265</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sun668" title="GitHub → https://github.com/Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <div class="wechat_channel" style="width: 50%;margin-left: 25%;">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src="/images/wechat_channel.png">
        <!-- <span>公众号</span> -->
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Sun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  <script src="/js/local-search.js"></script>












  

  

  

</body>
</html>
