<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Introduction to MicroservicesMonolithic applicationThe core of an application is business logic, which is implemented by modules that define services, domain objects, and events. Around the core is an"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Microservices"><meta property="og:url" content="https://sunra.top/en/posts/39f5c62f/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Introduction to MicroservicesMonolithic applicationThe core of an application is business logic, which is implemented by modules that define services, domain objects, and events. Around the core is an"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2020-03-25T11:16:10.000Z"><meta property="article:modified_time" content="2023-07-30T00:37:37.997Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/posts/39f5c62f/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/39f5c62f/","path":"posts/39f5c62f/","title":"Introduction to Microservices"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Introduction to Microservices | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-to-Microservices"><span class="nav-number">1.</span> <span class="nav-text">Introduction to Microservices</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Monolithic-application"><span class="nav-number">1.1.</span> <span class="nav-text">Monolithic application</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Microservices"><span class="nav-number">1.2.</span> <span class="nav-text">Microservices</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Advantages"><span class="nav-number">1.2.1.</span> <span class="nav-text">Advantages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Disadvantage"><span class="nav-number">1.2.2.</span> <span class="nav-text">Disadvantage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Building-Microservices-with-API-Gateway"><span class="nav-number">2.</span> <span class="nav-text">Building Microservices with API Gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Direct-communication-between-client-and-microservices"><span class="nav-number">2.1.</span> <span class="nav-text">Direct communication between client and microservices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-API-Gateway"><span class="nav-number">2.2.</span> <span class="nav-text">Using API Gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Advantages-and-disadvantages"><span class="nav-number">2.2.1.</span> <span class="nav-text">Advantages and disadvantages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Key-points"><span class="nav-number">2.2.2.</span> <span class="nav-text">Key points</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inter-Process-Communication-in-microservice-structures"><span class="nav-number">3.</span> <span class="nav-text">Inter-Process Communication in microservice structures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interactive-manner"><span class="nav-number">3.1.</span> <span class="nav-text">Interactive manner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constantly-changing-API"><span class="nav-number">3.2.</span> <span class="nav-text">Constantly changing API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fault-handling-principle"><span class="nav-number">3.3.</span> <span class="nav-text">Fault handling principle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-technology"><span class="nav-number">3.4.</span> <span class="nav-text">IPC technology</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Message-based-asynchronous-communication"><span class="nav-number">3.4.1.</span> <span class="nav-text">Message-based asynchronous communication</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronization-request"><span class="nav-number">3.4.2.</span> <span class="nav-text">Synchronization request</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service-Discovery"><span class="nav-number">4.</span> <span class="nav-text">Service Discovery</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-discovered"><span class="nav-number">4.1.</span> <span class="nav-text">Client discovered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-level-discovery"><span class="nav-number">4.2.</span> <span class="nav-text">Server level discovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-regedit"><span class="nav-number">4.3.</span> <span class="nav-text">Service regedit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Registration-Method"><span class="nav-number">4.3.1.</span> <span class="nav-text">Service Registration Method</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Self-registration"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">Self-registration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Third-party-registration"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">Third party registration</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Distributed-data-management-problem"><span class="nav-number">5.</span> <span class="nav-text">Distributed data management problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-driven-architecture"><span class="nav-number">5.1.</span> <span class="nav-text">Event-driven architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomicity"><span class="nav-number">5.2.</span> <span class="nav-text">Atomicity</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Publish-events-using-local-transactions"><span class="nav-number">5.2.1.</span> <span class="nav-text">Publish events using local transactions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mining-database-transaction-logs"><span class="nav-number">5.2.2.</span> <span class="nav-text">Mining database transaction logs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Use-event-sources-similar-to-blockchain-ledgers"><span class="nav-number">5.2.3.</span> <span class="nav-text">Use event sources (similar to blockchain ledgers).</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deployment-policy"><span class="nav-number">6.</span> <span class="nav-text">Deployment policy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Each-host-pattern-has-multiple-service-instances"><span class="nav-number">6.1.</span> <span class="nav-text">Each host pattern has multiple service instances</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Advantages-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">Advantages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Disadvantage-1"><span class="nav-number">6.1.2.</span> <span class="nav-text">Disadvantage</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-instance-per-host-mode"><span class="nav-number">6.2.</span> <span class="nav-text">Service instance per host mode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-instances-for-each-virtual-machine-mode"><span class="nav-number">6.2.1.</span> <span class="nav-text">Service instances for each virtual machine mode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Advantages-2"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">Advantages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Disadvantage-2"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">Disadvantage</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-instances-for-each-container-pattern"><span class="nav-number">6.2.2.</span> <span class="nav-text">Service instances for each container pattern</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serverless-deployment"><span class="nav-number">6.3.</span> <span class="nav-text">Serverless deployment</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refactor-monolithic-application-into-microservice-method"><span class="nav-number">7.</span> <span class="nav-text">Refactor monolithic application into microservice method</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#No-longer-increase-the-overall-project"><span class="nav-number">7.1.</span> <span class="nav-text">No longer increase the overall project</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Front-and-rear-end-separation"><span class="nav-number">7.2.</span> <span class="nav-text">Front and rear end separation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extraction-service"><span class="nav-number">7.3.</span> <span class="nav-text">Extraction service</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Which-modules-to-extract"><span class="nav-number">7.3.1.</span> <span class="nav-text">Which modules to extract</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-to-extract"><span class="nav-number">7.3.2.</span> <span class="nav-text">How to extract</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/39f5c62f/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Introduction to Microservices | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Introduction to Microservices</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-03-25 19:16:10" itemprop="dateCreated datePublished" datetime="2020-03-25T19:16:10+08:00">2020-03-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-07-30 08:37:37" itemprop="dateModified" datetime="2023-07-30T08:37:37+08:00">2023-07-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Sundry/" itemprop="url" rel="index"><span itemprop="name">Sundry</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/39f5c62f/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/39f5c62f/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Introduction-to-Microservices"><a href="#Introduction-to-Microservices" class="headerlink" title="Introduction to Microservices"></a>Introduction to Microservices</h2><h3 id="Monolithic-application"><a href="#Monolithic-application" class="headerlink" title="Monolithic application"></a>Monolithic application</h3><p>The core of an application is business logic, which is implemented by modules that define services, domain objects, and events. Around the core is an adapter that interfaces with the outside world. Examples of adapters include database access components, messaging components that generate and consume messages, and web components that expose APIs or implement UIs.</p><p>Despite the architecture of logical Modularization, the application is packaged and deployed as a whole. The actual format depends on the language and framework of the application. For example, many Java applications are packaged as WAR files and deployed on application servers such as Tomcat or Jetty. Other Java applications are packaged as standalone executable JARs.</p><p>Successful applications have a habit of growing large over time. During each sprint, the development team implements more stories, which of course means adding many lines of code. In a few years, small, simple applications will become behemoths.</p><span id="more"></span><ul><li>The absolute size of the application will also slow down the development speed. The larger the application, the longer the startup time.</li><li>Another problem with large, complex monolithic applications is that this is a barrier to continuous deployment. Today, the latest technology in SaaS applications is to push changes into production multiple times a day.</li><li>Monolithic applications may also be difficult to scale when different modules have conflicting resource requirements. For example, a module may implement CPU-intensive image processing logic and ideally be deployed on Amazon. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/about-aws/whats-new/2013/11/14/announcing-new-amazon-ec2-compute-optimized-instances/">EC2 Compute Optimized实例中</a>Another module may be an in-memory database, which is most suitable for<a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/about-aws/whats-new/2014/04/10/r3-announcing-the-next-generation-of-amazon-ec2-memory-optimized-instances/">EC2内存优化的实例</a>However, because these modules are deployed together, you have to compromise on hardware choices.</li><li>Since all modules run in the same process, errors in any module (such as memory leaks) may cause the entire process to break.<br>Monolithic applications make it extremely difficult to adopt new frameworks and languages.</li></ul><h3 id="Microservices"><a href="#Microservices" class="headerlink" title="Microservices"></a>Microservices</h3><p>Services usually implement a different set of features or functions, such as order management, customer management, etc. Each microservice is a micro-application with its own hexagonal architecture consisting of business logic and various adapters. Some microservices expose APIs used by other microservices or application clients. Other microservices may implement web UI. At runtime, each instance is usually a cloud VM or Docker container.</p><p>Now, each functional area of the application is implemented by its own microservice. In addition, the web application is divided into a set of simple web applications (for example, in our taxi hailing example, one for passengers and one for drivers). This makes it easier to deploy different experiences for specific users, devices, or special use cases.</p><p>Each backend service exposes a REST API, and most services use APIs provided by other services. For example, driver management uses a notification server to notify available drivers of potential trips. UI services call other services to render web pages. Services can also use message-based asynchronous communication. Inter-service communication will be covered in more detail later in this series.</p><h4 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h4><ul><li>Decompose what was originally a huge monolithic application into a set of services. Although the total number of functions remains unchanged, the application has been divided into manageable blocks or services. Each service has boundaries defined in the form of RPC or message-driven APIs.</li><li>Make each service can be developed independently by a team focused on that service. Developers are free to choose any meaningful technology, as long as the service adheres to the API contract.</li><li>The microservice structure pattern enables each microservice to be deployed independently. Developers do not need to coordinate the deployment of local changes to their services. These changes can be deployed as long as they are tested.</li><li>The micro-service structure pattern enables each service to scale independently. You can deploy only the number of instances of each service that meet its capacity and availability constraints.</li></ul><h4 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h4><ul><li> <strong>Complexity caused by the fact that microservice applications are distributed systems</strong> . Developers need to choose and implement Inter-Process Communication mechanisms based on messaging or RPC. In addition, since the destination of requests may be slow or unavailable, they must also write code to handle partial failures.</li><li>Another challenge is the partitioned database architecture. Updating business transactions of multiple business entities is quite common. Since there is only one database, it is simple to implement such transactions in a single application. However, in microservice-based applications, you need to update multiple databases owned by different services.<br>Testing microservice applications is also much more complex.</li><li>Implementing changes across multiple services is difficult.</li></ul><h2 id="Building-Microservices-with-API-Gateway"><a href="#Building-Microservices-with-API-Gateway" class="headerlink" title="Building Microservices with API Gateway"></a>Building Microservices with API Gateway</h2><h3 id="Direct-communication-between-client-and-microservices"><a href="#Direct-communication-between-client-and-microservices" class="headerlink" title="Direct communication between client and microservices"></a>Direct communication between client and microservices</h3><p>In theory, Clients can make requests directly to each microservice. Each microservice has a common endpoint ( <strong>https://\ <em>serviceName\</em> api.company.name</strong> ). This URL will map to the Load Balancer of the microservice, which distributes requests among available instances. To retrieve product details, the Mobile Client will make requests to each of the services listed above.</p><p>Unfortunately, there are challenges and limitations to this option. One issue is the mismatch between Client requirements and the fine grain API exposed by each microservice.</p><p>Another problem with clients calling microservices directly is that some services may use protocols that do not support the web. One service may use Thrift binary RPC, while another may use the AMQP messaging protocol. Neither protocol is particularly suitable for browsers or firewalls, and is best used internally. Applications should use protocols like HTTP and WebSocket outside the firewall.</p><p>Another disadvantage of this approach is that it is difficult to refactor microservices. Over time, we may want to change the way we divide the system into services. For example, we can merge two services or split a service into two or more services. However, if the customer communicates directly with the service, then performing this refactoring can be very difficult.</p><h3 id="Using-API-Gateway"><a href="#Using-API-Gateway" class="headerlink" title="Using API Gateway"></a>Using API Gateway</h3><p>The API Gateway is the server and is the single entry point to the system. It is the same as the “ <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Facade_pattern">外观”</a>The pattern is similar. API Gateway encapsulates the internal system architecture and provides APIs tailored to each client. It may also have other responsibilities such as authentication, monitoring, load balancing, caching, request shaping and management, and static response processing.</p><p>API Gateway is responsible for request routing, composition, and protocol conversion. All requests from clients go through API Gateway first. Then, it routes the request to the appropriate microservice. API Gateway usually handles requests by calling multiple microservices and aggregating the results. It can convert between web protocols like HTTP and WebSocket used internally and web-unfriendly protocols.</p><p>API Gateway can also provide custom APIs for each client. It usually provides Coarse Grain APIs for mobile clients.</p><h4 id="Advantages-and-disadvantages"><a href="#Advantages-and-disadvantages" class="headerlink" title="Advantages and disadvantages"></a>Advantages and disadvantages</h4><p>The main benefit of using API Gateway is that it encapsulates the internal structure of the application. Clients do not have to call specific services, but only talk to the gateway. API Gateway provides specific APIs for each type of client. This reduces the number of round trips between the client and the application. It also simplifies client code.</p><p>API Gateway also has some disadvantages. It is another high availability component that must be developed, deployed and managed. API Gateway also has the risk of becoming a development bottleneck. Developers must update API Gateway to expose the endpoint of each microservice. It is important that the process of updating API Gateway should be as light as possible. Otherwise, developers will be forced to wait in line to update the gateway.</p><h4 id="Key-points"><a href="#Key-points" class="headerlink" title="Key points"></a>Key points</h4><ul><li>Performance and scalability.</li><li>Uses a reactive programming model. API Gateway handles some requests by simply routing them to the appropriate backend service. It handles others by calling multiple backend services and aggregating the results. For some requests (e.g. product detail requests), requests to backend services are independent of each other. To minimize response time, API Gateway should execute independent requests simultaneously. However, sometimes there are dependencies between requests.</li><li>Service invocation. Microservice-based applications are a distributed system and must use the Inter-Process Communication mechanism. There are two styles of Inter-Process Communication. One option is to use a message-based asynchronous mechanism. Some implementations use message brokers, such as JMS or AMQP. Other companies such as Zeromq do not have brokers and services can communicate directly. Another form of Inter-Process Communication is a synchronous mechanism, such as HTTP or Thrift. Systems often use both asynchronous and synchronous styles.</li><li>Service Discovery. The API Gateway needs to know the location (IP Address and Port) of each microservice it communicates with. In traditional applications, you may need to hardwire the location, but in modern cloud-based microservice applications, this is no small problem. Infrastructure services (such as message brokers) will often have a static location, which can be specified through OS environment variables. However, determining the location of application services is not an easy task. Application services have dynamically allocated locations. Moreover, the instance set of the service changes dynamically due to automatic scaling and upgrading. Therefore, like any other service Client in the system, API Gateway also needs to use the system’s Service Discovery mechanism.</li><li>Fault handling. Another problem that must be solved when implementing API Gateway is the problem of partial failure. This problem occurs in all distributed systems whenever one service calls another service that responds slowly or is unavailable. API Gateway should never block indefinitely waiting for downstream services. However, how it handles failures depends on the specific situation and which service is failing.</li></ul><h2 id="Inter-Process-Communication-in-microservice-structures"><a href="#Inter-Process-Communication-in-microservice-structures" class="headerlink" title="Inter-Process Communication in microservice structures"></a>Inter-Process Communication in microservice structures</h2><p>In the overall application, components call each other through language-level method or function calls. In contrast, microservice-based applications are distributed systems running on multiple computers. Each service instance is usually a process. Therefore, as shown in the figure below, services must interact using the Inter-Process Communication (IPC) mechanism.</p><h3 id="Interactive-manner"><a href="#Interactive-manner" class="headerlink" title="Interactive manner"></a>Interactive manner</h3><p>When choosing an IPC mechanism for a service, it is useful to first consider how the service interacts. There are many different types of interaction patterns. They can be classified along two dimensions. The first dimension is whether the interaction is one-to-one or one-to-many:</p><ul><li>One-to-one - Each client request is processed by only one service instance.</li><li>One-to-many - Each request is processed by multiple service instances.</li></ul><p>The second dimension is whether the interaction is synchronous or asynchronous:</p><ul><li>Synchronization - Client expects the service to respond in a timely manner, and may even block while waiting.</li><li>Asynchronous - The client will not block while waiting for a response, and the response (if any) will not necessarily be sent immediately.</li></ul><p>One to one interaction:</p><ul><li>Request/Response - Client issues a request to the service and waits for a response. The client expects the response to arrive in a timely manner. In thread-based applications, the thread that made the request may even block while waiting.</li><li>Notification (also known as one-way request) - Client sends a request to the service, but does not want or does not send a reply.</li><li>Request/Asynchronous Response - The Client sends the request to the service, which replies asynchronously. The Client does not block while waiting and assumes that the response may not arrive for some time.</li></ul><p>There are several types of one-to-many interactions:</p><ul><li>Publish/Subscribe - Client publishes notification messages that are used by zero or more interested services.</li><li>Publish/Asynchronous Response - Client publishes a request message and then waits for a certain amount of time to wait for a response from the service of interest.</li></ul><h3 id="Constantly-changing-API"><a href="#Constantly-changing-API" class="headerlink" title="Constantly changing API"></a>Constantly changing API</h3><p>The API of a service will always change over time. In a monolithic application, it is usually simple to change the API and update all calling programs. In microservice-based applications, it is much more difficult even if all consumers of the API are other services in the same application. Usually, you cannot force all clients to upgrade synchronously with the service.</p><p>How API changes are handled depends on the size of the change. Some changes are minor and backward compatibility with previous versions.</p><p>However, sometimes you must make significant, incompatible changes to the API. Since you cannot force the client to upgrade immediately, the service must support older versions of the API for a period of time.</p><h3 id="Fault-handling-principle"><a href="#Fault-handling-principle" class="headerlink" title="Fault handling principle"></a>Fault handling principle</h3><ul><li>Network Timeout - Never block indefinitely, and always use timeout while waiting for a response. Using timeout ensures that resources are not occupied indefinitely.</li><li>Limit the number of outstanding requests - Limit the number of outstanding requests that a client can use a specific service. If the limit has been reached, it may be meaningless to make other requests, and these attempts must fail immediately.</li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://martinfowler.com/bliki/CircuitBreaker.html">断路器模式</a> Track the number of successful and failed requests. If the error rate exceeds the configured threshold, please trip the circuit breaker so that further attempts will fail immediately. If a large number of requests fail, it indicates that the service is unavailable and it is meaningless to send requests. After the timeout, the Client should retry, and if successful, close the circuit breaker.</li><li>Provide fallback - Execute fallback logic when the request fails. For example, return cached data or default values, such as empty suggestion sets.</li></ul><h3 id="IPC-technology"><a href="#IPC-technology" class="headerlink" title="IPC technology"></a>IPC technology</h3><h4 id="Message-based-asynchronous-communication"><a href="#Message-based-asynchronous-communication" class="headerlink" title="Message-based asynchronous communication"></a>Message-based asynchronous communication</h4><p>When using messaging, processes communicate by asynchronously exchanging messages. The Client makes a request to the service by sending it a message. If the service is expected to reply, it replies by sending a separate message back to the Client. Since communication is asynchronous, the Client does not block waiting for a reply. Instead, a Client is written, assuming no immediate reply is received.</p><p>One<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.enterpriseintegrationpatterns.com/Message.html">消息</a>Consists of a header (such as metadata such as sender) and a message body. Message passes through<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.enterpriseintegrationpatterns.com/MessageChannel.html">通道</a>Exchange. Any number of producers can send messages to a channel. Likewise, any number of consumers can receive messages from a channel. There are two channels,<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.enterpriseintegrationpatterns.com/PointToPointChannel.html">点对点</a>Channels and<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html">发布订阅</a>Channel. A point-to-point channel delivers a message to one of the consumers reading from the channel. The service uses a point-to-point channel for the one-to-one interaction style described earlier. The publish-subscribe channel delivers each message to all additional consumers. The service uses the publish-subscribe channel for the one-to-many interaction style described above.</p><p>There are many advantages to using messaging:</p><ul><li>Decouple the Client from the service - The Client can make requests only by sending messages to the appropriate channel. The Client is completely unaware of the service instance. It does not need to use a discovery mechanism to determine the location of the service instance.</li><li>Message Buffering - Using synchronous request/response protocols (such as HTTP), both the client and the service must be available during the exchange. Instead, the message broker queues messages written to the channel until the consumer can process them. For example, this means that an online store can accept orders from customers even if the Order Fulfillment system is slow or unavailable. Order messages are simply queued.</li><li>Flexible Client-Service Interaction - Messages support all the interaction styles described earlier.</li><li>Explicit Inter-Process Communication - RPC-based mechanisms try to make calling a remote service look the same as calling a local service. However, due to the laws of physics and the possibility of partial invalidation, they are actually completely different. Messaging makes these differences very obvious, so developers don’t fall into a false sense of security.</li></ul><p>However, there are some disadvantages to using message passing.</p><ul><li>Additional operational complexity - The mail system is another system component that must be installed, configured, and operated. The message broker must be highly available, otherwise system reliability will be affected.</li><li>Complexity of implementing request/response-based interactions - Request/response-style interactions require some work to implement. Each request message must contain a reply channel identifier and a correlation identifier. The service writes the response message containing the correlation ID into the reply channel. The client uses the correlation ID to match the response to the request. It is usually easier to use an IPC mechanism that directly supports request/response.</li></ul><h4 id="Synchronization-request"><a href="#Synchronization-request" class="headerlink" title="Synchronization request"></a>Synchronization request</h4><p>When using the request/response-based synchronous IPC mechanism, the Client sends the request to the service. The service processes the request and sends back a response. In many Clients, the requesting thread blocks while waiting for a response.</p><h2 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h2><p>Service instances have dynamically allocated network locations. Moreover, the service instance set changes dynamically due to autoscaling, failures, and upgrades. Therefore, your Client code needs to use a more complex Service Discovery mechanism.</p><p>There are two main modes of service discovery:<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/client-side-discovery.html">客户端发现</a>And<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/server-side-discovery.html">服务器端发现</a>。</p><h3 id="Client-discovered"><a href="#Client-discovered" class="headerlink" title="Client discovered"></a>Client discovered</h3><p>Use<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/client-side-discovery.html">客户端发现时</a>, the Client is responsible for determining the network locations of available service instances and making load balancing requests between them. The Client queries the service regedit, which is a database of available service instances. The Client then uses a load balancing algorithm to select one of the available service instances and issue requests.</p><p>The network location of the service instance is registered in the service regedit at startup. When the instance terminates, it will be removed from the service regedit. The registration of the service instance is refreshed periodically, usually using a heartbeat mechanism.</p><p>The Client Discovery pattern has several advantages and disadvantages. This pattern is relatively simple, with no active parts other than the service regedit. In addition, because the Client knows the available service instances, it can make intelligent, application-specific load balancing decisions, such as using hashes consistently. A significant flaw of this pattern is that it couples the Client with the service regedit. You must implement the Client Service Discovery logic for each programming language and framework used by the service Client.</p><h3 id="Server-level-discovery"><a href="#Server-level-discovery" class="headerlink" title="Server level discovery"></a>Server level discovery</h3><p>The Client makes requests to the service through the Load Balancer. The Load Balancer queries the service regedit and routes each request to an available service instance. As with Client discovery, the service instance is registered and unregistered in the service regedit.</p><p>HTTP Server and Load Balancer (for example<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.nginx.com/products/">NGINX Plus</a>And NGINX) can also be used as a server-side discovery Load Balancer.</p><p>The server-side discovery mode has several advantages and disadvantages. A big benefit of this mode is that the discovery details are abstracted from the Client. The client only needs to make a request to the Load Balance. This eliminates the need to implement discovery logic for each programming language and framework used by the service Client.</p><h3 id="Service-regedit"><a href="#Service-regedit" class="headerlink" title="Service regedit"></a>Service regedit</h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/service-registry.html">服务注册表</a>是服务发现的一个关键部分。它是一个数据库，其中包含服务实例的网络位置。服务注册表需要高度可用且最新。客户端可以缓存从服务注册表获得的网络位置。但是，该信息最终将过时，并且客户端将无法发现服务实例。因此，服务注册表由使用复制协议维护一致性的服务器群集组成。</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Netflix/eureka">Netflix Eureka</a>是服务注册表的一个很好的例子。它提供了一个REST API，用于注册和查询服务实例。服务实例使用<code>POST</code>请求注册其网络位置。每隔30秒，它必须使用<code>PUT</code>请求刷新其注册。通过使用HTTP <code>DELETE</code>请求或实例注册超时来删除注册。如您所料，客户端可以使用HTTP <code>GET</code>请求来检索注册的服务实例。</p><h4 id="Service-Registration-Method"><a href="#Service-Registration-Method" class="headerlink" title="Service Registration Method"></a>Service Registration Method</h4><h5 id="Self-registration"><a href="#Self-registration" class="headerlink" title="Self-registration"></a>Self-registration</h5><p>Use<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/self-registration.html">自我注册模式时</a>, the service instance is responsible for registering and deregistering itself in the service regedit. Similarly, if necessary, the service instance sends a heartbeat request to prevent its registration from expiring.</p><p>The self-registration pattern has various advantages and disadvantages. One of the benefits is that it is relatively simple and does not require any other system components. However, the main disadvantage is that it couples the service instance to the service regedit. You must use each programming language and framework used by the service to implement the registration code.</p><h5 id="Third-party-registration"><a href="#Third-party-registration" class="headerlink" title="Third party registration"></a>Third party registration</h5><p>Use<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/3rd-party-registration.html">第三方注册模式时</a>, the service instance is not responsible for self-registration in the service regedit. In its place is another <em>system component called the</em> service registrar that handles the registration. The service registrar tracks changes to the set of running instances by polling the deployment environment or subscribing to events. When a new available service instance is discovered, it registers the instance in the service regedit. The service registrar also unregisters the terminated service instance. The following diagram shows the structure of this pattern.</p><h2 id="Distributed-data-management-problem"><a href="#Distributed-data-management-problem" class="headerlink" title="Distributed data management problem"></a>Distributed data management problem</h2><p>Holistic applications often have a single relational database. The main benefit of using a relational database is that your application can use<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/ACID">ACID事务</a>This provides some important guarantees:</p><ul><li>atomicity - change atomically</li><li>Consistency - The database state is always consistent</li><li>Isolation - Even if transactions are executed simultaneously, they appear to be executed serially</li><li>Durability - Once a transaction is submitted, it will not be undone</li></ul><p>As a result, your application can simply start transactions, change (insert, update, and delete) multiple rows, and commit transactions.</p><p>When we move to a microservice structure, data access becomes more complex. This is because the data owned by each microservice is<a target="_blank" rel="external nofollow noopener noreferrer" href="http://microservices.io/patterns/data/database-per-service.html">该微</a>Service<a target="_blank" rel="external nofollow noopener noreferrer" href="http://microservices.io/patterns/data/database-per-service.html">专用的，</a>And can only be accessed through its API. Encapsulating data ensures that microservices are loosely coupled and can evolve independently of each other. If multiple services access the same data, schema updates require time-consuming and coordinated updates to all services.</p><p>To make matters worse, different microservices often use different kinds of databases. Modern applications store and process all kinds of data, and relational databases are not always the best choice. For some use cases, specific NoSQL databases may have more convenient data models and provide better performance and scalability.</p><p>The first challenge is how to achieve consistent business transactions across multiple services.</p><p>The second challenge is how to implement queries that retrieve data from multiple services.</p><h3 id="Event-driven-architecture"><a href="#Event-driven-architecture" class="headerlink" title="Event-driven architecture"></a>Event-driven architecture</h3><p>For many applications, the solution is to use<a target="_blank" rel="external nofollow noopener noreferrer" href="http://martinfowler.com/eaaDev/EventNarrative.html">事件驱动的体系结构</a>In this architecture, microservices publish events when significant events occur, such as updating business entitiesOther microservices subscribe to these eventsWhen a microservice receives an event, it can update its own business entity, which may result in more events being published</p><p>You can use events to achieve business transactions across multiple services. The transaction consists of a series of steps. Each step contains a microservice that updates the business entity and publishes an event that triggers the next step.</p><p>It is important to note that these are not ACID transactions. They offer much weaker guarantees such as<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Eventual_consistency">最终的一致性</a>This transaction processing model has been called<a target="_blank" rel="external nofollow noopener noreferrer" href="http://queue.acm.org/detail.cfm?id=1394128">BASE模型</a>。</p><h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>In an event-driven architecture, there is also the issue of atomically updating the database and publishing events. For example, the ordering service must insert a row in the ORDER table and publish the ordering creation event. These two operations must be done atomically. If the service crashes after updating the database but before publishing the event, the system becomes inconsistent.</p><h4 id="Publish-events-using-local-transactions"><a href="#Publish-events-using-local-transactions" class="headerlink" title="Publish events using local transactions"></a>Publish events using local transactions</h4><p>The trick is to have an EVENT table in the database that stores the state of the business entity, which acts as a message queue. The application starts a (local) database transaction, updates the state of the business entity, inserts the event into the EVENT table, and then commits the transaction. A separate application thread or process queries the EVENT table, publishes the event to the Message Broker, and then marks the event as published using a local transaction.</p><h4 id="Mining-database-transaction-logs"><a href="#Mining-database-transaction-logs" class="headerlink" title="Mining database transaction logs"></a>Mining database transaction logs</h4><p>Another way to achieve atomicity without 2PC is for events to be published by threads or processes that mine database transactions or commit logs. The application updates the database, which causes changes to be recorded in the database’s transaction log. The transaction log miner thread or process reads the transaction log and publishes events to Message Broker.</p><p>Transaction log mining has various advantages and disadvantages. One benefit is that it guarantees that events can be published with each update without using 2PC. Transaction log mining can also simplify applications by separating event publishing from the business logic of the application. A major disadvantage is that the format of the transaction log is proprietary to each database and can even be changed between database versions.</p><h4 id="Use-event-sources-similar-to-blockchain-ledgers"><a href="#Use-event-sources-similar-to-blockchain-ledgers" class="headerlink" title="Use event sources (similar to blockchain ledgers)."></a>Use event sources (similar to blockchain ledgers).</h4><p>By using a fundamentally different, event-centric approach to persisting business entities,<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing">事件采购</a>Atomicity can be achieved without 2PC. Instead of storing the current state of the entity, the application stores a series of state change events. The application rebuilds the current state of the entity by replaying events. Whenever the state of the business entity changes, a new event is appended to the event list. Since the save event is a single operation, it is atomic in nature.</p><p>Event sourcing has several benefits. It solves one of the key issues in implementing an event-driven architecture and makes it possible to reliably publish events when state changes. As a result, it solves the problem of data consistency in microservices architecture. Additionally, since it preserves events instead of domain objects, it avoids<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">对象关系阻抗不匹配的问题</a>Event sources also provide a 100% reliable audit log of changes made to business entities and make it possible to implement ad hoc queries to determine the state of an entity at any point in timeAnother major advantage of event sources is that your business logic consists of loosely coupled business entities exchanging eventsThis makes it much easier to migrate from monolithic applications to microservice structures.</p><p>Event sources also have some drawbacks. This is a different and unfamiliar programming style, so there is a learning curve. The event store only directly supports finding business entities by primary key. You must use<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/cer/event-sourcing-examples/wiki">命令查询职责隔离</a>(CQRS) to implement the query. As a result, the application must process eventually consistent data.</p><h2 id="Deployment-policy"><a href="#Deployment-policy" class="headerlink" title="Deployment policy"></a>Deployment policy</h2><h3 id="Each-host-pattern-has-multiple-service-instances"><a href="#Each-host-pattern-has-multiple-service-instances" class="headerlink" title="Each host pattern has multiple service instances"></a>Each host pattern has multiple service instances</h3><p>One way to deploy microservices is to use “ <a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/deployment/multiple-services-per-host.html">每个主机多个服务实例”</a>Mode. When using this mode, you configure one or more physical or virtual hosts and run multiple service instances on each virtual or virtual host. In many ways, this is the traditional method of application deployment. Each service instance runs on a well-known port on one or more hosts.</p><h4 id="Advantages-1"><a href="#Advantages-1" class="headerlink" title="Advantages"></a>Advantages</h4><ul><li>Resource usage is relatively efficient. Multiple service instances share the server and its operating system. It is more efficient if a process or process group runs multiple service instances, such as multiple web applications sharing the same Apache Tomcat server and JVM.</li><li>Deploying a service instance is relatively fast. You just need to copy the service to the host and start it.</li></ul><h4 id="Disadvantage-1"><a href="#Disadvantage-1" class="headerlink" title="Disadvantage"></a>Disadvantage</h4><ul><li>Unless each service instance is a separate process, there is little isolation of service instances. Although the resource utilization of each service instance can be accurately monitored, the resources used by each instance cannot be limited. Service instances with abnormal behavior may consume all the memory or CPU of the host.</li><li>The operations team deploying the service must know the specific details of how to execute the service. Services can be written in multiple languages and frameworks, so the development team must share many details with the operation. This complexity increases the risk of errors during deployment.</li></ul><h3 id="Service-instance-per-host-mode"><a href="#Service-instance-per-host-mode" class="headerlink" title="Service instance per host mode"></a>Service instance per host mode</h3><p>When using this mode, each service instance runs independently on its own host. This mode has two different specializations: service instance per virtual machine and service instance per container.</p><h4 id="Service-instances-for-each-virtual-machine-mode"><a href="#Service-instances-for-each-virtual-machine-mode" class="headerlink" title="Service instances for each virtual machine mode"></a>Service instances for each virtual machine mode</h4><h5 id="Advantages-2"><a href="#Advantages-2" class="headerlink" title="Advantages"></a>Advantages</h5><ul><li>Each service instance can run in complete isolation. It has a fixed amount of CPU and memory and cannot steal resources from other services.</li><li>Can leverage mature cloud infrastructure.</li><li>Encapsulates the implementation technology of the service. After packaging the service as a VM, it will become a black box. The management API of the VM becomes the API used to deploy the service. Deployment becomes simpler and more reliable.</li></ul><h5 id="Disadvantage-2"><a href="#Disadvantage-2" class="headerlink" title="Disadvantage"></a>Disadvantage</h5><ul><li>Low resource utilization efficiency. Each service instance has the overhead of the entire VM (including the operating system).</li></ul><h4 id="Service-instances-for-each-container-pattern"><a href="#Service-instances-for-each-container-pattern" class="headerlink" title="Service instances for each container pattern"></a>Service instances for each container pattern</h4><p>When you use “ <a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/deployment/service-per-container.html">每个容器</a>Of<a target="_blank" rel="external nofollow noopener noreferrer" href="https://microservices.io/patterns/deployment/service-per-container.html">服务实例”</a>Mode, each service instance runs in its own container. The container is<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统级别</a>Of<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">虚拟化机制</a>Containers consist of one or more processes running in a sandboxFrom a process perspective, they have their own port namespaces and root file systemsYou can limit the memory and CPU resources of a containerSome container implementations also have I/O rate limitsExamples of Container Technology include<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.docker.com/">Docker</a>And<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Solaris_Containers">Solaris Zones</a>。</p><h3 id="Serverless-deployment"><a href="#Serverless-deployment" class="headerlink" title="Serverless deployment"></a>Serverless deployment</h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/lambda/">AWS Lambda</a>是无服务器部署技术的示例。它支持Java，Node.js和Python服务。要部署微服务，请将其打包为ZIP文件，然后将其上传到AWS Lambda。您还提供元数据，元数据除其他事项外，还指定为处理请求（又称为事件）而调用的函数的名称。AWS Lambda自动运行您的微服务的足够实例来处理请求。您只需根据花费的时间和消耗的内存为每个请求付费。</p><h2 id="Refactor-monolithic-application-into-microservice-method"><a href="#Refactor-monolithic-application-into-microservice-method" class="headerlink" title="Refactor monolithic application into microservice method"></a>Refactor monolithic application into microservice method</h2><h3 id="No-longer-increase-the-overall-project"><a href="#No-longer-increase-the-overall-project" class="headerlink" title="No longer increase the overall project"></a>No longer increase the overall project</h3><p>When implementing new features, more code should not be added to the whole. Instead, the main idea of this strategy is to put new code into independent microservices.</p><h3 id="Front-and-rear-end-separation"><a href="#Front-and-rear-end-separation" class="headerlink" title="Front and rear end separation"></a>Front and rear end separation</h3><p>One strategy for shrinking the overall application is to separate the presentation layer from the business logic and data access layer. A typical enterprise application contains at least three different types of components:</p><ul><li>Presentation layer - Components that handle HTTP requests and implement (REST) APIs or HTML-based web UI. In applications with complex User Interfaces, the presentation layer is usually a lot of code.</li><li>Business Logic Layer - A component that serves as the core of an application and implements business rules.</li><li>Data Access Layer - Components that access infrastructure components, such as databases and message brokers.</li></ul><h3 id="Extraction-service"><a href="#Extraction-service" class="headerlink" title="Extraction service"></a>Extraction service</h3><p>The third refactoring strategy is to transform existing modules in the whole into independent microservices. Every time a module is extracted and converted into a service, the whole will contract. Once enough modules are converted, the whole will no longer be a problem. It either disappears completely or becomes small enough that it is just another service.</p><h4 id="Which-modules-to-extract"><a href="#Which-modules-to-extract" class="headerlink" title="Which modules to extract"></a>Which modules to extract</h4><p>Large, complex monolithic applications consist of tens or hundreds of modules, all of which are candidates for extraction. It is often difficult to figure out which modules to convert first. A good approach is to start with a few modules that are easy to extract. This will give you experience with microservices in general and the extraction process in particular. After that, you should extract those modules that will bring you the most benefit.</p><h4 id="How-to-extract"><a href="#How-to-extract" class="headerlink" title="How to extract"></a>How to extract</h4><p>The first step in extracting the module is to define the Coarse Grain interface between the module and the whole. It is most likely a two-way API, as the whole will require data owned by the service and vice versa. Implementing such an API is often challenging due to complex dependencies and fine grained interaction patterns between the module and the rest of the application. Due to the large number of associations between domain model classes, using<a target="_blank" rel="external nofollow noopener noreferrer" href="https://martinfowler.com/eaaCatalog/domainModel.html">域模型模式</a>The implemented business logic is particularly difficult to refactor. You usually need to make significant code changes to break these dependencies. The following figure shows the refactoring.</p><p>Once the Coarse Grain interface is implemented, it is possible to turn modules into independent services. To do this, you must write code to enable the overall components and services to be used by using<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.nginx.com/blog/building-microservices-inter-process-communication/inter-process-communication">进程间通信</a>API for (IPC) mechanism<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.nginx.com/blog/building-microservices-inter-process-communication/inter-process-communication">通信</a>。</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/39f5c62f/" title="Introduction to Microservices">https://sunra.top/en/posts/39f5c62f/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/991b3de7/" rel="prev" title="IP Address and Subnet Division, and the Difference from Intranet"><i class="fa fa-angle-left"></i> IP Address and Subnet Division, and the Difference from Intranet</a></div><div class="post-nav-item"> <a href="/en/posts/74ee5df7/" rel="next" title="Routing Protocol">Routing Protocol<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/39f5c62f/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>