<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="In the previous lighting model, we only had one light source, and it was parallel light. But in the actual development process, we often need to deal with a larger number of more complex types of ligh"><meta property="og:type" content="article"><meta property="og:title" content="Unity Rendering Principle (13) Unity&#39;s Rendering Path"><meta property="og:url" content="https://sunra.top/en/posts/40628/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="In the previous lighting model, we only had one light source, and it was parallel light. But in the actual development process, we often need to deal with a larger number of more complex types of ligh"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1659856950/origin-of-ray/screenshot-20220807-152143_bd5my0.png"><meta property="article:published_time" content="2022-08-07T02:09:09.000Z"><meta property="article:modified_time" content="2024-10-18T04:27:28.760Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1659856950/origin-of-ray/screenshot-20220807-152143_bd5my0.png"><link rel="canonical" href="https://sunra.top/en/posts/40628/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/40628/","path":"posts/40628/","title":"Unity Rendering Principle (13) Unity's Rendering Path"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Rendering Principle (13) Unity's Rendering Path | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#rendering-path-for-unity"><span class="nav-number">1.</span> <span class="nav-text">Rendering Path for Unity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#forward-rendering-path"><span class="nav-number">1.1.</span> <span class="nav-text">Forward rendering path</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#principle-of-forward-rendering-path"><span class="nav-number">1.1.1.</span> <span class="nav-text">Principle of Forward Rendering Path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-rendering-in-unity"><span class="nav-number">1.1.2.</span> <span class="nav-text">Forward Rendering in Unity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#built-in-lighting-variables-and-functions"><span class="nav-number">1.1.3.</span> <span class="nav-text">Built-in lighting variables and functions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertex-lighting-rendering-path"><span class="nav-number">1.2.</span> <span class="nav-text">Vertex lighting rendering path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deferred-rendering-path"><span class="nav-number">1.3.</span> <span class="nav-text">Deferred rendering path</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#the-principle-of-delayed-rendering"><span class="nav-number">1.3.1.</span> <span class="nav-text">The principle of delayed rendering</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deferred-rendering-in-unity"><span class="nav-number">1.3.2.</span> <span class="nav-text">Deferred Rendering in Unity</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#which-rendering-path-to-choose"><span class="nav-number">1.4.</span> <span class="nav-text">Which rendering path to choose</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/40628/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Rendering Principle (13) Unity's Rendering Path | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Rendering Principle (13) Unity's Rendering Path</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-08-07 10:09:09" itemprop="dateCreated datePublished" datetime="2022-08-07T10:09:09+08:00">2022-08-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-10-18 12:27:28" itemprop="dateModified" datetime="2024-10-18T12:27:28+08:00">2024-10-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/40628/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/40628/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>In the previous lighting model, we only had one light source, and it was parallel light. But in the actual development process, we often need to deal with a larger number of more complex types of light sources, and importantly, we need to get shadows. Now we’re going to learn how to deal with these more complex lights.</p><span id="more"></span><p>Before learning these, we need to know how Unity handles these light sources. That is, when we place various types of light sources in the scene, how does Unity’s underlying rendering engine make them accessible to our Shader?</p><h2 id="rendering-path-for-unity"><a class="markdownIt-Anchor" href="#rendering-path-for-unity"></a> Rendering Path for Unity</h2><p>In Unity, the Render Path determines how lighting is applied to the Unity Shader. Therefore, if we want to deal with light sources, we need to specify the rendering path used by each Pass. Only by correctly selecting and setting the required rendering path for the Shader can the lighting calculation of the Shader be executed smoothly.</p><p>Unity supports multiple types of rendering paths. Before version 5.0, there were three, forward rendering path, delayed rendering path, and vertex lighting rendering path. However, after 5.0, the fixed-point lighting rendering path has been abandoned, and the new delayed rendering path replaced the original delayed rendering path.</p><p>In most cases, a project only uses one rendering path, so we can set the rendering path when rendering for the entire project, which is set in Peoject Settings, which is the forward rendering path by default, but sometimes, we want to have multiple Rendering paths, for example, camera A uses forward rendering and B uses delayed rendering, we can modify the rendering path of this camera in the settings of each camera. But if the GPU does not support delayed rendering, it will still be downgraded to forward rendering. For details, please refer to the official doc.<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/Manual/RenderingPaths.html">内置渲染路径的渲染管线</a></p><p>Once the setup is complete, we can use the LightMode Tag on each pass to specify the render path used by that pass.</p><p>These are valid values for LightMode channel tags in the built-in render pipeline.</p><p>Value, function<br> Always always render; no lighting applied. This is the default.<br> ForwardBase is used in forward rendering; applies ambient light, main direction light, vertex/SH light source, and lightmaps.<br> ForwardAdd is used in forward rendering; applying additional per-pixel light sources (one channel per light source).<br> Deferred used in deferred rendering; rendering G buffer.<br> ShadowCaster depth renders an object into a shadow map or depth texture.<br> MotionVectors are used to compute the motion vector for each object.<br> PrepassBase is used for older versions of delayed lighting, render normals and specular reflection indices.<br> PrepassFinal for older versions of delayed lighting; render the final color by combining textures, lighting, and glow.<br> ShadowCaster depth renders an object into a shadow map or depth texture.<br> Vertex for legacy vertex lighting rendering (when objects are not lightmapped); apply all vertex lights.<br> Vertex LMRGBM is used for legacy vertex lightmap rendering (when objects are not lightmapped), and for platforms where lightmaps are RGBM-encoded (PC and game console).<br> VertexLM is used for legacy vertex lightmap rendering (when objects are not lightmapped), and on platforms where lightmaps are dual LDR encoded (mobile platforms).<br> Meta This Pass is not used during regular rendering, only for lightmap baking or Enlighten Realtime Global Illumination. For more information, see Lightmapping and shaders.</p><p>So what’s the use of specifying a render path? What’s wrong if a Pass doesn’t specify any render paths? Simply put, specifying a render path is an important communication between us and Unity’s underlying rendering engine. For example, if we set the label of the forward rendering path for a Pass, it is equivalent to notifying Unity that the required lighting properties are ready according to the forward rendering process, and then we can access these properties through the built-in variables provided by Unity.</p><h3 id="forward-rendering-path"><a class="markdownIt-Anchor" href="#forward-rendering-path"></a> Forward rendering path</h3><h4 id="principle-of-forward-rendering-path"><a class="markdownIt-Anchor" href="#principle-of-forward-rendering-path"></a> Principle of Forward Rendering Path</h4><p>For each full forward rendering, we need to render the render graph element of the object and calculate the information of two buffers, one is the color buffer and the other is the depth buffer. We use the depth buffer to determine whether a slice element is Visible, if visible, update the color value of the color buffer</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    <span class="keyword">for</span>(each primitive <span class="keyword">in</span> <span class="keyword">this</span> model) &#123;</span><br><span class="line">        <span class="keyword">for</span>(each fragment covered <span class="keyword">by</span> <span class="keyword">this</span> primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                discard;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For each pixel-by-pixel light source, we need to perform the complete rendering process above. If an object is in the affected area of multiple pixel-by-pixel light sources, then the object needs to execute multiple passes. Each pass calculates the lighting results of a pixel-by-pixel light source, and then mixes these lighting results in the frame buffer to obtain the final color value. Assuming there are N objects in the scene, and each object is affected by M light sources, a total of N * M passes are required to render the entire scene. It can be seen that if there are a lot of pixel-by-pixel lighting, the number of passes that need to be executed will also be large. Therefore, rendering engines usually limit the number of pixel-by-pixel lighting for each object.</p><h4 id="forward-rendering-in-unity"><a class="markdownIt-Anchor" href="#forward-rendering-in-unity"></a> Forward Rendering in Unity</h4><p>In fact, a Pass can be used to calculate not only pixel-by-pixel lighting, but also other lighting such as vertex-by-vertex, depending on the pipeline stage of the lighting calculation and the mathematical model used for the calculation.</p><p>When we render an object, Unity calculates which light sources illuminate it and how those light sources illuminate the object.</p><p>In Unity, there are three ways to handle lighting in the forward rendering path, vertex-by-vertex processing, pixel-by-pixel processing, and spherical harmonic function processing (SH). Deciding which processing mode a light source uses depends on its type and rendering mode. The light source type refers to whether the light source is parallel or other types of light sources, and the rendering mode of the light source is whether the light source is important. If we set the mode of a light to Important, it means that we tell Unity to treat this light source as a pixel-by-pixel light source.</p><p>In forward rendering, when we render an object, Unity will sort the light sources in order of importance according to the settings of each light source in the scene and the degree of influence of these light sources on the object (such as distance from the object, light intensity, etc.). A certain number of light sources will be processed on a pixel-by-pixel basis, then up to 4 light sources will be processed on a vertex-by-vertex basis, and the rest will be processed in an SH manner. The judgment rules used by Unity are as follows:<br> The brightest parallel light in the scene is always processed pixel by pixel</p><ul><li>Light sources with Render Mode set to Not Important will be handled vertex by vertex or SH</li><li>Rendering mode is set to Important light source and will be processed on a pixel-by-pixel basis</li><li>If the number of pixel-by-pixel light sources obtained according to the above rules is less than the number of pixel-by-pixel light sources in Quality Settings, more light sources will be rendered in pixel-by-pixel mode</li></ul><p>So where is the lighting calculation? The answer is that in Pass, there are two passes for forward rendering, Base Pass and Additional Pass, which perform label and rendering settings and general lighting calculations.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1659856950/origin-of-ray/screenshot-20220807-152143_bd5my0.png" alt></p><p>There are a few points that need to be explained in the above picture:</p><ul><li>First of all, you can find that in the rendering settings, in addition to setting the Pass label, we also use the compile directives like ‘#pragma multi_compile_fwdbase’. Although ‘#pragma multi_compile_fwdbase’ and ‘#pragma mulit_compile_fwdadd’ have not been given relevant instructions in the official doc, experiments have shown that without these two compile directives, we can get some correct lighting variables in the relevant Pass, such as lighting attenuation values</li><li>Notes next to Base Pass give some of the lighting features supported in Base Pass. For example in Base Pass we have access to lightmaps</li><li>The parallel light rendered in Base Pass supports shadows by default (if the shadow function of the light source is turned on), while the light rendered in Additional Pass has no shadow effect by default, even if we set it in its Light component Shadow Type with shadow. But we can use ‘#pragma multi_compile_fwdadd_fullshadows’ instead of ‘#pragma multi_compile_fwdadd’ compile command in Additional Pass to turn on shadows for electric lights and spotlights, but this requires Unity to use more Shader variants internally</li><li>Ambient light and self-luminous is also calculated in Base Pass, this is because, for an object, ambient light and self-luminous we only want once, and if we calculate these two kinds of care in Additional Pass, It will cause many times to add ambient light and self-luminous, which is not what we want.</li><li>In the rendering settings of Additional Pass, we also enable and set Blend Mode. This is because we want each Additional Pass to be overlaid with the last lighting result in the frame cache, so as to get the final rendering effect with multiple lighting. If we don’t enable Blend Mode, then the rendering result of Additional Pass will Overwrite the previous rendering results, it looks as if the object only receives the influence of this light source. Usually, the Blend Mode we choose is Blend One One</li><li>For forward rendering, a Unity Shader will typically define a Base Pass (which can also be defined multiple times, such as when double-sided rendering is required, etc.) and an Additional Pass. A Base Pass will only be executed once, while an Additional Pass will be invoked multiple times depending on the number of other pixel-by-pixel lights affecting the object, i.e. each pixel-by-pixel light source will execute an Additional Pass once</li></ul><p>In fact, the rendering path setting just tells Unity where the Pass is in the forward rendering path, and then the underlying rendering engine will perform the relevant calculations and fill in some built-in variables (such as _LightColor0). How to use these built-in variables for calculations is entirely It’s the developer’s choice.</p><h4 id="built-in-lighting-variables-and-functions"><a class="markdownIt-Anchor" href="#built-in-lighting-variables-and-functions"></a> Built-in lighting variables and functions</h4><p>In forward rendering, we can access the following variables in Pass, which we can find in the official doc,<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-UnityShaderVariables.html">内置着色器变量</a></p><p>It should be noted that these variables are not complete, and some built-in variables and functions that can be used for forward rendering are not explained in the official doc.</p><h3 id="vertex-lighting-rendering-path"><a class="markdownIt-Anchor" href="#vertex-lighting-rendering-path"></a> Vertex lighting rendering path</h3><p>The vertex lighting rendering path requires the least hardware configuration and has the highest running performance, but it is also the type with the worst results. It does not support pixel-by-pixel effects, such as shadows, normal mapping, and high-precision highlights. In fact, it is only a subset of forward rendering, and all functions that can be implemented in the vertex lighting rendering path can be completed in the front rendering path. Just like its name, the vertex lighting rendering path just uses a vertex-by-vertex approach to calculate lighting, and there is no magic.</p><p>This rendering path has been abandoned, so I won’t introduce it much.</p><h3 id="deferred-rendering-path"><a class="markdownIt-Anchor" href="#deferred-rendering-path"></a> Deferred rendering path</h3><p>The problem with forward rendering is that when there are a lot of real-time light sources in the scene, the performance of forward rendering will drop rapidly. For example, if we place multiple light sources in an area of the scene, and the areas affected by these light sources overlap each other, in order to get the final lighting effect, we need to execute multiple passes for each object in the area to calculate the lighting results of different light sources for that object, and then mix these results in the color cache to get the final care. However, we need to re-render the object every time we execute a Pass, but many calculations are actually repeated.</p><h4 id="the-principle-of-delayed-rendering"><a class="markdownIt-Anchor" href="#the-principle-of-delayed-rendering"></a> The principle of delayed rendering</h4><p>Delayed rendering mainly consists of two passes. In the first pass, we do not perform any lighting calculation, but only calculate which chips are visible, which is mainly achieved by depth buffering technology. When we find that a chip is visible, we store its relevant information in the G buffer. Then in the second Pass, we use the information of each chip element in the G buffer, such as surface normal, viewing angle direction, diffuse reflection coefficient, etc., to perform real lighting calculation.</p><p>The delayed rendering process can be roughly described with the following pseudocode:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Pass <span class="number">1</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(each primitive <span class="keyword">in</span> <span class="keyword">this</span> model) &#123;</span><br><span class="line">        <span class="keyword">for</span>(each fragment covered <span class="keyword">by</span> <span class="keyword">this</span> primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                discard;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                writeGBuffer(materialInfo, pos, normal, lightDir, viewDir)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(each pixel <span class="keyword">in</span> the screen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pixel <span class="keyword">is</span> valid) &#123;</span><br><span class="line">            <span class="comment">//If the pixel is valid, read the information in its G buffer</span></span><br><span class="line">            readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">//Light calculation based on the information read</span></span><br><span class="line">            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">//Update to frame buffer</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It can be seen that the number of passes used for delayed rendering is usually two, which has nothing to do with the number of light sources contained in the scene. In other words, the efficiency of delayed rendering does not depend on the complexity of the scene, but on the size of the screen space we use. This is because the information we need is stored in buffers, which can be understood as 2D images, and our calculation is actually performed in these image spaces.</p><h4 id="deferred-rendering-in-unity"><a class="markdownIt-Anchor" href="#deferred-rendering-in-unity"></a> Deferred Rendering in Unity</h4><p>There are two kinds of delayed rendering paths in Unity, one is the legacy delayed rendering path and the other is the current one. But either one requires corresponding hardware support.</p><p>The difference between the old and new delayed rendering paths is small, but different techniques are used to weigh different needs. For example, the old version of the delayed rendering path does not support Unity5’s physics-based Standard Shader.</p><p>Below we discuss the new version of the delayed rendering path.</p><p>For the delayed rendering path, it is suitable for situations where there are many light sources in the scene, and there will be performance bottlenecks in forward rendering, and each light source in the delayed rendering path can be processed on a pixel-by-pixel basis. However, delayed rendering also has some drawbacks:</p><ul><li>Does not support true anti-aliasing function</li><li>Cannot handle translucent objects</li><li>Requirements for the graphics card. If you want to use delayed rendering, the graphics card must support MRT (Multiple Render Target), Shader Mode3.0 and above, deep rendering textures and double-sided template buffering</li></ul><p>When using deferred rendering, Unity requires us to provide two passes.</p><ol><li>The first Pass is used to render the G buffer. In this Pass, we will render the object’s diffuse color, highlight color, smoothness, normal, self-luminous and depth into the G buffer of screen space. For each object, this Pass will only be executed once.</li><li>The second pass is used to calculate the real lighting model. This pass will use the data rendered in the previous pass to calculate the final lighting color and store it in the frame buffer</li></ol><p>The default G buffer contains the following render textures (Render Texture, RT)</p><ul><li>RT0: The format is ARGB32, the RBG channel is used to store diffuse colors, the A channel is useless</li><li>RT1: The format is ARGB32, the RGB channel is used to store the highlight reflection color, and the A channel is used to store the index part of the highlight reflection</li><li>RT2: When formatting ARGB2101010, RGB channel is used to store normals, A channel is not used</li><li>RT3: format is ARGB32 (non-HDR) or ARGBHalf (HDR) for storing self-luminous + lightmap + emission probes</li><li>Depth buffering and template buffering</li></ul><p>When calculating lighting in the second Pass, by default only the Standard lighting model built into Unity can be used. If we want to use other lighting models, we need to replace the original Internal-DefferedShading.shader file</p><h3 id="which-rendering-path-to-choose"><a class="markdownIt-Anchor" href="#which-rendering-path-to-choose"></a> Which rendering path to choose</h3><p>For details on which rendering path to choose, you can refer to the official doc:<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/2021.1/Manual/RenderingPaths.html">内置渲染管线中的渲染路径</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/40628/" title="Unity Rendering Principle (13) Unity&#39;s Rendering Path">https://sunra.top/en/posts/40628/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/29980/" rel="prev" title="Git command line scam notes"><i class="fa fa-chevron-left"></i> Git command line scam notes</a></div><div class="post-nav-item"> <a href="/en/posts/57422/" rel="next" title="Unity Rendering Principle (14) Unity's Light Source">Unity Rendering Principle (14) Unity's Light Source<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/40628/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>