<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Recently, I was curious about the protocol that chatgpt can return with streaming requests, so I went to learn about it. At first, I thought it was HTTP2, or the WS protocol, but later found out that"><meta property="og:type" content="article"><meta property="og:title" content="web instant messaging solution finishing"><meta property="og:url" content="https://sunra.top/en/posts/60091/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Recently, I was curious about the protocol that chatgpt can return with streaming requests, so I went to learn about it. At first, I thought it was HTTP2, or the WS protocol, but later found out that"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2023-04-08T01:35:32.000Z"><meta property="article:modified_time" content="2024-11-22T23:34:10.886Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/posts/60091/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/60091/","path":"posts/60091/","title":"web instant messaging solution finishing"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>web instant messaging solution finishing | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#instant-messaging-protocol-classification"><span class="nav-number">1.</span> <span class="nav-text">Instant messaging protocol classification</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http-and-http2"><span class="nav-number">1.1.</span> <span class="nav-text">HTTP and HTTP2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket"><span class="nav-number">1.2.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sse"><span class="nav-number">1.3.</span> <span class="nav-text">SSE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#instant-messaging-method-overview"><span class="nav-number">2.</span> <span class="nav-text">Instant messaging method overview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax-short-polling-script-sends-http-request"><span class="nav-number">2.1.</span> <span class="nav-text">Ajax short polling: script sends http request</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#comet-a-hack-technology-still-http-protocol"><span class="nav-number">2.2.</span> <span class="nav-text">Comet: A Hack Technology (Still HTTP Protocol)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#long-polling-based-on-ajax"><span class="nav-number">2.2.1.</span> <span class="nav-text">Long polling based on Ajax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#streams-based-on-iframe-and-htmlfile"><span class="nav-number">2.2.2.</span> <span class="nav-text">Streams based on Iframe and htmlfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket-2"><span class="nav-number">2.2.3.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sse-2"><span class="nav-number">2.2.4.</span> <span class="nav-text">SSE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#simple-principle-analysis-of-instant-message-scheme"><span class="nav-number">3.</span> <span class="nav-text">Simple principle analysis of instant message scheme</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#communication-principles-of-traditional-web"><span class="nav-number">3.1.</span> <span class="nav-text">Communication Principles of Traditional Web</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problems-that-need-to-be-solved-to-realize-im-application-in-traditional-communication-mode"><span class="nav-number">3.2.</span> <span class="nav-text">Problems that need to be solved to realize IM application in traditional communication mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#full-duplex-low-latency-solution"><span class="nav-number">3.3.</span> <span class="nav-text">Full duplex low latency solution</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#client-browser-short-polling"><span class="nav-number">3.3.1.</span> <span class="nav-text">Client browser short polling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#long-polling"><span class="nav-number">3.3.2.</span> <span class="nav-text">Long polling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#based-on-http-stream-communication"><span class="nav-number">3.3.3.</span> <span class="nav-text">Based on http-stream communication</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#streaming-method-based-on-xhr-objects"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">Streaming method based on XHR objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#based-on-iframe-data-stream"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">Based on iframe data stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-stream-communication-based-on-htmlfile"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">Data stream communication based on htmlfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sse-3"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">SSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#websocket-3"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">WebSocket</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/60091/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="web instant messaging solution finishing | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> web instant messaging solution finishing</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2023-04-08 09:35:32" itemprop="dateCreated datePublished" datetime="2023-04-08T09:35:32+08:00">2023-04-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-11-23 07:34:10" itemprop="dateModified" datetime="2024-11-23T07:34:10+08:00">2024-11-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Sundry/" itemprop="url" rel="index"><span itemprop="name">Sundry</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/60091/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/60091/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Recently, I was curious about the protocol that chatgpt can return with streaming requests, so I went to learn about it. At first, I thought it was HTTP2, or the WS protocol, but later found out that it was not, but a protocol called SSE (Server-Sent Events).) protocol.</p><span id="more"></span><h1 id="instant-messaging-protocol-classification"><a class="markdownIt-Anchor" href="#instant-messaging-protocol-classification"></a> Instant messaging protocol classification</h1><h2 id="http-and-http2"><a class="markdownIt-Anchor" href="#http-and-http2"></a> HTTP and HTTP2</h2><p>HTTP protocol is our most common front-end and back-end instant messaging protocol, the more common is HTTP1, and later in order to solve some of its problems, we proposed HTTP2, but there is no particular change in nature.</p><p>Disadvantages of Http1</p><ul><li>Line head blocking: The method is that several requests are queued for serial single-threaded processing, and the latter requests wait for the return of the previous request to get the opportunity to execute. Once a certain request timed out, etc., the subsequent request can only be blocked, and there is no way., which is often called thread head blocking;</li><li>Insufficient use of TCP links: In HTTP 1.x, if you want to make multiple requests, you must use multiple TCP links, and the browser will limit 6-8 TCP link requests to a single domain name in order to control resources</li></ul><p>Advantages of HTTP2</p><ul><li>Multiple paths to reuse: The most valuable advantage solves the problem of thread head blocking, allows a single http2 connection to send multiple requests and responses, and makes full use of TCP. This makes resource sub-domain names, sprite maps, internal connection styles, etc. no longer applicable.</li><li>Header compression: HTTP2.0 can maintain static dictionaries and dynamic dictionaries on the client and server side to compress and differentially update HTTP headers, greatly reducing the traffic generated by header transmission. Headers in non-two dictionaries can be compressed using Huffman compression.</li><li>New binary format: http1.x is a text format transfer, http2 is a binary format transfer.</li><li>server level push: The server side can actively push resources to the Client.</li></ul><p>Here I will focus on this server level push. This push is different from websocket. Its server level push here means that the server level can actively push other resources when sending the HTML of the page, without waiting for the browser to parse to the corresponding location and initiate the request. For example, the server level can actively push JS and CSS files to the Client without the need for the Client to parse HTML and then send these requests.</p><p>The server level can actively push, and the Client also has the right to choose whether to receive it. If the resources pushed by the server level have been cached by the browser, the browser can reject them by sending RST_STREAM frames. Active push also abides by the same-origin policy, and the server will not casually push third-party resources to the Client.</p><h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2><p>In the new generation of html standard html5, a network technology Websocket for full-duplex communication between browsers and servers is provided. From the Websocket draft, Websocket is a new and independent protocol, based on the TCP protocol, which is compatible with the http protocol, but will not be integrated into the http protocol, but only as part of html5. So the script is given another ability: to initiate websocket requests. We should be familiar with this method because Ajax does it this way, but the difference is that Ajax initiates http requests only.</p><p>Different from the request/response mode of the http protocol, Websocket has a Handshake (Opening Handshake) process before establishing a connection, and a Handshake (Closing Handshake) process before closing the connection. After establishing the connection, the two parties can communicate in both directions.</p><p>From the perspective of browser support, WebSocket is just around the corner, but there is still a long way to go, especially in China, a country where IE6, 7, and 8 are still prevalent. It will take a long time for the demise of old versions of browsers., Comet technology may still be the best solution before full browser compatibility is fully realized. However, there are currently some mature packaging solutions to solve this compatibility limitation</p><h2 id="sse"><a class="markdownIt-Anchor" href="#sse"></a> SSE</h2><p>SSE (Server-Sent Event) is an HTML5 technology that allows the server level to push new data to the client. This is a better solution than having the client pull new data from server level polling every few seconds.</p><p>Compared to WebSocket, it can also push data from the server level to the client. So how do you decide whether to use SSE or WebSocket? In general, what WebSocket can do, SSE can do, and vice versa, but they each have their own advantages in completing certain tasks.</p><p>WebSocket is a more complex server level implementation technology, but it is a true two-way transmission technology, which can push data from the server level to the client and from the client to the server level.</p><p>WebSocket and SSE have similar browser support rates, and most mainstream desktop browsers support both. In Android 4.3 and earlier, the system default browser does not support either, while Firefox and Chrome fully support both; in Android 4.4, the system default browser supports both; Safari supports SSE since 5.0 (iOS systems from 4.0), but does not properly support WebSocket until 6.0 (the WebSocket protocol implemented by Safari before 6.0 has security issues, so some mainstream browsers have disabled implementations based on this protocol).</p><p>Compared to WebSocket, SSE has some significant advantages. Personally, I think its biggest advantage is convenience: you don’t need to add any new components, and you can continue to use it in any backend language and framework you are used to. You don’t have to worry about creating a new virtual machine, getting a new IP or a new Port Number, it’s as simple as adding a new page to an existing website. I like to call this an existing infrastructure advantage.</p><p>The second advantage of SSE is the simplicity of the server. Relatively speaking, WebSocket is very complex and cannot be handled without the help of auxiliary class libraries.</p><p>Because SSE works on the existing HTTP/HTTPS protocol, it can run directly on existing proxy servers and authentication technologies. For WebSocket, proxy servers require some development (or other work) to support, and at the time of writing this book, many servers do not have it (although this situation will improve). SSE has another advantage: it is a text protocol, and script debugging is very easy.</p><p>However, this leads to a potential advantage of WebSocket over SSE: WebSocket is a binary protocol, while SSE is a text protocol (usually encoded in UTF-8). Of course, we can transfer binary data over an SSE connection: in SSE, there are only two characters with special meaning, CR and LF, and it is not difficult to transcode them. However, when transmitting binary data with SSE, the data will become larger. If you need to transfer a large amount of binary data from the server level to the Client, it is best to use WebSocket.</p><p>** The biggest advantage of WebSocket over SSE is that it is two-way communication, which means that sending data to the server level is as easy as receiving data from the server level. When using SSE, data is generally transmitted from the Client to the server level through a separate Ajax request. ** Compared to WebSocket, using Ajax in this way increases the overhead, but it is only a little more. As a result, the question becomes “When do you need to care about this difference?” If you need to transfer data to the server level at a frequency of 1 times per second or faster, you should use WebSocket. The frequency of 0.2 times per second to 1 time per second is a gray area, and there is little difference between using WebSocket and using SSE; but if you expect heavy loads, it is necessary to determine the reference point. When the frequency is lower than 0.2 times per second or so, there is little difference between the two.</p><p>What is the performance of transferring data from the server level to the Client? If it is text data instead of binary data (as mentioned earlier), there is no difference between SSE and WebSocket. They both use TCP/IP sockets and are both lightweight protocols. There is no difference in latency, bandwidth, server load, etc., unless… eh? Unless what?</p><p>When you take advantage of SSE’s existing infrastructure and set up a web server between client and server level scripts, the difference becomes apparent. An SSE connection not only uses a socket, but also takes up an Apache thread or process. If you use PHP, it will create a new PHP instance specifically for this connection. Apache and PHP use a lot of memory, which limits the number of parallel connections the server can support. Therefore, to achieve the same data transmission performance as WebSocket with SSE, you need to write your own backend server. Of course, those who will use their own server and use Node.js in any case will find this strange.</p><p>Let’s talk about the compatibility of WebSocket on older browsers. Currently, more than 2/3 of browsers support these new technologies, and the support rate of mobile end browsers will be lower. By convention, Flash is used whenever a two-way socket is needed, and backwards compatibility of WebSocket is usually done with Flash, which is quite complicated. If Flash is not available on the browser, the situation is even worse. In general, WebSocket is difficult to compatible, SSE is easy to compatible.</p><h1 id="instant-messaging-method-overview"><a class="markdownIt-Anchor" href="#instant-messaging-method-overview"></a> Instant messaging method overview</h1><p>In 1996, the IETF HTTP Working Group released version 1.0 of the HTTP protocol. Until version 1.1, which is commonly used now, the HTTP protocol has undergone 17 years of development. This distributed, stateless, TCP-based request/response protocol, which is widely used today when the Internet is prevalent, seems to have made slow progress compared to the rapid development of the Internet. From the rise of the Internet to the present, it has experienced the web1.0 era when portal websites were prevalent, and then with the emergence of ajax technology, it has developed into the web2.0 era when web applications were prevalent, and now it is moving towards web3.0. On the other hand, the development of the http protocol from version 1.0 to 1.1, in addition to default long connections, is a painless improvement in cache handling, bandwidth optimization, and security. It has always retained a stateless, request/response model, and never seems to realize that this should change.</p><p>Fortunately, the era of HTML5 has arrived, bringing WebSocket and SSE (Server-sent Events) to the realization of instant messages on the Web</p><h2 id="ajax-short-polling-script-sends-http-request"><a class="markdownIt-Anchor" href="#ajax-short-polling-script-sends-http-request"></a> Ajax short polling: script sends http request</h2><p>In order for a traditional web application to interact with a server, it must submit a form. The server receives and processes the incoming form, and then returns a brand new page. Because most of the data of the two pages before and after is the same, this process It transmits a lot of redundant data and wastes bandwidth. So Ajax technology came into being.</p><p>Ajax is short for Asynchronous JavaScript and XML, first proposed by Jesse James Garrett. This technology pioneered by allowing browser scripts (JS) to send http requests. Used by the Outlook Web Access team in 1998 and soon became part of IE4.0, but the technology remained niche until early 2005, when Google used it extensively in its goole groups, gmail and other interactive applications, making Ajax rapidly accepted by everyone.</p><p>The emergence of Ajax makes the transmission of data between the Client and the server much less and much faster, and also meets the needs of the initial development of the web2.0 era characterized by rich User Experience, but slowly it also exposes its drawbacks. For example, it cannot meet the requirements of real-time update data for rich interactive applications such as instant messaging. This browser-side technology is still based on the http protocol after all, and the request/response mode required by the http protocol cannot be changed unless the http protocol itself changes.</p><h2 id="comet-a-hack-technology-still-http-protocol"><a class="markdownIt-Anchor" href="#comet-a-hack-technology-still-http-protocol"></a> Comet: A Hack Technology (Still HTTP Protocol)</h2><p>The traditional polling-based method can no longer meet the low latency requirements of web applications represented by instant messaging, and it will also bring bad User Experience. So a “server push” technology based on http long connections was hacked. This technology was named Comet, a term first proposed by Alex Russell, project director of Dojo Toolkit, in the blog post Comet: Low Latency Data for the Browser, and has been used ever since.</p><p>In fact, server push has existed for a long time and is widely used in the classic client/server model. It’s just that browsers are too lazy and do not provide good support for this technology. But the advent of Ajax made it possible to implement this technology on browsers, and the integration of Google’s gmail and gtalk first used this technology. With the resolution of some key issues (such as the loading and display issues in IE), this technology was quickly recognized, and there are now many mature open source Comet frameworks.</p><p>The following is a comparison of typical Ajax and Comet data transmission methods. The difference is simple and clear. The typical Ajax communication method is also the classic use of the http protocol. To obtain data, you must first send a request. In web applications with high Low Latency requirements, the frequency of server requests can only be increased. Comet is different. The client maintains a long connection with the server, and only when the data required by the client is updated, the server actively pushes the data to the client.</p><p>There are two main ways to implement Comet, long-polling based on Ajax and http streaming based on Iframe and htmlfile.</p><h3 id="long-polling-based-on-ajax"><a class="markdownIt-Anchor" href="#long-polling-based-on-ajax"></a> Long polling based on Ajax</h3><p>The browser sends an XMLHttpRequest request. After receiving the request, the server side will block the request until there is data or timeout before returning it. The browser JS sends a request again after processing the request return information (timeout or valid data) to re-establish the connection. During this period, new data may have arrived on the server side, and the server will choose to save the data until the connection is re-established. The browser will retrieve all the data at once.</p><h3 id="streams-based-on-iframe-and-htmlfile"><a class="markdownIt-Anchor" href="#streams-based-on-iframe-and-htmlfile"></a> Streams based on Iframe and htmlfile</h3><p>Iframe is an html tag. The src attribute of this tag will keep the long connection request to the specified server, and the server can keep returning data. Compared with the first method, this method is closer to the traditional server push.</p><p>In the first way, the browser will call the JS callback function directly after receiving the data, but how to respond to the data in this way? You can embed a JS script in the returned data, such as’ &lt; script type = “text/javascript” &gt; js_func (“data from server”) ', the server side will return the data as the parameter of the callback function, and the browser will execute this JS script after receiving the data.</p><h3 id="websocket-2"><a class="markdownIt-Anchor" href="#websocket-2"></a> WebSocket</h3><p>WebScoket is a new protocol and naturally a new solution</p><h3 id="sse-2"><a class="markdownIt-Anchor" href="#sse-2"></a> SSE</h3><p>SSE is a new protocol and naturally a new solution</p><h1 id="simple-principle-analysis-of-instant-message-scheme"><a class="markdownIt-Anchor" href="#simple-principle-analysis-of-instant-message-scheme"></a> Simple principle analysis of instant message scheme</h1><h2 id="communication-principles-of-traditional-web"><a class="markdownIt-Anchor" href="#communication-principles-of-traditional-web"></a> Communication Principles of Traditional Web</h2><p>The browser itself, as a thin Client, does not have the function of communicating directly with another Client browser in a remote place through system calls. This is different from the way our desktop applications work. Usually, desktop applications can establish a TCP connection with a process on the other end of the remote host through a socket, thus achieving full-duplex instant communication.</p><p>Since the birth of the browser, the client requests the server and the server returns the result, and there has been no change even though it has developed so far. So it is certain that in order to achieve communication between two clients, information must be forwarded through the server. For example, if A wants to communicate with B, A should first send the information to the IM application server, and the server forwards it to B according to the recipient carried in A’s information. Similarly, B to A is also in this mode.</p><h2 id="problems-that-need-to-be-solved-to-realize-im-application-in-traditional-communication-mode"><a class="markdownIt-Anchor" href="#problems-that-need-to-be-solved-to-realize-im-application-in-traditional-communication-mode"></a> Problems that need to be solved to realize IM application in traditional communication mode</h2><p>We recognize that implementing IM software based on the web still requires the browser to request the server model. In this way, the development of IM software needs to solve the following three problems:</p><ul><li>Duplex communication: that is, the browser pulls (pull) server data, and the server pushes (push) data to the browser;</li><li>Low latency: that is, the information sent by the browser A to B should be quickly forwarded to B through the server, and the information of B should also be quickly handed over to A, in fact, it requires any browser to quickly request the data of the server, and the server can Quickly push data to the browser;</li><li>Support cross-domain: Usually the Client browser and the server are in different locations of the network, the browser itself does not allow direct access to servers under different domain names through scripts, even if the IP Address is the same and the domain name is different, and the domain name is the same and the port is different. No, this is mainly for security reasons.</li></ul><h2 id="full-duplex-low-latency-solution"><a class="markdownIt-Anchor" href="#full-duplex-low-latency-solution"></a> Full duplex low latency solution</h2><h3 id="client-browser-short-polling"><a class="markdownIt-Anchor" href="#client-browser-short-polling"></a> Client browser short polling</h3><p>This is the simplest solution. The principle is that the Client sends a request to the server every short period of time through Ajax, the server returns the latest data, and then the Client updates the interface according to the obtained data, so that It indirectly realizes instant communication. The advantage is simplicity, but the disadvantage is that it puts a lot of pressure on the server and wastes bandwidth traffic (usually the data does not change).</p><h3 id="long-polling"><a class="markdownIt-Anchor" href="#long-polling"></a> Long polling</h3><p>In the above polling solution, since a request is sent every time, the server level sends the data regardless of whether the data changes or not, and the connection is closed after the request is completed. A lot of the communication passing through this is unnecessary, so there is a long-polling method. In this way, the client sends a request to the server, the server checks if the data requested by the client has changed (whether there is the latest data), and responds immediately if there is a change, otherwise the connection is maintained and the latest data is checked regularly until a data update or connection timeout occurs. At the same time, once the client connection is disconnected, the request is issued again, which greatly reduces the number of client requests to the server in the same time.</p><h3 id="based-on-http-stream-communication"><a class="markdownIt-Anchor" href="#based-on-http-stream-communication"></a> Based on http-stream communication</h3><p>There is also a communication method based on http-stream stream. The principle is to keep the client connected to the server level continuously during a request, and then the server level continuously transmits data to the client, just like the data stream, it does not send all the data to the client at once. The difference between it and the polling method is that the client only sends a request during the entire communication process, and then the server level maintains a long connection with the client, and uses this connection to send back data to the client.</p><p>This scheme is divided into several different data stream transmission methods.</p><h4 id="streaming-method-based-on-xhr-objects"><a class="markdownIt-Anchor" href="#streaming-method-based-on-xhr-objects"></a> Streaming method based on XHR objects</h4><p>The idea of this method is to construct an XHR object, by listening to its onreadystatechange event, when its readyState is 3, get its responseText and then process it. The readyState is 3, which means that the data transmission is in progress, and the entire communication process has not yet ended. So it is still getting the data sent by the server level. It means that the data is sent until the readyState is 4, and the communication process ends. In this process, the data passed by the server level to the client is sent to the Client in the form of stream multiple times, and the Client is also obtained in the form of stream, so it is called http-streaming data stream mode.</p><p>Here, since the data received by the Client is sent in segments, it is best to define a cursor received to obtain the latest data and discard the data that has been received before, and print out the latest data received each time through this cursor., and print out the entire responseText after the communication ends.</p><h4 id="based-on-iframe-data-stream"><a class="markdownIt-Anchor" href="#based-on-iframe-data-stream"></a> Based on iframe data stream</h4><p>Since earlier versions of IE do not allow the responseText property of XHR to be obtained when the readyState is 3, in order to achieve the use of this technology on IE, an iframe-based data stream communication method has emerged. Specifically, it is dynamically loading an iframe in the browser, so that its src attribute points to the URL of the requested server. In fact, it sends an http request to the server, and then creates a function for processing data on the browser side. At the server level, the data is output to the Client through the long connection between the iframe and the browser, but the returned data is not general data, but a function similar to ‘&lt; script type =\ &quot;text/javascript&quot; &gt; parent.process (’ “+ randomNum.toString ()+”')&lt;/ script &gt; 'The way the script is executed, the browser receives This data will be parsed into js code and find the specified function on the page to execute, in fact, the server level indirectly uses its own data to indirectly call the client’s code, to achieve the purpose of real-time update client.</p><h4 id="data-stream-communication-based-on-htmlfile"><a class="markdownIt-Anchor" href="#data-stream-communication-based-on-htmlfile"></a> Data stream communication based on htmlfile</h4><p>A new problem has arisen again. In IE, the iframe is used to request the server level. Before the server level keeps the communication connection and does not all return, the browser title has been loaded, and the bottom also shows that it is loading. This is for a product. User Experience is not good, so Google’s geniuses came up with a hack method. That is, in IE, dynamically generate an htmlfile object, which is a com component in the form of ActiveX. It is actually an HTML doc implemented in memory. By adding the generated iframe to the HTMLfile in this memory, and using the data flow of the iframe The communication method achieves the above effect. At the same time, because the HTMLfile object is not directly added to the page, it does not cause the browser to display the phenomenon of loading.</p><h4 id="sse-3"><a class="markdownIt-Anchor" href="#sse-3"></a> SSE</h4><p>In order to solve the problem that the browser can only unidirectional transmission of data to the server level, HTML5 provides a new technology called server push event SSE, which can realize the client request server level, and then the server level uses the communication connection established with the client to push data to the client, the client receives the data and processes it. From an independent point of view, SSE technology provides the function of pushing data from the server to the browser in one way, but with the active request of the browser, it actually realizes the two-way communication between the client and the server. Its principle is to construct an eventSource object in the Client, which has the readySate property, which is represented as follows:</p><p>0: Connecting to the server.<br> 1: The connection is opened.<br> 2: The connection is closed.</p><p>At the same time, the eventSource object will maintain a long connection with the server, and will be automatically reconnected after disconnection. If you want to force the connection, you can call its close method. It can listen to the onmessage event, the server level follows the format of SSE data transmission to the Client, and the Client can receive data when the onmessage event is triggered, so as to perform some processing</p><blockquote><p>Browser Native API</p></blockquote><h4 id="websocket-3"><a class="markdownIt-Anchor" href="#websocket-3"></a> WebSocket</h4><p>In the above solutions, they are all hack technologies formed by combining the browser’s one-way request to the server or the server’s one-way push of data to the browser. In HTML5, in order to enhance the functionality of the web, websocket technology is provided. It is not only a web communication method, but also an application layer protocol. It provides native dual full-duplex cross-domain communication between the browser and the server. Through the establishment of a websocket connection (actually a TCP connection) between the browser and the server, it can achieve Client-to-server and server-to-client data transmission at the same time. For the principle of this technology, please refer to: “WebSocket Detailed Explanation (1): Preliminary Understanding of WebSocket Technology”, “WebSocket Detailed Explanation (2): Technical Principle, Code Demonstration and Application Cases”, “WebSocket Detailed Explanation (3): In-depth WebSocket Communication Protocol Details”, I will not go into details here, and give the code directly. Before looking at the code, you need to understand the entire working process of websocket.</p><p>The first is Client new, a websocket object, which will send an http request to the server level. The server level finds that this is a webscoket request, and will agree to the protocol conversion and send back a response with a 101 status code to the Client. The above process is called a handshake. After this handshake, the Client establishes a TCP connection with the server level. On this connection, the server level and the Client can communicate in two directions. At this time, the two-way communication at the application layer is the ws or wss protocol, which has nothing to do with http. The so-called WS protocol requires the Client and server levels to send data messages network packets (frames) in a certain format before the other party can understand.</p><p>Reference article:<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.52im.net/thread-336-1-1.html">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</a><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.52im.net/thread-338-1-1.html">新手入门贴：史上最全Web端即时通讯技术原理详解</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/60091/" title="web instant messaging solution finishing">https://sunra.top/en/posts/60091/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/12801/" rel="prev" title="Summary of GAMES101 Series (1) Linear Algebra and Model Transformation"><i class="fa fa-chevron-left"></i> Summary of GAMES101 Series (1) Linear Algebra and Model Transformation</a></div><div class="post-nav-item"> <a href="/en/posts/8b781825/" rel="next" title="fetch-event-source source code parsing">fetch-event-source source code parsing<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/60091/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>