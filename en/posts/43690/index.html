<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="The most important thing in hardware is the CPU, which is the core component of executing programs. The computer we commonly use is the x86 platform, so we need to have some basic understanding of the"><meta property="og:type" content="article"><meta property="og:title" content="Three Modes of CPU Work"><meta property="og:url" content="https://sunra.top/en/posts/43690/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="The most important thing in hardware is the CPU, which is the core component of executing programs. The computer we commonly use is the x86 platform, so we need to have some basic understanding of the"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://static001.geekbang.org/resource/image/14/13/14633ea933972e19f3439eb6aeab3d13.jpg?wh=2805*2805"><meta property="og:image" content="https://static001.geekbang.org/resource/image/14/13/14633ea933972e19f3439eb6aeab3d13.jpg?wh=2805*2805"><meta property="og:image" content="https://static001.geekbang.org/resource/image/e8/57/e8876e8561b949b8af5d5237e48f8757.jpg?wh=2783*1810"><meta property="og:image" content="https://static001.geekbang.org/resource/image/0f/2a/0f564d0aac8514245805eea31aa32c2a.jpeg?wh=1389*819"><meta property="og:image" content="https://static001.geekbang.org/resource/image/b4/34/b40a64dd5ca1dc1efd8957525e904634.jpg?wh=3855*3105"><meta property="og:image" content="https://static001.geekbang.org/resource/image/ab/f7/ab203e85dd8468051eca238c3ebd81f7.jpg?wh=3149*2440"><meta property="og:image" content="https://static001.geekbang.org/resource/image/d0/a4/d08ec3163c80a5dd94e488a71588f8a4.jpg?wh=4565*1513"><meta property="og:image" content="https://static001.geekbang.org/resource/image/e1/0b/e11b9de930a09fb41bd6ded9bf12620b.jpg?wh=3809*2105"><meta property="og:image" content="https://static001.geekbang.org/resource/image/ff/5b/ff5c25c85a7fa28b17f386848f19fb5b.jpg?wh=2696*1780"><meta property="og:image" content="https://static001.geekbang.org/resource/image/97/c4/974b59084976ddb3df9bdc3bea9325c4.jpg?wh=4260*3060"><meta property="og:image" content="https://static001.geekbang.org/resource/image/28/c4/28f28817ca5a3e47f80ea798698dbdc4.jpg?wh=4155*2655"><meta property="article:published_time" content="2022-02-06T08:05:53.000Z"><meta property="article:modified_time" content="2024-10-18T08:01:21.668Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static001.geekbang.org/resource/image/14/13/14633ea933972e19f3439eb6aeab3d13.jpg?wh=2805*2805"><link rel="canonical" href="https://sunra.top/en/posts/43690/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/43690/","path":"posts/43690/","title":"Three Modes of CPU Work"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Three Modes of CPU Work | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#real-mode"><span class="nav-number">1.</span> <span class="nav-text">Real mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#real-mode-register"><span class="nav-number">1.1.</span> <span class="nav-text">Real mode register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-memory-in-real-mode"><span class="nav-number">1.2.</span> <span class="nav-text">Access memory in real mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#real-mode-interrupt"><span class="nav-number">1.3.</span> <span class="nav-text">Real mode interrupt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protection-mode"><span class="nav-number">2.</span> <span class="nav-text">Protection mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-register"><span class="nav-number">2.1.</span> <span class="nav-text">Protected mode register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-privilege-level"><span class="nav-number">2.2.</span> <span class="nav-text">Protected mode privilege level</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-segment-descriptor"><span class="nav-number">2.3.</span> <span class="nav-text">Protected mode segment descriptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-segment-selector"><span class="nav-number">2.4.</span> <span class="nav-text">Protected mode segment selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-flat-model"><span class="nav-number">2.5.</span> <span class="nav-text">Protected mode flat model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode-interrupt"><span class="nav-number">2.6.</span> <span class="nav-text">Protected mode interrupt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#long-mode"><span class="nav-number">3.</span> <span class="nav-text">Long mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#long-mode-segment-descriptor"><span class="nav-number">3.1.</span> <span class="nav-text">Long mode segment descriptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#long-mode-interrupt"><span class="nav-number">3.2.</span> <span class="nav-text">Long mode interrupt</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/43690/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Three Modes of CPU Work | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Three Modes of CPU Work</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-02-06 16:05:53" itemprop="dateCreated datePublished" datetime="2022-02-06T16:05:53+08:00">2022-02-06</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-10-18 16:01:21" itemprop="dateModified" datetime="2024-10-18T16:01:21+08:00">2024-10-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/43690/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/43690/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>The most important thing in hardware is the CPU, which is the core component of executing programs. The computer we commonly use is the x86 platform, so we need to have some basic understanding of the x86 CPU. According to the order of CPU function upgrade iteration, the working modes of the CPU include real mode, protected mode, and long mode. The way the CPU executes programs in these working modes is very different. Let’s discuss these working modes together.</p><span id="more"></span><p>Please think about it. If the following application code can run successfully, what will be the consequences?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* addr = (<span class="type">int</span>*)<span class="number">0</span>;</span><br><span class="line">    Cli ();<span class="comment">//off interrupt</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = <span class="number">0</span>;</span><br><span class="line">        addr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above code first turns off the CPU interrupt, makes the CPU stop responding to the interrupt signal, then enters an infinite loop, and finally starts writing 0 from the memory 0 address.</p><p>You will immediately think that this code only does two things: one is to lock the CPU, and the other is to empty the memory. You may think that if such code could run normally, it would be terrible.</p><p>However, if it was in real mode, such code could indeed run normally. Because a long time ago, there were too few computer resources and too little memory, and it was only a single program that was executed. Most of the programs were written and debugged by professionals before they could make an appointment to run on the computer. There is no concept of a modern operating system.</p><p>Later, there was a DOS operating system, which was also a single-channel program system and did not have the ability to execute multiple programs, so the CPU mode could also work well.</p><h2 id="real-mode"><a class="markdownIt-Anchor" href="#real-mode"></a> Real mode</h2><p>Real mode is also called real address mode, real, that is, real, this real is divided into two aspects, one aspect is to run the real instruction, the action of the instruction does not distinguish, ** direct execution of the real function of the instruction **, on the other hand It is ** that the address sent to the memory is real **, and it is sent to the memory without restrictions on any address.</p><h3 id="real-mode-register"><a class="markdownIt-Anchor" href="#real-mode-register"></a> Real mode register</h3><p>Because the CPU completes the corresponding function according to the instruction, for example: ADD AX, CX; this instruction completes the addition operation, AX, CX are the operands of the ADD instruction, which can be understood as two parameters of the ADD function, and its function is to add the data in AX and CX.</p><p>The operands of the instruction can be registers, memory addresses, constants, in fact, usually registers, AX, CX is the register in the x86 CPU.</p><p>Let’s take a look at the registers of the x86 CPU in real mode. Each register in the table is 16 bits</p><h3 id="access-memory-in-real-mode"><a class="markdownIt-Anchor" href="#access-memory-in-real-mode"></a> Access memory in real mode</h3><p>Although there are registers, the data and instructions are placed in memory. Usually, data needs to be loaded into the register before it can be operated, and there are instructions to obtain the register. These need to access memory, and accessing memory requires knowing the address of the memory.</p><p>So how is this address calculated?</p><p><img src="https://static001.geekbang.org/resource/image/14/13/14633ea933972e19f3439eb6aeab3d13.jpg?wh=2805*2805" alt><br> <img src="https://static001.geekbang.org/resource/image/14/13/14633ea933972e19f3439eb6aeab3d13.jpg?wh=2805*2805" alt></p><p>Combined with the above figure, it can be found that all memory addresses are shifted 4 bits to the left by the segment register, plus a value or constant in the general purpose register to form an address, and then access the memory from this address.</p><p>This is the famous ** segmented memory management model ** (this memory management model should only be used in real mode, modern operating systems use paging or segmented paging). However, it should be noted here that the ** code segment is determined by CS and IP, and the stack segment is determined by SS and SP segments ** (CS, IP register is conceptually equivalent to what we often say PC register).</p><p>Next we write a DOS Hello World application, which is a work in real mode assembly code program, a total of 16 bits, the specific code is as follows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Data SEGMENT; Define a data segment to store Hello World!</span><br><span class="line">    Hello DB&#x27;Hello World! $&#x27;; note to end with $</span><br><span class="line">data ENDS</span><br><span class="line">Code SEGMENT; Define a code segment to store program instructions</span><br><span class="line">    ASSUME CS: CODE, DS: DATA; tells the assembler that DS points to the data segment and CS points to the code segment</span><br><span class="line">start:</span><br><span class="line">    MOV AX, data; Assign the first address of the data segment to AX                </span><br><span class="line">    MOV DS, AX; Assign AX to DS so that DS points to the data segment</span><br><span class="line">    LEA DX, hello; make DX point to hello first address</span><br><span class="line">    MOV AH, 09h; Set the parameter 09H for AH, AH is 8 bits higher in AX, AL is 8 bits lower in AX, other similar</span><br><span class="line">    INT 21h; Execute DOS interrupt Output DS points to DX points to string hello</span><br><span class="line">    MOV AX, 4C00h; Set parameters for AX 4C00h</span><br><span class="line">    INT 21h; call function number 4C00h, end the program</span><br><span class="line">code ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure><p>The structural model in the above code is also in line with the segmented memory management mode in the real mode of the CPU. After they are converted into binary data by the assembler, they also exist in the form of segments. The comments in the code are very clear, and you should be able to understand them easily. Most of them are operation registers, where LEA is the address instruction and MOV is the data transfer instruction, which is the INT interrupt. You may not understand it yet, let’s study it.</p><h3 id="real-mode-interrupt"><a class="markdownIt-Anchor" href="#real-mode-interrupt"></a> Real mode interrupt</h3><p>Interrupt is to stop the execution of the current program, and then jump to another specific address to run specific code. In real mode, its implementation process is to save the CS and IP registers first, and then load the new CS and IP registers, so how is the interrupt generated?</p><p>In the first case, the interrupt controller sends an electronic signal to the CPU, and the CPU will respond to this signal. The interrupt controller will then send the interrupt number to the CPU, which is a hardware interrupt.</p><p>The second situation is that the CPU executes the INT instruction, which will be followed by a constant, which is the soft interrupt number. This situation is a software interrupt.</p><p>Both hardware and software interrupts are a way for the CPU to respond to external events.</p><p>In order to implement interrupts, an interrupt vector table needs to be placed in memory. The address and length of this table are pointed to by the specific register IDTR of the CPU. In real mode, an entry in the table consists of code segment addresses and intra-segment offsets, as shown in the following figure</p><p><img src="https://static001.geekbang.org/resource/image/e8/57/e8876e8561b949b8af5d5237e48f8757.jpg?wh=2783*1810" alt></p><p>The meaning shown in the figure above, the IDTR register saves the start address and length of the interrupt vector table, which stipulates where the interrupt vector can be stored. When an interrupt number is received, it can first compare whether the length is exceeded. If not, then add the interrupt number and the start address to obtain the entry of the current interrupt.</p><p>With the interrupt number, the CPU can calculate the entries in the interrupt vector based on the information in the IDTR register, and then load the CS (load code segment base address) and IP (load code segment offset) registers, and finally respond to interrupt.</p><h2 id="protection-mode"><a class="markdownIt-Anchor" href="#protection-mode"></a> Protection mode</h2><p>As the size of the software continues to increase, higher computation and larger memory capacity are required. With a large memory, the first problem to be solved is the addressing problem, because the 16-bit register can only represent 216 addresses at most, so the CPU’s registers and arithmetic units must be expanded to 32 bits.</p><p>However, although expanding the number of bits of CPU internal devices solves the calculation and addressing problems, it still does not solve the problem in the previous real mode scenario. There are two reasons for the problem in the previous scenario.</p><p>First, the CPU executes any instruction indiscriminately.<br> Second, the CPU does not restrict the address of accessing memory.</p><p>Based on these reasons, the CPU implements a protected mode. That is, virtual abstraction is performed on the CPU.</p><h3 id="protected-mode-register"><a class="markdownIt-Anchor" href="#protected-mode-register"></a> Protected mode register</h3><p>Compared with the real mode, the protected mode adds some control registers and segment registers, expands the bit width of the general purpose register, all the general purpose registers are 32 bits, and the lower 16 bits can be used alone. Split into two 8-bit registers, as shown in the table below.</p><p><img src="https://static001.geekbang.org/resource/image/0f/2a/0f564d0aac8514245805eea31aa32c2a.jpeg?wh=1389*819" alt></p><h3 id="protected-mode-privilege-level"><a class="markdownIt-Anchor" href="#protected-mode-privilege-level"></a> Protected mode privilege level</h3><p>In order to distinguish which instructions (such as in, out, cli) and which resources (such as registers, I/O ports, memory addresses) can be accessed, the CPU implements privilege levels.</p><p>Privilege levels are divided into 4 levels, R0~ R3, each privilege level executes a different number of instructions, R0 can execute all instructions, R1, R2, R3 in descending order, they can only execute a subset of the number of instructions at the previous level. The access to memory is achieved by the cooperation between the segment descriptor and the privilege level mentioned later.</p><p>R0 has the most power and can access resources with low privilege levels, but not vice versa.</p><h3 id="protected-mode-segment-descriptor"><a class="markdownIt-Anchor" href="#protected-mode-segment-descriptor"></a> Protected mode segment descriptor</h3><p>Due to the expansion of the CPU, the 32-bit segment base address and intra-segment offset, as well as some other information, the 16-bit segment register must not be placed. If you can’t put it down, you need to find memory to borrow space, and then encapsulate the information describing a segment into a segment descriptor in a specific format and put it in memory. The format is as follows.</p><p><img src="https://static001.geekbang.org/resource/image/b4/34/b40a64dd5ca1dc1efd8957525e904634.jpg?wh=3855*3105" alt></p><p>A segment descriptor has 64 bits and 8 bytes of data, which contains the segment base address, segment length, segment permission, segment type (which can be system segment, code segment, data segment), whether the segment is readable and executable, etc. Although the data distribution is a bit messy, this is due to historical reasons.</p><p>A segment descriptor has 64 bits and 8 bytes of data, which contains the segment base address, segment length, segment permission, segment type (which can be system segment, code segment, data segment), whether the segment is readable and executable, etc. Although the data distribution is a bit messy, this is due to historical reasons.</p><p>Multiple segment descriptors form a global segment descriptor table in memory. The base address and length of this table are indicated by the CPU and GDTR registers. As shown in the figure below.</p><p><img src="https://static001.geekbang.org/resource/image/ab/f7/ab203e85dd8468051eca238c3ebd81f7.jpg?wh=3149*2440" alt></p><p>** We can see at a glance that the segment register no longer stores the segment base address, but the index of the specific segment descriptor. When accessing a memory address, the index in the segment register will first find the segment descriptor in memory in conjunction with the GDTR register., and then judge whether the access is successful according to the segment information **.</p><h3 id="protected-mode-segment-selector"><a class="markdownIt-Anchor" href="#protected-mode-segment-selector"></a> Protected mode segment selector</h3><p>If you think that CS, DS, ES, SS, FS, GS these segment registers, which is stored inside a memory segment descriptor index, then you can be sloppy, in fact, they are composed of shadow registers, segment descriptor index, descriptor table index, permission level. As shown in the figure below</p><p><img src="https://static001.geekbang.org/resource/image/d0/a4/d08ec3163c80a5dd94e488a71588f8a4.jpg?wh=4565*1513" alt></p><p>The shadow register in the above figure is operated by hardware and is not visible to system programmers. It is a cache of a segment descriptor designed by hardware to reduce performance loss. Otherwise, every memory access has to go to the memory to look up the table. The performance loss is huge, and the shadow register is exactly 64 bits, which stores 8-byte segment descriptor data.</p><p>The reason why the lower three bits can put TI and RPL is because the segment descriptor is 8-byte aligned, and the lower three bits of each index are 0 (this part means that because the segment descriptor is 8-byte aligned, its index is All are integer multiples of 8, so the lower three bits are 0. Similar to 1000, 10000, 11000. So the lower three bits can be used for other things, here we use TI and RPL.), we don’t need to pay attention to LDT, we just need to use the GDT global descriptor table, so TI is always set to 0.</p><p>Usually, RPL in CS and SS constitutes CPL (current permission level), so it is often RPL = CPL, and then CPL indicates what permission the initiator wants to access the target segment. When the CPL is greater than the target segment DPL, then The CPU prohibits access, and only when the CPL is less than or equal to the target segment DPL can it be accessed.</p><h3 id="protected-mode-flat-model"><a class="markdownIt-Anchor" href="#protected-mode-flat-model"></a> Protected mode flat model</h3><p>There are many flaws in the segmentation model, which will be introduced in detail in the memory management course later. In fact, modern operating systems will use the paging model (this will be discussed in the MMU class later).</p><p>** However, the x86 CPU cannot directly use the paging model, but must decide whether to turn on paging as needed under the premise of the segmented model. ** Because this is a hardware regulation, programmers cannot change it. But we can simplify the design to make segmentation a “dummy”, which is the flat model of protected mode.</p><p>According to the previous description, we found that the CPU 32-bit registers can only generate addresses of up to 4GB size, and the length of a segment can only be 4GB, so we set the base address of all segments to 0, and the maximum length of the segment is set to 0xFFFFF, and the granularity of the segment length is set to 4KB, so that all segments point to the same (0~ 4GB-1) byte-sized address space.</p><p>Let’s take a look at the previous Hello OS middle segment descriptor table, as shown below</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">The first segment descriptor CPU hardware specification must be 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">; segment base address = 0, segment length = 0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=1,C=1,R=1,A=0</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">; segment base address = 0, segment length = 0xfffff</span><br><span class="line">;G=1,D/B=1,L=0,AVL=0 </span><br><span class="line">;P=1,DPL=0,S=1</span><br><span class="line">;T=0,C=0,R=1,A=0</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure><p>The comments in the above code are already clear. The segment length needs to be matched with the G bit. If the G bit is 1, the segment length is equal to 0xfffff 4KB **. The DPL = 0 of the above segment descriptor means that the highest privilege is required, that is, CPL = 0 to access.</p><h3 id="protected-mode-interrupt"><a class="markdownIt-Anchor" href="#protected-mode-interrupt"></a> Protected mode interrupt</h3><p>Because the CPU does not need to do permission checking in real mode, it can load the CS: IP register directly from the values in the interrupt vector table.</p><p>The interrupt in protected mode requires permission checking and privilege level switching, so it is necessary to expand the information of the interrupt vector table, that is, each interrupt is represented by an interrupt gate descriptor, which can also be referred to as an interrupt gate. The interrupt gate descriptor still has its own format, as shown in the figure below.</p><p><img src="https://static001.geekbang.org/resource/image/e1/0b/e11b9de930a09fb41bd6ded9bf12620b.jpg?wh=3809*2105" alt></p><p>Similarly, to implement an interrupt in protected mode, there must also be an interrupt vector table in memory, which is also pointed to by the IDTR register, but the entry in the interrupt vector table becomes the interrupt gate descriptor, as shown in the following figure.</p><p><img src="https://static001.geekbang.org/resource/image/ff/5b/ff5c25c85a7fa28b17f386848f19fb5b.jpg?wh=2696*1780" alt></p><p>After an interrupt is generated, the CPU will first check whether the interrupt number is greater than the last interrupt gate descriptor. The x86 CPU supports a maximum of 256 interrupt sources (ie, interrupt numbers: 0~ 255), and then check the descriptor type (whether it is an interrupt gate or a trap gate), whether it is a system descriptor, and whether it exists in memory.</p><p>Next, check the segment descriptor in the interrupt gate descriptor to which the segment selector points.</p><p>Finally, do a permission check. If the CPL is less than or equal to the DPL of the interrupt gate, and the CPL is greater than or equal to the DPL of the segment descriptor pointed to by the segment selector in the interrupt gate, it points to the DPL of the segment descriptor.</p><p>Further, CPL is equal to the DPL of the segment selector in the interrupt gate pointing to the segment descriptor, which means that the same level permission does not perform stack switching, otherwise stack switching will be performed. If you perform a stack switch, you also need to load the SS and ESP of the specific permissions from the TSS, and of course check the segment descriptor pointed to by the segment selector in the SS. After this series of checks, the CPU will load the target code segment selector in the interrupt gate descriptor into the CS register, and load the target code segment offset into the EIP register.</p><h2 id="long-mode"><a class="markdownIt-Anchor" href="#long-mode"></a> Long mode</h2><p>Long mode, also known as AMD64, because this standard was first defined by AMD, it enables the CPU to have 64-bit processing power on the existing basis, which can not only complete 64-bit data operations, but also address 64-bit address space. This is still important on large computers, because their physical memory usually has several hundred GB.</p><p>Compared with protected mode, long mode adds some general purpose registers and expands the bit width of the general purpose register. All general purpose registers are 64 bits, and the lower 32 bits can also be used alone. This lower 32 bits can be split into a lower 16-bit register, and the lower 16 bits can be split into two 8-bit registers.</p><p>Long mode still has most of the features of protected mode, such as privilege level and permission checking. The same parts will not be repeated, and only the differences between long mode and protected mode will be explained here.</p><h3 id="long-mode-segment-descriptor"><a class="markdownIt-Anchor" href="#long-mode-segment-descriptor"></a> Long mode segment descriptor</h3><p><img src="https://static001.geekbang.org/resource/image/97/c4/974b59084976ddb3df9bdc3bea9325c4.jpg?wh=4260*3060" alt></p><p>In long mode, the CPU no longer checks the segment base address and segment length, but only checks the DPL. This check process is the same as in protected mode. When L = 1 and D/B = 0 in the descriptor, it is a 64-bit code segment, and the DPL is still a privilege level of 0~ 3. Then there are multiple segment descriptions in memory to form a global segment descriptor table, which is also pointed to by the CPU’s GDTR register.</p><h3 id="long-mode-interrupt"><a class="markdownIt-Anchor" href="#long-mode-interrupt"></a> Long mode interrupt</h3><p>In order to achieve the protection mode interrupt permission check, to achieve the interrupt gate descriptor, stored in the interrupt gate descriptor corresponding to the segment selector and its offset within the segment, as well as DPL permissions, if the permission check is passed, then with the corresponding segment selector and its offset within the segment load CS: EIP register.</p><p>If you remember the interrupt gate descriptor, you will find that the in-segment offset is only 32 bits, but long mode supports 64-bit memory addressing, so we need to modify and expand the interrupt gate descriptor. Let’s take a look at the format of the interrupt gate descriptor in long mode.</p><p><img src="https://static001.geekbang.org/resource/image/28/c4/28f28817ca5a3e47f80ea798698dbdc4.jpg?wh=4155*2655" alt></p><p>Firstly, in order to support 64-bit addressing, the interrupt gate descriptor is added by 8 bytes on the original basis to store the high 32-bit value of the target segment offset. Secondly, the code segment descriptor corresponding to the target code segment selector must be a 64-bit code segment. The IST in the last one is the IST pointer in 64-bit TSS, because we do not use this feature, so we will not introduce it in detail. Long mode also has an interrupt gate descriptor table in memory, but the entries in the table (as shown in the figure above) are 16 bytes in size, supporting up to 256 interrupt sources, and the response to interrupts and related permissions are checked and protected. Mode is the same</p><p>Reference link: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://time.geekbang.org/column/article/375278">https://time.geekbang.org/column/article/375278</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/43690/" title="Three Modes of CPU Work">https://sunra.top/en/posts/43690/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/39443/" rel="prev" title="Fundamentals of Linear Algebra (I)  Connections Between Determinants, Matrices, Vectors and Equations(above)"><i class="fa fa-chevron-left"></i> Fundamentals of Linear Algebra (I) Connections Between Determinants, Matrices, Vectors and Equations(above)</a></div><div class="post-nav-item"> <a href="/en/posts/38516/" rel="next" title="Unity Rendering Principle (2) Some easily confused terms">Unity Rendering Principle (2) Some easily confused terms<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/43690/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>