<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="This week, I used NodeJs to process pictures in the coding process. Because the interfaces for picture processing are all Promises, my program is full of nested returns of Promises. The result of then"><meta property="og:type" content="article"><meta property="og:title" content="Promise Source Code Analysis"><meta property="og:url" content="https://sunra.top/en/posts/52b6d429/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="This week, I used NodeJs to process pictures in the coding process. Because the interfaces for picture processing are all Promises, my program is full of nested returns of Promises. The result of then"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2019-12-06T12:22:00.000Z"><meta property="article:modified_time" content="2025-09-30T03:08:40.035Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/posts/52b6d429/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/52b6d429/","path":"posts/52b6d429/","title":"Promise Source Code Analysis"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Promise Source Code Analysis | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#promise"><span class="nav-number">1.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#then-the-rules"><span class="nav-number">1.1.</span> <span class="nav-text">Then the rules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rules-of-catch"><span class="nav-number">1.2.</span> <span class="nav-text">Rules of catch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#source-code-analysis"><span class="nav-number">2.</span> <span class="nav-text">Source code analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tool-function"><span class="nav-number">2.1.</span> <span class="nav-text">Tool function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#statement"><span class="nav-number">2.2.</span> <span class="nav-text">Statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#doresolve"><span class="nav-number">2.3.</span> <span class="nav-text">doResolve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resolve"><span class="nav-number">2.4.</span> <span class="nav-text">resolve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#then"><span class="nav-number">2.5.</span> <span class="nav-text">then</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-exactly-does-promise-mean-by-microtask"><span class="nav-number">3.</span> <span class="nav-text">What exactly does Promise mean by microtask?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/52b6d429/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Promise Source Code Analysis | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Promise Source Code Analysis</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-06 20:22:00" itemprop="dateCreated datePublished" datetime="2019-12-06T20:22:00+08:00">2019-12-06</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2025-09-30 11:08:40" itemprop="dateModified" datetime="2025-09-30T11:08:40+08:00">2025-09-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/52b6d429/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/52b6d429/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>This week, I used NodeJs to process pictures in the coding process. Because the interfaces for picture processing are all Promises, my program is full of nested returns of Promises. The result of then returns another Promise, and another Promise. Some of the then in the series will return a new Promise, which once confused me.</p><p>After sorting it out, I couldn’t help but be curious about why Promise could be so magical, so I read its source code and found that the design behind some accustomed functions was wonderful.</p><span id="more"></span><h2 id="promise"><a class="markdownIt-Anchor" href="#promise"></a> Promise</h2><p>ES6 provides Promise constructor function, we create a Promise instance, Promise constructor function receives a function as a parameter, the incoming function has two parameters, namely two functions’resolve ‘and’reject’ The effect is that’resolve ‘will Promise The state changes from unsuccessful to successful, and the result of the asynchronous operation is passed as a parameter; similarly,’ reject 'changes the state from non-failed to failed, and is called when the asynchronous operation fails, and the error reported by the asynchronous operation is passed as a parameter.<br> After the instance is created, you can use the then method to specify the success or failure of the callback function, which is more beautiful and readable than the nested callback function of f1 (f2 (f3))</p><p>When we create a new Promise, we need to pass in a function as a parameter. The passed function has two parameters, namely two functions, resolve and reject. The inside of the function body performs an asynchronous operation, and then according to whether the result of the operation is Call a different function for the desired result. If you get the correct return, call resolve function and take the result you need to return as a parameter. If you don’t get the correct return, call reject function and take the error information as a parameter., so that the outside world can get the error information. Here’s a simple example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> num = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">        num &gt; <span class="number">.5</span> ? <span class="title function_">resolve</span>(<span class="string">`success:<span class="subst">$&#123;num&#125;</span>`</span>) : <span class="title function_">reject</span>(<span class="string">`fail:<span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">resolveVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">rejectVal</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(rejectVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>This example creates a Promise that generates a random number after one second. If the random number is greater than 0.5, resolve will be called, and if it is less than 0.5, reject will be called if it is less than 0.5.</p><p>When resolve is executed, the state of the Promise will change to resolved and the function passed in then will be executed, which is actually equivalent to the function passed in then being executed as a resolve function. Similarly, when reject is executed, the state of the Promise will change to Rejected, and the function passed in catch will be used as the reject function to execute.</p><p>In general, then and catch load two specific functions that need to be executed when resolving and rejecting the Promise.</p><h3 id="then-the-rules"><a class="markdownIt-Anchor" href="#then-the-rules"></a> Then the rules</h3><ul><li><p>The next input of the’then 'method requires the previous output</p></li><li><p>If a promise is executed and returns a promise, the execution result of this promise will be passed to the next’then '. That is to say, if you return a PromiseB in the then of PromiseA, the result of PromiseB will be used as the imported parameter of the next then of PromiseA.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promiseB = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line">promiseA.<span class="title function_">then</span>(<span class="function">(<span class="params">resolveA</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promiseB;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">resolveB</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>In this case, the second then argument is the return result of the promise.</p></li><li><p>If the result returned in’then 'is not a Promise object but a normal value, this result will be regarded as the successful result of the next then</p></li></ul><p>If the current then fails, the next then fails</p><ul><li><p>If the return is undefined, the next success will follow regardless of the current success or failure</p></li><li><p>If there is no method written in’then ‘, the value will pass through and be passed to the next’then’</p></li><li><p>return val in the then function is the same as Promise resolve (val)</p></li></ul><p>For example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example1</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>When the argument is a non-promise, the state of the promise immediately changes to resolve after 1 second, and the event inside then is executed.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example2</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">resolve</span>(promise2);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>When the parameter is another promise, the state of promise1 is determined by promise2. When promise2 changes the state, the state of promise1 will also change accordingly, and the state will remain the same.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example3</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;promise2&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>When the callback function directly returns a non-promise, as in example1 above, the current promise2 state changes to resolve. It is equivalent to executing (resolve (‘non-promise’))</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example4</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise3;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>When the callback function directly returns a promise3, like example2 above, the state of the current promise2 depends on primise3, which is equivalent to executing (resolve (promise3))</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example5</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( iamnotundefined );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>When the code in the callback function reports an error and is not caught, the current promise state becomes reject. (The asynchronous error code cannot be caught, which will not affect the promise state change)</p><h3 id="rules-of-catch"><a class="markdownIt-Anchor" href="#rules-of-catch"></a> Rules of catch</h3><ul><li>catch will be called when executing reject</li><li>catch will be executed when there is any error that has not been handled before</li></ul><h2 id="source-code-analysis"><a class="markdownIt-Anchor" href="#source-code-analysis"></a> Source code analysis</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/then/promise">Promise源码地址</a></p><p>The following comments illustrate the possible values for the Promise state:</p><p>0 - Waiting<br> 1 - condition satisfied (value is _value)<br> 2 - Reject condition (value _value)<br> Adopting the state and value of another promise</p><blockquote><p>Once the state value is not 0,</p></blockquote><p>Before the formal declaration of Promise, in order to reduce the display of try catch in the code, several tool functions were defined.</p><h3 id="tool-function"><a class="markdownIt-Anchor" href="#tool-function"></a> Tool function</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span> <span class="title function_">noop</span> () &#123;&#125; <span class="comment">// empty callback function for then</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// States:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 0 - pending</span></span><br><span class="line"><span class="comment">// 1 - fulfilled with _value</span></span><br><span class="line"><span class="comment">// 2 - rejected with _value</span></span><br><span class="line"><span class="comment">// 3 - adopted the state of another promise, _value</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// once the state is no longer pending (0) it is immutable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All `_` prefixed properties will be reduced to `_&#123;random number&#125;`</span></span><br><span class="line"><span class="comment">// at build time to obfuscate them and discourage their use.</span></span><br><span class="line"><span class="comment">// We don&#x27;t use symbols or Object.defineProperty to fully hide them</span></span><br><span class="line"><span class="comment">// because the performance isn&#x27;t good enough.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// to avoid using try/catch inside critical functions, we</span></span><br><span class="line"><span class="comment">// extract them to here.</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LAST_ERROR</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IS_ERROR</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getThen</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">then</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="variable constant_">LAST_ERROR</span> = ex;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">IS_ERROR</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tryCallOne</span>(<span class="params">fn, a</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(a);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="variable constant_">LAST_ERROR</span> = ex;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">IS_ERROR</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tryCallTwo</span>(<span class="params">fn, a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>(a, b);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="variable constant_">LAST_ERROR</span> = ex;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">IS_ERROR</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Promise</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> ! <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promises must be constructed via new&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn ! <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promise constructor\&#x27;s argument is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  _deferredState = <span class="number">0</span>;<span class="comment">//This state is used to indicate what the future state will be like, only useful if the current Promise state depends on another Promise, that is, resolve a Promise</span></span><br><span class="line">  <span class="title class_">This</span>.<span class="property">_state</span> = <span class="number">0</span>;<span class="comment">//the current state of the Promise</span></span><br><span class="line">  _value = <span class="literal">null</span>;<span class="comment">//the value of resolve of the current Promise</span></span><br><span class="line">  _deferreds = <span class="literal">null</span>;<span class="comment">//array of callback functions executed when the _deferredState becomes successful, i.e. greater than 2</span></span><br><span class="line">  <span class="keyword">if</span> (fn = noop) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">doResolve</span>(fn, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A function promise takes a function as its argument and must be created with new.</p><p>Initialize _deferredState and _state to 0, _value and _deferreds to null,<br> If the passed function is an empty function, return directly.<br> Under normal circumstances, enter doResolve to start the process.</p><h3 id="doresolve"><a class="markdownIt-Anchor" href="#doresolve"></a> doResolve</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doResolve</span>(<span class="params">fn, promise</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//Note that fn is what we pass in our new Promise (resolve, reject) = &gt; &#123;if success resolve else reject&#125;, tryCallTwo will pass the second parameter to resolve, and the third parameter to reject, so that when we call resolve in the declared Promise The second parameter of trayCallTwo is actually called.</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="title function_">tryCallTwo</span>(fn, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="title class_">If</span> (done) returns;<span class="comment">//prevents running twice</span></span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">resolve</span>(promise, value);</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">reject</span>(promise, reason);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!done &amp;&amp; res = <span class="variable constant_">IS_ERROR</span>) &#123;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">reject</span>(promise, <span class="variable constant_">LAST_ERROR</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the synchronous direct call to the incoming function, talking about two functions (that is, externally written resolve and reject) as parameters passed in, after the call is completed, check whether it is not completed in the case of an error, if it is directly rejected.<br> For the incoming resolve function and reject function, after waiting for the result, if it has not yet completed, continue the process through resolve and reject as defined in this document.</p><p>** Note that the second and third parameters of the tryCallTwo function are both a function. The parameters of these two functions are actually the two functions ** passed in when we new a new Promise. ** The resolve and reject in this code are the methods defined inside the Promise. **</p><h3 id="resolve"><a class="markdownIt-Anchor" href="#resolve"></a> resolve</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">self, newValue</span>) &#123;</span><br><span class="line"> <span class="comment">//The solution result of a Promise cannot be itself (because according to the principle of then we mentioned at the beginning, if you return a new Promise, the state of the current Promise will depend on the new Promise, and if it depends on itself, then it will always be in a loop and in a pending state)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//The newValue here is actually the parameter resolved in the Promise instance we defined. According to the previous usage method, it can be a string, an array, etc., or another Promise.</span></span><br><span class="line">  <span class="keyword">if</span> (newValue = self) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">      self,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;A promise cannot be resolved with itself.&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//when the new value is the parameter of resolve function and the type is object or function</span></span><br><span class="line">  <span class="comment">//typeof Promised instance = &#x27;object&#x27;</span></span><br><span class="line">  <span class="title class_">That</span> is to say, the condition <span class="keyword">for</span> the success <span class="keyword">of</span> <span class="variable language_">this</span> <span class="keyword">if</span> is to resolve an object, <span class="keyword">function</span> or <span class="title class_">Promise</span> instance</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    newValue &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> newValue = <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue = <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> then = <span class="title function_">getThen</span>(newValue);  <span class="comment">// let then = newValue.then</span></span><br><span class="line">    <span class="keyword">if</span> (then = <span class="variable constant_">IS_ERROR</span>) &#123; <span class="comment">//IS_ERROR就是上面所说的工具中声明的，就是一个空对象，只有当return newValue.then发生异常时才会为IS_ERROR</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(self, <span class="variable constant_">LAST_ERROR</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      then = self.<span class="property">then</span> &amp;&amp;</span><br><span class="line">      newValue <span class="keyword">instanceof</span> <span class="title class_">Promise</span><span class="comment">//If the resvole is a Promise, and the then of this Promise is the same as the then of the current Promise (this then is generally the same and is defined on the prototype of the Promise), the result of the current Promise is directly used as the final result.</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      _state = <span class="number">3</span>;<span class="comment">//state 3 takes another promise as the result</span></span><br><span class="line">      self.<span class="property">_value</span> = newValue;</span><br><span class="line">      <span class="title class_">Finale</span> (self);<span class="comment">//then take the result of this Promise</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> then = <span class="string">&#x27;function&#x27;</span>) &#123;<span class="comment">//走到这里就说明，resolve了一个有then方法的对象（或者一个Promise，并且和当前Promise的then不同，这种情况比较少见）</span></span><br><span class="line">      <span class="title class_">DoResolve</span> (then.<span class="property">bind</span> (newValue), self);<span class="comment">//recursion calls doResolve, we just saw that the first parameter of doResolve is the function passed in when we new Promise, and the second parameter is the pointer of the current Promise instance, That is, when the then function is executed in recursion, the internal this points to the newValue here, and the self has not changed</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//If there is no return above, it will go here. When it comes here, it means that resolve ordinary values, such as numbers and strings, mark completion, and enter the end process.</span></span><br><span class="line">  _state = <span class="number">1</span>;<span class="comment">//Status 1 indicates that you have entered the success state</span></span><br><span class="line">  self.<span class="property">_value</span> = newValue;</span><br><span class="line">  <span class="title function_">finale</span>(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">self, newValue</span>) &#123;</span><br><span class="line">  <span class="comment">//Set reject status and reason</span></span><br><span class="line">  self.<span class="property">_state</span> = <span class="number">2</span>;</span><br><span class="line">  self.<span class="property">_value</span> = newValue;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Promise</span>.<span class="property">_onReject</span>) &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="property">_onReject</span> (self, newValue);<span class="comment">//process callback notification</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Finale</span> (self);<span class="comment">//end </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This function will only be executed when the state of self is not 0. At this time, the execution of handle will execute the second parameter passed in, that is, _deferreds. _deferredState 1 indicates that _deferreds is a Handler, and _deferredState is 2 indicates that _deferreds is an array of Handlers, all executed, and then assign _deferreds to null</span></span><br><span class="line"><span class="comment">//That is to say, finale executes all handlers once</span></span><br><span class="line"><span class="comment">//Each Hander is passed in through the then method. The then method has two parameters, onFulfilled and onRejected, which are the function that should be executed when resolving and the function that should be executed when rejecting.</span></span><br><span class="line"><span class="comment">//If the _state is 3, the finale is executed, in fact, the handler created by the current Promise through then is hung on the _deferreds of the Promise instance on which it depends</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">finale</span>(<span class="params">self</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(self, self.<span class="property">_deferreds</span>);</span><br><span class="line">    self.<span class="property">_deferreds</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.<span class="property">_deferreds</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">handle</span>(self, self.<span class="property">_deferreds</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    self.<span class="property">_deferreds</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then there are _deferredState and _deferreds that have not been touched before, what are they used for?<br> Before answering these, we first recall that in the Promise, when the promise is created and returned, the following operation is then to get the result (of course, including catch), so let’s take a look at the implementation of this then:</p><h3 id="then"><a class="markdownIt-Anchor" href="#then"></a> then</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The parameters of then are two functions, onFulfilled is the callback function called when we resolve, and onRejected is the callback function called when we reject</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">constructor</span> ! <span class="title class_">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">safeThen</span>(<span class="variable language_">this</span>, onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="title class_">Promise</span>(noop);</span><br><span class="line">  <span class="title function_">handle</span>(<span class="variable language_">this</span>, <span class="keyword">new</span> <span class="title class_">Handler</span>(onFulfilled, onRejected, res));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The usage of safeThen and then is basically the same. They both create an asynchronous empty callback res, and then use onFulfilled, onRejected and res to create a Handler. Then the core is on the handle function:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">self, deferred</span>) &#123;</span><br><span class="line">  <span class="comment">//self._state = 3说明self指向的Promise实例的状态依赖另一个Promise实例，这个实例就是self._value</span></span><br><span class="line">  <span class="title class_">That</span> is to say, through <span class="variable language_">this</span> loop, eventually self will eventually point to a state that only depends on its own <span class="title class_">Promise</span> instance</span><br><span class="line">  <span class="comment">//That is to say, assuming that self is p1, it depends on the state of p2. When p1 calls handle, and p2 has not resolved, in fact, the Handler created by p1 through then hangs on the _deferreds of p2, and when p2 resolves, execute it in turn.</span></span><br><span class="line">  <span class="keyword">while</span> (self.<span class="property">_state</span> = <span class="number">3</span>) &#123;</span><br><span class="line">    self = self.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Promise</span>.<span class="property">_onHandle</span>) &#123; <span class="comment">// for injection - not in main loop</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">_onHandle</span>(self);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//If the state only depends on its own Promise instance and there is no result, save the incoming callback function first</span></span><br><span class="line">  <span class="comment">//_deferredState 0 indicates that the callback function has not been saved, then assign the callback function to the _deferreds, this time _deferreds just a callback function</span></span><br><span class="line">  <span class="comment">//_deferredState 1 indicates that the callback function has been saved, then the callback function and the original callback function stored in the _deferreds are constructed into an array and reassigned to the _deferreds, this time _deferreds just an array of callback functions</span></span><br><span class="line">  <span class="comment">//_deferredState 2 indicates that _deferreds is already an array of functions, just push it</span></span><br><span class="line">  <span class="comment">//until a certain call handle, the state of self is not 0, will execute handleResolved</span></span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">_state</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">0</span>) &#123;</span><br><span class="line">      self.<span class="property">_deferredState</span> = <span class="number">1</span>;</span><br><span class="line">      self.<span class="property">_deferreds</span> = deferred;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">1</span>) &#123;</span><br><span class="line">      self.<span class="property">_deferredState</span> = <span class="number">2</span>;</span><br><span class="line">      self.<span class="property">_deferreds</span> = [self.<span class="property">_deferreds</span>, deferred];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self.<span class="property">_deferreds</span>.<span class="title function_">push</span>(deferred);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleResolved</span>(self, deferred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The parameter of this function is deferred, so it means that deferred is Handler, which means delayed processing. To be clear, it is what needs to be done after completing the promise.<br> So what is the specific process like?<br> First, determine whether the current state depends on another promise, if so, wait through while<br> Then onHandle is just a progress callback provided to the outside, which is ignored here for now<br> When the state is 0, this is the setting of future processing.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If the future state has not been <span class="keyword">set</span> (<span class="number">0</span>), then <span class="keyword">set</span> the callback (<span class="keyword">deferred</span>) <span class="keyword">as</span> a separate callback</span><br><span class="line">If the future state has been <span class="keyword">set</span> (<span class="number">1</span>), then <span class="keyword">set</span> the callback (<span class="keyword">deferred</span>) into the callback array</span><br><span class="line">If the other state (<span class="number">2</span> +), then directly into the callback array.</span><br><span class="line">The processing <span class="keyword">in</span> the <span class="keyword">case</span> of state <span class="number">0</span> <span class="keyword">is</span> returned here. Because at <span class="keyword">this</span> time, the promise <span class="keyword">is</span> executed synchronously and then, the function process <span class="keyword">for</span> future processing <span class="keyword">is</span> <span class="keyword">set</span>. </span><br></pre></td></tr></table></figure><p>When the state is non-zero, handleResolved is entered, which should be the place where the processing ends after completion. Wait, the above only enters the handle from then, at that time the promise should not be completed, and the call to complete the processing must be somewhere else. By searching for the call to handle, you can see that it is also in the finale function, so it is connected to the above. Let’s review when the finale will be called?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 Status 3 When waiting for the result of another promise - here the wait will enter</span><br><span class="line">When 2 state 1 is completed</span><br><span class="line">3 state 2 when rejected</span><br></pre></td></tr></table></figure><p>It can be seen that only when the promise ends or relies on other promises will it enter finale.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">finale</span>(<span class="params">self</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(self, self.<span class="property">_deferreds</span>);</span><br><span class="line">    self.<span class="property">_deferreds</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.<span class="property">_deferredState</span> = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.<span class="property">_deferreds</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">handle</span>(self, self.<span class="property">_deferreds</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    self.<span class="property">_deferreds</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The finale will remove the deffereds placed before one by one, call handle, then the state is non-0, directly enter handleResolved, the code is as follows:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResolved</span>(<span class="params">self, deferred</span>) &#123;</span><br><span class="line">  <span class="title function_">asap</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//_state is 1, the first parameter of the then function is executed, which is the successful callback function, otherwise the callback function of reject is executed.</span></span><br><span class="line">    <span class="keyword">var</span> cb = self.<span class="property">_state</span> = <span class="number">1</span> ? deferred.<span class="property">onFulfilled</span> : deferred.<span class="property">onRejected</span>;</span><br><span class="line">    <span class="keyword">if</span> (cb = <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">_state</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(deferred.<span class="property">promise</span>, self.<span class="property">_value</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(deferred.<span class="property">promise</span>, self.<span class="property">_value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="title function_">tryCallOne</span>(cb, self.<span class="property">_value</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret = <span class="variable constant_">IS_ERROR</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(deferred.<span class="property">promise</span>, <span class="variable constant_">LAST_ERROR</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(deferred.<span class="property">promise</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is relatively simple, through asynchronous asap call, if there is no onFulfilled (onRejected failure), then directly call resolve (reject), if there is first call onFulfilled (onRejected failure), according to the result to call resolve (reject).</p><p>Wait… Don’t the resolve and reject here appear in the above process? Please note that the resolve and rejected promises here are empty promises created at then, which means that nothing will be executed (directly into the finale no handle case). So what really affects the process here is that for the callback execution of deferred.onFulfilled or deferred.onRejected, after executing the callback, the execution process of this promise is completed.</p><p>In summary, the execution process of a promise is like this</p><p>Creating a Promise</p><ul><li>Set the function that needs to be executed, that is, new Promise is the incoming function</li><li>Set the completed callback, that is, the two functions passed in by then, the first is executed when resolving, and the other is executed when rejecting. If a Promise2 is resolved, the Handler created by then will be mounted on Promise2, and wait until Promise2 resolves and then executes together.</li><li>Commencing function</li><li>Select callback based on execution result</li></ul><p>Another mention of safeThen, the role of safeThen is to continue to safely execute then when the environment this is no longer a Promise when then is called.</p><h2 id="what-exactly-does-promise-mean-by-microtask"><a class="markdownIt-Anchor" href="#what-exactly-does-promise-mean-by-microtask"></a> What exactly does Promise mean by microtask?</h2><p>We read the source code and then go back to understand why the Promise is a microtask</p><p>Let’s take the starting code as an example.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">    num &gt; <span class="number">.5</span> ? <span class="title function_">resolve</span>(<span class="string">`success:<span class="subst">$&#123;num&#125;</span>`</span>) : <span class="title function_">reject</span>(<span class="string">`fail:<span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">resolveVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">rejectVal</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rejectVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>In this code, setTimeout This code will be executed directly, and then create a macro task, that is, resolve or reject after 1s, and then the following then and catch actually create two handlers, and these two Handlers will be thrown into the microtask by the asap package after calling resolve or reject.</p><p>Therefore, we have been talking about promises as microtasks, which actually means that the incoming functions in then and catch will be put into the microtask queue when the state changes.</p><p>Reference article:</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.im/post/5caf147af265da035d0c698a">https://juejin.im/post/5caf147af265da035d0c698a</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.im/entry/599968f6518825244630f809">https://juejin.im/entry/599968f6518825244630f809</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.jianshu.com/p/b63ec30eefdd">https://www.jianshu.com/p/b63ec30eefdd</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/52b6d429/" title="Promise Source Code Analysis">https://sunra.top/en/posts/52b6d429/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/dfe9e270/" rel="prev" title="Overview of Smart Contracts"><i class="fa fa-chevron-left"></i> Overview of Smart Contracts</a></div><div class="post-nav-item"> <a href="/en/posts/376816af/" rel="next" title="JavaScript arrow function exploration">JavaScript arrow function exploration<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/52b6d429/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>