<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Recently, I found that the Unity project consumes a lot of memory during operation, and there will be frequent GC causing the game’s CPU to overheat. So I went to read the official best practice doc,"><meta property="og:type" content="article"><meta property="og:title" content="Unity Memory Best Practices"><meta property="og:url" content="https://sunra.top/en/posts/12773/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Recently, I found that the Unity project consumes a lot of memory during operation, and there will be frequent GC causing the game’s CPU to overheat. So I went to read the official best practice doc,"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://docs.unity3d.com/cn/2018.4/uploads/Main/UnderstandingPerformanceinUnity-AssetAuditingSection_image_0.png"><meta property="og:image" content="https://docs.unity3d.com/cn/2018.4/uploads/Main/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png"><meta property="article:published_time" content="2022-03-25T08:03:26.000Z"><meta property="article:modified_time" content="2023-11-19T00:05:39.268Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://docs.unity3d.com/cn/2018.4/uploads/Main/UnderstandingPerformanceinUnity-AssetAuditingSection_image_0.png"><link rel="canonical" href="https://sunra.top/en/posts/12773/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/12773/","path":"posts/12773/","title":"Unity Memory Best Practices"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Memory Best Practices | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-the-concept-of-escrow"><span class="nav-number">1.</span> <span class="nav-text">What is the concept of escrow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Managed-heap"><span class="nav-number">2.</span> <span class="nav-text">Managed heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#There-are-two-core-issues-with-managed-heap-scaling"><span class="nav-number">2.1.</span> <span class="nav-text">There are two core issues with managed heap scaling:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Temporary-allocation"><span class="nav-number">2.2.</span> <span class="nav-text">Temporary allocation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-memory-saving-methods"><span class="nav-number">3.</span> <span class="nav-text">Basic memory saving methods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-and-Array-Reuse"><span class="nav-number">3.1.</span> <span class="nav-text">Collection and Array Reuse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Closure-and-anonymity-methods"><span class="nav-number">3.2.</span> <span class="nav-text">Closure and anonymity methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IL2CPP"><span class="nav-number">3.3.</span> <span class="nav-text">IL2CPP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packing"><span class="nav-number">3.4.</span> <span class="nav-text">Packing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dictionaries-and-enumerations"><span class="nav-number">3.5.</span> <span class="nav-text">Dictionaries and enumerations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Foreach"><span class="nav-number">3.6.</span> <span class="nav-text">Foreach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity"><span class="nav-number">3.7.</span> <span class="nav-text">Unity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Empty-array-reuse"><span class="nav-number">3.8.</span> <span class="nav-text">Empty array reuse</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference-article"><span class="nav-number">4.</span> <span class="nav-text">Reference article</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/12773/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Memory Best Practices | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Memory Best Practices</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-03-25 16:03:26" itemprop="dateCreated datePublished" datetime="2022-03-25T16:03:26+08:00">2022-03-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-11-19 08:05:39" itemprop="dateModified" datetime="2023-11-19T08:05:39+08:00">2023-11-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/12773/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/12773/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Recently, I found that the Unity project consumes a lot of memory during operation, and there will be frequent GC causing the game’s CPU to overheat. So I went to read the official best practice doc, learned some knowledge of Unity’s memory management, and summarized it a little.</p><span id="more"></span><h2 id="What-is-the-concept-of-escrow"><a href="#What-is-the-concept-of-escrow" class="headerlink" title="What is the concept of escrow"></a>What is the concept of escrow</h2><p>When understanding Unity memory management, I often hear it once, called managed heap, and I often hear some words before, such as managed code, managed thread, so what does this managed mean?</p><p>In layman’s terms, Unity itself is written in C ++, the reason why you can write scripts in C # is because the bottom of a virtual machine, the virtual machine code, memory is managed.</p><p>C #has its own memory collection mechanism, so in C #we can only new, do not care how to delete, C #uses gc to clean up the memory, this part of the memory is managed memory, most of the time we work in the C #environment, are using managed memory, but C #after all runs on C ++, sometimes, (for example, we may need to introduce some third-party C ++ or native code library, in the Unity3d development is very common) we need to directly Manipulate unmanaged code in C #, these non-managed memory we need to handle their application and release C # provides some interfaces to complete the conversion between managed and unmanaged, as well as operations on this part of memory.</p><p>For example, if we create a new object in C #without deleting, but if we call Resources. Load to load a resource, we need to manually unload it.</p><h2 id="Managed-heap"><a href="#Managed-heap" class="headerlink" title="Managed heap"></a>Managed heap</h2><p>Another common problem faced by many Unity developers is unexpected expansion of the managed heap. In Unity, expansion of the managed heap is much easier than contraction. In addition, Unity’s garbage collection strategy tends to fragment memory and therefore may prevent contraction of large heaps.</p><p>A “managed heap” is a piece of memory that is automatically managed by the memory manager of the project script runtime (Mono or IL2CPP). All objects created in managed code must be allocated on the managed heap ( <strong>note:</strong> strictly speaking, all non-null reference type objects and all boxed value type objects must be allocated on the managed heap).</p><p><img src="https://docs.unity3d.com/cn/2018.4/uploads/Main/UnderstandingPerformanceinUnity-AssetAuditingSection_image_0.png" alt></p><p>In the above figure, the white boxes represent the amount of memory allocated to the managed heap, while the colored boxes in it represent the data values stored in the managed heap’s Memory Space. When more values are needed, more space will be allocated from the managed heap.</p><p>The garbage collector runs periodically ( <strong>note:</strong> depending on the platform). All objects on the heap are scanned, and any that are no longer referenced are marked for deletion. Unreferenced objects are then deleted, freeing up memory.</p><p>Crucially, Unity’s garbage collection (using the Boehm GC algorithm) is non-generational and non-compressed. “Non-generational” means that GC must scan the entire heap when performing each pass of collection, so its performance degrades as the heap expands. “Non-compressed” means that memory addresses are not reallocated for objects in memory to eliminate gaps between objects.</p><blockquote><p>The generation here should be the generation of the new generation and the generation of the old generation. There are two algorithms for garbage collection in JS. For the temporary variables, the generational garbage collection algorithm is used. If you want to know more, you can see my other blog: <a href="https://sunra.top/posts/29695/">https://sunra.top/posts/29695/</a></p></blockquote><p><img src="https://docs.unity3d.com/cn/2018.4/uploads/Main/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png" alt></p><p>The image above shows an example of memory fragmentation. When an object is freed, its memory is freed. However, the freed space is not consolidated as part of the overall pool of “available memory”. Objects located on either side of the freed object may still be in use. Therefore, the freed space becomes a “gap” between other memory segments (this gap is indicated by the red circle in the image above). Therefore, the newly freed space can only be used to store data for objects of the same size or smaller as the freed one.</p><p>When allocating objects, please note that the allocation address of the object in the Memory Space must always be a contiguous space block.</p><p>This leads to the core problem of memory fragmentation: although the total amount of available space in the heap may be large, there may be small “gaps” between some or all of the allocatable space objects. In this case, even if the total amount of available space is higher than the amount of space to be allocated, the managed heap may not find a contiguous block of memory large enough to meet the allocation requirements.</p><p>However, if a large object is allocated, but there is not enough contiguous free space to accommodate the object (as shown above), the Unity memory manager will perform two operations.</p><p>First, run the garbage collector if it is not already running. This tool attempts to free up enough space to satisfy the allocation request.</p><p> <strong>If after GC runs, there is still not enough contiguous space to meet the requested amount of memory, the heap must be expanded. The exact amount of expansion of the heap depends on the platform; however, most Unity platforms will double the size of the managed heap.</strong></p><h3 id="There-are-two-core-issues-with-managed-heap-scaling"><a href="#There-are-two-core-issues-with-managed-heap-scaling" class="headerlink" title="There are two core issues with managed heap scaling:"></a>There are two core issues with managed heap scaling:</h3><ul><li><p>Unity does not often free the memory pages allocated to the managed heap after it expands the managed heap; it optimistically preserves the expanded heap, even when most of the heap is empty. This is to prevent the need to re-expand the heap when a large allocation occurs again.</p></li><li><p>On most platforms, Unity will eventually release the pages used by the empty portion of the managed heap back to the operating system. The interval between this behavior is indeterminate, so don’t expect to free memory this way.</p></li></ul><p>The address space used by the managed heap is never returned to the operating system.</p><ul><li>For 32-bit programs, if the managed heap expands and contracts multiple times, it may cause address space exhaustion. If a program’s available memory address space is exhausted, the operating system will terminate the program.</li></ul><p>For 64-bit programs, the address space is large enough to run programs that exceed the average human lifespan, so it is extremely unlikely that the address space will be exhausted.</p><h3 id="Temporary-allocation"><a href="#Temporary-allocation" class="headerlink" title="Temporary allocation"></a>Temporary allocation</h3><p>Many Unity projects have tens or hundreds of KB of temporary data allocated to the managed heap per frame. This situation is often extremely detrimental to the performance of the project. Consider the following math:</p><p>If a program allocates one kilobyte (1 KB) of temporary memory per frame and runs at a rate of 60 frames per second, it must allocate 60 KB of temporary memory per second. In one minute, this adds 3.6 MB of garbage to memory. Calling the garbage collector once per second may have a detrimental impact on performance, but allocating 3.6 MB of memory per minute is a problem for devices with insufficient memory.</p><p>In addition, consider load operations. If a large number of temporary objects are generated during a large resource load operation, and references to these objects persist until the operation is completed, the garbage collector cannot release these temporary objects, and the managed heap needs to be expanded, even if many of the objects it contains will be released shortly after.</p><h2 id="Basic-memory-saving-methods"><a href="#Basic-memory-saving-methods" class="headerlink" title="Basic memory saving methods"></a>Basic memory saving methods</h2><p>In fact, this part of the content is not only applicable to C #, many methods and JS write the same precautions, such as the reuse of sets and arrays, if you need to repeatedly use an auxiliary array in a loop, it is better to apply for memory outside the loop, and then reuse within the loop to prevent frequent GC; there are empty methods, empty array reuse, if you need to return an empty array in many cases, it is better to define an empty array in advance, in all cases All return this empty array; there is also a property of the object that is frequently accessed in the loop, it is best to declare a new variable outside the loop Point to this property, so you don’t need to look for it every time you loop.</p><h3 id="Collection-and-Array-Reuse"><a href="#Collection-and-Array-Reuse" class="headerlink" title="Collection and Array Reuse"></a>Collection and Array Reuse</h3><p>When using a C # collection class or array, consider reusing or pooling the allocated collection or array whenever possible. The collection class exposes a Clear method that eliminates the values within the collection, but does not free up the memory allocated to the collection.<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="built_in">float</span>&gt; nearestNeighbors = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt;();</span><br><span class="line"></span><br><span class="line">    findDistancesToNearestNeighbors(nearestNeighbors);</span><br><span class="line"></span><br><span class="line">    nearestNeighbors.Sort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... use a sorted list in some way...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>This is especially useful when allocating a temporary “helper” collection for complex calculations. The following code is a very simple example:</p><p>In this example, in order to collect a set of Data Points, memory is allocated once per frame for the nearestNeighbors List. It is very simple to promote this List from the method to the containing class, which avoids allocating memory for the new List every frame:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">float</span>&gt; m_NearestNeighbors = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    m_NearestNeighbors.Clear();</span><br><span class="line"></span><br><span class="line">    findDistancesToNearestNeighbors(NearestNeighbors);</span><br><span class="line"></span><br><span class="line">    m_NearestNeighbors.Sort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... use a sorted list in some way...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this version, the memory of the List is reserved and reused between multiple frames. New memory is allocated only when the List needs to be expanded.</p><h3 id="Closure-and-anonymity-methods"><a href="#Closure-and-anonymity-methods" class="headerlink" title="Closure and anonymity methods"></a>Closure and anonymity methods</h3><p>There are two things to note when using closures and anonymous methods.</p><p>First of all, all method references in C # are reference types, so allocations are made on the heap. Temporary memory can be easily allocated by passing a method reference as an argument. This allocation occurs regardless of whether the method passed is an anonymous method or a predefined method.</p><p>Second, after converting an anonymous method to a closure, the amount of memory required to pass the closure to the method receiving the closure increases significantly.</p><p>Please refer to the following code:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">float</span>&gt; listOfNumbers = createListOfRandomNumbers();</span><br><span class="line"></span><br><span class="line">listOfNumbers.Sort( (x, y) =&gt;</span><br><span class="line"></span><br><span class="line">(<span class="built_in">int</span>)x.CompareTo((<span class="built_in">int</span>)(y/<span class="number">2</span>)) </span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>This code uses a simple anonymous method to control the sorting order of the list of numbers created on the first line. However, if programmers want to make this code snippet reusable, it is easy to think of replacing the constant 2 with a variable in local scope, as follows:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">float</span>&gt; listOfNumbers = createListOfRandomNumbers();</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> desiredDivisor = getDesiredDivisor();</span><br><span class="line"></span><br><span class="line">listOfNumbers.Sort( (x, y) =&gt;</span><br><span class="line"></span><br><span class="line">(<span class="built_in">int</span>) x.CompareTo ((<span class="built_in">int</span>) (y / desiredDivisor))</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Anonymous methods now require the method to be able to access the variable state outside the scope of the method, so it has become a closure. The desiredDivisor variable must be passed to the closure somehow so that the actual code of the closure can use the variable.</p><p>To do this, C # generates an anonymous class that holds the outer-scope variables required by the closure. When the closure is passed to the Sort method, a copy of this class is instantiated and initialized with the value of the desiredDivisor integer.</p><p>Because performing a closure requires instantiating a copy of the closure-generated class, and all classes are reference types in C # , performing a closure requires allocating objects on the managed heap.</p><p>In general, avoid closures in C # whenever possible. Anonymous methods and method references should be minimized in performance-sensitive code, especially code that needs to be executed every frame.</p><h3 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h3><p>Currently, by looking at the code generated by IL2CPP, we know that the declaration and assignment of a variable of type System. Function will assign a new object. This is true whether the variable is explicit (declared in a method/class) or implicit (declared as a parameter of another method).</p><p>Therefore, using the anonymous method under the IL2CPP script backend necessarily allocates managed memory. This is not the case under the Mono script backend.</p><p>In addition, due to the different declaration of method parameters, IL2CPP will show a large difference in the amount of managed memory allocation. As expected, each call to closure consumes the most memory.</p><p>Predefined methods, when passed as arguments under the IL2CPP script backend, <strong>allocate almost as much memory as closure</strong> , but this is not very intuitive. Anonymous methods generate a minimum amount of temporary garbage (one or more orders of magnitude) on the heap.</p><p>Therefore, if you plan to release your project on the IL2CPP script backend, there are three main recommendations:</p><p>It is best to choose a coding style that does not require passing methods as parameters.</p><p>When unavoidable, it is better to choose anonymous methods rather than predefined methods.</p><p>Avoid using closures regardless of the script backend.</p><h3 id="Packing"><a href="#Packing" class="headerlink" title="Packing"></a>Packing</h3><p>Boxing is one of the most common sources of unexpected temporary memory allocation in Unity projects. Boxing occurs whenever a value of a value type is used as a reference type; this most often occurs when passing variables of primitive value types (such as int and float) to methods of object types.</p><p>In the very simple example below, the integers in x are boxed to pass to the object. Equals method, because the Equals method on object requires object to be passed as a parameter to it.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> y = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">y.Equals(x);</span><br></pre></td></tr></table></figure><p>The C # IDE (Integrated Development Environment) and compiler usually do not issue warnings about boxing, even when it results in unexpected memory allocations. This is because the design concept of the C # language believes that small temporary allocations can be effectively handled by generational garbage collectors and memory pools that are sensitive to allocation size.</p><p>While Unity’s allocator actually uses different memory pools for small and large allocations, Unity’s garbage collector is “not” generational, so it cannot effectively clean up small, frequent temporary allocations generated by boxing.</p><p>When writing C # code for the Unity runtime, you should avoid boxing as much as possible.</p><p>Identification packing<br>Boxing appears in the CPU trace as calls to one of several specific methods, depending on the script backend used. These calls typically take one of the following forms, where &lt; some class &gt; is the name of another class or struct and… is some parameter:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;some <span class="keyword">class</span>&gt;::<span class="title">Box</span>(…)</span><br><span class="line"></span><br><span class="line"><span class="title">Box</span>(…)</span><br><span class="line"></span><br><span class="line">&lt;<span class="title">some</span> <span class="title">class</span>&gt;_<span class="title">Box</span>(…)</span><br></pre></td></tr></table></figure><h3 id="Dictionaries-and-enumerations"><a href="#Dictionaries-and-enumerations" class="headerlink" title="Dictionaries and enumerations"></a>Dictionaries and enumerations</h3><p>A common reason for boxing is to use an enum type as the key of a dictionary. Declaring enum creates a new value type that is treated as an integer in the background, but implements type safety rules at compile time.</p><p>By default, calling Dictionary.add (key, value) results in a call to Object.getHashCode (Object). This method is used to get the corresponding hash code for the keys of the dictionary and is used in all methods that accept keys, such as: Dictionary.tryGetValue, Dictionary.remove, etc.</p><p>The Object.getHashCode method is a reference type, but the enum value is always a value type. Therefore, for enumerated key dictionaries, each method call will cause the key to be boxed at least once.</p><p>The following code snippet shows a simple example that illustrates this boxing problem.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> MyEnum &#123; a, b, c &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDictionary = <span class="keyword">new</span> Dictionary&lt;MyEnum, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">myDictionary.Add(MyEnum.a, <span class="keyword">new</span> <span class="built_in">object</span>());</span><br></pre></td></tr></table></figure><p>To solve this problem, you need to write a custom class that implements the IEqualityComparer interface and specifies an instance of that class as a comparator for the dictionary ( <strong>note:</strong> this object is usually stateless, so it can be reused with different dictionary instances to save memory).</p><p>The following is a simple example of the above code snippet IEqualityComparer.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEnumComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">MyEnum</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">MyEnum x, MyEnum y</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x  y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">MyEnum x</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>An instance of the above class can be passed to the dictionary constructor function.</p><h3 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h3><p>In Unity’s version of the Mono C # compiler, using a foreach loop forces Unity to box a value each time the loop terminates ( <strong>note:</strong> boxes the value once each time the entire loop completes in its entirety, not once in each iteration of the loop, so the memory usage remains the same whether the loop is run twice or 200 times). This is because the IL generated by Unity’s C # compiler constructs an enumerator of generic value types to traverse the collection of values.</p><p>This enumerator implements the IDisposable interface; it must be called when the loop terminates. However, calling interface methods on value-type objects, such as structures and enumerators, requires them to be boxed.</p><p>Please refer to the following very simple example code.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> x <span class="keyword">in</span> myList) &#123;</span><br><span class="line"></span><br><span class="line">    accum += x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The above code will generate the following intermediate language after running through Unity’s C # compiler:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">private</span> hidebysig instance <span class="keyword">void</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">ILForeach</span>() cil managed</span> </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    .maxstack <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    .<span class="function">locals <span class="title">init</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">      [<span class="number">0</span>] int32 num,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">      [<span class="number">1</span>] int32 current,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">      [<span class="number">2</span>] valuetype [mscorlib]System.Collections.Generic.List`<span class="number">1</span>/Enumerator&lt;int32&gt; V_2</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// [67 5 - 67 16]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL _ 0000: ldc.i4.0     </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL _ 0001: stloc.0 / / num</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// [68 5 - 68 74]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL_0002: ldarg.0      <span class="comment">// this</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL_0003: ldfld        <span class="keyword">class</span> [mscorlib]System.Collections.Generic.List`1&lt;int32&gt; test::myList</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL_0008: callvirt     instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator&lt;!0<span class="comment">/*int32*/</span>&gt; <span class="keyword">class</span> [mscorlib]System.Collections.Generic.List`1&lt;int32&gt;::<span class="title">GetEnumerator</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    IL_000d: stloc.2      <span class="comment">// V_2</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .<span class="keyword">try</span></span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">000</span>e: br IL _ <span class="number">001f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [72 9 - 72 41]</span></span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">0013</span>: ldloca.s V _ <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      IL_0015: call         instance !<span class="number">0</span><span class="comment">/*int32*/</span> valuetype [mscorlib]System.Collections.Generic.List`<span class="number">1</span>/Enumerator&lt;int32&gt;::get_Current()</span><br><span class="line"></span><br><span class="line">      IL_001a: stloc<span class="number">.1</span>      <span class="comment">// current</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [73 9 - 73 23]</span></span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">001b</span>: ldloc<span class="number">.0</span> / / num</span><br><span class="line"></span><br><span class="line">      IL_001c: ldloc<span class="number">.1</span>      <span class="comment">// current</span></span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">001</span>d: <span class="keyword">add</span>          </span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">001</span>e: stloc<span class="number">.0</span> / / num</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [70 7 - 70 36]</span></span><br><span class="line"></span><br><span class="line">      IL_001f: ldloca.s     V_2</span><br><span class="line"></span><br><span class="line">      IL_0021: call         instance <span class="built_in">bool</span> valuetype [mscorlib]System.Collections.Generic.List`<span class="number">1</span>/Enumerator&lt;int32&gt;::MoveNext()</span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">0026</span>: brtrue IL _ <span class="number">0013</span></span><br><span class="line"></span><br><span class="line">      IL _ <span class="number">002b</span>: leave IL _ <span class="number">003</span>c</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//. end of try</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      IL_0030: ldloc<span class="number">.2</span>      <span class="comment">// V_2</span></span><br><span class="line"></span><br><span class="line">      IL_0031: box          valuetype [mscorlib]System.Collections.Generic.List`<span class="number">1</span>/Enumerator&lt;int32&gt;</span><br><span class="line"></span><br><span class="line">      IL_0036: callvirt     instance <span class="keyword">void</span> [mscorlib]System.IDisposable::Dispose()</span><br><span class="line"></span><br><span class="line">      IL_003b: endfinally   </span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//finally ended</span></span><br><span class="line"></span><br><span class="line">    IL _ <span class="number">003</span>c: ret          </span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">//Method test :: IL Foreach ends</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//test class ends</span></span><br></pre></td></tr></table></figure><p>The most relevant code is the <strong>finally near the bottom { … }</strong> Code Block. The callvirt directive discovers the location of the IDisposable. Dispose method in memory before calling it and requires the enumerator to be boxed.</p><p>In general, foreach loops should be avoided in Unity. The reason is not only that these loops do boxing, but also that method calls to traverse collections through enumerators are more expensive and often much slower than manual iterations through for or while loops.</p><h3 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h3><p>One of the more harmful and less obvious reasons for virtual array allocation is repeated access to the Unity API that returns an array. All Unity APIs that return arrays create a new copy of the array every time they are accessed. Accessing array values unnecessarily from the Unity API is extremely inappropriate.</p><p>For example, the following code will blur to create four copies of the vertices array each iteration of the loop. Assignments occur each time the .vertices property is accessed.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.vertices.Length; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    x = mesh.vertices[i].x;</span><br><span class="line"></span><br><span class="line">    y = mesh.vertices[i].y;</span><br><span class="line"></span><br><span class="line">    z = mesh.vertices[i].z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    DoSomething(x, y, z);   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By capturing an array of vertices before entering the loop, it can be simply refactored into a single array allocation regardless of the number of loop iterations:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertices = mesh.vertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    x = vertices[i].x;</span><br><span class="line"></span><br><span class="line">    y = vertices[i].y;</span><br><span class="line"></span><br><span class="line">    z = vertices[i].z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    DoSomething(x, y, z);   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Although the CPU cost of accessing properties once is not very high, repeated accesses within a compact cycle can overheat CPU performance. In addition, repeated accesses can cause unnecessary expansion of the managed heap.</p><p>This issue is extremely common in mobile end because the Input.touches API behaves similarly to the above. It is extremely common for projects to contain code similar to the following, in which case an assignment occurs every time the .touches property is accessed.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Input.touches.Length; i++ )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   Touch touch = Input.touches[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Of course, this problem can be easily improved by promoting the array allocation from the loop condition.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Touch[] touches = Input.touches;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; touches.Length; i++ )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   Touch touch = touches[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, there are now many versions of the Unity API that do not result in memory allocation. If you can use these versions, please try to choose this version.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> touchCount = Input.touchCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; touchCount; i++ )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   Touch touch = Input.GetTouch(i);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Converting the above example to a non-allocated Touch API is simple:</p><p>Note that the property access (Input.touchCount) remains outside the loop condition in order to save the CPU cost of calling the get method of the property.</p><h3 id="Empty-array-reuse"><a href="#Empty-array-reuse" class="headerlink" title="Empty array reuse"></a>Empty array reuse</h3><p>When an array value method needs to return an empty set, some development teams prefer to return an empty array instead of null. This coding pattern is common in many managed languages, especially C # and Java.</p><p>In general, when returning a zero-length array from a method, it is much more efficient to return a pre-allocated singleton instance of a zero-length array than to repeatedly create an empty array <strong>note:</strong> of course, the exception is when the array is resized after returning the array).</p><p>Footnote</p><p>(1) This is because reading back from GPU memory is extremely slow on most platforms. Reading textures from GPU memory into temporary buffers for use by CPU code such as Texture. GetPixel would be very inefficient.</p><p>Strictly speaking, all non-null reference type objects and all boxed value type objects must be allocated on the managed heap.</p><p>(3) The specific running time depends on the platform.</p><p>(4) Note that this is not the same as the number of bytes temporarily allocated during a given frame. The profiler displays the number of bytes allocated in a particular frame, regardless of whether some/all of the allocated memory has been reused in subsequent frames.</p><p>(5) Of course, adjusting the size of the array after returning the array is an exception.</p><h2 id="Reference-article"><a href="#Reference-article" class="headerlink" title="Reference article"></a>Reference article</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/2018.4/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html">了解托管堆</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/12773/" title="Unity Memory Best Practices">https://sunra.top/en/posts/12773/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/36409/" rel="prev" title="C#  Delegates and Events"><i class="fa fa-chevron-left"></i> C# Delegates and Events</a></div><div class="post-nav-item"> <a href="/en/posts/12560/" rel="next" title="Unity Android Symbol Table Parsing Crash Log">Unity Android Symbol Table Parsing Crash Log<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/12773/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>