<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="In the built-in rendering pipeline, surface shaders are a simplified way to write shaders that interact with lighting. Writing shaders that interact with lighting is very complex. There are different"><meta property="og:type" content="article"><meta property="og:title" content="Unity Rendering Principle (7) Surface Shaders and Shader Graphs"><meta property="og:url" content="https://sunra.top/en/posts/19866/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="In the built-in rendering pipeline, surface shaders are a simplified way to write shaders that interact with lighting. Writing shaders that interact with lighting is very complex. There are different"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652600532/origin-of-ray/20018137-d2ff6da2b4e91a45.jpg_sdysuu.webp"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652579914/origin-of-ray/screenshot-20220515-095732_izsvgx.png"><meta property="article:published_time" content="2022-05-15T01:26:47.000Z"><meta property="article:modified_time" content="2024-07-02T11:45:07.398Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg"><link rel="canonical" href="https://sunra.top/en/posts/19866/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/19866/","path":"posts/19866/","title":"Unity Rendering Principle (7) Surface Shaders and Shader Graphs"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Rendering Principle (7) Surface Shaders and Shader Graphs | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#working-principle"><span class="nav-number">1.</span> <span class="nav-text">Working principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#standard-output-structure-for-surface-shaders"><span class="nav-number">1.1.</span> <span class="nav-text">Standard output structure for surface shaders:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#surface-shader-input-structure"><span class="nav-number">2.</span> <span class="nav-text">Surface shader input structure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#surface-shader-compile-instruction"><span class="nav-number">3.</span> <span class="nav-text">Surface shader compile instruction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#required-parameters"><span class="nav-number">3.1.</span> <span class="nav-text">Required parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#optional-parameter"><span class="nav-number">3.2.</span> <span class="nav-text">Optional parameter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#transparency-and"><span class="nav-number">3.2.1.</span> <span class="nav-text">Transparency and</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#custom-modifier-function"><span class="nav-number">3.2.2.</span> <span class="nav-text">Custom modifier function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shading-and-surface-subdivision"><span class="nav-number">3.2.3.</span> <span class="nav-text">Shading and Surface Subdivision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code-generation-options"><span class="nav-number">3.2.4.</span> <span class="nav-text">Code Generation Options</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#other-options"><span class="nav-number">3.2.5.</span> <span class="nav-text">Other options</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rendering-path-for-surface-shader"><span class="nav-number">4.</span> <span class="nav-text">Rendering path for surface shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#example-of-surface-shader"><span class="nav-number">5.</span> <span class="nav-text">Example of surface shader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#simple-shader-example"><span class="nav-number">5.1.</span> <span class="nav-text">Simple Shader Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#texture"><span class="nav-number">5.2.</span> <span class="nav-text">Texture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#normal-map"><span class="nav-number">5.3.</span> <span class="nav-text">Normal map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edge-illumination"><span class="nav-number">5.4.</span> <span class="nav-text">Edge illumination</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#whats-behind-unity"><span class="nav-number">6.</span> <span class="nav-text">What’s behind Unity?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shader"><span class="nav-number">7.</span> <span class="nav-text">Shader</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/19866/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Rendering Principle (7) Surface Shaders and Shader Graphs | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Rendering Principle (7) Surface Shaders and Shader Graphs</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-05-15 09:26:47" itemprop="dateCreated datePublished" datetime="2022-05-15T09:26:47+08:00">2022-05-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-07-02 19:45:07" itemprop="dateModified" datetime="2024-07-02T19:45:07+08:00">2024-07-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/19866/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/19866/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>In the built-in rendering pipeline, surface shaders are a simplified way to write shaders that interact with lighting.</p><p>Writing shaders that interact with lighting is very complex. There are different light source types, different shadow options, different rendering paths (forward and deferred rendering); shaders should somehow cope with all these complexities.</p><p>Surface shaders are a code generation method that makes it easier to write light shaders than using low-level vertex/pixel shader programs.</p><span id="more"></span><h2 id="working-principle"><a class="markdownIt-Anchor" href="#working-principle"></a> Working principle</h2><p>You can define a “surface function” that takes all the UVs or data you need as input and populates the output structure SurfaceOutput. SurfaceOutput basically describes the properties _ of _ surface (albedo color, normal, luminescence, specular reflection, etc.). ** This code needs to be written using HLSL **.</p><p>The surface shader compiler then calculates the required inputs, filled outputs, etc., and generates actual vertex and pixel shaders and rendering channels to handle forward and delayed rendering.</p><h3 id="standard-output-structure-for-surface-shaders"><a class="markdownIt-Anchor" href="#standard-output-structure-for-surface-shaders"></a> Standard output structure for surface shaders:</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SurfaceOutput</span><br><span class="line">&#123;</span><br><span class="line">    Fixed3 Albedo;<span class="comment">//diffuse color</span></span><br><span class="line">    Fixed3 Normal;<span class="comment">//tangent space normal (if written)</span></span><br><span class="line">    fixed3 Emission;</span><br><span class="line">    Half Specular;<span class="comment">//0.. 1 specular reflection capability</span></span><br><span class="line">    Fixed Gloss;<span class="comment">//specular reflection intensity</span></span><br><span class="line">    Fixed Alpha;<span class="comment">//Transparency Alpha</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In Unity 5, surface shaders can also use a physics-based lighting model. The built-in standard lighting model and standard specular reflection lighting model (see below) use the following output structures respectively:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SurfaceOutputStandard</span><br><span class="line">&#123;</span><br><span class="line">    Fixed3 Albedo;<span class="comment">//base (diffuse or specular reflection) color</span></span><br><span class="line">    Fixed3 Normal;<span class="comment">//tangent space normal (if written)</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    Half Metallic;<span class="comment">//0 = non-metallic, 1 = metal</span></span><br><span class="line">    Half Smoothness;<span class="comment">//0 = rough, 1 = smooth</span></span><br><span class="line">    Half Occlusion;<span class="comment">//occlusion (default 1)</span></span><br><span class="line">    Fixed Alpha;<span class="comment">//Transparency Alpha</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> SurfaceOutputStandardSpecular</span><br><span class="line">&#123;</span><br><span class="line">    Fixed3 Albedo;<span class="comment">//diffuse color</span></span><br><span class="line">    Fixed3 Specular;<span class="comment">//specular reflection color</span></span><br><span class="line">    Fixed3 Normal;<span class="comment">//tangent space normal (if written)</span></span><br><span class="line">    half3 Emission;</span><br><span class="line">    Half Smoothness;<span class="comment">//0 = rough, 1 = smooth</span></span><br><span class="line">    Half Occlusion;<span class="comment">//occlusion (default 1)</span></span><br><span class="line">    Fixed Alpha;<span class="comment">//Transparency Alpha</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="surface-shader-input-structure"><a class="markdownIt-Anchor" href="#surface-shader-input-structure"></a> Surface shader input structure</h2><p>The input structure Input usually has all the texture coordinates required by the shader. The texture coordinates must be named in the form of “uv” followed by the texture name (starting with “uv2” if you want to use a second set of texture coordinates).</p><p>Other values that can be put into the input structure:</p><ul><li>float3 viewDir - Contains view orientation for calculating parallax effects, edge lighting, and more.</li><li>float4 with COLOR semantics - contains per vertex color for interpolation.</li><li>float4 screenPos - contains the screen space position of the reflection or screen space effect. Note that this is not suitable for GrabPass; you will need to calculate the custom UV yourself using the ComputeGrabScreenPos function.</li><li>float3 worldPos - contains the world space location.</li><li>float3 worldRefl - Contains the world reflection vector without writing Normal_ to the _ surface shader. See Reflect-Diffuse Shaders for an example.</li><li>float3 worldNormal - contains the world normal vector without writing Normal_ to the _ surface shader.</li><li>float3 worldRefl; INTERNAL_DATA - Contains the world reflection vector with _ surface shader written to Normal_. To obtain a reflection vector based on a normal map per pixel, use WorldReflectionVector (IN, o. Normal). See Reflect-Bumped Shaders for an example.</li><li>float3 worldNormal; INTERNAL_DATA - Include the world normal vector with _ surface shader written to o.Normal_. To get a normal vector based on a per pixel normal map, use WorldNormalVector (IN, o. Normal).</li></ul><h2 id="surface-shader-compile-instruction"><a class="markdownIt-Anchor" href="#surface-shader-compile-instruction"></a> Surface shader compile instruction</h2><p>Just like any other shader, the surface shader is placed inside the CGPROGRAM… ENDCG Code Block. The difference is:</p><p>** It must be placed inside a SubShader Code Block, not a Pass. The surface shader itself will be compiled into multiple channels **.<br> It uses the #pragma surface… directive to indicate that it is a surface shader.<br> The ‘#pragma surface’ directive is:</p><p><code># pragma surface surfaceFunction lightModel [optionalparams]</code></p><h3 id="required-parameters"><a class="markdownIt-Anchor" href="#required-parameters"></a> Required parameters</h3><ul><li>surfaceFunction - Cg function with surface shader code. The format of the function should be void surf (Input IN, inout SurfaceOutput o) where Input is the structure you defined. Input should contain any texture coordinates and extra auto variables required by the surface function.</li><li>lightModel - the lighting model to use. The built-in lighting models are physically based Standard and StandardSpecular, and simple non-physically based Lambert (diffuse) and BlinnPhong (specular reflection). See the Custom Lighting Model page to learn how to write your own lighting model.<ul><li>The Standard lighting model uses the SurfaceOutputStandard output structure and matches the standard (metal workflow) shaders in Unity.</li><li>The Standard Specular lighting model uses the SurfaceOutputStandard Specular output structure and matches the standard (specular reflection setting) shaders in Unity.</li><li>Lambert and BlinnPhong lighting models are not physically based (from Unity 4.x), but shaders using these two lighting models can improve rendering speed on low-end hardware.</li></ul></li></ul><h3 id="optional-parameter"><a class="markdownIt-Anchor" href="#optional-parameter"></a> Optional parameter</h3><blockquote><p>For these optional parameters, start by focusing on custom function modifiers and code generation options</p></blockquote><h4 id="transparency-and"><a class="markdownIt-Anchor" href="#transparency-and"></a> Transparency and</h4><p>Controlled by alpha and alphatest commands.<br> Transparency can generally be of two types: traditional alpha blending (for fading out objects) or the more physical “premultiplied blending” (allowing translucent surfaces to retain proper specular reflection). Enabling translucency causes the generated surface shader code to include blending commands; while enabling Alpha cutout will perform element discarding in the generated pixel shader based on the given variables.</p><ul><li>alpha or alpha: auto - for simple lighting functions, fade transparency (same as alpha: fade) will be selected; for physics-based lighting functions, premultiply transparency (same as alpha: premul) will be selected.</li><li>alpha: blend - Enable alpha blending.</li><li>alpha: fade - Enables traditional fade transparency.</li><li>alpha: premul - Enable premultiplied alpha transparency.</li><li>alphatest: VariableName - Enable Alpha cutout transparency. The clipping value is in a floating point variable with VariableName. You may also want to generate the correct shadow projectile channel using the addshadow directive.</li><li>keepalpha - by default, the opaque surface shader writes 1.0 (white) to the alpha channel regardless of what the alpha output of the output structure is, or what the lighting function returns. Use this option to keep the alpha value of the lighting function, even for opaque surface shaders.</li><li>decal: add - Attach decal shader (e.g. terrain AddPass). This works for objects that are on top of other surfaces and use additional blending. See Surface Shader Example</li><li>decal: blend - Semitransparent decal shader. This works for objects that are on top of other surfaces and blended using Alpha. See Surface Shader Example</li></ul><h4 id="custom-modifier-function"><a class="markdownIt-Anchor" href="#custom-modifier-function"></a> Custom modifier function</h4><p>Can be used to change or calculate incoming vertex data, or change the final calculated slice color.</p><ul><li>vertex: VertexFunction - Custom vertex modification function. This function is called at the beginning of the generated vertex shader, and this function can modify or calculate per-vertex data. See the surface shader example.</li><li>finalcolor: ColorFunction - Customize the final color modification function. See the surface shader example.</li><li>finalgBuffer: ColorFunction - A custom delay path for changing the contents of the G buffer.</li><li>finalprepass: ColorFunction - Customize the prepass base path.</li></ul><h4 id="shading-and-surface-subdivision"><a class="markdownIt-Anchor" href="#shading-and-surface-subdivision"></a> Shading and Surface Subdivision</h4><p>Other instructions may be provided to control the processing of shadows and surface subdivisions.</p><ul><li>addshadow - Generate shadow projectile channels. Commonly used for custom vertex modification so that shadow casting can also get procedural vertex animation. Typically, shaders do not require any special shadow handling, as they can use shadow projectile channels through a fallback mechanism.</li><li>fullforwardshadows - Support all light shadow types in Forward rendering path. By default shaders only support shadows from one directional light in forward rendering (to save on internal shader variant count). If you need point or Spot Light shadows in forward rendering, use this directive.</li><li>tessellate: TessFunction - Surface Subdivision using DX11 GPU; this function calculates the surface subdivision factor. See Surface Shader Surface Subdivision for more information.</li></ul><h4 id="code-generation-options"><a class="markdownIt-Anchor" href="#code-generation-options"></a> Code Generation Options</h4><p>By default, the generated surface shader code tries to handle all possible light/shadow/lightmap situations. But in some cases, you know you don’t need parts of it, and you can adjust the generated code to skip them. This reduces the shader, which improves loading speed.</p><ul><li>exclude_path: deferred, exclude_path: forward, and exclude_path: prepass - do not generate channels for the given render path (corresponding to delayed shading path, forward path, and legacy delayed path, respectively).</li><li>noshadow - disables all shadows in this shader to receive support.</li><li>noambient - do not apply any ambient lighting or light probes.</li><li>novertexlights - do not apply any lighting probes or per vertex lights in forward rendering.</li><li>nolightmap - disables all lightmap support in this shader.</li><li>nodynlightmap - disables runtime dynamic global lighting support in this shader.</li><li>nodirlightmap - disables directional lightmap support in this shader.</li><li>nofog - disables all built-in fog effect support.</li><li>nometa - does not generate “Meta” channels (used by lightmapping and dynamic global illumination to extract surface information).</li><li>noforwardadd - disables additional channels for forward rendering. This enables the shader to support a full directional light, with all other lights being calculated per vertex/SH. Shaders can also be reduced.</li><li>nolppv - disables lightprobe agent support in this shader.</li><li>noshadowmask disables shadow mask support (including Shadowmask and Distance Shadowmask) for this shader.</li></ul><h4 id="other-options"><a class="markdownIt-Anchor" href="#other-options"></a> Other options</h4><ul><li>softvegetation - Render surface shaders only when Soft Vegetation is turned on.</li><li>interpolateview - Calculate view orientation and interpolate in vertex shader; not in pixel shader. This makes pixel shader faster, but consumes an extra texture interpolator.</li><li>alfasview - Pass the halfdirection vector to the lighting function instead of the view orientation. Calculate the halfdirection and normalize it for each vertex. This is faster, but not quite correct.</li><li>approxview - removed in Unity 5.0. Please use interpolateview instead.</li><li>dualforward - Use bilightmaps in forward rendering paths.</li><li>dithercrossfade - Make the surface shader support the dither effect. You can then apply this shader to gameobjects that use the LOD Group component configured to cross-fade transition mode.</li></ul><h2 id="rendering-path-for-surface-shader"><a class="markdownIt-Anchor" href="#rendering-path-for-surface-shader"></a> Rendering path for surface shader</h2><p>In the built-in render pipeline, when using surface shaders, how lighting is applied and which channels of the shader are used depends on the render path used. Each channel in the shader expresses its lighting type through a channel label.</p><ul><li>In forward rendering, ForwardBase and ForwardAdd channels will be used.</li><li>In delayed shading, the Deferred channel will be used.</li><li>In older versions of deferred lighting, the PrepassBase and PrepassFinal channels will be used.</li><li>In legacy vertex lighting, Vertex, VertexLMRGBM, and VertexLM channels will be used.</li><li>In any of the above cases, to render shadows or depth textures, the ShadowCaster channel will be used.</li></ul><h2 id="example-of-surface-shader"><a class="markdownIt-Anchor" href="#example-of-surface-shader"></a> Example of surface shader</h2><h3 id="simple-shader-example"><a class="markdownIt-Anchor" href="#simple-shader-example"></a> Simple Shader Example</h3><p>We’ll start with a very simple shader and build on it. The shader below sets the surface color to “white”. It uses the built-in Lambert (diffuse) lighting model.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Diffuse Simple&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma surface surf Lambert</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        float4 color : COLOR;</span><br><span class="line">    &#125;;</span><br><span class="line">    void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg" alt></p><h3 id="texture"><a class="markdownIt-Anchor" href="#texture"></a> Texture</h3><p>An all white object is boring, so let’s add a texture. We will add Properties Code Block to the shader, so we will see the texture selector in the material.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Diffuse Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma surface surf Lambert</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To understand this code you need to understand what the concept of UV is, in simple terms, is that each point on the model has a UV coordinate, this coordinate corresponds to a point on the map, when rendering this point on the model, this point The color is obtained by going to the map with these coordinates. For a detailed explanation, see: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/cancantrbl/p/14766502.html">https://www.cnblogs.com/cancantrbl/p/14766502.html</a></p><p>There are two variables used in the surf function, and you may feel a little confused about how they came about.<br> The first is the variable _MainTex, which is defined in the HLSL code. Find a variable whose name is exactly the same as the property name defined in Properties.<br> Another variable is in the structure “Input” we defined, called “uv_MainTex”, this variable compiler will automatically help us inject the uv coordinates of the point</p><blockquote><p>Input structure</p></blockquote><h3 id="normal-map"><a class="markdownIt-Anchor" href="#normal-map"></a> Normal map</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Example/Diffuse Bump&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">      _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">      _BumpMap (<span class="string">&quot;Bumpmap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">      Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">      <span class="keyword">struct</span> Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float2 uv_BumpMap;</span><br><span class="line">      &#125;;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      sampler2D _BumpMap;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>)</span> &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this Shader, we have one more input and one more output, we have one more input normal map, and we also assign valid values to the output normal variables.</p><p>If you are not sure about the concept of normal maps, you can take a look.<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html">法线贴图的官方文档</a></p><p>Here we talk about the line of code’o. Normal = UnpackNormal (tex2D (_BumpMap, IN. uv_BumpMap)); ’</p><p>The first is the section’tex2D (_BumpMap, IN. uv_BumpMap) ', we have understood that it is to obtain the corresponding rgba (or xyzw) value from the normal map according to the uv coordinate of this point, so why can’t we directly assign the value to Normal?<br> First of all, we need to understand that the storage of the discovery map in Unity is packaged format DXT5nm, only G and A channels are useful, and our discovery is a 3D vector, so we need to restore it. At this time, we will take a look at the definition of’UnpackNormal ':</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline fixed3 <span class="title">UnpackNormal</span>(<span class="params">fixed4 packednormal</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SHADER_API_GLES)</span></span><br><span class="line">    <span class="keyword">return</span> packednormal.xyz * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    fixed3 normal;</span><br><span class="line">    normal.xy = packednormal.wy * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    normal.z = sqrt(<span class="number">1</span> - normal.x*normal.x - normal.y * normal.y);</span><br><span class="line">    <span class="keyword">return</span> normal;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="edge-illumination"><a class="markdownIt-Anchor" href="#edge-illumination"></a> Edge illumination</h3><p>Now, try adding some edge lighting to highlight the edges of the game object. We will add some emission lighting based on the angle between the surface normal and the view direction. For this, we will use the built-in surface shader variable viewDir</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Example/Rim&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BumpMap (<span class="string">&quot;Bumpmap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">    _RimColor (<span class="string">&quot;Rim Color&quot;</span>, Color) = (<span class="number">0.26</span>,<span class="number">0.19</span>,<span class="number">0.16</span>,<span class="number">0.0</span>)</span><br><span class="line">    _RimPower (<span class="string">&quot;Rim Power&quot;</span>, Range(<span class="number">0.5</span>,<span class="number">8.0</span>)) = <span class="number">3.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">    <span class="keyword">struct</span> Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float2 uv_BumpMap;</span><br><span class="line">        float3 viewDir;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    sampler2D _BumpMap;</span><br><span class="line">    float4 _RimColor;</span><br><span class="line">    <span class="built_in">float</span> _RimPower;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutput o</span>)</span> &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</span><br><span class="line">        half rim = <span class="number">1.0</span> - saturate(dot (normalize(IN.viewDir), o.Normal));</span><br><span class="line">        o.Emission = _RimColor.rgb * pow (rim, _RimPower);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code has two more lines. First, let’s look at the first line: ‘half rim = 1.0 - saturate (dot (normalize (IN.viewDir), o. Normal);’, let’s interpret this code. First, it is’normalize (IN.viewDir) ', which unifies the viewing direction, and then the dot method multiplies the normal point. The function of the saturate function is to return 0 if the result is less than 0, and 1 if it is greater than 1. Then the result of this piece of code is to determine the direction of the viewing angle and the direction of the normal of this point. If the included angle is greater than 90 degrees, the dot product result is less than 0, and the saturate result is 0, then the result of rim is 1. Everyone else can push it down by themselves.</p><p>Then there is the second line: ‘o. Emission = _RimColor rgb * pow (rim, _RimPower);’, use the pow function to exponent the rim, get the self-luminous intensity of the point, then multiply the rgb value we set to ‘_RimColor’, and finally assign it to’Emission ', which is the self-luminous property of the point.</p><blockquote><p>The official doc has some other examples, here will not be analyzed one by one, interested can continue to watch: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaderExamples.html">https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaderExamples.html</a></p></blockquote><h2 id="whats-behind-unity"><a class="markdownIt-Anchor" href="#whats-behind-unity"></a> What’s behind Unity?</h2><p>Unity will generate a vertex/slice shader with many passes based on the surface shader behind it.</p><p>Some of these passes are for different rendering paths. For example, by default, Unity will generate passes with LightMode as ForwardBase and ForwardAdd for forward rendering paths, passes with LightMode as PrePassBase and PrePassFinal for delayed rendering paths before Unity 5, and passes with LightMode as Deferred for delayed rendering paths after Unity 5.</p><p>There are also passes that are used to generate additional information. For example, to extract surface information for lightmapping and dynamic global lighting, Unity generates a Pass with LightMode of Meta. The generation of these passes is based on the compile command and custom functions in our surface shader, which follow the rules. Unity provides a feature that allows us to look at the code automatically generated by the surface shader: on the panel of each compiled surface shader, there is a “Show generated code” button, as shown in the image below. We only need to click to see all vertex/slice shaders that Unity has generated for this surface shader.</p><p>Taking the Pass with LightMode ForwardBase generated by Unity as an example, its rendering pipeline is shown in the following figure:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652600532/origin-of-ray/20018137-d2ff6da2b4e91a45.jpg_sdysuu.webp" alt></p><p>Unity’s automatic generation process for this Pass is roughly as follows:</p><ol><li>Copy the code between CGPROGRAM and ENDCG in the surface shader.</li><li>Unity generates struct v2f_surf (the output of the vertex shader) based on the above code. If Input defines some variables but is not used, the generated struct will not contain the variables. It will also contain shadow texture coordinates, lighting texture coordinates, vertex-by-vertex lighting, etc.</li><li>Generate vertex shaders.</li></ol><ul><li>If a vertex modification function is defined, the variables in the custom Input structure will be called first or filled. Unity will analyze the data modified by the function and store the modified result in the corresponding variable v2f_surf through the Input structure.</li><li>Calculate other variables in the v2f_surf: vertex position, texture coordinates, normal direction, vertex-by-vertex lighting, lighting texture, etc.</li><li>Pass the v2f_surf to the slice element shader.</li></ul><ol start="4"><li>Generate chip element shaders.</li></ol><ul><li>Fill v2f_surf variables (texture coordinates, viewing angle direction) into the Input structure.</li><li>Call the custom surface function to populate the SurfaceOutput structure.</li><li>Call the lighting function to get the initial color value. If using the built-in Lambert or BlinnPhong lighting functions, Unity will also calculate dynamic global lighting and add it to the calculation of the lighting model.</li><li>Make other color overlays. For example, baking without light will add the effect of vertex-by-vertex lighting.</li><li>Call the final color modification function.</li></ul><h2 id="shader"><a class="markdownIt-Anchor" href="#shader"></a> Shader</h2><p>To simplify the process of writing vertex and slice shaders, Unity abstracts them into surface shaders.<br> But this is not enough. In order to simplify, Unity has proposed Shader Graph, which can help us visually write Shaders.</p><p>We simply drag one out:<br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652579914/origin-of-ray/screenshot-20220515-095732_izsvgx.png" alt></p><p>The function of this Shader Graph is to extract the rgb value corresponding to each point in the map from the map, and then assign it to the output of the surface shader, Albeo and Emission, respectively.</p><p>The Shader Graph is stored as node after node, which is compiled into surface shaders, which in turn are compiled into vertex shaders and remote shaders.</p><p>Although Shader Graph is convenient, there is also a problem, that is, he adds a lot of keywords by default, which will lead to too many Shader variants compiled in the end. If it is a simple Shader, there is no need to use Shader Graph</p><p>Reference article:<br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.jianshu.com/p/3d8a9f3f2430">https://www.jianshu.com/p/3d8a9f3f2430</a><br> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaders.html">https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaders.html</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/19866/" title="Unity Rendering Principle (7) Surface Shaders and Shader Graphs">https://sunra.top/en/posts/19866/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/33290/" rel="prev" title="Unity Rendering Principles (6) Unity HLSL"><i class="fa fa-chevron-left"></i> Unity Rendering Principles (6) Unity HLSL</a></div><div class="post-nav-item"> <a href="/en/posts/27889/" rel="next" title="Unity Rendering Principle (8) Unity Rendering Order and Rendering Path">Unity Rendering Principle (8) Unity Rendering Order and Rendering Path<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/19866/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>