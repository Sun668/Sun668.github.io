<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Read the notes,原文链接"><meta property="og:type" content="article"><meta property="og:title" content="15 Essentials for Cloud Native Apps"><meta property="og:url" content="https://sunra.top/en/posts/d20b574c/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Read the notes,原文链接"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2020-04-05T02:54:03.000Z"><meta property="article:modified_time" content="2023-10-21T13:23:10.958Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/posts/d20b574c/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/d20b574c/","path":"posts/d20b574c/","title":"15 Essentials for Cloud Native Apps"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>15 Essentials for Cloud Native Apps | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#One"><span class="nav-number">1.</span> <span class="nav-text">One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dependency"><span class="nav-number">3.</span> <span class="nav-text">Dependency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Design"><span class="nav-number">4.</span> <span class="nav-text">Design,</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Design-1"><span class="nav-number">4.1.</span> <span class="nav-text">Design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Establish"><span class="nav-number">4.2.</span> <span class="nav-text">Establish</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Publish"><span class="nav-number">4.3.</span> <span class="nav-text">Publish</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Run"><span class="nav-number">4.4.</span> <span class="nav-text">Run</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Configuration"><span class="nav-number">5.</span> <span class="nav-text">Configuration,</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Configurational-chemistry"><span class="nav-number">5.1.</span> <span class="nav-text">Configurational chemistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Treat-your-application-like-open-source"><span class="nav-number">5.2.</span> <span class="nav-text">Treat your application like open source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Externalized-configuration"><span class="nav-number">5.3.</span> <span class="nav-text">Externalized configuration</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logs"><span class="nav-number">6.</span> <span class="nav-text">Logs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Disposability"><span class="nav-number">7.</span> <span class="nav-text">Disposability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backing"><span class="nav-number">8.</span> <span class="nav-text">Backing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Environment"><span class="nav-number">9.</span> <span class="nav-text">Environment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Time"><span class="nav-number">9.1.</span> <span class="nav-text">Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#People"><span class="nav-number">9.2.</span> <span class="nav-text">People</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resources"><span class="nav-number">9.3.</span> <span class="nav-text">Resources</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Administrative"><span class="nav-number">10.</span> <span class="nav-text">Administrative</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Port"><span class="nav-number">11.</span> <span class="nav-text">Port</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Avoid-ports-identified-by-the-container"><span class="nav-number">11.1.</span> <span class="nav-text">Avoid ports identified by the container</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Avoid-micro-management-port-allocation"><span class="nav-number">11.2.</span> <span class="nav-text">Avoid micro-management port allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-is-a-support-service"><span class="nav-number">11.3.</span> <span class="nav-text">Application is a support service</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stateless-process"><span class="nav-number">12.</span> <span class="nav-text">Stateless process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Practical-Definition-of-Stateless"><span class="nav-number">12.1.</span> <span class="nav-text">Practical Definition of Stateless</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shared-free-mode"><span class="nav-number">12.2.</span> <span class="nav-text">Shared-free mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-cache"><span class="nav-number">12.3.</span> <span class="nav-text">Data cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency"><span class="nav-number">13.</span> <span class="nav-text">Concurrency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Telemetry"><span class="nav-number">14.</span> <span class="nav-text">Telemetry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Authentication-and-authorization"><span class="nav-number">15.</span> <span class="nav-text">Authentication and authorization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cloud-Native"><span class="nav-number">16.</span> <span class="nav-text">Cloud Native</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-Cloud-Native"><span class="nav-number">16.1.</span> <span class="nav-text">What is Cloud Native?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why-use-the-Cloud"><span class="nav-number">16.2.</span> <span class="nav-text">Why use the Cloud?</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/d20b574c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="15 Essentials for Cloud Native Apps | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 15 Essentials for Cloud Native Apps</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-04-05 10:54:03" itemprop="dateCreated datePublished" datetime="2020-04-05T10:54:03+08:00">2020-04-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-10-21 21:23:10" itemprop="dateModified" datetime="2023-10-21T21:23:10+08:00">2023-10-21</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Cloud/" itemprop="url" rel="index"><span itemprop="name">Cloud</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/d20b574c/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/d20b574c/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Read the notes,<a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/?download=true">原文链接</a></p><span id="more"></span><h2 id="One"><a href="#One" class="headerlink" title="One"></a>One</h2><p>Cloud Native applications must always consist of a single code repository tracked in the version control system. A code repository is a source code repository or group of repositories that share a common root.</p><p>A single code repository for an application is used to generate any number of immutable publishers<a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch01.html#idm139821584969376">1</a>, these publishes are intended to be used in different environments. Following this particular discipline, the team must analyze the seams of its application and potentially determine the whole that should be split into microservices.<a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch01.html#idm139821584968992">2</a>If you have multiple code repositories, you have a system that needs to be decomposed, not a single application.</p><p>This rule can be broken when a codebase is used to generate multiple applications. For example, a single codebase has multiple startup scripts or even multiple execution points in a single wrapper module.</p><p>Multiple applications in a single codebase often indicate that multiple teams are maintaining a codebase, which can become ugly for a variety of reasons.</p><p>In other words, <em>one codebase, one application</em> does not mean that you are not allowed to share code between multiple applications. It just means that sharing code is another codebase.</p><p>This also does not mean that all shared code must be microservices. Instead, you should evaluate whether shared code should be considered as a separately released product.</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Assuming you have fully embraced all the other factors discussed in this book. You are building a native cloud application, after checking the code into the repository, the tests will be automatically run, and the release candidate can be run in a laboratory environment within a few minutes.</p><p>Now, another team in your organization starts building services that interact with your code. Then, another team sees it, and they join the team and bring their services. Soon, you will have multiple teams working together to build services with horizontal dependencies, all at different release rhythms.</p><p>The nightmare of integration failures can occur without discipline. To avoid these integration failures and formally recognize your API as a first-class artifact of the development process, <em>APIs first</em> enable teams to collaborate with each other on public contracts without interfering with the internal development process.</p><p>The concept of “ <em>mobile first”</em> is getting more and more attention. It refers to everything you do from the beginning of a project revolving around the idea that what you build is a product that mobile devices are going to consume. Similarly, <em>API first</em> means that you are building an API for use by Client applications and services.</p><p>By designing your API first, you can easily discuss it with your stakeholders (your internal team, customers, or other teams in your organization who may want to use your API) until you code yourself to the point where you can’t return. Then, with this collaboration, you can build user cases, mock up APIs, and generate docs that can be used to further socialize the intent and functionality of the built service.</p><p>All of this can be done to review (and test!) your direction and plan without having to invest too much money in the pipeline that supports a given API.</p><p>This mode is an extension of the contract-first development mode, in which developers focus on building the edges or seams of their applications first. Continuous testing of integration points through CI servers allows both teams to use their own services and still maintain reasonable assurance that all components work properly.</p><ul><li>APIs first * liberate organizations from waterfalls, elaborate systems that follow pre-planned orchestration patterns and allow products to evolve into organic, self-organizing ecosystems that can grow to respond to new and unforeseen needs.</li></ul><h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><p>The cloud is the maturity of the classic enterprise model, therefore, our applications need to <em>grow</em> to take advantage of the cloud. Applications cannot assume that servers or application containers will have everything they need. Instead, applications need to carry dependencies with them.</p><p>Most contemporary programming languages have some tools for managing application dependencies. ‘Maven’ and’Gradle ‘are two of the most popular tools in the Java world. Regardless of which tool is used, these utilities provide a common set of features: they allow developers to declare dependencies and make the tool responsible for ensuring those dependencies are met.</p><p>Many of these tools also have the ability to isolate dependencies. This is done by analyzing declared dependencies and bundling (also known as <em>vendoring</em> ) these dependencies into a substructure underneath or within the application artifact itself.</p><p>Failure to properly isolate dependencies can lead to unsolvable problems. Among some of the most common dependency-related problems, you can have a developer version X working on a workstation with some dependency libraries, but version <em>X + 1</em> the library is installed in a central location in production. This can lead to everything from runtime failures all the way down to subtle faults that are insidious and difficult to diagnose. If left unaddressed, these types of failures can bring down an entire server or cost a company millions of dollars due to undiagnosable data corruption.</p><p>Properly managing the dependencies of an application is about the concept of redeployable. It should not be considered that the runtime of deploying an application is not automated. Ideally, the container of the application is bundled (or booted, as some frameworks call it) in the release artifacts of the application, or better yet, the application has no container at all.</p><h2 id="Design"><a href="#Design" class="headerlink" title="Design,"></a>Design,</h2><ul><li>Build, Release, Run <em>requires a strict distinction between the build and run phases of development. This is excellent advice, and failure to follow this guideline may cause you difficulties in the future. In addition to the</em> Build, Release, Run <em>trio of Three-factor Verification, discrete</em> design * steps are also critical.</li></ul><p>The process from design to code to run is an iterative process that can happen in a small or longer amount of time that your team can handle. If the team has a mature CI/CD process, it can take several minutes from design to production.</p><p>A single codebase will be used during the build process to generate compiled artifacts. This artifact is then merged with configuration information <em>external to the application to produce an</em> immutable * published version. The immutable version is then released to the cloud environment (development, QA, production, etc.) and run. The focus of this chapter is that each of the following deployment phases is isolated and occurs separately.</p><h3 id="Design-1"><a href="#Design-1" class="headerlink" title="Design"></a>Design</h3><p>In the world of waterfall application development, we spend a lot of time designing applications before writing a single line of code. This type of software development lifecycle does not adapt well to the needs of modern applications that need to be released frequently.</p><p>However, this doesn’t mean that we don’t design at all. Instead, it means that we design small features to be released, and we have a high-level design that informs everything we do. But we also know that designs change, and a small amount of design is part of <em>each iteration</em> , not completely up-front.</p><p>Application developers best understand the dependencies of the application, and declare them at the design stage to declare dependencies and the way these dependencies are sold or bundled into the application. In other words, the developer decides which libraries the application will use and how to bundle these libraries into an immutable published version.</p><h3 id="Establish"><a href="#Establish" class="headerlink" title="Establish"></a>Establish</h3><p>During the build phase, the code repository is converted into versioned binary artifacts. During this phase, dependencies declared during the design phase are extracted and bundled into the build artifacts (often referred to simply as “builds”). In Java world, a build could be a WAR <a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch04.html#idm139821584893536">1</a>Or JAR files, or possibly ZIP files or binary executables for other languages and frameworks.</p><p>Ideally, a build is created by a Continuous Integration server, and there is a 1: many relationship between build and deployment. A single build should be able to be released or deployed to any number of environments, and each unmodified build should be able to work as expected. The immutability of this artifact, as well as compliance with other factors (especially <em>environment parity</em> ), gives you confidence that if your application can run in quality check, it will run in a production environment.</p><p> <strong>If you find yourself troubleshooting “working on my machine” issues, it’s a clear indication that the four stages of this process may not be as separate as they should be.</strong></p><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><p>In the Cloud Native world, publishing is usually done by pushing to your cloud environment. The output of the build phase is combined with environment-specific and application-specific configuration information to produce another immutable artifact, the <em>publish version</em> .</p><p>Versions must be unique, and ideally, each version should be labeled with some kind of unique ID, such as a timestamp or auto-increment number.</p><p>Let’s say your CI system has just built your application and tagged that artifact build-1234. The CI system can then publish the application to development, staging, and production environments. The scenario is up to you, but each publish should be unique because each publish combines the original with <em>environment-specific</em> configuration settings.</p><p>If something goes wrong, you want to be able to audit what has been published to a given environment and roll back to a previous version if necessary. This is another key reason to keep releases immutable and uniquely identified.</p><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>The runtime phase is usually also done by cloud providers (although developers need to be able to run applications locally). Details vary between providers, but the usual pattern is to place your application in some kind of container (Docker, Garden, Warden, etc.) and then start a process to launch your application.</p><p>It is worth noting that ensuring that developers can run applications locally on their own workstations, while still allowing them to deploy to multiple clouds through CD pipelines, is usually a difficult problem to solve. However, this is worth solving because developers need to be unhindered when dealing with native cloud applications.</p><p>When the application is running, the cloud runtime will be responsible for keeping it running, monitoring its health and aggregating its logs, as well as a large number of other management tasks, such as dynamic scaling and fault tolerance.</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration,"></a>Configuration,</h2><h3 id="Configurational-chemistry"><a href="#Configurational-chemistry" class="headerlink" title="Configurational chemistry"></a>Configurational chemistry</h3><p>Think of configurations, credentials, and codes as volatile substances that explode when combined.</p><p>This may sound a bit harsh, but not following this rule can cause you to be extremely frustrated, which will only bring your application closer to a production environment.</p><p>In order to keep configuration separate from code and credentials, we need to have a very clear definition of configuration. Configuration refers to any value that can change with deployment (for example, developer workstation, QA, and production). This may include:</p><ul><li>URLs and other information about fallback services, such as web services and SMTP servers</li><li>Information needed to find and connect to the database<br>Credentials for third-party services (such as Amazon AWS) or APIs (such as Google Maps, Twitter, and Facebook)<br>Information that may typically be bundled in properties files or configuration XML or YML</li></ul><p>Configuration does not include internal information that it is part of the application itself. Similarly, if the value remains unchanged across all deployments (which is part of your immutable building block), it is not a configuration.</p><p>Credentials are extremely sensitive information and there are absolutely no transactions in the codebase. Typically, developers will extract credentials from compiled source code and put them into properties files or XML configurations, but this doesn’t actually solve the problem. Bundled resources, including XML and properties files, are still part of the codebase. This means that credentials bundled in resource files that come with your application still violate this rule.</p><h3 id="Treat-your-application-like-open-source"><a href="#Treat-your-application-like-open-source" class="headerlink" title="Treat your application like open source"></a>Treat your application like open source</h3><p>Check if you have properly externalized credentials and configuration to imagine the consequences of pushing application source code to GitHub.</p><p>If the public has access to your code, are you exposing sensitive information about the resources or services your application relies on? Can people see internal URLs, credentials for support services, or other information that is sensitive or irrelevant to people not working in the target environment?</p><p>If you can open source the codebase without exposing sensitive or environment-specific information, you may have isolated the code, configuration, and credentials well.</p><p>Obviously, we don’t want to expose credentials, but the need for external configuration is often not so obvious. External configuration supports our ability to <em>automatically</em> deploy immutable versions to multiple environments through CD pipelines, and helps us maintain parity between development/production environments.</p><h3 id="Externalized-configuration"><a href="#Externalized-configuration" class="headerlink" title="Externalized configuration"></a>Externalized configuration</h3><p>It’s one thing to say that your application’s configuration should be <em>externalized</em> , but it’s another thing to actually do it. If you’re using a Java application, you might bundle the release artifact with a property file. Other types of applications and languages tend to use YAML files, while .NET applications traditionally get their configuration from XML-based <em>web.config</em> and <em>machine.config</em> files.</p><p>You should think of <em>all</em> of these as <em>anti-patterns</em> of the cloud. All of these situations make it impossible for you to change configurations between environments while still maintaining the same published artifacts.</p><p>The brute force approach to externalizing configuration is to get rid of all the configuration files and then traverse the codebase and modify them in the expectation that all these values are provided by environment variables. Environment variables are considered a best practice for externalizing configuration, especially on Cloud Computing platforms like Cloud Foundry or Heroku.</p><p>Depending on your cloud provider, you may be able to use their tools to manage <em>fallback services</em> or <em>bind services</em> to expose structured environment variables containing service credentials and URLs to applications in a secure manner.</p><p>Another way you are strongly advised to externalize your configuration is to actually use a server product that is designed to expose the configuration. One such open source server is Spring Cloud Configuration Server, but there are countless other products available. One thing you should be aware of when purchasing a configuration server product is support for version control. If you are externalizing your configuration, you should be able to secure data changes and get a history of who made the changes and when. It is this requirement that makes a configuration server located at the top of a version control repository (such as <em>git)</em> attractive.</p><h2 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h2><p>Logs should be treated as <em>event streams</em> , that is, logs are sequences of events emitted from an application in chronological order. The key to handling logs the Cloud Native way is that true Cloud Native applications never route or store their own output streams.</p><p>Cloud applications cannot make any assumptions about the file system they are running on, unless it is ephemeral. Native cloud applications write all their log entries to’stdout ‘and’stderr’. This can scare a lot of people, worried that it means losing control.</p><p>You should consider the aggregation, processing, and storage of logs as a non-functional requirement that is not met by your application, but by your cloud provider or other tool suite that runs in partnership with the platform.</p><p>When your application is decoupled from the knowledge of log storage, processing, and analysis, your code will become simpler, and you can rely on industry-standard tools and stacks to handle logs. In addition, if you need to change the way logs are stored and processed, there is no need to modify the application *.</p><p>One of the many reasons your application should not control the ultimate fate of its logs is due to scalability. When you have a fixed number of instances on a fixed number of servers, it seems to make sense to store logs on disk. But when your application can go from 1 running instance to 100 on the fly, and you don’t know <em>where</em> those instances are running, you need your cloud provider to aggregate those logs on your behalf.</p><p>Simplifying the application’s log sending process allows you to reduce the code base and focus more on the core business value of the application.</p><h2 id="Disposability"><a href="#Disposability" class="headerlink" title="Disposability"></a>Disposability</h2><p>On a cloud instance, the life of an application is as short as the infrastructure that supports it. The process for Cloud Native applications is one-time, which means they can be started or stopped quickly. <strong>If an application cannot be started quickly and shut down properly, it cannot be quickly scaled, deployed, released, or restored</strong> . We need to build applications that not only realize this, but must also <em>embrace</em> it to make the most of the platform.</p><p> <strong>If you are launching an application and it takes a few minutes to enter a stable state, in today’s high-traffic world, this can mean rejecting hundreds or thousands of requests when launching the application</strong> . What’s more, depending on the platform on which the application is deployed, such a slow startup time may actually trigger alerts or warnings because the application cannot pass its health check. Extremely slow startup times may even prevent your application from launching completely in the cloud.</p><p>If your application is under increasing load, and you need to quickly launch more instances to handle that load, any delay in the startup process may hinder its ability to handle that load. If the application fails to shut down quickly and properly, it may also prevent the ability to restart it again after failure. Failure to shut down the system fast enough may also bring the risk of not being able to process resources, which may corrupt data.</p><p>When writing many applications, they perform many long-running activities during startup, such as fetching data to fill the cache or preparing other runtime dependencies. In order to truly embrace the Cloud Native architecture, this activity needs to be handled separately. For example, <strong>you can externalize the cache as a <em>support service</em> so that your application can quickly perform up and down operations without the need for preload operations</strong> .</p><h2 id="Backing"><a href="#Backing" class="headerlink" title="Backing"></a>Backing</h2><p>A <em>support service</em> is any service that your application relies on for its functionality. This is a fairly broad definition, and its broad scope is intentional. Some of the most common types of support services include data storage, messaging systems, caching systems, and many other types of services, including those that perform business functions or security.</p><p>When building applications designed to run in cloud environments where file systems must be treated as ephemeral, you also need to treat file storage or disk as a fallback service. You should not read or write files on disk as you would with regular enterprise applications. Instead, file storage should be a support service bound to your application as a resource.</p><p>An application, a set of support services, and resource bindings (connection lines) for these services. Binding resources is really just a way to connect your application to support services. Resource bindings for a database may include usernames, passwords, and URLs that allow your application to use that resource.</p><p>We should have externalized configuration (separate from credentials and code), and our published product must be immutable. Applying these other rules to the way the application uses background services, we end up with some rules for resource binding:</p><p>Applications should <em>declare</em> their requirements for a given support service, but should allow the cloud environment to perform actual resource binding.</p><ul><li>The binding of the application to its supporting services should be done through external configuration.</li><li>It should be possible to attach and detach support services from the application at will <em>without redeploying the application</em> .</li></ul><p>For example, suppose you have an application that needs to communicate with an Oracle database. You write your application so that its specific Oracle database dependencies <em>are declared</em> (the way this is declared is usually for a certain language or toolset) <em>.</em> The source code of the application assumes that the configuration of resource binding occurs outside the application.</p><p>This means that there will <em>never</em> be lines of code in your application that tightly couple the application to a specific support service. Similarly, you may also have a support service for sending emails, so you know you will communicate with it via SMTP. However, the exact implementation of the mail server has no impact on your application, and your application should not rely on an SMTP server that exists in a specific location or has specific credentials.</p><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>Although some organizations have made greater developments, many of us may be working in environments where the Shared Development Environment has different scalability and reliability profiles compared to QA, and QA differs from the production environment. the database drivers used in dev and QA differ from the production version. Security rules, firewalls, and other environment configuration settings also differ. Some people are able to deploy to certain environments, while others do not. Finally, and worst of all, people are afraid to deploy, they have little confidence that if the product works in one environment, it will work in another.</p><p>While discussing the <em>design, build, release, run</em> cycle, I brought up the notion that the “run on my machine” scenario is the Cloud Native anti-pattern. The same goes for other phrases we’ve heard before losing hours or days of firefighting and troubleshooting: “It works in Quality Assurance” and “It works in the product”.</p><p>The purpose of applying rigor and discipline to environmental parity is to give your team and the entire organization confidence that the application <em>can be used anywhere</em> .<a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch09.html#idm139821584754432">1个</a></p><p>While the opportunities to create gaps between environments are almost limitless, the most common culprits are usually:</p><ul><li>Time</li><li>People</li><li>Resources</li></ul><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>In many organizations, it can take weeks or months from developers checking in code to production completion. In such organizations, you will often hear phrases such as “Q3 release” or “20xx December release”. Such phrases are a warning sign for anyone paying attention.</p><p>When there is such a time interval, people often forget what changes were made in the release (even if there are enough release notes), and more importantly, developers have forgotten what the code looks like.</p><p>With a modern approach, organizations should strive to reduce the time interval from check-in to production, from weeks or months to <em>minutes or hours</em> . The end of the correct CD pipeline should be to perform automated testing in different environments until changes are automatically pushed to the <em>production</em> environment. With the help of a cloud that supports zero downtime deployment, this pattern can become the norm.</p><h3 id="People"><a href="#People" class="headerlink" title="People"></a>People</h3><ul><li>Humans * Applications should never be deployed, at least not to any environment other than your own workstation or lab. If the correct build pipeline exists, the application will be automatically deployed to all applicable environments based on CI tools and security restrictions within the target cloud instance, and can be manually deployed to other environments.</li></ul><p>In fact, even if your target is a public cloud provider, you can still use cloud-hosted CD tools like CloudBees or Wercker to automate your testing and deployment.</p><p>Although there are always exceptions, I think if you can’t deploy by pressing a button or automatically responding to some event, you’re doing it wrong.</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>The way we use and provide <em>support services</em> is usually one such compromise. Our application may require a database, and we know that in production we will connect it to an Oracle or Postgres server, but setting it up to be available locally for development is very cumbersome, so we will compromise and use an in-memory database that is * like the target database.</p><p>Every time we make one of these compromises, we widen the gap between our development and production environments. The bigger the gap, the less predictable we are about how our applications work. As predictability declines, so does reliability. If reliability declines, we lose the <em>continuous</em> process from code check-in to production deployment. It makes everything we do vulnerable. The worst part is that we often don’t know the consequences of increasing the dev/prod gap until it’s too late.</p><p>When evaluating every step in the development lifecycle when building on-premises cloud applications, you need to flag and question every decision that increases the functional gap between deployment environments, and you need to resist the urge to mitigate this by allowing your environment to maintain the difference even if it seems trivial at the time.</p><h2 id="Administrative"><a href="#Administrative" class="headerlink" title="Administrative"></a>Administrative</h2><p>In some cases, using a management process is actually not a <em>good</em> idea, and you should always be asking yourself if a management process is what you want, or if a different design or architecture is better suited to your needs. Examples of management processes that might be refactored into something else include:</p><ul><li>Database migration</li><li>Interactive Programming Console (REPL)</li><li>Run timed scripts, such as nightly batch jobs or hourly imports</li><li>Run a one-time job that only executes custom code once</li></ul><p>First, let’s look at the issue of timers (usually managed by applications such as Autosys or Cron). One idea might be to only internalize timers and have your application wake up every <em>n</em> hour to perform its batch operations. On the surface, this seems like a good solution, but what happens when there are 20 application instances running in one Availability Zone and another 15 instances running in another zone? If they are all performing the same batch operation on the timer, you are basically causing confusion at this point, and corrupted or duplicate data will be just one of many terrible events caused by this pattern.</p><p>Interactive shells are also problematic for a number of reasons, but the biggest one is that even if it is possible to reach that shell, you can only interact with the temporary memory of a single instance. If the application is properly built as a <em>stateless process</em> , then I think there is little value in exposing the REPL for process introspection.<a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch10.html#idm139821584721360">2</a></p><p>Next, let’s look at the mechanism that triggers a timed or batch management process. This is usually Autosys that occurs due to some external timer stimulus (such as cron or) executing a shell script. In the cloud, you can’t expect to be able to invoke these commands, so you need to find other ways to trigger temporary activities in your application.</p><p>There are multiple solutions, but the one I find most appealing is to expose a RESTful endpoint that can be used to invoke ad hoc functionality, especially when migrating the rest of the application to Cloud Native.</p><p>This still allows the timing function to be called at will, but moves the stimulus for this operation <em>outside</em> of the application. In addition, this method solves the <em>problem that internal timers can only be executed</em> once <em>at most</em> on dynamic scaling instances. Batch operations are processed once by one application instance and can then interact with other <em>support services</em> to complete the task. Securing batch endpoints should also be fairly simple so that they can only be operated by authorized personnel. Even more useful, your batch operations can now be flexibly scaled and take advantage of all other cloud benefits.</p><p>If you still feel the need to take advantage of management processes, you should make sure to use them in a way that is consistent with the functionality provided by your cloud provider. In other words, don’t use your preferred programming language to generate new processes to run your work; use tools designed to run one-time tasks in a Cloud Native way.</p><h2 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h2><h3 id="Avoid-ports-identified-by-the-container"><a href="#Avoid-ports-identified-by-the-container" class="headerlink" title="Avoid ports identified by the container"></a>Avoid ports identified by the container</h3><p>Web applications (especially those already running inside an enterprise) are often executed in some kind of server container. Java world is full of containers like Tomcat, JBoss, Liberty, and WebSphere. Other web applications may run in other containers, such as Microsoft Internet Information Server (IIS).</p><p>In non-cloud environments, web applications have been deployed into these containers, and then the container is responsible for assigning ports to the application when it starts.</p><p>An extremely common pattern in enterprises that manage their own web servers is to host multiple applications in the same container, separate the applications by Port Number (or URL hierarchy), and then use DNS to provide a user-friendly appearance around that server. For example, you might have a host called appserver (virtual or physical), and have assigned ports 8080 through 8090. Instead of having users remember the Port Number, use DNS hostname associations like app1 for some applications, appserver: 8080 for app2, and so on.</p><h3 id="Avoid-micro-management-port-allocation"><a href="#Avoid-micro-management-port-allocation" class="headerlink" title="Avoid micro-management port allocation"></a>Avoid micro-management port allocation</h3><p>Platform as a Service is adopted here, so that both developers and developers no longer have to perform this micro-management. Your cloud provider should manage port allocation for you, as it may also manage routing, scaling, high availability, and fault tolerance, all of which require the cloud provider to manage certain aspects of the network, including routing hostnames to ports and mapping external Port Numbers to container internal ports.</p><p>The original 12 factors for port binding use the term “export” because it is assumed that cloud-native applications are independent and never injected into any type of external application server or container.</p><p>Practicality and the nature of existing enterprise applications can make it difficult or impossible to build applications in this way. As a result, there are slightly less restrictive guidelines that <em>a 1:1 association must always be maintained between the application and the application server</em> . In other words, your cloud provider may support web application containers, but it is extremely unlikely to support hosting multiple applications in the same container, as it is nearly impossible to achieve durability, scalability, and elasticity.</p><p>For modern applications, the impact of port binding on developers is very simple: your application can <a target="_blank" rel="external nofollow noopener noreferrer" href="http://localhost:12001">http://localhost:12001</a> run on the developer’s workstation, while in quality check it can run on <a target="_blank" rel="external nofollow noopener noreferrer" href="http://192.168.1.10:2000">http://192.168.1.10:2000</a> and <a target="_blank" rel="external nofollow noopener noreferrer" href="http://app.company.com">http://app.company.com</a> in the production environment. Applications developed with export port binding in mind support this environment-specific port binding without any code changes.</p><h3 id="Application-is-a-support-service"><a href="#Application-is-a-support-service" class="headerlink" title="Application is a support service"></a>Application is a support service</h3><p>Finally, applications developed to allow externalized runtime port binding can act as support services for another application. This flexibility and all the other benefits of running on the cloud are very powerful.</p><h2 id="Stateless-process"><a href="#Stateless-process" class="headerlink" title="Stateless process"></a>Stateless process</h2><h3 id="Practical-Definition-of-Stateless"><a href="#Practical-Definition-of-Stateless" class="headerlink" title="Practical Definition of Stateless"></a>Practical Definition of Stateless</h3><p>One of the questions I often ask is due to confusion over the concept of statelessness. People want to know how to build a stateless process. After all, every application needs <em>some</em> state, right? Even the simplest applications leave some data floating, so how can you have a truly stateless process?</p><p>Stateless Application does not make any assumptions about the contents of memory before processing the request, nor does it make any assumptions about the contents of memory after processing the request. During the processing of requests or transactions, the application can create and use transients, but when the client receives a response, the data should all disappear.</p><p>Simply put, all persistent state must be external to the application, provided by a backup service.</p><p>For example, a microservice that exposes functions for user management must be stateless, so a list of all users is maintained in a support service such as an Oracle or MongoDB database. For obvious reasons, database statelessness is meaningless.</p><h3 id="Shared-free-mode"><a href="#Shared-free-mode" class="headerlink" title="Shared-free mode"></a>Shared-free mode</h3><p>Processes often communicate with each other by sharing common resources. Even without considering migrating to Cloud Services, there are many benefits to adopting a no <em>sharing</em> model.</p><p>First, anything that is shared between processes is the responsibility that makes all of these processes more vulnerable. In many high availability models, processes will share data through multiple technologies to choose a cluster leader, determine if a process is a primary or a backup process, and so on.</p><p>When running in the cloud, you need to avoid all of these options. Your processes can disappear instantly without any warning, <em>which is a good thing</em> . Processes come and go, scale horizontally and vertically, and are highly disposable. This means that anything shared between processes can also disappear, potentially causing cascading failures.</p><p>Needless to say, but <em>the file system is not a fallback service</em> . This means that you cannot view files as a way for applications to share data. Disks in the cloud are temporary disks, and in some cases even read-only disks.</p><p>If processes need to share data, such as the session state of a group of processes forming a web farm, this session state should be externalized and made available through a true support service.</p><h3 id="Data-cache"><a href="#Data-cache" class="headerlink" title="Data cache"></a>Data cache</h3><p>Especially in container-based long-running web applications, a common pattern is to cache frequently used data during process startup. As mentioned in this book, processes need to start and stop quickly, and spending a long time filling the cache in memory violates this principle.</p><p>To make matters worse, storing what your application thinks is always available in-memory cache can make your application bloated, leaving each of your instances (which should be scalable elastically) consuming far more memory than it needs.</p><p>There are dozens of third-party caching products, including Gemfire and Redis, all of which are designed to act as fallback service caches for applications. They can be used for session state, but also for caching data that may be needed during startup and avoiding tightly coupled data sharing between processes.</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><ul><li>Concurrency <em>, it is recommended that we</em> scale <em>native cloud applications using the process model. Sometimes, if the application reaches its capacity limit, the solution is to increase its size. If the application can only handle a certain number of requests per minute, the preferred solution is to simply make the application</em> larger *.</li></ul><p>Adding CPU, RAM, and other resources (virtual or physical) to a single monolithic application is called vertical scaling, and this type of behavior is generally unpopular in today’s civilized society.</p><p>A more modern approach, ideally the kind of elastically scalable cloud support, is to scale up <em>*, or</em> horizontally *. Instead of making a large process bigger and then distributing the application load between these processes, you can create multiple processes.</p><p>Most cloud providers have perfected this feature and can even configure rules that will dynamically scale the number of application instances based on the available load or other runtime telemetry in the system.</p><p>If you want to build a one-time, stateless, shared-free process, you will be able to take full advantage of horizontal scaling and running multiple concurrent instances of the application</p><h2 id="Telemetry"><a href="#Telemetry" class="headerlink" title="Telemetry"></a>Telemetry</h2><p>When monitoring applications, there are usually several different categories of data.</p><p>Application Performance Monitoring (APM)</p><ul><li>Specific domain telemetry</li><li>Health status and system logs</li></ul><p>The first is APM, which consists of a series of events that tools outside the cloud can use to monitor the health of your application. This is something you are responsible for, as the definition and watermark of performance is specific to your application and criteria. The data used to provide the APM dashboard is often quite generic and can come from multiple applications across multiple Lines of Business.</p><p>Second, domain-specific telemetry is also up to you. This refers to events and data streams that are meaningful to your business and can be used for your own analysis and reporting. Such event streams are often fed into “Big data” systems for warehousing, analysis, and prediction.</p><p>The difference between APM and domain-specific telemetry may not be immediately apparent. Think of it this way: APM can provide you with the average number of HTTP requests processed per second by your application, while domain-specific telemetry can tell you the number of widgets sold to iPad users in the last 20 minutes.</p><p>Finally, health and system logs should be provided by your cloud provider. They make up a series of events, such as application startup, shutdown, expansion, web request tracking, and the results of regular health checks.</p><p>Cloud Services make a lot of things simple, but monitoring and telemetry are still difficult, and perhaps even more difficult than monitoring for traditional enterprise applications. When you stare at a pipeline that contains routine health checks, request audits, business-level events, and streams that track data and performance metrics, that’s an incredible amount of data.</p><p>When planning a monitoring strategy, you need to consider the amount of information to be aggregated, the speed of input, and the amount of information to be stored. If your application dynamically scales from 1 instance to 100 instances, this can also lead to a hundredfold increase in log traffic.</p><p>Auditing and monitoring cloud applications is often overlooked, but may be some of the most important things to plan and properly execute for production deployments. If you’re not going to blindly launch satellites into orbit without being able to monitor them, you shouldn’t do the same with cloud applications.</p><h2 id="Authentication-and-authorization"><a href="#Authentication-and-authorization" class="headerlink" title="Authentication and authorization"></a>Authentication and authorization</h2><p>Security is an important part of any application and cloud environment. <em>Security is never an afterthought</em> .</p><p>Many times, we are so focused on implementing the functional requirements of an application that we neglect one of the most important aspects of delivering any application, whether it is enterprise-oriented, mobile-device-oriented, or application-oriented. Cloud.</p><p>Cloud Native applications are the most secure applications. Your code (whether compiled or raw) is transferred across multiple data centers, executed in multiple containers, and accessed by countless clients (some legitimate, most harmful).</p><p>Even if the only reason to implement security in your application is that you can audit track which data changes have been made by which user, this alone is enough to prove that it takes relatively little time and effort to secure your application endpoints.</p><p>Ideally, all Cloud Native applications will use RBAC (Role-Based Access Control) to protect all their endpoints. Every request for an application resource should know who is making the request and the role that consumer belongs to. These roles indicate whether the calling Client has sufficient permissions to allow the application to fulfill the request.</p><p>With tools such as OAuth2, OpenID Connect, various SSO servers and standards, and almost unlimited language-specific authentication and authorization libraries, security should be incorporated into the development of applications from the beginning, rather than adding bolted projects after the application runs in production.</p><h2 id="Cloud-Native"><a href="#Cloud-Native" class="headerlink" title="Cloud Native"></a>Cloud Native</h2><h3 id="What-is-Cloud-Native"><a href="#What-is-Cloud-Native" class="headerlink" title="What is Cloud Native?"></a>What is Cloud Native?</h3><p>Buzzwords and phrases like “SOA”, “Cloud Native”, and “Microservices” all started popping up because we needed a faster and more efficient way to communicate our ideas about a certain topic. This was critical to facilitating meaningful conversations about complex topics, and we ended up establishing a <em>shared context</em> or <em>common language</em> .</p><p>The problem with these buzzwords is that they rely on a common or common understanding among multiple parties. Similar classic games<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Chinese_whispers">电话</a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch16.html#idm139821584628208">1</a>On an unprecedented scale, this so-called shared understanding quickly deteriorated to confusion with each other.</p><p>We saw this through SOA (service-oriented architecture) and again through the concept of Cloud Native. It seems that every time this concept is shared, the meaning changes until we think about Cloud Native as much as IT professionals.</p><p>To understand “Cloud Native”, we must first understand “cloud”. Many people believe that “cloud” is synonymous with open and unrestricted public access to the internet. Although there are some such cloud products, there is far from a complete definition.</p><p>In the context of this book, cloud refers to Platform as a Service. PaaS providers expose a platform that hides infrastructure details from application developers, which sits on top of Infrastructure as a Service (IaaS). Examples of PaaS providers include Google App Engine, Redhat Open Shift, Pivotal Cloud Foundry, Heroku, AppHarbor, and Amazon AWS.</p><p>The key takeaway is that cloud is not necessarily synonymous with public, and enterprises are setting up their own Private Cloud in their own IaaS or data centers of third-party IaaS providers such as VMware or Citrix.</p><p>Cast doubt on the word “native” in the word “cloud native”. <strong>This creates the false impression that only brand new green applications developed natively within the cloud can be considered Cloud Native. This is completely incorrect</strong> .</p><blockquote><ul><li>A Cloud Native application is an application that has been designed and implemented to run on a “Platform as a Service” installation and includes horizontal elastic scaling. *</li></ul></blockquote><h3 id="Why-use-the-Cloud"><a href="#Why-use-the-Cloud" class="headerlink" title="Why use the Cloud?"></a>Why use the Cloud?</h3><p>Not long ago, deploying applications on physical servers was considered the norm for building applications - from large towers in air-conditioned rooms to ultra-thin <em>1U</em> devices installed in actual Data centers.</p><p>Bare metal deployments are fraught with problems and risks: we can’t scale applications dynamically, the deployment process is difficult, changes to hardware can cause application failures, and hardware failures often result in massive data loss and significant downtime.</p><p>This sparked the virtualization revolution. Everyone agreed to stop using bare metal, so the hypervisor was born. The industry decided to put an abstraction layer on top of hardware so that we could simplify deployment, scale out applications, and hopefully avoid a lot of downtime and sensitivity to hardware failures.</p><p>In today’s world of always-connected smart devices and even smarter software, you have to search long and hard for a company that doesn’t have some kind of software development process as its cornerstone. Even in the traditional manufacturing industry, where companies make hard <em>physical products</em> , manufacturing doesn’t happen without software. Without software, you can’t organize people to build things efficiently and at scale, and without software, you certainly can’t participate in a global market.</p><p>No matter what industry you’re in, you can’t compete in today’s market without the ability to quickly deliver <em>unfailing</em> software. It needs to be able to dynamically scale to handle previously unheard of amounts of data. If you can’t handle <em>Big data</em> , then your competitors will. If you can’t produce software that can handle massive loads, stay responsive and change as fast as the market, then your competitors will find a way to do it.</p><p>This brings us to the essence of <em>Cloud Native</em> . In the past, companies could escape the days of distraction by spending an inordinate amount of time and resources on DevOps tasks, building and maintaining fragile infrastructure, and worrying about the consequences of production deployments that only happen once every blue moon.</p><p>This is the age of Cloud Services and we need to build applications in a way that encompasses this way. We need to build applications so that we can spend most of our time on the hedgehog (a big deal) and have someone or someone else take care of the many little things of the fox. Super fast IPO time is no longer a good time; it is necessary to avoid being left behind by our competitors. We want to be able to put resources into our business area and let other experts handle things they do better than we do.</p><p>By adopting a <em>Cloud Native architecture</em> and assuming <em>everything is a service,</em> and deploying them in a cloud environment to build our applications, we can achieve all these benefits and more. The question is not <em>Why Cloud Native?</em> The question you have to ask yourself is, why not * embrace Cloud Native?</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/d20b574c/" title="15 Essentials for Cloud Native Apps">https://sunra.top/en/posts/d20b574c/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/e421a043/" rel="prev" title="Devil's Dichotomy Lookup"><i class="fa fa-chevron-left"></i> Devil's Dichotomy Lookup</a></div><div class="post-nav-item"> <a href="/en/posts/9fba193f/" rel="next" title="Double pointer algorithm">Double pointer algorithm<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/d20b574c/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>