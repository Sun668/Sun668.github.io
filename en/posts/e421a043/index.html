<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="PrincipleKnuth (who invented the KMP algorithm) said that dichotomous lookups are simple, but the details are the devil**. Many people like to talk about the integer overflow bug, but the real pitfall"><meta property="og:type" content="article"><meta property="og:title" content="Devil&#39;s Dichotomy Lookup"><meta property="og:url" content="https://sunra.top/en/posts/e421a043/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="PrincipleKnuth (who invented the KMP algorithm) said that dichotomous lookups are simple, but the details are the devil**. Many people like to talk about the integer overflow bug, but the real pitfall"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://github.com/Sun668/fucking-algorithm/raw/master/pictures/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885648/origin-of-ray/1_nmfrw2.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885675/origin-of-ray/2_anlru2.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885701/origin-of-ray/3_wizs40.png"><meta property="article:published_time" content="2020-04-05T01:57:54.000Z"><meta property="article:modified_time" content="2023-09-28T07:11:25.977Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://github.com/Sun668/fucking-algorithm/raw/master/pictures/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg"><link rel="canonical" href="https://sunra.top/en/posts/e421a043/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/e421a043/","path":"posts/e421a043/","title":"Devil's Dichotomy Lookup"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Devil's Dichotomy Lookup | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Principle"><span class="nav-number">1.</span> <span class="nav-text">Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Framework"><span class="nav-number">1.1.</span> <span class="nav-text">Framework</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Example"><span class="nav-number">2.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-a-number"><span class="nav-number">2.1.</span> <span class="nav-text">Find a number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dichotomous-lookup-to-find-the-left-hand-boundary"><span class="nav-number">2.2.</span> <span class="nav-text">Dichotomous lookup to find the left-hand boundary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dichotomous-lookup-to-find-the-right-hand-side-boundary"><span class="nav-number">2.3.</span> <span class="nav-text">Dichotomous lookup to find the right-hand side boundary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dichotomous-variants-updated-2021-04-08"><span class="nav-number">3.</span> <span class="nav-text">Dichotomous variants (updated 2021.04.08)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-few-questions"><span class="nav-number">3.1.</span> <span class="nav-text">A few questions</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/e421a043/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Devil's Dichotomy Lookup | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Devil's Dichotomy Lookup</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-04-05 09:57:54" itemprop="dateCreated datePublished" datetime="2020-04-05T09:57:54+08:00">2020-04-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-09-28 15:11:25" itemprop="dateModified" datetime="2023-09-28T15:11:25+08:00">2023-09-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/e421a043/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/e421a043/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>Knuth (who invented the KMP algorithm) said that dichotomous lookups are simple, but the details are the devil**. Many people like to talk about the integer overflow bug, but the real pitfall of dichotomous lookup is not that detail at all, but whether to add one or subtract one to <code>mid</code>, and whether to use <code>&lt;=</code> or <code>&lt;</code> in while.</p><p>If you do not have a proper understanding of these details, writing dichotomous is certainly metaphysical programming, there is no bug can only rely on the blessing of God.</p><span id="more"></span><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;<span class="comment">// 可有效防止left + right溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Find-a-number"><a href="#Find-a-number" class="headerlink" title="Find a number"></a>Find a number</h3><p>This scenario is the simplest and probably the most familiar, i.e., search for a number and return its index if it exists, otherwise return -1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. Why is &lt;= in the condition of the while loop instead of &lt;</strong>?</p><p>A: Because the assignment to initialize <code>right</code> is <code>nums.length - 1</code>, which is the index of the last element, not <code>nums.length</code>.</p><p>The difference between these two, which may occur in dichotomous lookups with different functions, is that <strong>the former corresponds to the closed interval <code>[left, right]</code> at both ends, while the latter corresponds to the left-closed, right-open interval <code>[left, right)</code>, since the index size of <code>nums.length</code> is out of bounds.</strong></p><p>We use in this algorithm the interval where the former <code>[left, right]</code> is closed at both ends. <strong>This interval is actually the interval where the search is performed each time</strong>.</p><p>When should I stop the search? Of course, it can be terminated when the target value has been found:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] target)</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure><p>But if you don’t find it, you need the while loop to terminate and return -1. When should the while loop terminate? <strong>The loop should terminate when the search interval is empty</strong>, which means you have nothing to find, which means you didn’t find it.</p><p>The termination condition of <code>while(left &lt;= right)</code> is <code>left right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p>The termination condition of <code>while(left &lt; right)</code> is <code>left right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><p>Of course, if you have to use <code>while(left &lt; right)</code> that’s fine, we already know what’s going wrong, so let’s just patch it:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><strong>In summary, if right is length - 1 at the beginning, then you need to let the case left = right be searched as well. If right is length at the beginning, the critical case left = right is actually out of the valid range of the array</strong></p><p><strong>2. Why <code>left = mid + 1</code>, <code>right = mid - 1</code>? I see some code is <code>right = mid</code> or <code>left = mid</code>, there is no such addition and subtraction, what is going on and how to determine</strong> ?</p><p>A: This is also a difficult part of the dichotomous search, but as long as you can understand the previous content, you will be able to easily determine.</p><p>We have just clarified the concept of <code>search interval&#39;, and the search interval of this algorithm is closed at both ends, i.e.,</code>[left, right]<code>. So when we find that the index</code>mid<code>is not the</code>target` we are looking for, where should we search next?</p><p>Of course it goes to search <code>[left, mid-1]</code> or <code>[mid+1, right]</code>, right? <strong>Because <code>mid</code> has already been searched and should be removed from the search interval</strong>.</p><p><strong>3. What are the flaws of this algorithm</strong>?</p><p>A: At this point, you should have all the details of the algorithm and the reasons for treating it this way. However, there are limitations to this algorithm.</p><p>Let’s say you are given the ordered array <code>nums = [1,2,2,2,3]</code> and <code>target</code> is 2, this algorithm returns an index of 2, yes. But if I want to get the left-hand side of <code>target</code>, which is index 1, or if I want to get the right-hand side of <code>target</code>, which is index 3, then this algorithm can’t handle that.</p><p>This is a very common requirement, <strong>you may say, find a target, and then search linearly left or right, can’t you? Yes, but it’s not good, because it’s hard to guarantee the complexity of a dichotomous search on a logarithmic scale</strong>.</p><h3 id="Dichotomous-lookup-to-find-the-left-hand-boundary"><a href="#Dichotomous-lookup-to-find-the-left-hand-boundary" class="headerlink" title="Dichotomous lookup to find the left-hand boundary"></a>Dichotomous lookup to find the left-hand boundary</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. Why is <code>&lt;</code> in while instead of <code>&lt;=</code></strong>?</p><p>A: The same way, because <code>right = nums.length</code> instead of <code>nums.length - 1</code>. So the <code>search interval</code> of each loop is <code>[left, right)</code> left closed and right open.</p><p><code>while(left &lt; right)</code> terminates with the condition <code>left right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p><p><strong>2. Why is there no operation that returns -1? What if the value <code>target</code> does not exist in <code>nums</code></strong>?</p><p>A: Because we have to take one step at a time, let’s first understand what the special meaning of this “left border” is:</p><p>For this array, the algorithm returns 1. The meaning of this 1 can be interpreted as follows: there is 1 element in <code>nums</code> that is less than 2.</p><p>For example, for the ordered array <code>nums = [2,3,5,7]</code>, <code>target = 1</code>, the algorithm will return 0, meaning that there are 0 elements in <code>nums</code> that are less than 1.</p><p>If we say <code>nums = [2,3,5,7], target = 8</code>, the algorithm will return 4, meaning that there are 4 elements in <code>nums</code> that are less than 8.</p><p>As you can see above, the return value of the function (i.e. the value of the <code>left</code> variable) takes the closed interval <code>[0, nums.length]</code>, so we can simply add two lines of code to return -1 at the right time:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target is larger than all numbers</span></span><br><span class="line"><span class="keyword">if</span> (left nums.<span class="property">length</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// Similar processing to the previous algorithm</span></span><br><span class="line"><span class="keyword">return</span> nums[left] target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3. Why <code>left = mid + 1</code> and <code>right = mid</code>? is not the same as the previous algorithm</strong>?</p><p>A: This is easy to explain, because our <code>search interval&#39; is</code>[left, right)<code>closed left and open right, so when</code>nums[mid]<code>is detected, the next search interval should be split into two intervals by removing</code>mid<code>, i.e.</code>[left, mid)<code>or</code>[mid + 1, right)`.</p><p><strong>4. Why is the algorithm able to search the left-hand side boundary</strong>?</p><p>A: The key is that for <code>nums[mid] target</code> 这种情况的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure><p>It can be seen that, instead of returning immediately when the target is found, the upper bound <code>right</code> of the <code>search interval</code> is narrowed, and the search continues in the interval <code>[left, mid)</code>, i.e., it keeps shrinking to the left to lock the left boundary.</p><p><strong>5. Why does it return <code>left</code> instead of <code>right</code></strong>?</p><p>A: It’s the same, because the while termination condition is <code>left right</code>。</p><p><strong>6、Can you find a way to turn <code>right</code> into <code>nums.length - 1</code>, that is, continue to use both sides of the closed <code>search interval</code>? This way you can and the first dichotomous search in some way unified</strong> .</p><p>A: Of course you can, as long as you understand the concept of “search interval”, you can effectively avoid missing elements, you can change it any way you want. The following we modify strictly according to the logic:</p><p>Since you have to make both ends of the search interval closed, <code>right</code> should be initialized to <code>nums.length - 1</code> and the terminating condition while should be <code>left right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">left_bound</span>(<span class="params">int[] nums, int target</span>) &#123;</span><br><span class="line">    <span class="comment">// The search interval is [left, right]</span></span><br><span class="line">    int left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because the search interval is closed at both ends and is now searching the left-hand boundary, the update logic for <code>left</code> and <code>right</code> is as follows:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// The search interval becomes [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// The search interval becomes [left, mid-1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] target) &#123;</span><br><span class="line">    <span class="comment">// Shrink the right border</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since the exit condition of while is <code>left right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Sun668/fucking-algorithm/blob/master/pictures/二分查找/2.jpg"><img src="https://github.com/Sun668/fucking-algorithm/raw/master/pictures/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg" alt="img"></a></p><p>Therefore, the code that finally returns the result should check for out-of-bounds:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt;= nums.<span class="property">length</span> || nums[left] != target)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure><p>At this point, the entire algorithm is written, and the complete code is as follows:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">left_bound</span>(<span class="params">int[] nums, int target</span>) &#123;</span><br><span class="line">    int left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// The search interval is [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// The search interval becomes [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// The search interval becomes [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] target) &#123;</span><br><span class="line">            <span class="comment">// Shrink the right border</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check for out-of-bounds conditions</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.<span class="property">length</span> || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This will be unified with the first dichotomous search algorithm, both ends are closed “search interval”, and the final return is also the value of the <code>left</code> variable. As long as the logic of the dichotomous search, the two forms you see which one you like to remember which it.</p><h3 id="Dichotomous-lookup-to-find-the-right-hand-side-boundary"><a href="#Dichotomous-lookup-to-find-the-right-hand-side-boundary" class="headerlink" title="Dichotomous lookup to find the right-hand side boundary"></a>Dichotomous lookup to find the right-hand side boundary</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">right_bound</span>(<span class="params">int[] nums, int target</span>) &#123;</span><br><span class="line">    int left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] target) &#123;</span><br><span class="line">            <span class="comment">// Just change it here to shrink the left border</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Here it is changed to check for right out of bounds, see the figure below</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Link to original article:<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/二分查找详解.md">二分法详解</a></p><h2 id="Dichotomous-variants-updated-2021-04-08"><a href="#Dichotomous-variants-updated-2021-04-08" class="headerlink" title="Dichotomous variants (updated 2021.04.08)"></a>Dichotomous variants (updated 2021.04.08)</h2><p>Today’s leetcode question of the day is a dichotomy question, but different from the above dichotomy, here is an updated record</p><p>这是题目链接：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p><p>Here I will use the official solution directly to answer the question, except that it will be explained in more detail</p><p>An ascending array without duplicate elements, after rotation, gives the following visualization of a line graph:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885648/origin-of-ray/1_nmfrw2.png" alt></p><p>The horizontal axis represents the subscripts of the array elements and the vertical axis represents the values of the array elements. The position of the minimum value is marked in the figure and is the target we need to find.</p><p>We consider the last element of the array xx: the elements to the right of the minimum (excluding the last element itself) must all have values strictly less than xx, while the elements to the left of the minimum must all have values strictly greater than xx. Thus, we can find the minimum by means of a dichotomous lookup based on this property.</p><p>In each step of the dichotomous lookup, the left boundary is low, the right boundary is high, and the midpoint of the interval is pivot, within which the minimum value lies. We compare the middle element nums[pivot] with the right boundary element nums[high], and there are three possible cases:</p><p>The first case is nums[pivot] &lt; nums[high]. As shown in the figure below, this means that nums[pivot] is the element to the right of the minimum, so we can ignore the right half of the dichotomous lookup interval.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885675/origin-of-ray/2_anlru2.png" alt></p><p>The second case is nums[pivot]&gt;nums[high]. As shown in the figure below, this means that nums[pivot] is the element to the left of the minimum, so we can ignore the left half of the dichotomous lookup interval.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885701/origin-of-ray/3_wizs40.png" alt></p><p>Since the array does not contain duplicate elements, and as long as the current interval length is not 1, pivot will not coincide with high; and if the current interval length is 11, this means that we can already end the binary lookup. So there is no case where nums[pivot]=nums[high].</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> pivot = low + <span class="title class_">Math</span>.<span class="title function_">floor</span>((high - low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">            high = pivot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="A-few-questions"><a href="#A-few-questions" class="headerlink" title="A few questions"></a>A few questions</h3><p>After reading those explanations above, you may think you understand, but there are still a few issues we need to think about:</p><ul><li><p>What is the search interval</p><blockquote><p>According to the principle part, since high = nums.length - 1, the search interval is [low, high]</p></blockquote></li><li><p>Why is it executed when low &lt; high, i.e. why is it not necessary to determine when low = high?</p><blockquote><p>This is because when low = high, the length of the interval is 1, so the minimum value is this unique value, so just return it</p></blockquote></li><li><p>Why is it comparing pivot and high instead of low</p><blockquote><p>The values at the left, center and right positions are compared in the following ways:</p><p>left &lt; median, median &lt; right : no rotation, the minimum value is on the leftmost side, you can shrink the right boundary</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Right</span><br><span class="line">Medium</span><br><span class="line">Left</span><br></pre></td></tr></table></figure><p>left &gt; median, median &lt; right : there is rotation, the minimum value is on the left half, you can shrink the right boundary</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Left</span><br><span class="line">Right</span><br><span class="line">Medium</span><br></pre></td></tr></table></figure><p>left &lt; median, median &gt; right : there is a rotation, the minimum value is in the right half, you can shrink the left border</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Medium</span><br><span class="line">Left</span><br><span class="line">Right</span><br></pre></td></tr></table></figure><p>left &gt; median, median &gt; right : monotonically decreasing, not possible</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Left</span><br><span class="line">Medium</span><br><span class="line">Right</span><br></pre></td></tr></table></figure><p>We can analyze the above cases and compare the median and right values in just two cases. The median value is greater than the left value has to be divided into two more cases</p></blockquote></li><li><p>Why does high = pivot and low = pivot + 1 when narrowing the interval</p><blockquote><p>Because when <code>nums[pivot] &lt; nums[high]</code>, this <code>nums[pivot]</code> is still possible to be the minimum, so pivot is still in the search interval. And when <code>nums[pivot] &gt; nums[high]</code>, <code>nums[pivot]</code> can’t be the minimum</p></blockquote></li></ul></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/e421a043/" title="Devil&#39;s Dichotomy Lookup">https://sunra.top/en/posts/e421a043/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/a39e0cda/" rel="prev" title="Sliding window algorithm"><i class="fa fa-chevron-left"></i> Sliding window algorithm</a></div><div class="post-nav-item"> <a href="/en/posts/d20b574c/" rel="next" title="15 Essentials for Cloud Native Apps">15 Essentials for Cloud Native Apps<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/e421a043/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>