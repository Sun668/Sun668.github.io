<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="The textures we used before, such as normal textures, gradual change textures, mask textures, etc., are all one-dimensional or two-dimensional. This time we will introduce the cube texture and see how"><meta property="og:type" content="article"><meta property="og:title" content="Principles of Unity Rendering (16) Unity Cube Textures"><meta property="og:url" content="https://sunra.top/en/posts/62391/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="The textures we used before, such as normal textures, gradual change textures, mask textures, etc., are all one-dimensional or two-dimensional. This time we will introduce the cube texture and see how"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1662173924/origin-of-ray/screenshot-20220903-105804_dy7y2h.png"><meta property="article:published_time" content="2022-09-03T02:03:07.000Z"><meta property="article:modified_time" content="2024-06-10T03:12:08.237Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1662173924/origin-of-ray/screenshot-20220903-105804_dy7y2h.png"><link rel="canonical" href="https://sunra.top/en/posts/62391/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/62391/","path":"posts/62391/","title":"Principles of Unity Rendering (16) Unity Cube Textures"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Principles of Unity Rendering (16) Unity Cube Textures | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Sky-Box"><span class="nav-number">1.</span> <span class="nav-text">Sky Box</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-create-a-cube-texture"><span class="nav-number">2.</span> <span class="nav-text">How to create a cube texture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflection"><span class="nav-number">3.</span> <span class="nav-text">Reflection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refraction"><span class="nav-number">4.</span> <span class="nav-text">Refraction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fresnel-reflection"><span class="nav-number">5.</span> <span class="nav-text">Fresnel reflection</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/62391/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Principles of Unity Rendering (16) Unity Cube Textures | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Principles of Unity Rendering (16) Unity Cube Textures</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-09-03 10:03:07" itemprop="dateCreated datePublished" datetime="2022-09-03T10:03:07+08:00">2022-09-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-06-10 11:12:08" itemprop="dateModified" datetime="2024-06-10T11:12:08+08:00">2024-06-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/62391/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/62391/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>The textures we used before, such as normal textures, gradual change textures, mask textures, etc., are all one-dimensional or two-dimensional. This time we will introduce the cube texture and see how to use the cube texture to achieve environment mapping.</p><span id="more"></span><p>In graphics, Cubemap is an implementation of Environment Mapping. Environment mapping can simulate the environment around an object, and objects using environment mapping can appear to reflect the surrounding environment as if they were plated with metal.</p><p>The cube texture contains a total of six images, which correspond to the six faces of a cube, hence the name of the cube texture. Each face of the cube represents the image obtained by observing along the axis (up, down, left, right, front, and back) below the world space.</p><p>So how do we sample this texture? Unlike the 2D texture coordinates used before, for cube texture sampling we need to provide a 3D texture coordinate, and this ** 3D texture coordinate represents a 3D direction in world space. This vector is emitted from the center of the cube, and when it extends outward, it will intersect with one of the six textures of the cube, and the sampling result is calculated from this intersection point.</p><p>The advantage of the cube texture is that it is simple and fast to implement, and the effect is better. However, there are some drawbacks, such as introducing new objects into the scene, when the light source or object moves, we need to regenerate the cube texture. In addition, the cube texture can only reflect the environment, but not the object itself using the cube texture. This is because the cube texture cannot touch the result of multiple reflections, such as when two metal balls reflect each other.</p><p>Cube textures have many applications in real-time rendering, the most common being skybox.</p><h2 id="Sky-Box"><a href="#Sky-Box" class="headerlink" title="Sky Box"></a>Sky Box</h2><p>Skybox is a method used in games to simulate backgrounds. The name Skybox also contains two pieces of information: it is used to simulate the sky, and secondly it is a box. When we use Skybox in a scene, our entire scene is surrounded by a cube. The technology used for each face of this cube is <strong>cube texture mapping technology</strong> .</p><p>The use of the skybox is relatively simple, so I won’t go into details. The main thing is that the WrapMode of the six maps selects Clamp to prevent mismatch at the seams due to accuracy problems.</p><h2 id="How-to-create-a-cube-texture"><a href="#How-to-create-a-cube-texture" class="headerlink" title="How to create a cube texture"></a>How to create a cube texture</h2><p>In Unity 5, there are three ways to create cube textures for environment mapping:</p><ul><li>Created directly from some special layout texture. This texture can be roughly imagined as the texture itself is the layout of the cube expansion.</li><li>Manually create a Cubemap resource and assign six images to it</li><li>The third method is script generation</li></ul><p>Unity officially recommends using the first method, which compresses texture data and supports edge correction, glossy reflection, and HDR</p><p>The first two methods require us to prepare the image of the cube texture in advance, and the cube texture we get is often shared by the objects in the scene. Ideally, we want to generate different cube textures depending on the position of the object in the scene. This is, we can use scripts to create it in Unity. This is achieved by using the’Camera. RenderToCubemap ‘function provided by Unity. This function can store the scene image seen from any location into six images, thereby creating the corresponding cube texture at that location.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Tools.Scripts.CreateCubemap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateCubemap</span>: <span class="title">ScriptableWizard</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">        <span class="keyword">public</span> Transform renderFromPosition;</span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;Tools/CreateCubemap&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ScriptableWizard.DisplayWizard&lt;CreateCubemap&gt;(<span class="string">&quot;CreateCubemap&quot;</span>, <span class="string">&quot;Create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>()</span> &#123;</span><br><span class="line">            GameObject go = <span class="keyword">new</span> GameObject(<span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">            go.AddComponent&lt;Camera&gt;();</span><br><span class="line">            go.transform.position = renderFromPosition.position;</span><br><span class="line">            go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line">            DestroyImmediate(go);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the above code, we create a camera at the renderFromPosition position and call the RenderToCubemap function to render the currently observed image into the user-specified cube texture, and then destroy it after completion.</p><p>It is also very simple to use:</p><ul><li>This code will add a menu item to the editor menu, we can click “Tools- &gt; CreateCubemap” to bring up the panel</li><li>Then right-click “Create - &gt; Legacy - &gt; Cubemap” in Project to create a Cubemap, and check <strong>Readable</strong> in the panel, and assign it to the cubemap variable on the panel<br>Create a gameobject in the scene and assign it to the renderFromPosition variable of the panel</li><li>Click the Create button</li></ul><p>Then we can get the environment texture as seen from the gameobject location.</p><p>Once created, we can use environment mapping techniques. The most common environment mapping techniques are reflection and refraction.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1662173924/origin-of-ray/screenshot-20220903-105804_dy7y2h.png" alt></p><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>Objects that use the reflection effect usually look like they are plated with metal. To simulate the reflection effect is very simple, you only need to calculate the reflection direction by the direction of the incident ray and the surface method display direction, and then use the reflection direction to sample the cube texture.</p><p>We need to make the following preparations:</p><ul><li>Create a new scene and replace the skybox of the new scene with the Cubemap we just generated</li><li>Drag a Teapot into the scene at the same location as the gameobject we used to generate the Cubemap in the previous step</li><li>Create a new material, named ReflectionMat, and assign the material to the Teapot model</li><li>Create a new Shader, named Reflection and assign it to the material created in the previous step</li></ul><p>The reflected Shader is relatively simple and can be divided into the following steps:</p><p>(1) Declare new attributes:<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    _ReflectColor(<span class="string">&quot;Reflection Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    _ReflectAmount(<span class="string">&quot;Reflect Amount&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>))  = <span class="number">1</span></span><br><span class="line">    _Cubemap(<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(2) Calculate the reflection direction at this point in the vertex shader, we directly use the reflect function of CG to calculate<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_Object2World, v.vertex).xyz;</span><br><span class="line">    o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(3) Sampling by reflection direction in chip element shader<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span> &#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">    fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">    fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflecColor.rgb;</span><br><span class="line"></span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Refraction"><a href="#Refraction" class="headerlink" title="Refraction"></a>Refraction</h2><p>In this section, we will learn how to simulate another common application of environment mapping in Unity Shader - refraction.</p><p>The physics of refraction is a little more complicated than reflection. We have been dealing with the definition of refraction since junior high school physics; when light is incident obliquely from one medium to another, the direction of propagation generally changes. When given the angle of incidence, we can use Snell’s theorem to calculate the reflection angle. When light enters medium 2 from medium 1 at an angle of $θ _1 $to the surface normal, the angle between the refracted light and the normal can be calculated using the following formula $θ _2 $</p><script type="math/tex;mode=display">
n_1sinθ_1 = n_2sinθ_2</script><p>$n_1 $and $n_2 $are the refractive indices of the two media, respectively, and the refractive index is an important physical constant.</p><p>Normally, once we have the refraction direction, we will use it directly to sample the cube texture, but this is not in accordance with the laws of physics. For a transparent object, a more accurate simulation method requires calculating two refractions - one when light enters its interior and the other when it exits from its interior. However, simulating the second refraction direction in real-time rendering is more complicated, and simulating the effect obtained only once seems to be no problem, so we usually only simulate the first refraction.</p><p>We first need to do a similar preparation to the previous section on reflection, this time we call the Shader Refraction</p><p>(1) Declare new attributes:<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    _RefractColor(<span class="string">&quot;Refraction Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    _ReflractAmount(<span class="string">&quot;Refraction Amount&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>))  = <span class="number">1</span></span><br><span class="line">    _ReflractRatio(<span class="string">&quot;Refraction Ratio&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>))  = <span class="number">1</span></span><br><span class="line">    _Cubemap(<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(2) Calculate the direction of refraction at the point in the vertex shader. We use the refract function to calculate the direction of refraction. Its first parameter is the direction of the incident ray line, which must be a normalized vector; The second parameter is the surface normal, and the normal direction is also normalized when needed. The third parameter is the ratio between the refractive index of the medium where the incident ray line is located and the refractive index of the ring where the refracted light is located<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_Object2World, v.vertex).xyz;</span><br><span class="line">    o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">    o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _ReflractRatio);</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(3) Sampling by using the refraction direction in the chip element shader<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span> &#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">    fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">    fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line"></span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Fresnel-reflection"><a href="#Fresnel-reflection" class="headerlink" title="Fresnel reflection"></a>Fresnel reflection</h2><p>In real-time rendering, we often use Fresnel reflection to control the degree of reflection according to the viewing angle direction. Generally speaking, Fresnel reflection describes an optical phenomenon, that is, when light shines on the surface of an object, part of it is reflected, and part of it enters the object and is refracted or scattered.</p><p>There is a certain ratio between the reflected light and the incident ray, which can be calculated by Fresnel’s equation. An often used example is that standing by the lake and looking directly at the water surface at your feet, you will find that the water is almost transparent, and you can directly see the small fish and stones at the bottom of the water; but when you look up and see the water surface in the distance, you will find that you can hardly see the underwater scene, but only see the reflected environment of the water surface. This is the so-called Fresnel effect.</p><p>So how to calculate Fresnel reflection? You need to use the Fresnel equation. The Fresnel equation in the real world is very complicated, but in real-time rendering we usually use some approximation formula, such as <strong>Schlick Fresnel approximation equation</strong> .</p><script type="math/tex;mode=display">
F_{schlick}(v, n) = F_0 + (1 - F_0)(1 - v * n)^5</script><p>Where $F_0 $is a reflection coefficient that controls the intensity of the Fresnel reflection, v is the viewing angle direction, and n is the direction of the surface normal.</p><p>Another equation that is more widely used is the Emprurine Fresnel approximation equation.</p><script type="math/tex;mode=display">
F_{Empricial}(v,n) = max(0, min(1, bias + scale * (1 - v * n)^{power}))</script><p>Among them, bias, scale, and power are all controls.</p><p>Let’s try a Shader of Schlick Fresnel’s approximation of the equation</p><p>(1) Declare new attributes:<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    _FrenelScale(<span class="string">&quot;Fresnel Scale&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>))  = <span class="number">0.5</span></span><br><span class="line">    _Cubemap(<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(2) Calculate the reflection direction, normal direction, and viewing angle direction at this point in the vertex shader. We directly use the reflect function of CG to calculate<br></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldPos = mul(unity_Object2World, v.vertex).xyz;</span><br><span class="line">    o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>(3) Implement Fresnel reflection in a slice shader and mix diffuse and reflected illumination using the resulting values</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span> &#123;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">    fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 fresnel = _FrenelScale + (<span class="number">1</span> - _FrenelScale) * pow(<span class="number">1</span> - dot(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/62391/" title="Principles of Unity Rendering (16) Unity Cube Textures">https://sunra.top/en/posts/62391/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/53817/" rel="prev" title="Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows"><i class="fa fa-chevron-left"></i> Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows</a></div><div class="post-nav-item"> <a href="/en/posts/24195/" rel="next" title="Performance and Principle of Universal Lock">Performance and Principle of Universal Lock<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/62391/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>