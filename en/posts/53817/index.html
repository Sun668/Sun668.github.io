<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Let’s move on to the last part of Unity lighting, the decay"><meta property="og:type" content="article"><meta property="og:title" content="Unity Rendering Principle (15) Unity&#39;s Light Attenuation and Opaque Object Shadows"><meta property="og:url" content="https://sunra.top/en/posts/53817/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Let’s move on to the last part of Unity lighting, the decay"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2022-08-25T09:15:51.000Z"><meta property="article:modified_time" content="2024-03-31T02:07:10.511Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/posts/53817/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/53817/","path":"posts/53817/","title":"Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Light-attenuation"><span class="nav-number">1.</span> <span class="nav-text">Light attenuation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Textures-for-light-attenuation"><span class="nav-number">1.1.</span> <span class="nav-text">Textures for light attenuation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calculate-attenuation-using-mathematical-formulas"><span class="nav-number">1.2.</span> <span class="nav-text">Calculate attenuation using mathematical formulas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity"><span class="nav-number">2.</span> <span class="nav-text">Unity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#How-is-the-shadow-achieved"><span class="nav-number">2.1.</span> <span class="nav-text">How is the shadow achieved?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shadows-of-opaque-objects"><span class="nav-number">2.2.</span> <span class="nav-text">Shadows of opaque objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Make-objects-cast-shadows"><span class="nav-number">2.2.1.</span> <span class="nav-text">Make objects cast shadows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Make-objects-receive-shadows"><span class="nav-number">2.2.2.</span> <span class="nav-text">Make objects receive shadows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unified-management-of-attenuation-and-shadows"><span class="nav-number">2.3.</span> <span class="nav-text">Unified management of attenuation and shadows</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/53817/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Rendering Principle (15) Unity's Light Attenuation and Opaque Object Shadows</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-08-25 17:15:51" itemprop="dateCreated datePublished" datetime="2022-08-25T17:15:51+08:00">2022-08-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-03-31 10:07:10" itemprop="dateModified" datetime="2024-03-31T10:07:10+08:00">2024-03-31</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/53817/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/53817/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Let’s move on to the last part of Unity lighting, the decay</p><span id="more"></span><h2 id="Light-attenuation"><a href="#Light-attenuation" class="headerlink" title="Light attenuation"></a>Light attenuation</h2><p>In the previous blog, we mentioned that Unity uses a texture as a Look up table to calculate pixel-by-pixel light attenuation in the chip shader. The advantage of this is that calculating attenuation does not depend on the complexity of mathematical formulas, we just need to use a parameter value to sample the texture. However, using texture lookup to calculate attenuation also has some drawbacks:</p><ul><li>Requires preprocessing to get the sampled texture, and the size of the texture also affects the accuracy of the attenuation</li><li>Inintuitive and inconvenient, so once the data is stored in the Look up table, we cannot use other mathematical formulas to calculate the attenuation</li></ul><p>However, since this method can improve performance to a certain extent, and the results obtained are good in most cases, Unity uses this texture lookup method by default to calculate pixel-by-pixel point light and spotlight attenuation.</p><h3 id="Textures-for-light-attenuation"><a href="#Textures-for-light-attenuation" class="headerlink" title="Textures for light attenuation"></a>Textures for light attenuation</h3><p>Unity internally uses a texture called _LightTexture0 to calculate the light source attenuation. It should be noted that if we use cookies for this light source, then the attenuation lookup texture is _LigthTextureB0, but this situation is not discussed here. We usually only care about the texture color values on the diagonal of the _LightTexture0, which indicate the attenuation value of points at different positions in the light source space, such as (0,0) point indicates the attenuation value of the point that coincides with the light source position, and (1,1) point indicates the attenuation of the farthest point of interest in the light source space.</p><p>In order to sample the _LightTexture0 texture to get the attenuation value of a given point to the light source, we first need to get the position of the point in the light source space, which is obtained by _LightMatrix0 transformation matrix. We only need to multiply the vertex coordinates in the _LightMatrix0 and world space. To get the corresponding position in the light source space:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flaot3 lightCoord = mul(_LightMatrix0, float4(i.worldPostion, <span class="number">1</span>)).xyz</span><br></pre></td></tr></table></figure><p>Then we can use the square of the modulus of this coordinate to sample the attenuation texture and get the attenuation value</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fixed</span> atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL</span><br></pre></td></tr></table></figure><p>In the above code, we use the square of the vertex distance in the light source space to sample the texture. The reason why we do not use the distance value is because this method can avoid the square operation. Then we use the macro UNITY_ATTEN_CHANNEL to obtain the attenuation value in the attenuation texture. Component, get the final attenuation value.</p><h3 id="Calculate-attenuation-using-mathematical-formulas"><a href="#Calculate-attenuation-using-mathematical-formulas" class="headerlink" title="Calculate attenuation using mathematical formulas"></a>Calculate attenuation using mathematical formulas</h3><p>Although the texture sampling method can reduce the complexity of calculating the attenuation, sometimes we want to use the formula in the code to calculate the attenuation of the light source. For example, we can use the code to calculate the linear attenuation of the light source</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> distance = length(_WorldSpaceLightPos0.xyz - i.worldPosition.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> / distance;</span><br></pre></td></tr></table></figure><p>However, Unity does not give relevant instructions for the built-in attenuation calculation. Although we can still use some mathematical formulas in the chip shader to calculate the attenuation, since we cannot get the range of the light source, the orientation of the spotlight, the opening angle and other information through the built-in variables in the Shader, the effect obtained is often somewhat Unsatisfactory, especially when the object leaves the lighting range of the light source, it will mutate (because the object is not in the range of the light source, Unity will not perform an Additional Pass for the object). Of course, we can use the script to pass the relevant information of the light source to the Shader, but the flexibility is relatively low.</p><h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>In order to make the scene look more realistic and have depth information, we usually hope that the light source can cast shadows of some objects on other objects.</p><p>Let’s take a look at how to make an object cast shadows on other objects, and how to make an object receive shadows from other objects.</p><h3 id="How-is-the-shadow-achieved"><a href="#How-is-the-shadow-achieved" class="headerlink" title="How is the shadow achieved?"></a>How is the shadow achieved?</h3><p>We can first consider how shadows are generated in real life. When a ray of light emitted by a light source encounters an opaque object, the light cannot continue to illuminate other objects (regardless of reflection). So the object casts shadows on the objects next to it, and those shadow areas are generated because the light cannot reach those areas.</p><p>In real-time rendering, we most often use a technology called Shadow Map. This technology is relatively simple to understand. First, the position of the camera will be placed in a position coinciding with the light source, so the shaded area of the light source in the scene is the place that the camera cannot see. And Unity uses this technology.</p><p>In the forward rendering path, if the most important parallel light in the scene has shadows turned on, Unity will calculate its shadow map texture (shadowmap) for that light source. In this way, the shadow map texture is essentially a depth map, which records the closest surface position (depth information) in the scene that can be seen from the position of the light source.</p><p>So when calculating the shadow map texture, how do we determine the closest surface position to it? One method is to first place the camera at the light source position, and then follow the normal rendering process, that is, call Base Pass and Additional Pass to update the depth information and obtain the shadow map texture. But this method will cause a certain waste of performance, because we actually only need depth information, and Base Pass and Additional Pass often involve a lot of complex lighting model calculations.</p><p>Therefore, <strong>Unity chooses to use an additional Pass specifically to update the light source, this Pass is the Pass whose LightMode tag is set to ShadowCaster. The rendering target of this Pass is not for frame cache, but shadow map texture (depth texture)</strong> . Unity first places the camera at the light source position, and then calls the Pass to obtain the position under the light source space by transforming the vertices, and accordingly outputs the depth information to the shadow map texture.</p><p>Therefore, <strong>when the shadow effect of the light source is turned on, the underlying rendering engine will first find the Pass with LightMode as ShadowCaster in the Unity Shader of the currently rendered object. If not, it will continue to search in the Unity Shader specified by Fallback. If still not found, the object cannot cast shadows on other objects</strong> (but it can still receive shadows from other objects). When a Pass with LightMode as ShdowCaster is found, Unity will use that Pass to update the shadow mapping texture of the light source.</p><p>In traditional shadow map texture line of sight, we transform the vertex position under the light source space in the normally rendered Pass to obtain its 3D position in the light source space. Then, we use the xy component to sample the shadow map texture to obtain depth information at that position in the shadow map texture. If the depth value is less than the depth value of the vertex (usually obtained by the z component), then the point is in shadow.</p><p>In Unity 5, Unity uses a different shadow sampling technique from this traditional one, Screenspace Shadow Map. This technique was originally a method for generating shadows in deferred rendering. It should be noted that not all platforms Unity will use this technique. This is because the technology requires the graphics card to support MRT, which some mobile platforms do not support.</p><p>When using screen space shadow mapping technology, Unity first obtains the shadow mapping texture of the light source that can cast shadows and the depth texture of the camera by calling LightMode to ShadowCaster’s Pass. Then the screen space shadow map is obtained based on the shadow mapping texture of the light source and the camera depth texture. If the surface depth recorded in the camera’s depth map is greater than the depth value in the converted shadow mapping texture, it means that the surface is visible, but in the shadow of the light source. In this way, the shadow map contains all hard and hard areas in screen space. If we want an object to accept shadows from other objects, we only need to sample the shadow map in Shader. Since the shadow map is in screen space, we first need to transform the surface coordinates from model space to screen space, and then use this coordinate to sample the shadow map</p><p>To sum up, an object receiving shadows from other objects and it casting shadows on other objects are two processes.</p><ul><li>If we want an object to accept shadows from other objects, we must sample the shadow map texture (including the shadow map of screen space) in Shader, multiply the sampling result and the final lighting result to produce the shadow effect.</li><li>If we want an object to cast a shadow on other objects, we must add the object to the calculation of the shadow map texture of the light source, so that other objects can get the relevant information of the object when sampling the shadow map texture. In Unity, this process is achieved by executing a Pass with LightMode to ShadowCaster for the object. If screen-space projection mapping technology is used, Unity will also use this Pass to generate a camera depth texture</li></ul><h3 id="Shadows-of-opaque-objects"><a href="#Shadows-of-opaque-objects" class="headerlink" title="Shadows of opaque objects"></a>Shadows of opaque objects</h3><p>We first create two planes, a cube, and then create a new material, the material Shader is ForwardRendering from our last blog, and assign the new material to the cube.</p><h4 id="Make-objects-cast-shadows"><a href="#Make-objects-cast-shadows" class="headerlink" title="Make objects cast shadows"></a>Make objects cast shadows</h4><p>In Unity, we can choose whether to make an object cast or accept shadows. This is achieved by setting the Cast Shadows and Receive Shadows properties in the Mesh Render component.</p><p>Cast Shadows can be turned on or off. If the Cast Shadows property is enabled, Unity will add the object to the calculation of the shadow map texture of the light source, so that other objects can get information about the object when sampling the shadow map texture. As mentioned earlier, this process is achieved by executing a pass with LightMode to ShadowCaster for the object. Receive Shadows can choose whether to let the object accept shadows from other objects. If Receive Shadows is not enabled, then when we call Unity’s built-in macros and variables to calculate shadows, these macros will not calculate shadows for us internally by judging that the object does not have the function of accepting shadows enabled.</p><p>When we enable Cast Shadows on the cube and Receive Shadows on two planes, we can find that the cube produces shadows on the plane. This is because although our ForwardRendering does not have a Pass with LightMode as ShaderCaster, its Fallback is Specular, and the Fallback of Specular is VertexLit, which contains a Pass with LightMode as ShaderCaster in VertexLit.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name <span class="string">&quot;ShadowCaster&quot;</span></span><br><span class="line">    Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    CFPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster</span></span><br><span class="line">    <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> v2f &#123;</span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata _ <span class="keyword">base</span> v</span>)</span> &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">float4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span> &#123;</span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are many macro definitions in this code, but the actual use is to write depth information into the rendering target.</p><blockquote><p>One more thing to note here is that by default, we will remove the back of the object when calculating the shadow map texture of the light source. But for the built-in plane, it has only one face, and if the object does not have any frontface in the light source space when calculating the shadow map texture, it will not be added to the shadow map texture. We can set Cast</p></blockquote><h4 id="Make-objects-receive-shadows"><a href="#Make-objects-receive-shadows" class="headerlink" title="Make objects receive shadows"></a>Make objects receive shadows</h4><p>The reason why our plane can produce shadows is because of the use of built-in Standard Shader, and the built-in Shader of both performs operations related to receiving shadows.</p><p>In order for the cube to accept shadows, we need to modify our Shader code. We create a new Shader, name it Shadow, and then copy the ForwardRendering code to it and modify it</p><p>First you need to include a new built-in file in Base Pass</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;AutoLight.cgnic&quot;</span></span><br></pre></td></tr></table></figure><p>This is because the macro definitions used when calculating shadows are all in this file</p><p>Then we need to add a built-in macro SHADOW_COORDS to our output architecture v2f.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f &#123;</span><br><span class="line">    float4 pos:SV_POSITION;</span><br><span class="line">    float3 worldNormal: TEXCOORD0;</span><br><span class="line">    float3 worldPos: TEXCOORD1;</span><br><span class="line">    SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The purpose of this macro is very simple, just declare a coordinate for sampling the shadow texture. It should be noted that the parameter of this macro needs to be the index value of the next available interpolation register.</p><p>Then we add a built-in macro TRANSFER_SHADOW before the vertex shader returns.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This macro is used to calculate the shadow texture coordinates declared in the previous step in the vertex shader</p><p>Next, we calculate the shadow value in the chip shader, which also applies a macro definition SHADOW_ATTENUATION</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fixed</span> shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure><p>SHADOW_COORDS, TRANSFER_SHADOW and SHADOW_ATTENUATION are the three Musketeers when calculating shadows. These built-in macros help us calculate shadows of light sources when necessary. We can find their declarations in AutoLight.cgnic</p><p>SHADOW_COORDS actually declares a shadow texture coordinate variable called _ShadowCoord. The implementation of TRANSFER_SHADOW will vary depending on the platform. If the current platform can use screen space shadow mapping technology (by determining whether UNITY_NO_SCREENSPACE_SHADOWS are defined), TRANSFER_SHADOW will call the built-in ComputeScreenPos function to calculate the _ShadowCoord. If the platform does not support screen space shadow mapping technology, traditional shadow mapping technology will be used. TRANSFER_SHADOW will transform the vertex coordinates from model space to light space and store them in the _ShadowCoord. SHADOW_ATTENUATION then responsible for sampling the relevant texture using _ShadowCoord to obtain shadow information.</p><p>It should be noted that these macros will use context variables for related calculations, such as TRANSFER_SHADOW will use v.vertex and a.pos to calculate coordinates, so in order to make these macros work correctly, we need to ensure that our custom variable names match the variable names used by these macros</p><h3 id="Unified-management-of-attenuation-and-shadows"><a href="#Unified-management-of-attenuation-and-shadows" class="headerlink" title="Unified management of attenuation and shadows"></a>Unified management of attenuation and shadows</h3><p>We have already talked about how to calculate the light attenuation in the forward rendering path of Unity Shader before - in Base Pass, the attenuation factor of parallel light is always equal to 1, while in Additional Pass, we need to determine the type of light source processed by the Pass, and then use the built-in variables and macros to calculate the attenuation factor. In fact, the effect of light attenuation and shadow on the final rendering result of the object is essentially the same - we multiply the light attenuation factor and shadow value with the lighting result to get the final rendering result. So, is there a way to calculate both information at the same time?</p><p>Unity does provide such functionality in Shader, mainly through built-in UNITY_LIGHT_ATTENUATION macros</p><p>Let’s go back to the previous step of Shadow Shader copy and rename it to AttenuationAndShadowUseBuildInFunctions</p><p>Although the code in Shdow Shader allows us to get the correct shadow, in practice we usually use Unity’s built-in macros and functions to calculate decay and shadow, thus hiding some details.</p><p>First, it needs to be included in the required header file.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;Lighting.cgnic&quot;</span></span><br><span class="line"><span class="meta">#include &quot;AutoLight.cgnic&quot;</span></span><br></pre></td></tr></table></figure><p>Use macros to define SHADOW_COORD declare shadow coordinates in the v2f structure</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f &#123;</span><br><span class="line">    float4 pos : SV_Target;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) Use built-in macro TRANSFER_SHADOW in vertex shader to calculate and pass shadow coordinates to chip shader</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span> &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    TRANSDER_SHADOW(o);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) In the chip element shader, we use the built-in macro UNITY_LIGHT_ATTENUATION to calculate the light attenuation and shadow</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    UNITY_LIGHT_ATTENUATION(attne, i, i.worldPos);</span><br><span class="line">    <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UNITY_LIGHT_ATTENUATION is a built-in macro for calculating light attenuation and shadows. We can find its declaration in the built-in AutoLight.cgnic. It accepts three parameters and stores the result of multiplying the light attenuation and shadow values into the first parameter. Notice that we didn’t declare the first parameter, atten, because UNITY_LIGHT_ATTENUATION will declare this variable for me. The second parameter is the struct v2f, which will be passed to the SHADOW_ATTENUATION to calculate the shadow value. The third parameter is the coordinates of world space. This parameter will be used to calculate the coordinates in light space, and then sample the light attenuation texture to obtain the light attenuation.</p><p>Due to the use of UNITY_LIGHT_ATTENUATION, we have unified the code of Base Pass and Additional Pass. We do not need to handle shadows separately in Base Pass, nor do we need to determine the type of light source in Additional Pass to handle light attenuation. If we want to add shadow effects in Additional Pass, we need to use ‘#pragma multi_compile_fwdadd_fullshadows’ compile directive instead of ‘#pragma multi_compile_fwadd’ in Additional Pass</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/53817/" title="Unity Rendering Principle (15) Unity&#39;s Light Attenuation and Opaque Object Shadows">https://sunra.top/en/posts/53817/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/12495/" rel="prev" title="Unity physics system introduction doc finishing"><i class="fa fa-chevron-left"></i> Unity physics system introduction doc finishing</a></div><div class="post-nav-item"> <a href="/en/posts/62391/" rel="next" title="Principles of Unity Rendering (16) Unity Cube Textures">Principles of Unity Rendering (16) Unity Cube Textures<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/53817/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>