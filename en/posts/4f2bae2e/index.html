<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Features  TCP is a connection-oriented transport layer protocol. That is, a TCP connection must be established before an application can use it. After the data is transferred, the TCP connection must"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to TCP Protocol"><meta property="og:url" content="https://sunra.top/en/posts/4f2bae2e/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Features  TCP is a connection-oriented transport layer protocol. That is, a TCP connection must be established before an application can use it. After the data is transferred, the TCP connection must"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200418085415_bobkzr.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587195669/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418154042_tktoqj.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587196595/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418155614_iod7dv.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587197557/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418161217_djnuqg.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587202028/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418172540_by140j.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587203074/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418174406_itnljo.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587209077/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418192408_lz3rfp.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211176/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418195848_xt17r1.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211807/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418200900_kruofd.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587214008/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418204614_kprnwt.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587215346/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418210855_mpcozg.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587216170/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418212241_j13fkc.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587217099/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418213810_lbd6iv.png"><meta property="article:published_time" content="2020-04-18T00:15:46.000Z"><meta property="article:modified_time" content="2025-09-30T03:27:56.652Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200418085415_bobkzr.jpg"><link rel="canonical" href="https://sunra.top/en/posts/4f2bae2e/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/posts/4f2bae2e/","path":"posts/4f2bae2e/","title":"Introduction to TCP Protocol"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Introduction to TCP Protocol | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#features"><span class="nav-number">1.</span> <span class="nav-text">Features</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-a-tcp-connection"><span class="nav-number">2.</span> <span class="nav-text">What is a TCP connection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#principle-of-reliable-transmission"><span class="nav-number">3.</span> <span class="nav-text">Principle of reliable transmission</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stop-waiting-protocol"><span class="nav-number">3.1.</span> <span class="nav-text">Stop waiting protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continuous-arq-protocol"><span class="nav-number">3.2.</span> <span class="nav-text">Continuous ARQ protocol</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-message-segment-header"><span class="nav-number">4.</span> <span class="nav-text">TCP message segment header</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#source-and-destination-ports"><span class="nav-number">4.1.</span> <span class="nav-text">Source and destination ports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serial-number"><span class="nav-number">4.2.</span> <span class="nav-text">Serial number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#confirmation-number"><span class="nav-number">4.3.</span> <span class="nav-text">Confirmation number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-offset"><span class="nav-number">4.4.</span> <span class="nav-text">Data Offset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reserved"><span class="nav-number">4.5.</span> <span class="nav-text">Reserved</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emergency-urg-urgent"><span class="nav-number">4.6.</span> <span class="nav-text">Emergency URG (URGent)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#confirm-ack"><span class="nav-number">4.7.</span> <span class="nav-text">Confirm ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forwarding-psh-push"><span class="nav-number">4.8.</span> <span class="nav-text">Forwarding PSH (PuSH)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reset-rst"><span class="nav-number">4.9.</span> <span class="nav-text">Reset RST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-syn"><span class="nav-number">4.10.</span> <span class="nav-text">Synchronized SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#terminate-fin"><span class="nav-number">4.11.</span> <span class="nav-text">Terminate FIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#window"><span class="nav-number">4.12.</span> <span class="nav-text">Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test-and"><span class="nav-number">4.13.</span> <span class="nav-text">Test and</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emergency-pointer"><span class="nav-number">4.14.</span> <span class="nav-text">Emergency pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#options"><span class="nav-number">4.15.</span> <span class="nav-text">Options</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#principle-of-tcp-reliable-transmission"><span class="nav-number">5.</span> <span class="nav-text">Principle of TCP reliable transmission</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sliding-window-in-bytes"><span class="nav-number">5.1.</span> <span class="nav-text">Sliding window in bytes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cache"><span class="nav-number">5.1.1.</span> <span class="nav-text">cache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selection-of-timeout-retransmission-time"><span class="nav-number">5.2.</span> <span class="nav-text">Selection of timeout retransmission time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-to-confirm-sack"><span class="nav-number">5.3.</span> <span class="nav-text">Select to confirm SACK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-traffic-control"><span class="nav-number">6.</span> <span class="nav-text">TCP Traffic Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#timing-of-sending-tcp-message-segments"><span class="nav-number">6.1.</span> <span class="nav-text">Timing of sending TCP message segments</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#congestion-control"><span class="nav-number">7.</span> <span class="nav-text">Congestion Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#principle"><span class="nav-number">7.1.</span> <span class="nav-text">Principle</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-connection-management"><span class="nav-number">8.</span> <span class="nav-text">TCP connection management</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-connection-establishment-three-handshakes"><span class="nav-number">8.1.</span> <span class="nav-text">TCP connection establishment (three handshakes)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-connection-release-four-waves"><span class="nav-number">8.2.</span> <span class="nav-text">TCP connection release (four waves)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcps-finite-state-machine"><span class="nav-number">9.</span> <span class="nav-text">TCP’s finite state machine</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/posts/4f2bae2e/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Introduction to TCP Protocol | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Introduction to TCP Protocol</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-04-18 08:15:46" itemprop="dateCreated datePublished" datetime="2020-04-18T08:15:46+08:00">2020-04-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2025-09-30 11:27:56" itemprop="dateModified" datetime="2025-09-30T11:27:56+08:00">2025-09-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/posts/4f2bae2e/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/posts/4f2bae2e/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="features"><a class="markdownIt-Anchor" href="#features"></a> Features</h2><ul><li>TCP is a <strong>connection-oriented</strong> transport layer protocol. That is, a TCP connection must be established before an application can use it. After the data is transferred, the TCP connection must be released.</li><li>Each TCP connection can only have two endpoints, and each TCP connection is <strong>point-to-point</strong>.</li><li>TCP provides <strong>reliable delivery service</strong>, which means that data is error-free, not lost, not duplicated, and arrives in order.</li><li>TCP provides <strong>full-duplex communication</strong>, allowing both sides of the communication to send data at any time.** Both sides of TCP have a send cache and a receive cache**, which are used to temporarily store data for both sides of the communication.</li><li><strong>Byte-stream-oriented</strong> The term <strong>&quot;stream &quot;</strong> in TCP refers to the sequence of bytes** flowing into and out of a process. Byte-stream oriented means that although the application and TCP interact one block at a time, TCP sees the data handed off by the application as just a sequence of <strong>unstructured byte streams</strong>. TCP does not know the meaning of the byte stream being transmitted, nor does it guarantee that the size of the block received by the receiver corresponds to the size of the block sent by the sender. It is possible to send and send 10 blocks of data to the upper layer and have it organized into 4 blocks on the receiving side.</li></ul><span id="more"></span><p>TCP and udp use a completely different approach when sending messages. TCP does not care how long messages are sent by the application process to the cache of the TCP connection at a time, but decides how many bytes each message should contain based on the window value given by the other side and the current network congestion (the message length of UDP is given by the application process, and the messages given by the application process, UDP just (simply add the header and pass it to the next layer).</p><p>My current understanding is that <strong>after the upper layer deposits the byte stream into the cache in multiple blocks of different sizes, TCP will re-cut the byte stream to send messages based on window values, congestion conditions, etc., just to ensure that all bytes eventually arrive in order</strong>.</p><h2 id="what-is-a-tcp-connection"><a class="markdownIt-Anchor" href="#what-is-a-tcp-connection"></a> What is a TCP connection</h2><p>TCP uses connections as the most basic abstraction, and many of TCP’s features are built on this connection-oriented foundation, so we need to figure out what a TCP connection really is.</p><p>Each TCP connection has two endpoints, also called sockets or sockets, which are actually port numbers spliced together behind an IP address; the endpoint of a TCP connection is a very abstract socket, and the same IP address can have multiple different TCP connections, while the same port number can appear in multiple different TCP connections. A socket-based abstraction.</p><p>My current understanding of why TCP is connection-oriented is this:** A TCP connection requires a port on both sides of the connection, and during that time, the data transmitted on that port belongs only to the TCP connection, so it is like a link for both sides, but it does not mean that all routers between TCP connections have to do anything special for that connection. **</p><p><strong>When you read the following content, if you have the question: What makes TCP designed this way to achieve this effect, think about its connection-oriented feature</strong>.</p><h2 id="principle-of-reliable-transmission"><a class="markdownIt-Anchor" href="#principle-of-reliable-transmission"></a> Principle of reliable transmission</h2><p>The network beneath the TCP protocol provides unreliable transport, so TCP must take steps to remedy some of the surprises and make transport between transport layers reliable.</p><h3 id="stop-waiting-protocol"><a class="markdownIt-Anchor" href="#stop-waiting-protocol"></a> Stop waiting protocol</h3><p>The Stop and Wait protocol is very simple.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200418085415_bobkzr.jpg" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/微信图片编辑_20200418085415_bobkzr.jpg"></p><ul><li><p>A pauses after sending packet M1 and waits for an acknowledgement from B. B sends an acknowledgement to A when it receives M1, and A continues with the next packet M2 after receiving an acknowledgement for M1.</p></li><li><p><strong>There is an error</strong>. B detects an error when it receives M1 and simply discards M1** and then does nothing**. A assumes that the packet just sent is lost as long as no acknowledgement is received for a period of time, and thus retransmits the packet sent earlier. This is called a <strong>timeout retransmission</strong>. To implement timeout retransmission, you must set a <strong>timeout timer</strong> for each completed packet sent, and if an acknowledgement is received before the timer expires, the timer is revoked. There are three points to note here:</p><ul><li>A After a group is sent, a copy of the sent group must <strong>be temporarily stored</strong> until an acknowledgement is received before it can be deleted.</li><li>Both the subgroup and the acknowledgement subgroup must be set up with numbers so that we know which subgroup received the acknowledgement and which did not.</li><li>The timeout timer is set for a <strong>retransmission time that should be slightly longer than the average round trip time of the data during packet transmission</strong>.</li></ul></li><li><p><strong>Lost acknowledgement and late</strong>. If the acknowledgement to M1 sent by B is lost and A does not receive an acknowledgement within the set timeout period, there is no way to know if the packet it sent was in error, lost, or if the acknowledgement sent by B was lost, so after the timeout timer expires A has to retransmit M1, assuming that B receives M1 once again, and takes two actions:</p><ul><li>This duplicate packet M1 is discarded and not delivered to the upper layer.</li><li>Send the delivery confirmation to A again, and you cannot assume that a confirmation that has already been sent will not be sent again.</li></ul></li><li><p>Channel Utilization. The advantage of the stop-wait protocol is its simplicity, but the disadvantage is that the channel utilization is too low</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587195669/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418154042_tktoqj.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587195669/computer_network/微信截图_20200418154042_tktoqj.png"></p><p>Assume that the time required for A to send the packet is TD, which is obviously equal to the packet length divided by the data rate. Further assume that the processing time is negligible after the packet arrives correctly at B, while the acknowledgement is sent immediately. Assume that B takes time TA to send the acknowledgment packet. if A also takes negligible time to process the acknowledgment packet, then A can send the next packet only after time (TD + RTT + TA) has elapsed. Since only useful data is used for transmission within TD, the channel utilization U can be expressed as</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">U = \frac{T_D}{T_D + RTT + T_A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-.8360000000000001em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em"><span style="top:-2.3139999999999996em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.8360000000000001em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>To improve transmission efficiency, instead of using the inefficient stop-and-wait protocol, the sender can use pipelined transmissions. Pipelining means that the sender can send multiple packets in succession without having to stop after each packet to wait for an acknowledgement from the other side.</p><p>When using pipelined transfers, continuous <strong>ARQ protocol</strong> and <strong>sliding window protocol</strong> are used.</p></li></ul><h3 id="continuous-arq-protocol"><a class="markdownIt-Anchor" href="#continuous-arq-protocol"></a> Continuous ARQ protocol</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587196595/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418155614_iod7dv.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587196595/computer_network/微信截图_20200418155614_iod7dv.png"></p><p>The above figure indicates the sending window maintained by the sender, which means that all 5 packets located in the sending window can be sent out consecutively without waiting for an acknowledgement from the other party.</p><p>When discussing the sliding window, we should note that there is also a time coordinate in the graph. By convention, forward refers to the direction of increasing time, while backward refers to the direction of decreasing time. Grouped sends are sent from the smallest to the largest group number.</p><p>The continuous ARQ protocol specifies that the sender slides the sending window forward one packet position for each acknowledgment received.</p><p>The receiver generally adopts the <strong>cumulative acknowledgement</strong> method, which means that instead of sending an acknowledgement for each packet received, the receiver receives several packets and <strong>sends an acknowledgement</strong> for the last packet that arrives in order.</p><h2 id="tcp-message-segment-header"><a class="markdownIt-Anchor" href="#tcp-message-segment-header"></a> TCP message segment header</h2><p>Although TCP is byte-stream oriented, the data unit transmitted by TCP is the message segment. A TCP message segment is divided into two parts, the header and the data, and the entire function of TCP is reflected in the role of the fields in the header. Therefore, only by mastering the role of each field in the TCP header can you master the working principle of TCP.</p><p>The first 20 bytes of the TCP header are fixed, and the next 4n bytes are options to be added as needed.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587197557/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418161217_djnuqg.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587197557/computer_network/微信截图_20200418161217_djnuqg.png"></p><h3 id="source-and-destination-ports"><a class="markdownIt-Anchor" href="#source-and-destination-ports"></a> Source and destination ports</h3><p>Each takes up two bytes and writes the far port number and the destination port number, respectively.</p><h3 id="serial-number"><a class="markdownIt-Anchor" href="#serial-number"></a> Serial number</h3><p>It takes up four bytes, and the range of serial number is [0, 2^32 - 1], and after the serial number increases to the maximum, it is using the modulo operation.</p><p>Each byte in a stream of bytes transferred in a TCP connection is numbered sequentially. The starting serial number of the entire stream of bytes to be transmitted must be set at connection establishment. The sequence number field in the header refers to the first byte sequence number of the data sent in this message segment.</p><h3 id="confirmation-number"><a class="markdownIt-Anchor" href="#confirmation-number"></a> Confirmation number</h3><p>It takes up four bytes and is the <strong>sequence number</strong> of the first data byte of the next message segment expected to be received from the other party. For example, B correctly receives a message segment from A with a sequence number field value of 501 and a data length of 200 bytes, which indicates that B correctly receives the data sent by A up to sequence number 700. Therefore, B expects A’s next data number to be 701, so B sets the acknowledgement number to 701 in the acknowledgement message segment sent to A. In summary, <strong>if the acknowledgment number equals N, then all data up to serial number N-1 has been received correctly</strong>.</p><p>In general, it can be ensured that when the serial number is reused, the data of the old serial number has already reached the end point through the network.</p><h3 id="data-offset"><a class="markdownIt-Anchor" href="#data-offset"></a> Data Offset</h3><p>Occupying 4 bits, it indicates the TCP message segment header length. The data offset is necessary because there are also option fields of indeterminate length in the header. This field unit is <strong>32 bits (4 bytes)</strong>. Since the maximum number of 4-bit binary numbers that can be expressed is 15, the maximum data offset is 60 bytes.</p><h3 id="reserved"><a class="markdownIt-Anchor" href="#reserved"></a> Reserved</h3><p>Occupies 6 bits, reserved for future use, currently set to 0</p><h3 id="emergency-urg-urgent"><a class="markdownIt-Anchor" href="#emergency-urg-urgent"></a> Emergency URG (URGent)</h3><p>When URG is 1, it indicates that the urgent pointer field is valid, which tells the system that there is urgent data in this message and should be transmitted as soon as possible instead of following the original queue book order. For example, if the user issues Ctrl + C from the keyboard when a remote control program is running and needs to be interrupted, these two characters will be stored at the end of the receiving TCP cache if no urgent data is used. Only after all the data has been processed are these two characters given to the receiving application.</p><p>When URG is set to 1, the sending application process tells the sender’s TCP that it has urgent data to send, so TCP inserts the urgent data at the top of the data in this message segment, which is then paired with another prefix field <strong>The urgent pointer field indicates the length of the urgent data, and then the rest of the data remains as normal data</strong>.</p><h3 id="confirm-ack"><a class="markdownIt-Anchor" href="#confirm-ack"></a> Confirm ACK</h3><p>The acknowledgement number field is valid only when ACK = 1, and invalid when ACK = 0. <strong>TCP specifies that all messages transmitted after the connection is established must have ACK set to 1</strong></p><h3 id="forwarding-psh-push"><a class="markdownIt-Anchor" href="#forwarding-psh-push"></a> Forwarding PSH (PuSH)</h3><p>When two application processes communicate interactively, sometimes the application process at one end wants to receive a response from the other immediately after adding a command, and this is when a push operation can be used. In this case, the sender sets PSH to 1 and immediately creates a message segment to send out, and the receiver receives the message with PSH of 1 and hands it to the receiving process as soon as possible, instead of waiting for the cache to fill up before delivering it together.</p><h3 id="reset-rst"><a class="markdownIt-Anchor" href="#reset-rst"></a> Reset RST</h3><p>When a major error occurs, the connection must be released and a new one established. Or it can be used to reject an illegal message or refuse to open a connection.</p><h3 id="synchronized-syn"><a class="markdownIt-Anchor" href="#synchronized-syn"></a> Synchronized SYN</h3><p>When SYN = 1 and ACK = 0, this is a connection request message, and if the other party agrees to establish a connection, SYN = 1 and ACK = 1 are used in the response message. Therefore, a SYN of 1 indicates that this is a <strong>connection request or a connection establishment message</strong>.</p><h3 id="terminate-fin"><a class="markdownIt-Anchor" href="#terminate-fin"></a> Terminate FIN</h3><p>Used to release a connection. When FIN = 1, it indicates that the sender data for this message segment should have been sent and requests the release of the transport connection.</p><p>**That means that in theory, the TCP connection will not be broken without sending a message with this field of 1. **</p><h3 id="window"><a class="markdownIt-Anchor" href="#window"></a> Window</h3><p>Occupies 2 bytes and the window value is an integer between [0, 2^16 - 1]. The window value is the receive window of the party sending this message segment. The window value tells the other party: <strong>The amount of data (in bytes) that the receiver is currently allowing the other party to send, counting from the acknowledgement number at the beginning of this message segment</strong> The window value is used as a basis for the receiver to allow the sender to set its send window.</p><p>The window field specifies the amount of data the other party is allowed to send now, and the window value changes frequently.</p><h3 id="test-and"><a class="markdownIt-Anchor" href="#test-and"></a> Test and</h3><p>Occupies 2 bytes, the test and field test range includes the first part and data two parts. How to calculate the specific is more complex, interested in their own search</p><h3 id="emergency-pointer"><a class="markdownIt-Anchor" href="#emergency-pointer"></a> Emergency pointer</h3><p>Occupies 2 bytes, meaningful only when URG = 1, indicates the length of the urgent data in this message segment, ** when all urgent data are processed, normal operation will resume for the next normal data in this message segment**.</p><h3 id="options"><a class="markdownIt-Anchor" href="#options"></a> Options</h3><p>Variable length, up to 40 bytes, when no option is used, the length of the first part is 20 bytes.</p><p>Initially, only the <strong>MSS (Maximum Segment Size)</strong> was specified. The MSS should be as large as possible, as long as the IP layer is transmitted without further fragmentation, but of course, because the path experienced by the IP layer is dynamically changing, this MSS is also very difficult to determine.</p><p>During connection establishment, both parties can write their supported MSS into this field and later transmit according to this field, both transmission directions can have different size MSS. if the host does not fill in this field, the default is 536 and all Internet hosts should be able to accept an MSS of 536 + 20 (fixed prefix length) = 556 bytes.</p><h2 id="principle-of-tcp-reliable-transmission"><a class="markdownIt-Anchor" href="#principle-of-tcp-reliable-transmission"></a> Principle of TCP reliable transmission</h2><h3 id="sliding-window-in-bytes"><a class="markdownIt-Anchor" href="#sliding-window-in-bytes"></a> Sliding window in bytes</h3><p>TCP’s sliding window is all in bytes. Suppose A receives an acknowledgement message segment from B, where the window value is 20 and the acknowledgement number is 31 (this indicates that the next sequence number B expects to receive is 31, and the data up to sequence number 30 has already been received). Based on these two pieces of data, A constructs its own send window.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587202028/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418172540_by140j.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587202028/computer_network/微信截图_20200418172540_by140j.png"></p><blockquote><p>There may be some people here who are suddenly a bit confused as I am. If you have to wait for B to return an acknowledgement of A each time before you can change the window position and size and then send the window data out, what is the difference between that and the stop-wait protocol? The difference I can see so far is that the window size may be much larger than the MSS, requiring multiple groupings to be sent out, and each acknowledgement does not mean that the entire window is acknowledged.</p></blockquote><p>For A’s send window, A can send all the data in the window continuously until an acknowledgement is received from B. Any data that has been sent must be temporarily stored until an acknowledgement is received, for use in timeout retransmissions.</p><p>The serial number inside the send window indicates the number of allowed sends. Obviously, the larger the window is, the more data the sender can send in succession before receiving an acknowledgement from the other party, thus obtaining higher data transmission efficiency.</p><p>The back part of the trailing edge of the send window means that the data has been sent and an acknowledgement has been received, and this data obviously does not need to be kept any longer. The leading part of the leading edge means that the sending is not allowed because the receiver has not reserved cache space for temporary storage of this data.</p><p>The position of the sending window is determined by both the leading edge and the trailing edge. There are two cases of changes in the trailing edge, i.e. not moving (no new acknowledgement received), and moving forward (new acknowledgement received). It is not possible for the trailing edge to move backward, because it is not possible to revoke an acknowledgement already received. The leading edge can keep moving forward, or it can be immobile. There are two cases of immobility, one is that no new confirmation is received, and the size of the window of more notifications is also unchanged, and the second is that a new confirmation is received, but the window of the other notification shrinks, which just makes the leading edge immobile. Of course the frontier can also shrink backward, but <strong>TCP standard strongly discourages doing so</strong>.</p><p>Now suppose A sends the data of serial numbers 31-41, the position of the sending window does not change at this time, the 11 bytes behind the window means that the acknowledgement has been sent but not received, and the 9 bytes in front means that the sending is allowed but not yet sent.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587203074/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418174406_itnljo.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587203074/computer_network/微信截图_20200418174406_itnljo.png"></p><p>As can be seen from the above figure, to describe the state of a send window requires three pointers, P1,P2,P3, less than P1 is the part that has been sent and received, and greater than P3 is the part that is not allowed to be sent.</p><p>The size of B’s receive window is 20. Outside the receive window, all data up to 30 has been acknowledged as sent and delivered to the host, so B can no longer retain this data. 31-50 is allowed to be received.</p><p>In the above diagram <strong>32,33 has been received by B, but not in order, because 31 has not been received, at this time B can only give an acknowledgement to the highest order number received in order, which means that the acknowledgement number in the message returned by B now is still 31</strong>.</p><p>If B receives number 31 and delivers 31-33 to the host, B deletes these data and moves the receive window forward by three serial numbers while sending an acknowledgement to A. The window value is 20 and the acknowledgement number is 34. After A receives it, P1,P3 move forward by three serial numbers and P2 remains unchanged.</p><p>Next, if A sends 42-53, ** pointers P2 and P3 overlap, the data in the window is sent, and no further acknowledgement is received, you need to stop sending**.</p><h4 id="cache"><a class="markdownIt-Anchor" href="#cache"></a> cache</h4><p>The sender’s application process writes the byte stream to TCP’s send cache, and the receiver’s application reads the byte stream from TCP’s receive cache</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587209077/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418192408_lz3rfp.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587209077/computer_network/微信截图_20200418192408_lz3rfp.png"></p><p>To be clear: both cache space and serial numbers are limited and recycled.</p><p>The send cache is used to temporarily store:</p><ul><li>The sending application transmits to the sender the data that TCP is ready to send.</li><li>The part of TCP that has been sent but not yet acknowledged.</li></ul><p><strong>The send window is usually only part of the send cache and the acknowledged data should be removed from the send cache, so the trailing edges of the send cache and the send window are coincident</strong>. The last byte written to the send cache by the sending application minus the last byte acknowledged is the number of bytes still remaining in the send cache to be written.</p><p>The receive cache is used to temporarily store:</p><ul><li>Sequentially arriving data that has not yet been read by the receiving application</li><li>Data that did not arrive in order.</li></ul><p>If the application does not have time to read the received data, the receive cache will eventually fill up and the receive window will be reduced to 0.</p><p>Three additional points** are emphasized here**:</p><ul><li>Although A’s send window is set according to B’s receive window, <strong>at the same time, the size of A’s send window is not the same size as B’s receive window</strong>. Because there is a delay in the transmission of the network, and A’s sending window is also limited by the network congestion, when congestion occurs, the value of its own sending window should be reduced appropriately.</li><li>For data that arrives out of order, TCP usually stores the data that arrives out of order** in a cache** first, and then delivers it to the upper layer application process** in order when the missing bytes are received in the byte stream**.</li><li>TCP requires the receiver to have cumulative acknowledgements. The receiver can send an acknowledgement when appropriate or piggyback the acknowledgement when it has data to send itself, but the acknowledgement should be delayed no more than 0.5 seconds.</li></ul><h3 id="selection-of-timeout-retransmission-time"><a class="markdownIt-Anchor" href="#selection-of-timeout-retransmission-time"></a> Selection of timeout retransmission time</h3><p>TCP’s timeout retransmission time uses an adaptive algorithm. It records the time when a message segment is sent and the time when the corresponding acknowledgement is received. The difference between these two times is the message segment round-trip time RTT, and TCP keeps a weighted average round-trip time RTT<sub>s</sub> , also known as <strong>smoothed round-trip time</strong>.</p><p>When the RTT sample is measured for the first time, the RTT<sub>s</sub> takes the value of the RTT sample value and is recalculated every time the RTT is received next:</p><p><u>New RTT<sub>s</sub> = (1 - α)* (old RTT<sub>s</sub>) + α * new RTT samples</u></p><p>where the alpha is recommended to be 0.125</p><p>Obviously the timeout retransmission time RTO (RetransmissionTime-Out) should be slightly greater than RTT<sub>s</sub>.</p><p><u>RTO = RTT<sub>s</sub> + 4 * RTT<sub>D</sub></u></p><p>RTT<sub>D</sub> is the weighted average of the deviations from RTT<sub>s</sub>. For the first measurement, RTT<sub>D</sub> takes the value of half of RTT, and the following algorithm is used next:</p><p><u>New RTT<sub>D</sub> = (1 - β)*(old RTT<sub>D</sub>) + β * |RTT<sub>s</sub> - new RTT samples|</u></p><p>The recommended value of β is 0.25</p><p>Now there is a problem, when the set retransmission time is up, still no acknowledgement is received, so the message is retransmitted and after some time an acknowledgement is received, ** how to confirm whether this acknowledgement is for the previously sent message or for the retransmitted message? **, this has a big impact on the RTT<sub>s</sub> calculation.</p><p>For this case, the current approach is to increase the RTO to twice as much for each retransmission of the message</p><h3 id="select-to-confirm-sack"><a class="markdownIt-Anchor" href="#select-to-confirm-sack"></a> Select to confirm SACK</h3><p>If there is no error in the received message segment, but it just <strong>didn’t arrive in order</strong>, and there is some serial number data missing in the middle, **can we find a way to transmit only the missing data and not the data that has been received correctly? **</p><p>The answer is yes, it is SACK, and here is just a brief explanation of the principle.</p><p>Suppose the received message sequence number is 1 - 1000,1501 - 3000,3501 - 4500, the middle is missing two parts, if **these bytes of the sequence number are within the reception window **, then first these data received, but to find a way to notify the sending send I have received.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211176/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418195848_xt17r1.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211176/computer_network/微信截图_20200418195848_xt17r1.png"></p><p>From the above figure we can see that every byte block that is not contiguous with the preceding and following bytes has two boundaries, and the figure uses L1, R1, L2,R2 to represent these four boundaries</p><p>We know that the TCP header does not have a field that can be populated with such boundary values.</p><p>If you want to use SACK you have to add <strong>allow SACK option</strong> to the header during the TCP establishment phase. If you confirm the use, the original usage of the acknowledgement number field remains the same, only the SACK option is added to the options. However, a maximum of 4 bytes of information is specified in the option, because the serial number has 32 bits and requires four bytes, a byte block requires two serial numbers and 8 bytes, while two bytes are required to specify which are SACK options, 4 byte blocks will use up 34 bytes, and the maximum option is 40 bytes, so adding another byte block will exceed it.</p><h2 id="tcp-traffic-control"><a class="markdownIt-Anchor" href="#tcp-traffic-control"></a> TCP Traffic Control</h2><p>So-called flow control is to keep the sender from sending too fast and the receiver from receiving in time.</p><p>Traffic control on the sender side can be easily implemented using sliding windows.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211807/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418200900_kruofd.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211807/computer_network/微信截图_20200418200900_kruofd.png"></p><p>The flow of the above diagram can be summarized as follows</p><ul><li>When the connection is established, B tells A: My receive window is rwnd = 400, so <strong>the sender’s send window cannot exceed the receive window given by the receiver</strong>. Note that the TCP window unit is bytes and not message segments.</li><li>Let the length of each message segment be 100 bytes, the initial sequence number be 1, ACK is the acknowledgement bit, and ack is the acknowledgement number.</li><li>B performed three flow controls, the first reducing rwnd to 300, the second to 100, and finally to 0.</li></ul><p>Think about a problem. If A sends a zero-window message segment shortly after B has space in its receive cache again and sends rwnd = 400 to A, but this message is lost, A keeps waiting for B to send a non-zero-window notification, and B keeps waiting for A’s data, a deadlock is created.</p><p>To solve this problem, TCP sets a persistent timer for each connection, and whenever the TCP side receives a zero-window notification, it turns on the timer, sends a probe message when it does, and breaks the deadlock if the result returned is not zero.</p><h3 id="timing-of-sending-tcp-message-segments"><a class="markdownIt-Anchor" href="#timing-of-sending-tcp-message-segments"></a> Timing of sending TCP message segments</h3><p>The application process will transfer the data to the TCP send cache and leave the rest of the task to TCP. Different mechanisms can be used to control the timing of sending TCP message segments.</p><ul><li>The first one is to use MSS to encapsulate the data stored in the cache into a message segment and send it out as soon as the MSS is reached.</li><li>The second is the application specifying the send, such as PSH operations</li><li>The third is for the sender to set a timer and send the data in the cache packaged when the time comes.</li></ul><h2 id="congestion-control"><a class="markdownIt-Anchor" href="#congestion-control"></a> Congestion Control</h2><p>In computer networks, link capacity, caches and processors in switching nodes are resources of the network. When the demand for a resource in the network exceeds the available portion of that resource, the network performance has to change, and this situation is called congestion.</p><p><strong>Congestion control is about preventing too much data from being injected into the network, which keeps the routers or links in the network from being overloaded</strong>.</p><p><strong>Congestion control is a global process</strong> that involves all hosts, routers and all factors related to degrading network transmission performance, while <strong>Traffic control</strong> often refers to the control of point-to-point traffic and is an <strong>end-to-end problem</strong>.</p><p>There are four congestion control algorithms for TCP, the very familiar <strong>slow start, congestion avoidance, fast retransmission, and fast recovery</strong>.</p><p>The sender maintains a value called the congestion window cwnd. The size of the congestion window depends on the congestion level of the network and is dynamically changing. The <strong>sender makes its sending window equal to the congestion window</strong>.</p><p>The principle of cwnd control on the sender side is to expand cwnd a bit as long as there is no congestion, and to reduce cwnd as long as there is congestion or the possibility of congestion, and <strong>the basis for determining that the network is congested is that there is a timeout</strong>.</p><h3 id="principle"><a class="markdownIt-Anchor" href="#principle"></a> Principle</h3><p>We also use this classic diagram to illustrate:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587214008/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418204614_kprnwt.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587214008/computer_network/微信截图_20200418204614_kprnwt.png"></p><p>**The idea of <strong>slow start</strong> is this: when the host starts to send data, it is not clear about the load of the network, and if a large amount of data is injected into the network immediately, congestion may occur, so it increases the cwnd from small to large.</p><ul><li><p>When the messages are first sent, the congestion window cwnd is first set to 2 to 4 sender maximum message segments SMSS.</p></li><li><p>If no acknowledgement is received, cwnd is increased by up to one SMSS.</p><p>cwnd per increment = min(N, SMSS), N is the number of bytes of messages that were originally unacknowledged and just received in the acknowledgment segment of the acknowledgment message.</p></li></ul><p>We use the following example to illustrate the principle of slow start. For the sake of illustration , we use the number of message segments as the unit of cwnd, which should actually be the number of bytes.</p><ul><li><p>At the beginning, the sender sets cwnd to 1, sends the first message M1, and the receiver receives M1 and returns an acknowledgement. After the sender receives an acknowledgement from M1, it increases cwnd from 1 to 2. Then it sends M2 and M3, and after receiving an acknowledgement from both, cwnd increases from 2 to 4, which means that the slow start algorithm, <strong>with each transmission round elapsed, cwnd doubles</strong>. The elapsed time of one transmission round is actually an RTT</p></li><li><p>To prevent cwnd from growing too fast, a <strong>slow start threshold ssthresh</strong> also needs to be set.</p><ul><li>When cwnd &lt; ssthresh, the slow start algorithm is used.</li><li>When cwnd &gt; ssthresh, use congestion avoidance algorithm</li><li>Both are possible when cwnd = ssthresh.</li></ul><p>The idea of congestion avoidance is to make cwnd grow slower and let cwnd add 1 for every RTT passed. when cwnd grows to ssthresh (point 1 in the figure) change to congestion control algorithm from slow start.</p></li><li><p>After a timeout (point 2 in the figure), the sender determines that the network is congested and adjusts ssthresh = cwnd / 2, cwnd = 1 to re-enter the slow start.</p></li><li><p>Sometimes the sender receives three ACKs in a row (point 4 in the figure). This occurs because it is thought that sometimes, individual message segments are lost in the network, when in fact the network is not congested, and if the sender is late in receiving an acknowledgement, a timeout is generated and it is thought that congestion has occurred, which can lead to a false start of slow start by the sender. The use of the <strong>fast retransmission algorithm allows the sender to know early that individual messages are lost</strong>.</p><p>The fast retransmission algorithm requires the receiver not to wait for its own data to be sent before waiting for an acknowledgement, but to <strong>send an acknowledgement immediately</strong>. Repeat acknowledgements of received messages are sent immediately even if out-of-sequence messages are received. Suppose the receiver receives M1 and M2 and acknowledges them in time, now suppose the receiver does not receive M3 but receives M4, the receiver cumulatively confirms that it can only send an acknowledgement of M2, and then receives M5 and M6, and retransmits two more acknowledgements of M2 respectively, the sender receives a total of four acknowledgements of M2, three of which are duplicates, and knows that the receiver should initiate an immediate retransmission.</p></li><li><p>At point 4 in the figure, the sender, knowing that only individual segments of the message are lost, does not perform a slow start but a fast recovery with ssthresh = cwnd / 2, cwnd = ssthresh.</p></li></ul><p>The above process can constantly adjust the size of cwnd, thus the size of the send window will be controlled by the level of congestion, but in reality the receiver has limited cache space, the receiver sets rwnd (receiver window, aka notification window) according to its receiving capability and writes this value into the window field in the TCP header, from the receiver’s point of view, the sender’s send window cannot exceed rwnd, so <strong>the upper limit of the sender’s sending window should be the smallest of rwnd and cwnd</strong>.</p><h2 id="tcp-connection-management"><a class="markdownIt-Anchor" href="#tcp-connection-management"></a> TCP connection management</h2><p>We’ve said from the beginning that TCP is connection-oriented, and much of its design is based on that premise to function properly, so how does TCP establish and maintain that connection?</p><p>There are three problems to be solved during the establishment of a TCP connection:</p><ul><li>To enable each party to confirm the presence of the other</li><li>To allow both parties to agree on some values, such as the maximum window value</li><li>Ability to allocate resources to the most transportable entities.</li></ul><h3 id="tcp-connection-establishment-three-handshakes"><a class="markdownIt-Anchor" href="#tcp-connection-establishment-three-handshakes"></a> TCP connection establishment (three handshakes)</h3><p>The process of establishing a TCP connection is called handshaking and requires the exchange of three TCP messages between the client and the server</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587215346/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418210855_mpcozg.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587215346/computer_network/微信截图_20200418210855_mpcozg.png"></p><ul><li>Initially both ends are closed, in the above diagram it is A that actively opens the connection and B that passively opens it.</li><li>At the beginning B’s TCP server creates the transport control block TCB, ready to accept connections from client processes, and then the server is in the LISTIN state.</li><li>A’s TCP client creates a TCB, and before establishing a connection, first sends a connection request message to B with synchronization bit SYN = 1, while selecting an initial sequence number seq = x. TCP specifies that SYN messages cannot carry data, but a sequence number is consumed and the TCP client enters the SYN-SENT state</li><li>After receiving the request message, B sends an acknowledgement to A if it agrees to establish a connection, sets both SYN and ACK to 1, ack to x + 1, and chooses an initial sequence number for itself seq = y. This message segment also cannot carry data, but consumes a sequence number.</li><li>The TCP client of A has to give an acknowledgement to B after receiving the acknowledgement from B. ACK is 1, ack = y + 1, seq = x + 1, and at this time, the ACK message segment can carry data. At this time, A has entered the ESTABLISHED state, and B has also entered the ESTABLISHED state after receiving the acknowledgement.</li></ul><p>The above process is called three handshakes, but the message segment sent by B to A can also be split into two message segments by sending an ACK = 1, ack = x + 1, and a synchronization message (SYN = 1, seq = y),** which becomes four handshakes. **</p><p><strong>So why does A send an acknowledgement at the end? The main reason is to prevent connection request messages that have failed from suddenly arriving at B again</strong>. This situation generally arises after the first connection request message sent by A timeout, A again sent a request, B received a second request to complete the establishment of the connection and send data, after releasing the connection after the first request again, this time if B did not receive a second confirmation from A, it will not care about the first request.</p><h3 id="tcp-connection-release-four-waves"><a class="markdownIt-Anchor" href="#tcp-connection-release-four-waves"></a> TCP connection release (four waves)</h3><p>The release process is similar to the build process, except that it is more complex and uses a header field of FIN</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587216170/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418212241_j13fkc.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587216170/computer_network/微信截图_20200418212241_j13fkc.png"></p><ul><li><p>A’s application process first sends a connection release message to its TCP and stops sending data, actively closing the TCP connection</p></li><li><p>A sets the first field of the connection release message, FIN, to 1, with the sequence number seq = u, which is equal to the sequence number of the last byte of all data transmitted before it plus 1. At this point, A enters the FIN-WAIT-1 (abort-wait-1) state.</p></li><li><p>B receives the connection release message and sends an acknowledgement, ack = u + 1, with its own ordinal number seq = v, equal to the ordinal number of the last byte of data transmitted by B plus 1, and then B enters the CLOSE-WAIT (closed and waiting) state. At this point TCP enters a <strong>semi-closed state</strong>, i.e. A has no more data to send, but if B wants to send data, A can accept it, i.e. the connection from <strong>B to A is not closed</strong>.</p></li><li><p>A receives an acknowledgment hand from B and enters the FIN-WAIT-2 state, waiting for a release message from B.</p></li><li><p>If B has no more data to send, its application process notifies TCP to release the connection, at which point B sends a FIN message, seq = w (assuming B has sent some data in the semi-closed state), and ack remains u + 1.</p></li><li><p>After A receives the connection release message, it must send an acknowledgement for it, ACK = 1, ack = w + 1, seq = u + 1, and then enters the TIME-WAIT state. After the time set by the Time-WAIT timer (TIME-WAIT timer) of 2MSL, A enters the CLOSED state, MSL is called Maximum MSL is called Maximum Segment Lifetime (MSL).</p><p>There are two reasons for waiting this amount of time:</p><ul><li>It is guaranteed that the last ACK message sent by A reaches B. This message may be lost, so B may retransmit the last FIN message, at which time it is necessary for A to retransmit an acknowledgement and then restart the 2MSL timer.</li><li>Preventing the above-mentioned failed connections by waiting for 2MSL ensures that all messages generated during the duration of this connection disappear from the network.</li><li>In addition to the time waiting timer, there is a keepalive timer, the server did not receive a client data, it will reset it, the time is two hours, if two hours did not receive data, it will send a probe message, every 75 seconds to send a, if there is no reply for 10 consecutive, then close the connection.</li></ul></li></ul><h2 id="tcps-finite-state-machine"><a class="markdownIt-Anchor" href="#tcps-finite-state-machine"></a> TCP’s finite state machine</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587217099/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418213810_lbd6iv.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587217099/computer_network/微信截图_20200418213810_lbd6iv.png"></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/posts/4f2bae2e/" title="Introduction to TCP Protocol">https://sunra.top/en/posts/4f2bae2e/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/posts/2b2971ba/" rel="prev" title="Development and Design of OAuth"><i class="fa fa-chevron-left"></i> Development and Design of OAuth</a></div><div class="post-nav-item"> <a href="/en/posts/51308784/" rel="next" title="Introduction to the HTTPS Protocol">Introduction to the HTTPS Protocol<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/posts/4f2bae2e/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>