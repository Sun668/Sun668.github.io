<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Why do we need a process?What is the process and what does it consist of?How does the process solve the problem?"><meta property="og:type" content="article"><meta property="og:title" content="Operating System Learning Notes (3) Process and Thread"><meta property="og:url" content="https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Why do we need a process?What is the process and what does it consist of?How does the process solve the problem?"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2021-10-14T00:02:47.000Z"><meta property="article:modified_time" content="2023-06-21T01:18:16.936Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/","path":"2021/10/14/operating-system-note-3-process-and-thread/","title":"Operating System Learning Notes (3) Process and Thread"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Operating System Learning Notes (3) Process and Thread | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Concept-and-characteristics-of-the-process"><span class="nav-number">1.</span> <span class="nav-text">Concept and characteristics of the process</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-concept"><span class="nav-number">1.1.</span> <span class="nav-text">Process concept</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Characteristics-of-the-process"><span class="nav-number">1.2.</span> <span class="nav-text">Characteristics of the process</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#State-and-transition-of-processes"><span class="nav-number">2.</span> <span class="nav-text">State and transition of processes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Organization-of-the-process"><span class="nav-number">3.</span> <span class="nav-text">Organization of the process</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-control-block"><span class="nav-number">3.1.</span> <span class="nav-text">Process control block</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Program-segment"><span class="nav-number">3.2.</span> <span class="nav-text">Program segment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-segment"><span class="nav-number">3.3.</span> <span class="nav-text">Data segment</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Process-control"><span class="nav-number">4.</span> <span class="nav-text">Process control</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Creation-of-a-process"><span class="nav-number">4.1.</span> <span class="nav-text">Creation of a process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Termination-of-the-process"><span class="nav-number">4.2.</span> <span class="nav-text">Termination of the process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-blocking-and-wakeup"><span class="nav-number">4.3.</span> <span class="nav-text">Process blocking and wakeup</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Process-communication"><span class="nav-number">5.</span> <span class="nav-text">Process communication</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shared-storage"><span class="nav-number">5.1.</span> <span class="nav-text">Shared storage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message-passing"><span class="nav-number">5.2.</span> <span class="nav-text">Message passing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline-shared-file-communication"><span class="nav-number">5.3.</span> <span class="nav-text">Pipeline (shared file) communication</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread-and-multithreaded-models"><span class="nav-number">6.</span> <span class="nav-text">Thread and multithreaded models</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-concepts-of-threads"><span class="nav-number">6.1.</span> <span class="nav-text">Basic concepts of threads</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparison-of-threads-and-processes"><span class="nav-number">6.2.</span> <span class="nav-text">Comparison of threads and processes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties-of-a-thread"><span class="nav-number">6.3.</span> <span class="nav-text">Properties of a thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-state-and-transitions"><span class="nav-number">6.4.</span> <span class="nav-text">Thread state and transitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-organization-and-control"><span class="nav-number">6.5.</span> <span class="nav-text">Thread organization and control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-control-block"><span class="nav-number">6.5.1.</span> <span class="nav-text">Thread control block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-creation"><span class="nav-number">6.5.2.</span> <span class="nav-text">Thread creation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Termination-of-thread"><span class="nav-number">6.5.3.</span> <span class="nav-text">Termination of thread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-implementation"><span class="nav-number">6.6.</span> <span class="nav-text">Thread implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#User-level-threads-coroutines"><span class="nav-number">6.6.1.</span> <span class="nav-text">User-level threads (coroutines)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel-level-threads"><span class="nav-number">6.6.2.</span> <span class="nav-text">Kernel level threads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combination-mode"><span class="nav-number">6.6.3.</span> <span class="nav-text">Combination mode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multithreaded-model"><span class="nav-number">6.7.</span> <span class="nav-text">Multithreaded model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Many-to-one-model"><span class="nav-number">6.7.1.</span> <span class="nav-text">Many-to-one model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#One-to-one-model"><span class="nav-number">6.7.2.</span> <span class="nav-text">One-to-one model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Many-to-many-model"><span class="nav-number">6.7.3.</span> <span class="nav-text">Many-to-many model</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">267</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Operating System Learning Notes (3) Process and Thread | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Operating System Learning Notes (3) Process and Thread</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-10-14 08:02:47" itemprop="dateCreated datePublished" datetime="2021-10-14T08:02:47+08:00">2021-10-14</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-06-21 09:18:16" itemprop="dateModified" datetime="2023-06-21T09:18:16+08:00">2023-06-21</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2021/10/14/operating-system-note-3-process-and-thread/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2021/10/14/operating-system-note-3-process-and-thread/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Why do we need a process?<br>What is the process and what does it consist of?<br>How does the process solve the problem?</p><span id="more"></span><h1 id="Concept-and-characteristics-of-the-process"><a href="#Concept-and-characteristics-of-the-process" class="headerlink" title="Concept and characteristics of the process"></a>Concept and characteristics of the process</h1><h2 id="Process-concept"><a href="#Process-concept" class="headerlink" title="Process concept"></a>Process concept</h2><p>In a multiprogram environment, allowing multiple programs to execute concurrently, they will lose their closeness and have the characteristics of intermittency and non-reproducibility.</p><p>To this end, the concept of process is introduced in order to better describe and control the execution of the program, and achieve the concurrency and sharing of the operating system (the two most basic characteristics).</p><p>In order for the program (including data) involved in concurrent execution to run independently, a special data structure must be configured for it, called the Process Control Block (PCB).</p><p>The system uses PCB to describe the basic situation and running state of the process, and then controls and manages the process.</p><p>Correspondingly, the process image (process entity) is composed of three parts: the program segment, the relevant data segment and the PCB.</p><p>The so-called creation process is actually the PCB that creates the process image, and the undo process is essentially the PCB that undoes the process.</p><p>It is worth noting that the process image is static, the process is dynamic, and the PCB is the only sign of the existence of the process.</p><p>From different perspectives, processes can have different definitions. A more typical definition is:<br>A process is an execution of a program.<br>A process is the activity that occurs when a program and its data are executed sequentially on a processor.</p><ul><li>A process is a process in which a program with independent functions runs on a data set. It is an independent unit of the system for quota and scheduling. (This requires an accurate understanding of system resources, which refer to the “time” of processors, memory, and other devices serving a process. For example, processor resources are accurately understood as processor time slices)</li></ul><h2 id="Characteristics-of-the-process"><a href="#Characteristics-of-the-process" class="headerlink" title="Characteristics of the process"></a>Characteristics of the process</h2><p>The process is proposed by the concurrent execution of multiple programs. It is two completely different concepts from the program. The basic characteristics of the process are proposed by comparing the sequential execution of a single program, which is also the most basic requirement for process management.</p><ul><li>Dynamics. A process is an execution of a program. It has processes such as creation, activity, suspension, and termination, and has a certain life cycle. Dynamics is the most basic feature of a process.</li><li>Concurrency. Multiple process entities exist in memory at the same time and can run simultaneously for a period of time. Concurrency is an important feature of processes and an important feature of operating systems. <strong>The purpose of introducing processes is to enable programs to execute concurrently with programs of other processes</strong> .</li><li>Independence. The process entity is a basic unit that can run independently, obtain resources independently and accept scheduling independently. <strong>Any program that has not established a PCB cannot participate in the operation as an independent unit</strong> .</li><li>Asynchronous. Due to the mutual restriction of processes, the process has intermittent execution, that is, the process advances at an unpredictable speed. Asynchrony will lead to the non-reproducibility of the execution result. For this reason, the operating system must configure the corresponding process synchronization mechanism.</li><li>Structural. Each process is configured with a PCB to describe it. From a structural point of view, the process entity is composed of program segments, related data segments, and PCBs.</li></ul><h1 id="State-and-transition-of-processes"><a href="#State-and-transition-of-processes" class="headerlink" title="State and transition of processes"></a>State and transition of processes</h1><p>During the life cycle of the process, due to the mutual restrictive relationship between the processes in the system and the changes in the operating environment of the system, the state of the process is also constantly changing (a process will experience several different states). Usually, the process has 5 states., the first three are the basic states of the process.</p><ol><li>Running state. The process is running on the processor. In a uniprocessor environment, at most one process is running at a time.</li><li>Ready state. The process has obtained all resources except the processor, and once it has obtained the processor, it can run immediately.</li><li>Blocked state. Also known as waiting state, the process is waiting for an event and pauses, such as waiting for a resource ( <strong>excluding the processor</strong> ) to be available or waiting for input and output to complete. Even if the processor is idle, the process cannot run.</li><li>Create state. The process is being created and has not yet been transferred to the ready state. The creation of a process usually requires multiple steps. First, apply for a blank PCB, and fill in some information about controlling and managing the process to the PCB; then the system allocates the necessary resources for the process to run, and finally changes the process to the ready state.</li><li>End state. The process is disappearing from the system, which may be due to the normal end of the process or an interruption for other reasons. When a process needs to end its operation, the system must first set the process to end state, and then further process resource release and recycling.</li></ol><p>Note the distinction between the ready state and the waiting state. The ready state refers to the lack of only a processor and can run immediately as long as the processor resources are obtained, while the waiting state refers to the process needing other resources or waiting for an event.<br>The reason for separating the processor from other resources is that in the time-slice rotation mechanism of the time-sharing system, each process is assigned a time slice of several milliseconds, that is, the process gets the processor time very short and very frequently., the process actually switches to the ready state frequently during operation.</p><h1 id="Organization-of-the-process"><a href="#Organization-of-the-process" class="headerlink" title="Organization of the process"></a>Organization of the process</h1><p>A process is an independent running unit and the basic unit for quota and scheduling in the operating system. It consists of the following three parts, the core of which is the Process Control Block (PCB).</p><h2 id="Process-control-block"><a href="#Process-control-block" class="headerlink" title="Process control block"></a>Process control block</h2><p>When the process is created, the operating system will create a PCB for it, which will then be resident in memory, can be accessed at any time, and deleted at the end of the process. The PCB is a part of the process entity and the only sign of the existence of the process.</p><p>When the process executes, the system knows its current status and priority through its PCB, so that the operating system can control and manage it.</p><ul><li>When scheduling a process, it is necessary to set the site where the process resumes operation according to the processor state information stored in its PCB, and find its program and data according to the memory address of the program and data in its PCB.</li><li>During the operation of the process, when it needs to synchronize, communicate or access files with the cooperating process, it also needs to access the PCB.</li><li>When the process is suspended for some reason, the processing and environment of its breakpoint need to be saved in the PCB</li></ul><p>The system always controls the process through the PCB, that is, the system can only perceive the existence of the process through the PCB of the process.</p><p>PCB mainly includes process description information, process control and management information, quota list and processor related information.</p><ul><li>Process description information. Process Identifier: Identifies each process, and each process has a unique identification number. User Identifier: The user to whom the process belongs. The process identifier is mainly used for sharing and protection services.</li><li>Process control and management information. Process current status: describes the status information of the process as the basis for processor scheduling. Process priority: describes the priority of the process to preempt the processor. Processes with higher priority can obtain the processor first.</li><li>quota list. Describes information about the memory address space or virtual address space, the list of files opened, or the device used.</li><li>Processor related information, also known as processor context, mainly refers to the values of each register in the processor. When a process is in the execution state, much of the processor’s information is in the registers. When a process is switched, the processor state information must be saved in the corresponding PCB so that when the process is re-executed, execution can continue from the breakpoint.</li></ul><p>There are linking methods and indexing methods for organizing PCBs. The linking method links PCBs in the same state into a queue, and different states correspond to different queues. The PCBs of processes in a blocking state can also be arranged into multiple blocking queues according to their blocking reasons. The indexing method organizes processes in the same state into an index table, and the entries in the index table point to the corresponding PCB.</p><h2 id="Program-segment"><a href="#Program-segment" class="headerlink" title="Program segment"></a>Program segment</h2><p>A program segment is a piece of program code that can be scheduled to be executed by the CPU by the process scheduler. Note that a program can be shared by multiple processes, that is, multiple processes can run the same program.</p><h2 id="Data-segment"><a href="#Data-segment" class="headerlink" title="Data segment"></a>Data segment</h2><p>The data segment of a process can be the original data source of the program processing corresponding to the process, or it can be the intermediate or final result generated when the program is executed.</p><h1 id="Process-control"><a href="#Process-control" class="headerlink" title="Process control"></a>Process control</h1><p>The main function of process control is to effectively manage all processes in the system. It has functions such as creating processes, canceling existing processes, and realizing process conversion.</p><p>In the operating system, the program segment used for process control is generally called primitive. The characteristic of primitive is that no interruption is allowed during execution, and it is an inseparable basic unit.</p><h2 id="Creation-of-a-process"><a href="#Creation-of-a-process" class="headerlink" title="Creation of a process"></a>Creation of a process</h2><p>Allows one process to create another process. At this time, the creator is also called the parent process, and the created process is called the child process. The child process can inherit the resources owned by the parent process. When the child process is revoked, the resources it obtained from the parent process should be returned to the parent process. In addition, when revoking the parent process, all its child processes are usually also revoked.<br>The process of creating a new process in the operating system is as follows (creation primitive):</p><ul><li>Assign a unique process identifier to the new process and apply for a blank PCB (PCB is limited). If the PCB application fails, the process creation fails.</li><li>Allocate the resources needed by the process to run, such as memory, files, I/O devices, etc. (reflected in the PCB). These resources are either obtained from the operating system or only obtained from the parent process. If there are insufficient resources, it is not a creation failure, but a creation state, waiting for resources.<br>Initialize the PCB, including initialization flag information, initialization processor status information, initialization processor control information, and setting process priority.</li><li>If the process Ready Queue can accommodate the new process, insert the new process into the Ready Queue and wait to be scheduled for execution.</li></ul><h2 id="Termination-of-the-process"><a href="#Termination-of-the-process" class="headerlink" title="Termination of the process"></a>Termination of the process</h2><p>The practices that cause the process to terminate mainly include: normal end, indicating that the task of the process has been completed and is ready to exit the operation; abnormal end, indicating that the process has encountered some kind of exception during operation, making the program unable to continue to run, such as storage area out of bounds, protection error, Illegal instruction, privileged instruction error, run timeout, arithmetic operation error, I/O failure, etc.; External intervention: refers to the process that stops running at the request of the outside world, such as operator or operating system intervention, parent process request, parent process termination Wait.<br>The termination primitive is as follows:</p><ul><li>According to the terminated process identifier, retrieve the PCB of the process and read the status of the process from it.</li><li>If the terminated process is in a running state, immediately terminate the execution of the process and give the processor quota to other processes.</li><li>If the process has a descendant process, its descendant process shall be terminated.</li><li>Return all resources owned by the process, either to its parent process or to the operating system.</li><li>Remove the PCB from the queue where it is located.</li></ul><h2 id="Process-blocking-and-wakeup"><a href="#Process-blocking-and-wakeup" class="headerlink" title="Process blocking and wakeup"></a>Process blocking and wakeup</h2><p>The process that is being executed, because some of the expected events do not occur, the process changes itself from the running state to the blocking state by calling the blocking primitive. It can be seen that when blocking, it is an active behavior of the process itself, and therefore only in the running state. The process may become blocked. The blocking primitive is as follows:</p><ul><li>Find the PCB of the process to be blocked</li><li>Protect its site, change its state to blocking state, stop operation</li><li>Insert the PCB into the waiting queue for the corresponding event, and schedule the processor resources to other ready processes.</li></ul><p>When the event expected by the blocked process occurs, the wake primitive is called by the process concerned.</p><ul><li>Find the corresponding PCB in the waiting queue for the event</li><li>Remove it from the waiting queue and set its status to ready state</li><li>Insert the PCB into the Ready Queue and wait for dispatch.<br>The blocking primitive and the wake primitive must appear in pairs. If a Block primitive is called in a process, a corresponding warkup primitive must be arranged in the cooperating or other related process.</li></ul><h1 id="Process-communication"><a href="#Process-communication" class="headerlink" title="Process communication"></a>Process communication</h1><p>Process communication refers to the exchange of information between processes. PV operations are low-level communication methods, and high-level communication methods refer to communication methods that transmit large amounts of data with high efficiency. There are three main types of high-level communication methods:</p><h2 id="Shared-storage"><a href="#Shared-storage" class="headerlink" title="Shared storage"></a>Shared storage</h2><p>There is a shared space that can be directly accessed between communicating processes. Information exchange between processes is achieved by reading and writing to this shared space.</p><p>Synchronous mutual exclusion tools (such as PV operations) are required when reading or writing to a shared space.</p><p>Shared storage is divided into two types. The sharing of low-level methods is based on the sharing of data structures; the sharing of high-level methods is based on the sharing of storage areas.</p><p>The operating system is only responsible for providing shared storage space and synchronous mutual exclusion tools for communication processes, and data exchange is completed by user-arranged read and write instructions.</p><h2 id="Message-passing"><a href="#Message-passing" class="headerlink" title="Message passing"></a>Message passing</h2><p>Data exchange between processes is based on formatted messages. If there is no shared space that can be directly accessed between the communicating processes, the message passing method provided by the operating system must be used to realize process communication.</p><p>Data is exchanged through two primitives provided by the system to send and receive messages.</p><p>This method hides the details of communication and is currently the most widely used Inter-Process Communication method. In the microkernel operating system, the communication between the microkernel and the server adopts message passing.</p><ol><li>Direct communication method, the sending process directly sends the message to the receiving process and hangs it on the message buffer queue of the receiving process. The receiving process retrieves messages from the message buffer queue.</li><li>Indirect communication method, the sending process sends the message to an intermediate entity, and the receiving process obtains the message from the intermediate entity, which is generally called “mailbox”.</li></ol><h2 id="Pipeline-shared-file-communication"><a href="#Pipeline-shared-file-communication" class="headerlink" title="Pipeline (shared file) communication"></a>Pipeline (shared file) communication</h2><p>The so-called pipe refers to a shared file used to connect a read process and a write process to achieve communication between them, also known as a pipe file.</p><p>The sending process that provides input to the pipeline sends a large amount of data into the write pipeline in the form of a character stream, while the receiving process that receives the output of the pipeline receives data from the pipeline. In order to coordinate communication between two parties, the pipe-to mechanism must provide the ability to coordinate the following three aspects: mutual exclusion, synchronization, and determination of each other’s existence.</p><p>In essence, a pipeline is also a type of file, but unlike ordinary files, pipelines can overcome two problems of using file communication.</p><ul><li>Limit pipe size. In practice, a pipe is a fixed-size buffer, which prevents its size from growing unchecked. There are also problems with using a single fixed buffer, such as when the pipe is full, in which case subsequent write calls to the pipe get blocked waiting for some data to be read.</li><li>The read process may also work faster than the write process. When the pipe is empty, a subsequent read call will be blocked by default.</li></ul><blockquote><p>Reading data from the pipeline can only be a one-time operation. Once the data is read, it frees up space for writing more data. The pipeline can only take half-duplex communication, that is, it can only be transported one way at a time.</p></blockquote><h1 id="Thread-and-multithreaded-models"><a href="#Thread-and-multithreaded-models" class="headerlink" title="Thread and multithreaded models"></a>Thread and multithreaded models</h1><h2 id="Basic-concepts-of-threads"><a href="#Basic-concepts-of-threads" class="headerlink" title="Basic concepts of threads"></a>Basic concepts of threads</h2><p>The purpose of introducing processes is to better enable multi-program concurrency, improve resource utilization and system throughput, while the purpose of introducing threads is to reduce the time and space overhead paid by the program during concurrent execution and improve the concurrency performance of the operating system.</p><p>The most direct understanding of threads is “lightweight process”. It is a basic CPU execution unit and the smallest unit of program execution flow. It consists of thread ID, program counter, register set, and stack.</p><p>Thread is an entity of a process, the basic unit of independent scheduling and allocation by the system, the thread itself does not have system resources, only a little essential resources in operation, but it can share all the resources with other threads belonging to the same process.</p><p>One thread can create and undo another thread, and multiple threads in the same process can execute concurrently.</p><p>Due to the mutual restriction between threads, threads will also be intermittent during operation. Threads also have three basic states: running, ready, and blocking.</p><p>After the introduction of threads, the connotation of processes has changed. Processes only serve as allocation units for system resources other than the CPU, while threads serve as allocation units for processors.</p><h2 id="Comparison-of-threads-and-processes"><a href="#Comparison-of-threads-and-processes" class="headerlink" title="Comparison of threads and processes"></a>Comparison of threads and processes</h2><ol><li>Scheduling. Simply put, some things that require multiple processes can be done with multiple threads. In traditional operating systems, the basic unit of resource and independent scheduling is a process, and context switching is required for each scheduling, which is expensive. After the introduction of threads, the cost of thread switching is much lower than that of processes in the unit of independent scheduling of line cities.</li><li>Concurrency. Multiple threads in the same process can execute concurrently, improving system resource utilization and system throughput.</li><li>Own resources. A process is the basic unit of having resources in the system, while a thread does not have system resources (only one essential resource that can guarantee independent operation), but a thread can access the system resources of the process it belongs to, which is mainly manifested in belonging to the same process. All counties have the same address space.</li><li>Independence. Each process has its own address space and resources. In addition to sharing global variables, other processes are not allowed to access them. Threads in a process are invisible to other processes. Different threads in the same process are created to improve concurrency and cooperation with each other. They share the address space and resources of the process.</li><li>System overhead. To create or cancel a process, the system must allocate and recover PCB and other resources, such as Memory Space, I/O devices, etc., which is very expensive. Process context switching is involved when switching processes, while thread switching only needs to save and set a small amount of register content, which is very small overhead.</li><li>Support multi-processor system. For traditional single-threaded processes, no matter how many processors there are, the process can only run on one processor, while multi-threaded processes can run multiple threads in the process on multiple processors.</li></ol><h2 id="Properties-of-a-thread"><a href="#Properties-of-a-thread" class="headerlink" title="Properties of a thread"></a>Properties of a thread</h2><p>A process in a multi-threaded operating system is no longer a basic execution entity, but it still has an execution-related state. The so-called process in the “execution” state actually means that one of the threads in the process is executing.</p><p>The main properties available are as follows:</p><ul><li>A thread is a lightweight entity that does not own system resources, but each thread has a unique identifier and a thread control block that records the field state such as registers and stacks for thread execution.</li><li>Different threads can execute the same program. That is, when the same service program is called by different users, the system can create them into different threads.<br>Each thread in the same process shares the resources owned by that process.</li><li>A thread is an independent scheduling unit of a processor. In a single-CPU computer, threads can use the CPU interchangeably, and in a multi-CPU system, each thread can occupy different CPUs.<br>After a thread is created, it begins its life cycle until it terminates.</li></ul><h2 id="Thread-state-and-transitions"><a href="#Thread-state-and-transitions" class="headerlink" title="Thread state and transitions"></a>Thread state and transitions</h2><p>Execution state: The thread has acquired the processor and is running.</p><ul><li>Ready state: The thread has various execution conditions, and it can be executed immediately after obtaining the CPU.</li><li>Blocked state: The thread is in a suspended state due to an event blocking its execution.</li></ul><h2 id="Thread-organization-and-control"><a href="#Thread-organization-and-control" class="headerlink" title="Thread organization and control"></a>Thread organization and control</h2><h3 id="Thread-control-block"><a href="#Thread-control-block" class="headerlink" title="Thread control block"></a>Thread control block</h3><p>Similar to processes, the system also configures a thread control block TCB for each thread, usually including:</p><ul><li>Thread identifier.</li><li>A set of registers. Includes program counters, status registers, and general purpose registers.</li><li>Thread running state. Used to describe what state the thread is in.</li><li>Priority.</li><li>Thread-specific storage area. Thread switching is used to save the scene.</li><li>stack pointer.</li></ul><p>Threads in the same process completely share the address space and global variables of the process. Each thread can access each unit of the process address space, so one thread can read and write or even clear the stack of another thread.</p><h3 id="Thread-creation"><a href="#Thread-creation" class="headerlink" title="Thread creation"></a>Thread creation</h3><p>There are functions (or system calls) to create and undo threads in the system</p><p>When the user program starts, usually only one thread called “initialization thread” is executing, and its main function is to create a new thread.</p><h3 id="Termination-of-thread"><a href="#Termination-of-thread" class="headerlink" title="Termination of thread"></a>Termination of thread</h3><p>When a thread completes its own task or is forced to terminate due to an exception during operation, the terminating thread calls the corresponding function to perform the termination operation. However, some threads (mainly system threads) will continue to run without being terminated once they are established.</p><p>Usually, the thread is terminated and does not immediately release the resources it occupies. Only when other threads in the process execute the separation function, the terminated thread is separated from the resources, and the resources can be used by other threads at this time.</p><p>Threads that are terminated but have not yet released resources can still be called by other threads to resume the terminated thread.</p><h2 id="Thread-implementation"><a href="#Thread-implementation" class="headerlink" title="Thread implementation"></a>Thread implementation</h2><p>The implementation of threads can be divided into two categories: user-level threads (ULT) and kernel-level threads (KLT).</p><blockquote><p>User-level threads are actually commonly referred to as coroutines. In fact, they are also threads</p></blockquote><h3 id="User-level-threads-coroutines"><a href="#User-level-threads-coroutines" class="headerlink" title="User-level threads (coroutines)"></a>User-level threads (coroutines)</h3><p>In user-level threads, all work related to thread management is done by the application in user space, and the kernel is unaware of the existence of threads.</p><p>An application can be designed as a multi-threaded program by using the thread library. Usually, the application starts from a single thread and starts running in that thread. At any time it runs, a new thread running in the same process can be created by calling a derived routine in the thread library.</p><p>For a system with user-level threads, the scheduling is still process-by-process, and each process takes turns executing a time slice. Assuming that process A contains one user-level thread and process B contains 100 user-level threads, the running time of threads in process A will be 100 times that of threads in process B, so it is essentially unfair to threads.</p><p>Advantages of this implementation:<br>Thread switching does not need to go to kernel space, saving the cost of mode switching.</p><ul><li>The scheduling algorithm can be process-specific, and different processes can choose different scheduling algorithms for their own threads according to their own needs.<br>The implementation of user-level threads is independent of the operating platform, and the code that manages threads is part of the user process.</li></ul><p>Disadvantages of this implementation:<br>When a thread executes a system call, not only is the thread blocked, but all threads in the process are blocked.</p><ul><li>Can not take advantage of multiprocessor, the kernel is allocated to a process at a time only one CPU, so only one thread in the process can execute.</li></ul><h3 id="Kernel-level-threads"><a href="#Kernel-level-threads" class="headerlink" title="Kernel level threads"></a>Kernel level threads</h3><p>Kernel-level threads also run under the support of the kernel, and all the work of thread management is also implemented in kernel space. Kernel space also sets up a thread control block for each kernel-level thread, according to which the kernel senses the existence of a thread and controls it.</p><p>Advantages of this implementation:</p><ul><li>It can take advantage of multiprocessors, and the kernel can schedule multiple threads within a process at the same time.<br>If a thread in a process is blocked, the kernel can schedule other threads in that process to occupy the processor, and can also run threads in other processes.</li><li>The kernel supports threads with small data structures and stacks, thread switching is faster and less overhead.</li><li>The kernel itself can also use multi-threading technology.</li></ul><p>Cons: <strong>Thread switching in the same process requires switching from User Mode to Kernel Mode</strong> .</p><h3 id="Combination-mode"><a href="#Combination-mode" class="headerlink" title="Combination mode"></a>Combination mode</h3><p>The kernel supports the creation, scheduling, and management of multiple kernel-level threads, while allowing user programs to establish, schedule, and manage user-level threads.</p><p>Some kernel-level threads correspond to multiple user-level threads, which is achieved by user-level threads to reuse kernel-level threads.</p><h2 id="Multithreaded-model"><a href="#Multithreaded-model" class="headerlink" title="Multithreaded model"></a>Multithreaded model</h2><p>Some systems support both user threads and kernel threads. Due to the different connection methods between the two, the following three different multi-threading models have been formed.</p><h3 id="Many-to-one-model"><a href="#Many-to-one-model" class="headerlink" title="Many-to-one model"></a>Many-to-one model</h3><p>Map multiple user-level threads to a kernel-level thread. These user threads generally belong to a single process. The scheduling and management of threads is done in user space. User threads need to be mapped to a kernel thread only when they need to access the kernel, and only one thread is allowed to be mapped at a time.<br>Advantages: Thread management is performed in user space, which is highly efficient<br>Disadvantages: If one thread blocks accessing the kernel, the entire process will be blocked; at any time, only one thread can access the kernel, and multiple threads cannot run on multiple processors at the same time.</p><h3 id="One-to-one-model"><a href="#One-to-one-model" class="headerlink" title="One-to-one model"></a>One-to-one model</h3><p>Map each user-level thread to a kernel-level thread.<br>Advantages: After each process is blocked, another kernel-level thread is allowed to be scheduled<br>Disadvantages: Every time a user thread is created, a kernel thread is required, which is expensive</p><h3 id="Many-to-many-model"><a href="#Many-to-many-model" class="headerlink" title="Many-to-many model"></a>Many-to-many model</h3><p>Map n user-level threads to m kernel-level threads</p><p>Features: It overcomes the shortcomings of low concurrency in the many-to-one model, and overcomes the shortcomings of the one-to-one model that a user process occupies too many kernel-level threads and costs too much.</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/" title="Operating System Learning Notes (3) Process and Thread">https://sunra.top/en/2021/10/14/operating-system-note-3-process-and-thread/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2021/10/06/ddos-base/" rel="prev" title="Basic knowledge of DDOS"><i class="fa fa-chevron-left"></i> Basic knowledge of DDOS</a></div><div class="post-nav-item"> <a href="/en/2021/10/16/uniyt-asset-workflow/" rel="next" title="Unity doc reading notes (2) Asset Workflow">Unity doc reading notes (2) Asset Workflow<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2021/10/14/operating-system-note-3-process-and-thread/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>