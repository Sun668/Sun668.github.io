<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="As we all know, JavaScript is a language for automatic garbage collection, which means that we don’t need to manually collect garbage data. All of this is done by V8’s garbage collector. In order to c"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript Execution Mechanism (8) Garbage Collection Mechanism"><meta property="og:url" content="https://sunra.top/en/2021/08/04/javascript-gc/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="As we all know, JavaScript is a language for automatic garbage collection, which means that we don’t need to manually collect garbage data. All of this is done by V8’s garbage collector. In order to c"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642353/origin-of-ray/screenshot-20210811-083742_tf2rdn.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642437/origin-of-ray/12519a0d1f2484cd24297e821f2f1887_oaspxk.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642627/origin-of-ray/6a558a6731fd68757e1a43c1dbc27ed8_t4jw7a.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642991/origin-of-ray/9004196c53f2f381a1321bcbc346fc23_fogdhf.jpg"><meta property="og:image" content="https://static001.geekbang.org/resource/image/be/6f/be18e6dc6c93e761a37d50aed48f246f.jpg"><meta property="og:image" content="https://static001.geekbang.org/resource/image/2c/4d/2cd1ef856522ad0c8176c60b75e63c4d.jpg"><meta property="og:image" content="https://static001.geekbang.org/resource/image/19/17/19bbfb35d274064b253814b58413bc17.jpg"><meta property="og:image" content="https://static001.geekbang.org/resource/image/75/15/759f6a8105d64d3aebdc16f81a2b5e15.jpg"><meta property="og:image" content="https://static001.geekbang.org/resource/image/7b/42/7b8b901cb2eb575bb8907e1ad7dc1842.jpg"><meta property="article:published_time" content="2021-08-04T00:26:20.000Z"><meta property="article:modified_time" content="2023-08-02T03:24:18.112Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642353/origin-of-ray/screenshot-20210811-083742_tf2rdn.png"><link rel="canonical" href="https://sunra.top/en/2021/08/04/javascript-gc/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2021/08/04/javascript-gc/","path":"2021/08/04/javascript-gc/","title":"JavaScript Execution Mechanism (8) Garbage Collection Mechanism"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>JavaScript Execution Mechanism (8) Garbage Collection Mechanism | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-is-junk-data-generated"><span class="nav-number">1.</span> <span class="nav-text">How is junk data generated?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-collection-algorithm-steps"><span class="nav-number">2.</span> <span class="nav-text">Garbage collection algorithm steps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Two-types-of-garbage-collectors"><span class="nav-number">3.</span> <span class="nav-text">Two types of garbage collectors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Secondary-garbage-collector"><span class="nav-number">3.1.</span> <span class="nav-text">Secondary garbage collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Main-garbage-collector"><span class="nav-number">3.2.</span> <span class="nav-text">Main garbage collector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-improve-garbage-collection-efficiency-with-V8"><span class="nav-number">4.</span> <span class="nav-text">How to improve garbage collection efficiency with V8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-recovery"><span class="nav-number">4.1.</span> <span class="nav-text">Parallel recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Incremental-recycling-dismantling-tasks"><span class="nav-number">4.2.</span> <span class="nav-text">Incremental recycling (dismantling tasks)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Three-color-mark"><span class="nav-number">4.2.1.</span> <span class="nav-text">Three-color mark</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Write-barrier"><span class="nav-number">4.2.2.</span> <span class="nav-text">Write barrier</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comprehensive-garbage-collection-strategy-for-V8"><span class="nav-number">4.3.</span> <span class="nav-text">Comprehensive garbage collection strategy for V8</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2021/08/04/javascript-gc/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="JavaScript Execution Mechanism (8) Garbage Collection Mechanism | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> JavaScript Execution Mechanism (8) Garbage Collection Mechanism</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-08-04 08:26:20" itemprop="dateCreated datePublished" datetime="2021-08-04T08:26:20+08:00">2021-08-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-08-02 11:24:18" itemprop="dateModified" datetime="2023-08-02T11:24:18+08:00">2023-08-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2021/08/04/javascript-gc/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2021/08/04/javascript-gc/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>As we all know, JavaScript is a language for automatic garbage collection, which means that we don’t need to manually collect garbage data. All of this is done by V8’s garbage collector. In order to collect garbage more efficiently, V8 introduced two garbage collectors, each targeting different scenarios.</p><p>Let’s analyze the usage scenarios and working principles of these two recycling mechanisms together.</p><span id="more"></span><h2 id="How-is-junk-data-generated"><a href="#How-is-junk-data-generated" class="headerlink" title="How is junk data generated?"></a>How is junk data generated?</h2><p>For example, the following code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code will first create the function execution context on the stack, then create a new object on the heap, and then store the pointer to that object in the context of’gc ‘.</p><p>Then when the’gc ‘function exits, the a in the stack is deleted, and the object corresponding to the pointer stored in the a will become garbage data in the heap, which is invalid.</p><p>From this example, we can also see that the garbage collection algorithm targets the heap.</p><h2 id="Garbage-collection-algorithm-steps"><a href="#Garbage-collection-algorithm-steps" class="headerlink" title="Garbage collection algorithm steps"></a>Garbage collection algorithm steps</h2><p>So how is garbage collection achieved? It can be roughly divided into the following steps:</p><p>The first step is to tag the active objects and inactive objects in the GC Root space.</p><p>The current reachability algorithm used by V8 determines whether objects in the heap are active objects. Specifically, this algorithm uses some GC Roots as a set of initially viable objects, starting from the GC Roots object, and traversing all objects in the GC Root:</p><p>This is a bit like multi-source BFS/DFS. Starting from multiple root nodes, search the entire tree. If it can be searched, it means that the corresponding memory address is still in use, and the remaining space in the heap is unused.</p><ul><li><p>Through the GC Root traverse to the object, we consider the object is accessible (reachable), then we must ensure that these objects should be retained in memory, we also call the accessible object as the active object;</p></li><li><p>Objects that are not traversed by GC Roots are unreachable, so these unreachable objects may be reclaimed. We call inaccessible objects inactive objects.</p></li></ul><p>In the browser environment, there are many GC Roots, usually including the following (but more than these):</p><ul><li><p>the global window object (located in each iframe);</p></li><li><p>doc DOM tree, consisting of all native DOM nodes that can be reached by traversing the doc;</p></li><li><p>Store variables on the stack.</p></li></ul><p>The second step is to reclaim the memory occupied by the inactive object. In fact, after all the marks are completed, all the objects marked as recyclable in the memory are cleaned up uniformly.</p><p> <strong>The third step</strong> is to do memory defragmentation. Generally speaking, after frequent collection of objects, there will be a large amount of discontinuous space in memory. We call these discontinuous Memory Spaces memory fragments. When a large number of memory fragments appear in the memory, if a large contiguous memory needs to be allocated, there may be insufficient memory, so the last step needs to <strong>defragment these memory fragments</strong> . But this step is actually optional, because some garbage collectors do not generate memory fragments, such as the secondary garbage collector we will introduce next.</p><h2 id="Two-types-of-garbage-collectors"><a href="#Two-types-of-garbage-collectors" class="headerlink" title="Two types of garbage collectors"></a>Two types of garbage collectors</h2><p>V8 currently uses two garbage collectors, <strong>the main garbage collector - Major GC and the secondary garbage collector - Minor GC (Scavenger)</strong> . The reason why V8 uses two garbage collectors is mainly influenced by The Generational Hypothesis</p><p>The intergenerational hypothesis is an important term in the field of garbage collection, which has the following two characteristics:</p><ul><li><p>The first is that most objects are “live and die”, which means that most objects live in memory for a short time, such as variables declared inside a function, or variables in a block-level scope. When the function or Code Block ends, the variables defined in the scope will be destroyed. Therefore, once this type of object is allocated memory, it quickly becomes inaccessible;</p></li><li><p>The second is immortal objects that will live longer, such as global window, DOM, Web API, etc.</p></li></ul><p>For those objects with short lifetime, due to their short lifetime characteristics, we need to recycle them frequently, so we first do not need to apply for much space for such objects, because they will be recycled soon, and secondly, Due to frequent recycling, if you have to defragment the memory every time, it will consume performance.</p><p>In view of these two points, we need to apply a small Memory Space for this variable, called the new generation, the new generation of garbage collector, is the secondary collector, which is characterized by not generating memory fragments.</p><p>For objects that survive for a long time, a large Memory Space is needed, called the old generation. The garbage collector of the old generation is the main collector, which is characterized by memory fragmentation and requires memory sorting, but because it is almost Will not die, so there is almost no need to sort out memory.</p><h3 id="Secondary-garbage-collector"><a href="#Secondary-garbage-collector" class="headerlink" title="Secondary garbage collector"></a>Secondary garbage collector</h3><p>The secondary garbage collector is mainly responsible for garbage collection of the new generation. Usually, most small objects are allocated to the new generation, so although this area is not large, garbage collection is still relatively frequent. The garbage data in the new generation is processed by the Scavenge algorithm. The so-called Scavenge algorithm divides the new generation space into two regions in half, <strong>half is the object area (from-space) and half is the free area (to-space)</strong> , as shown in the figure below:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642353/origin-of-ray/screenshot-20210811-083742_tf2rdn.png" alt></p><p>Newly added objects will be stored in the object area. <strong>When the object area is almost full, a garbage cleaning operation needs to be performed.</strong></p><p>In the garbage collection process, the garbage in the object area must first be marked; after the marking is completed, it enters the garbage cleaning stage. The secondary garbage collector will copy these surviving objects to the free area, and it will also arrange these objects in an orderly manner, so this copying process is equivalent to completing the memory sorting operation, and there will be no memory fragmentation in the free area after copying.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642437/origin-of-ray/12519a0d1f2484cd24297e821f2f1887_oaspxk.jpg" alt></p><p>After copying, the object area and the free area perform role flipping, that is, the original object area becomes the free area, and the original free area becomes the object area. This completes the garbage object collection operation, and at the same time, this role reversal operation can also make these two areas in the new generation infinitely reused.</p><p>Each time the sub-garbage collector performs a clean-up operation, it is necessary to copy the surviving object from the object area to the free area. The copy operation requires time cost. If the space in the new area is set too large, the time for each clean-up will be too long. Therefore, in order to perform efficiently, the space in the general new area will be set relatively small.</p><p>It is precisely because the space in the new area is not large, so it is easy to fill the entire area with surviving objects. Once the secondary garbage collector is full of monitoring objects, it will perform garbage collection. At the same time, the secondary garbage collector will also use the Object Promotion Strategy, which is to move objects that are still alive after two garbage collections to the old generation.</p><h3 id="Main-garbage-collector"><a href="#Main-garbage-collector" class="headerlink" title="Main garbage collector"></a>Main garbage collector</h3><p>The main garbage collector is mainly responsible for garbage collection in the old generation. In addition to objects promoted in the new generation, some large objects are directly assigned to the old generation. Therefore, objects in the old generation have two characteristics:</p><ul><li><p>One is that the object occupies a large space;</p></li><li><p>The other is that the object survives for a long time.</p></li></ul><p>Since the objects of the old generation are relatively large, if you want to use the Scavenge algorithm for garbage collection in the old generation, it will take more time to copy these large objects, resulting in inefficient collection execution and wasting half of the space. Therefore, the main garbage collector uses the Mark-Sweep algorithm for garbage collection.</p><p>The first is the marking process stage. The marking stage starts from a set of root elements, and recursion traverses this set of root elements. During this traversal process, the elements that can be reached are called active objects, and the elements that cannot be reached can be judged as garbage data.</p><p>The next step is the garbage removal process. It is completely different from the garbage removal process of the secondary garbage collector. The main garbage collector will directly clean up the data marked as garbage.</p><p>Mark the garbage data and then clear it. This is the mark-clear algorithm. However, after executing the mark-clear algorithm multiple times on a piece of memory, a large number of discontinuous memory fragments will be generated. Too much fragmentation will cause large objects to fail to allocate enough contiguous memory, so another algorithm is introduced - Mark-Compact.</p><p>The labeling process of this algorithm is still the same as in the labeling-clearing algorithm. The recyclable object is marked first, but the subsequent steps are not to clean up the recyclable object directly, but to move all the surviving objects to one end, and then clean up directly. Remove the memory outside this end. You can refer to the following figure:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642627/origin-of-ray/6a558a6731fd68757e1a43c1dbc27ed8_t4jw7a.jpg" alt></p><h2 id="How-to-improve-garbage-collection-efficiency-with-V8"><a href="#How-to-improve-garbage-collection-efficiency-with-V8" class="headerlink" title="How to improve garbage collection efficiency with V8"></a>How to improve garbage collection efficiency with V8</h2><p>Since JavaScript runs on the main thread, once the garbage collection algorithm is executed, it is necessary to pause the executing JavaScript script and resume the script execution after the garbage collection is completed. We call this behavior Stop-The-World.</p><p>A complete garbage collection is divided into two stages: marking and cleaning. After the garbage data is marked, V8 will continue to perform cleaning and sorting operations. Although the main garbage collector and the secondary garbage collector have slightly different processing methods, they are all main threads. During the garbage collection process, other tasks on the main thread will be suspended. The specific execution effect of the full pause is shown in the following figure:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642991/origin-of-ray/9004196c53f2f381a1321bcbc346fc23_fogdhf.jpg" alt></p><p>It can be seen that executing garbage collection will occupy the time of the main thread. If the garbage collector occupies the main thread for too long during the process of executing garbage collection, as shown in the picture above, it takes 200 milliseconds. During these 200 milliseconds, the main thread cannot do other things. For example, the page is executing a JavaScript animation, and because the garbage collector is working, the animation cannot be executed within these 200 milliseconds, resulting in poor page Jank and poor user experience.</p><p>In order to solve the User Experience problem caused by the full pause, the V8 team has worked hard for many years to add garbage collection technologies such as parallelism, concurrency, and increment to the existing garbage collector, and has also achieved some results. These technologies mainly solve the garbage collection efficiency problem from two aspects:</p><ul><li><p>First, split a complete garbage collection task into <strong>multiple small tasks</strong> , thus eliminating a single long garbage collection task;</p></li><li><p>second, transfer tasks such as marking objects and moving objects to the background thread, which will greatly reduce the time of the main thread to pause, improve the problem of page Stuttering, and make animation, Scrolling and user interaction smoother.</p></li></ul><h3 id="Parallel-recovery"><a href="#Parallel-recovery" class="headerlink" title="Parallel recovery"></a>Parallel recovery</h3><p>Since it is time-consuming to perform a complete garbage collection process, the first idea to solve the efficiency problem is to introduce multiple auxiliary threads to process in parallel when the main thread performs the task of garbage collection, which will accelerate the execution speed of garbage collection. Therefore, the V8 team introduced a parallel collection mechanism</p><p>The so-called parallel collection means that during the execution of the garbage collector on the main thread, it will also open multiple assistant threads to perform the same collection work at the same time.</p><p>When using parallel collection, the time consumed by garbage collection is equal to the time consumed by the total helper threads (the number of helper threads multiplied by the time consumed by individual threads), plus some synchronization overhead time. This approach is relatively simple because during the execution of garbage marking, the main thread does not execute JavaScript code at the same time, so the JavaScript code will not change the collection process. <strong>So we can assume that the memory state is static</strong> , so just make sure that only one helper thread is accessing the object at the same time.</p><p> <strong>V8’s secondary garbage collector adopts a parallel strategy</strong> . During the process of executing garbage collection, it starts multiple threads to be responsible for garbage cleaning operations in the new generation. These threads also move the data in the object space to the free area. Since the address of the data has changed, the pointers that refer to these objects need to be updated synchronously.</p><h3 id="Incremental-recycling-dismantling-tasks"><a href="#Incremental-recycling-dismantling-tasks" class="headerlink" title="Incremental recycling (dismantling tasks)"></a>Incremental recycling (dismantling tasks)</h3><p>Although the parallel strategy can increase the efficiency of garbage collection and optimize the secondary garbage collector well, it is still a full-stop garbage collection method. The auxiliary thread will only be started when the main thread executes the collection work, which will still exist. Efficiency issues. For example, the old generation stores some large objects, such as window and DOM, and it will still take a long time to fully execute the garbage collection of the old generation. These large objects are all part of the main garbage collector, so in 2011, V8 introduced incremental markup, which we call incremental garbage collection.</p><p>The so-called incremental garbage collection refers to the garbage collector breaking the labeling work into smaller blocks and interspersing it between different tasks of the main thread. When using incremental garbage collection, it is not necessary for the garbage collector to perform the complete garbage collection process at once, but only a small part of the entire garbage collection process is executed each time.</p><p><img src="https://static001.geekbang.org/resource/image/be/6f/be18e6dc6c93e761a37d50aed48f246f.jpg" alt></p><p>Incremental markup algorithm is slightly more complex than the full pause algorithm, mainly because incremental collection is concurrent (concurrent). To achieve incremental execution, two requirements need to be met:</p><ul><li><p>Garbage collection can be paused and restarted at any time. <strong>When paused, you need to save the scan results at that time</strong> , and you can continue to start it after the next wave of garbage collection comes.</p></li><li><p>During the pause, marked garbage data needs to be handled correctly by the garbage collector if it has been modified by JavaScript code.</p></li></ul><h4 id="Three-color-mark"><a href="#Three-color-mark" class="headerlink" title="Three-color mark"></a>Three-color mark</h4><p>Here we need to know that V8 uses black and white to label data before using the incremental algorithm. Before performing a full garbage collection, the garbage collector will set all data to white to indicate that it has not been marked yet, and then the garbage collector will start from GC Roots and mark all accessible data as black. After the traversal, the data marked black is the active data, and the white data is the garbage data.</p><p>If the data in memory has only two states, black and white, then when you pause the current garbage collector and resume the garbage collector again, the garbage collector will not know where to continue execution. For example, after the garbage collector performs a short incremental collection, it is paused by V8, and then the main thread executes a piece of JavaScript code, and then the garbage collector is restored, so the memory state when it resumes is shown in the following figure</p><p><img src="https://static001.geekbang.org/resource/image/2c/4d/2cd1ef856522ad0c8176c60b75e63c4d.jpg" alt></p><p> <strong>If you simply think of continuing to execute the marker from black, which black node should you start from?</strong> From A? B? Or other black nodes, or even start from scratch?</p><p>In order to solve this problem, V8 adopts a three-color marking method, in addition to black and white, gray is also introduced:</p><ul><li><p>Black indicates that this node is referenced by GC Root, and the sub-nodes of this node have been marked</p></li><li><p>Gray indicates that this node is referenced by GC Root, but the sub-node has not been marked for processing by the garbage collector, and it also indicates that this node is currently being processed;</p></li><li><p>White indicates that this node has not been visited. If it is still white at the end of this round of traversal, then this piece of data will be recovered.</p></li></ul><p>After introducing the gray mark, the garbage collector can judge whether the entire mark is complete based on whether there are gray nodes in the current memory. If there are no gray nodes, the cleaning work can be carried out. If there are still gray marks, the next time the garbage collector is restored, execution will continue from the gray node.</p><h4 id="Write-barrier"><a href="#Write-barrier" class="headerlink" title="Write barrier"></a>Write barrier</h4><p>Simple three-color markers are actually still a bit problematic. For example, the following code:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> = <span class="title class_">Object</span>()</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="title class_">Object</span>()</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>=<span class="title class_">Object</span>() </span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/19/17/19bbfb35d274064b253814b58413bc17.jpg" alt></p><p>Then another code was executed, which is as follows:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="title class_">Object</span>() <span class="comment">//d</span></span><br></pre></td></tr></table></figure><p>After execution, the garbage collector resumes the incremental marking process. Since b repoints to the d object, the connection between the b and c objects is disconnected. The application of the code at this time is shown in the following figure:</p><p><img src="https://static001.geekbang.org/resource/image/75/15/759f6a8105d64d3aebdc16f81a2b5e15.jpg" alt></p><p>This shows a problem. When the garbage collector marks a node as black, and then the black node is followed by a white node, then the garbage collector will not mark the white node as a black node again, because It has already traveled this path. But this new white node is indeed referenced, so we still need to find a way to mark it as black.</p><p>To solve this problem, the incremental garbage collector adds a constraint: black nodes cannot point to white nodes. Usually we use the write-barrier mechanism to implement this constraint, that is, when a black node references a white node, the write barrier mechanism will force the referenced white node to turn gray, thus ensuring that black Nodes cannot point to white nodes constraints.</p><p>This method, also known as strong tricolor invariance, guarantees that the garbage collector can correctly recycle data, because all white objects at the end of the marker are unreachable to the garbage collector and can be safely released.</p><h3 id="Comprehensive-garbage-collection-strategy-for-V8"><a href="#Comprehensive-garbage-collection-strategy-for-V8" class="headerlink" title="Comprehensive garbage collection strategy for V8"></a>Comprehensive garbage collection strategy for V8</h3><p><img src="https://static001.geekbang.org/resource/image/7b/42/7b8b901cb2eb575bb8907e1ad7dc1842.jpg" alt></p><p>It can be seen that the main garbage collector uses these three strategies at the same time.</p><ul><li><p>First of all, the main garbage collector mainly uses concurrent tags. We can see that when the main thread executes JavaScript, the auxiliary thread starts to execute the tagging operation, so the tagging is done in the auxiliary thread.</p></li><li><p>After marking is complete, perform parallel cleanup operations. While the main thread is performing cleanup operations, multiple worker threads are also performing cleanup operations.</p></li></ul><p>In addition, the main garbage collector also uses incremental markup, and the cleaning task will be interspersed between various JavaScript tasks.</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2021/08/04/javascript-gc/" title="JavaScript Execution Mechanism (8) Garbage Collection Mechanism">https://sunra.top/en/2021/08/04/javascript-gc/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2021/07/27/javascript-obj-attr-search/" rel="prev" title="JavaScript Execution Mechanism (7) How to quickly find properties on objects"><i class="fa fa-chevron-left"></i> JavaScript Execution Mechanism (7) How to quickly find properties on objects</a></div><div class="post-nav-item"> <a href="/en/2021/08/15/javascript-conclusion/" rel="next" title="JavaScript Execution Mechanism (9) Phase Summary">JavaScript Execution Mechanism (9) Phase Summary<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/en/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2021/08/04/javascript-gc/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>