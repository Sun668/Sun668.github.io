<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="The original purpose of texturing is to use an image to control the appearance of the model. Using texture mapping technology, we can “glue” an image to the surface of the model and control the color"><meta property="og:type" content="article"><meta property="og:title" content="Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures)"><meta property="og:url" content="https://sunra.top/en/2022/06/12/unity-render-pipeline-10/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="The original purpose of texturing is to use an image to control the appearance of the model. Using texture mapping technology, we can “glue” an image to the surface of the model and control the color"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2022-06-12T00:23:05.000Z"><meta property="article:modified_time" content="2024-10-16T23:17:13.965Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/2022/06/12/unity-render-pipeline-10/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2022/06/12/unity-render-pipeline-10/","path":"2022/06/12/unity-render-pipeline-10/","title":"Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures)"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures) | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#single-grain"><span class="nav-number">1.</span> <span class="nav-text">Single grain</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#properties-of-unity-textures"><span class="nav-number">1.1.</span> <span class="nav-text">Properties of Unity Textures</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concave-convex-mapping"><span class="nav-number">2.</span> <span class="nav-text">Concave-convex mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#height-texture"><span class="nav-number">2.1.</span> <span class="nav-text">Height texture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#normal-texture"><span class="nav-number">2.2.</span> <span class="nav-text">Normal texture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#comparison-of-normal-textures-in-different-spaces"><span class="nav-number">2.2.1.</span> <span class="nav-text">Comparison of normal textures in different spaces</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#practice"><span class="nav-number">2.3.</span> <span class="nav-text">Practice</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#calculate-in-tangent-space"><span class="nav-number">2.3.1.</span> <span class="nav-text">Calculate in tangent space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#computing-in-world-space"><span class="nav-number">2.3.2.</span> <span class="nav-text">Computing in world space</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2022/06/12/unity-render-pipeline-10/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures) | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures)</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-06-12 08:23:05" itemprop="dateCreated datePublished" datetime="2022-06-12T08:23:05+08:00">2022-06-12</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-10-17 07:17:13" itemprop="dateModified" datetime="2024-10-17T07:17:13+08:00">2024-10-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2022/06/12/unity-render-pipeline-10/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2022/06/12/unity-render-pipeline-10/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>The original purpose of texturing is to use an image to control the appearance of the model. Using texture mapping technology, we can “glue” an image to the surface of the model and control the color of the model by texel (to distinguish from pixels).</p><p>When modeling, artists usually use texture expansion techniques in modeling software to store texture map coordinates on each vertex. Texture map coordinates define the 2D coordinates corresponding to the vertex in the texture. Usually, these coordinates are represented by a 2D variable (u, v), where u is the abscissa and v is the ordinate, so texture coordinates are also called uv coordinates.</p><span id="more"></span><p>Texture sizes can be various, for example 256 * 256, but uv coordinates are generally normalized to between [0,1]. It should be noted that the texture coordinates used for texture sampling are not necessarily in the range [0,1]. In fact, such texture coordinates that are not in the range [0,1] can be very useful. Closely related is the tile mode of the texture, which will determine how the rendering engine samples the texture when encountering texture coordinates that are not in the range [0,1]</p><h2 id="single-grain"><a class="markdownIt-Anchor" href="#single-grain"></a> Single grain</h2><p>We usually use a texture instead of the diffuse color of the object. Let’s use a simple example with annotations to actually look at the mapping process of a single texture:</p><p>First, we declare some properties required for the texture.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/SingleTexture&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">//Each texture has a corresponding set of implicit properties, where &#123;texture name&#125; _ST represents the zoom and offset of the modified texture</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="built_in">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//The reason why this is float4 is because xyzw is a homogeneous coordinate, w is 1 for point coordinates, and 0 is a vector</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//The semantic role of the slice element shader can be seen: https://docs.unity3d.com/cn/2019.4/Manual/SL-ShaderSemantics.html</span></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Get the coordinates of the vertex in the clipping space</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//Get the direction of the normal in the world coordinate system, not normalized</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                <span class="comment">//Get the vertex coordinates in the world coordinate system</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">//Get the sampled texture coordinates of the point</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//normalize the direction of the normal under the world coordinate system</span></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                <span class="comment">//Get and normalize the direction of the point to the light source in the world coordinate system</span></span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Sample the texture and mix it with our custom colors to get the reflected color</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Get the ambient light direction and combine the reflected color</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//get diffuse light</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Get and normalize the viewing direction of the point to the camera in world coordinates</span></span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                <span class="comment">//get specular reflection</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="properties-of-unity-textures"><a class="markdownIt-Anchor" href="#properties-of-unity-textures"></a> Properties of Unity Textures</h3><p>After we import the image into Unity, there are many properties to choose from.</p><p>Let’s pick one of the more critical ones and talk about it:</p><ul><li>Texture type. There are Texture, Normal Map and CubeMap available, we are currently using Texture</li><li>Wrap Mode. Determines how to tile when the texture coordinates exceed the range of [0,1]. There are two options, one is Repeat. In this mode, if the texture coordinates exceed 1, then its integer part will be discarded, and the fractional part will be used directly Sampling, the result is that the texture will be repeated continuously (that is, if it is greater than 1, then subtract one by ten, if it is still greater than 1, then continue to subtract one by ten), the other mode is Clamp, if the texture coordinates greater than 1, then select 1, if less than 0, intercept to 0</li><li>Filter Mode. Determines which filtering method will be taken when the transformation is stretched. There are three options, Point, Billinear and Trilinear. The filtering effect is improved once, but the consumption also increases in turn (Trillinear needs to use the result of Minmap. If minmap is not enabled, then the results of Trillnear and Billinear are the same)</li><li>Minmap. If a texture is shrunk, multiple pixels in the original texture will correspond to one target pixel. This time the problem is more complicated because we often need to deal with anti-aliasing problems. One way is to use multi-level asymptotic texture (mipmapping), which uses filtering techniques in advance to get many smaller images, forming an image pyramid. Each layer is the result of sampling the previous layer, so that when running in real time, You can quickly get the resulting pixels, which is a typical space-for-time approach.</li><li>Read/Write Enable. If you want to read the texture in code at runtime, you need to enable this option, but remember that once enabled, the memory occupied by the texture will double</li></ul><h2 id="concave-convex-mapping"><a class="markdownIt-Anchor" href="#concave-convex-mapping"></a> Concave-convex mapping</h2><p>Another common application of textures is bump mapping. The purpose of bump mapping is to use a texture to modify the normals of the surface of the model in order to provide more detail to the model. This method does not change the position of the fixed point of the model, but makes the model look uneven, but can see flaws in the contour of the model.</p><p>There are two main methods that can be used for bump mapping: one method is to use a height map to simulate the surface displacement and get a modified normal value, this method is also called Height mapping; the other method is to use a normal texture to directly store the surface normal value, this method is called normal mapping.</p><h3 id="height-texture"><a class="markdownIt-Anchor" href="#height-texture"></a> Height texture</h3><p>The bump mapping is implemented using a height map. The intensity value is stored in the height map, which is used to represent the altitude of the local surface of the model. The shallower the color, the more convex the surface at that location is, and the darker the color, the more concave the location is. The advantage of this method is that it is very intuitive, but the disadvantage is that the calculation is more complicated. The surface normal cannot be directly obtained in real-time calculation, but needs to be calculated from the canary release value of the pixel, so it requires more performance.</p><p>Height maps are often used together with normal maps to give additional information about surface irregularities. That is, we usually use normal maps to modify lighting.</p><h3 id="normal-texture"><a class="markdownIt-Anchor" href="#normal-texture"></a> Normal texture</h3><p>What is stored in the normal texture is the normal direction of the surface. Since the component range of the discovery direction is between [-1, 1], and the component range of the pixel is [0, 1], we need to make a mapping, the commonly used mapping is</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">pixel = \frac{normal + 1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>This requires that after we sample the normal texture in the Shader, we also need to carry out a mapping process on the result to obtain the original normal direction. The process of reflection is actually the inverse function of the above mapping function</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>p</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>l</mi><mo>∗</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">normal = pixel * 2 -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></span></p><p>Since the direction is relative to the coordinate space, in which coordinate space is the normal direction stored in the normal texture? For the normals built into the model, it is defined in the model space, so a straightforward idea is to store the surface normals in the modified model space in a texture, which is called the normal texture of the model space (object-space normal map). However, in the actual production process, we often use another coordinate space, that is, the tangent space of the fixed point of the model, to store the normals. For each vertex of the model, it has its own tangent space. The origin of this tangent space is the vertex itself, and the z-axis is the normal direction of the vertex, the x-axis is the tangent direction of the vertex, and the y-axis consists of x and z cross product, also known as a sub-tangent or sub-normal, this texture is called a tangent-space normal map</p><p>The normal texture in the model space looks colorful, because the coordinate space where all normals are located is the model space, and the normal direction stored at each point is different, some are (0, 1, 0), after mapping After storing in the texture, it corresponds to RGB (0.5, 1.0.5) light green, and some are (0, -1, 0), after mapping and storing in the texture, it corresponds to (0.5, 0, 0.5) purple. The normal texture in tangent space looks almost all light blue, because the coordinate space where each normal is located is different, that is, each vertex’s own tangent space. This normal texture actually stores the normal disturbance direction of each point in their respective tangent space. That is to say, if the normal direction of a point does not change, then in its tangent space, the new normal direction is the z-axis direction, that is, (0,0,1), which corresponds to light blue after mapping and storing in the texture.</p><h4 id="comparison-of-normal-textures-in-different-spaces"><a class="markdownIt-Anchor" href="#comparison-of-normal-textures-in-different-spaces"></a> Comparison of normal textures in different spaces</h4><p>In general, the normal texture in the model space is more in line with people’s intuitive cognition, and the normal texture itself is also intuitive and easy to adjust, and different normal directions represent different colors. But artists prefer normal textures in tangent space, why is this?</p><p>In fact, the normal itself can be stored in any coordinate system, we can even store it in world space, but the problem is that we don’t want to simply get the normal, the subsequent illumination calculation is our purpose. And choosing that coordinate system means that we need to convert different information into the corresponding coordinate system. If tangent space is selected, we need to convert the normal direction obtained from the normal texture from tangent space to world space</p><p>In general, the advantages of using normals to model spaces are as follows;</p><ul><li>Simple to implement and more intuitive. We don’t even need the original normal and tangent information of the model, that is, there is less calculation. Generation is also simple, and if you want to generate normal textures in tangent space, since the tangents of the model are generally in the same direction as uv, to get a better normal mapping requires that the texture mapping is also continuous.</li><li>At the stitches of texture coordinates and sharp corners, there are fewer visible mutations, which can provide a smooth boundary. This is because the normal texture in the model space stores the normal information in the same coordinate system, so the normal obtained by the difference at the boundary can be smoothly transformed. The normal information in the normal texture in tangent space is the result of relying on the direction of the texture coordinates, and may be more visible signs of stitching at the edges or sharp parts</li></ul><p>But tangent space has more advantages:</p><ul><li>High degree of freedom. The normal texture in model space records absolute normal information and can only be used for the model when it was created, while applying it to other models means completely wrong. The normal texture in tangent space records relative normal information, which means. Even if the texture is applied to a completely different mesh, a reasonable result can be obtained.</li><li>Can do uv animation. For example, we can move the uv coordinates of a texture to achieve a bump movement effect, but using the normal texture in model space will get completely wrong results, for the same reason. This uv animation is often used on objects of the type of water and volcanic rocks.</li><li>Reusable normal textures. For example, for a brick, we can use only one normal texture for all 6 faces.</li><li>Compressible. Since the z-direction of the normal in a normal texture in tangent space is always positive, we can store only the xy direction and push to get the z-direction.</li></ul><h3 id="practice"><a class="markdownIt-Anchor" href="#practice"></a> Practice</h3><p>We need to unify the coordinate space where each direction vector is located in the computational illumination model. Since the normal stored in the normal texture is the direction under tangent space, we usually have two options: one is to perform illumination calculation in tangent space, at this time we need to transform the illumination direction and viewing angle direction to tangent space; Another option is to perform illumination calculation in world space. At this time, we need to transform the normal direction obtained by sampling to world space, and then calculate the illumination direction and viewing angle direction in world space.</p><p>In terms of efficiency, the first method is often better than the second method, because we can complete the transformation of the lighting direction and viewing angle direction in the vertex shader, while the second method needs to sample the normal texture first, so the transformation process must be implemented in the chip element shader, which means we have to perform a matrix operation in the chip element shader. But from a general point of view, the second method is better than the first method, because sometimes we need to perform some calculations in world space. For example, when using Cubemap for environment mapping, we need to sample Cubemap using the reflection direction in world space</p><h4 id="calculate-in-tangent-space"><a class="markdownIt-Anchor" href="#calculate-in-tangent-space"></a> Calculate in tangent space</h4><p>The basic idea is to obtain the normal line in tangent space through texture sampling in the slice element shader, and then calculate with the viewing angle direction and illumination direction in tangent space to obtain the final illumination result.</p><p>To this end, we first need to transform the viewing angle direction and illumination direction from the model space to the tangent space in the vertex shader, that is, we need to know the transformation matrix from the model space to the tangent space, the Inverse Matrix of this transformation matrix, that is, from the tangent The transformation matrix from line space to model space is very easy to find. We can obtain it in the order of tangent (x axis), sub-tangent (y axis), and normal (z axis) in the vertex shader. And if there is only translation and rotation in a transformation, then the Inverse Matrix of this transformation is equal to its transpose matrix, so the transformation matrix from model space to tangent space is the transpose matrix from tangent space to model space transformation matrix, that is, we put The tangent (x-axis), the sub-tangent (y-axis), and the normal (z-axis) are arranged in rows</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/NormalMapTangentSpace&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex(<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap(<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpScale(<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span>&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="built_in">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="built_in">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal: NORMAL;</span><br><span class="line">                float4 tangent: TANGENT;</span><br><span class="line">                float4 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos: SV_POSITION;</span><br><span class="line">                float4 uv: TEXCOORD0;</span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir: TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy * _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line"><span class="comment">//TANGENT_SPACE_ROTATION macro, which is equivalent to embedding the following two lines of code:</span></span><br><span class="line"><span class="comment">//                 </span></span><br><span class="line"><span class="comment">// 　　          float3 binormal = cross( v.normal, v.tangent.xyz ) * v.tangent.w;</span></span><br><span class="line"><span class="comment">//float3x3 rotation = float3x3 (v.tangent.xyz, binormal, v. normal); Defines the rotation matrix that transforms the vector of the object space to the tangent space.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = sqrt(<span class="number">1.0</span> - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(<span class="number">0</span>, dot(tangentNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computing-in-world-space"><a class="markdownIt-Anchor" href="#computing-in-world-space"></a> Computing in world space</h4><p>We need to transform the normal direction from tangent space to world space in the slice element shader. The basic idea of this method is to calculate the transformation matrix from tangent space to world space in the vertex shader and pass it to the slice element shader. The calculation of the transformation matrix can be obtained from the representation of the tangent, sub-tangent and normal of the vertices in world space. Finally, we just need to transform the normal direction in the normal texture from tangent space to world space in the slice element shader.</p><p>Although this method requires more computation, we need to use this method in situations such as using Cubemap for environment mapping.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/NormalMapWorldSpace&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex(<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap(<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpScale(<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span>&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="built_in">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="built_in">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex: POSITION;</span><br><span class="line">                float3 normal: NORMAL;</span><br><span class="line">                float4 tangent: TANGENT;</span><br><span class="line">                float4 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos: SV_POSITION;</span><br><span class="line">                float4 uv: TEXCOORD0;</span><br><span class="line">                float4 TtoW0: TEXCOORD0;</span><br><span class="line">                float4 TtoW1: TEXCOORD1;</span><br><span class="line">                float4 TtoW2: TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy * _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>): SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 bump = UnpackNormal(packedNormal);</span><br><span class="line">                bump.xy *= _BumpScale;</span><br><span class="line">                bump.z = sqrt(<span class="number">1.0</span> - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(bump, lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(<span class="number">0</span>, dot(bump, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2022/06/12/unity-render-pipeline-10/" title="Unity Rendering Principles (10) Unity Basic Textures (Normal Textures and Normal Textures)">https://sunra.top/en/2022/06/12/unity-render-pipeline-10/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2022/06/11/operating-system-note-9-process-dispatch/" rel="prev" title="Operating System Learning Notes (3) Process Scheduling, Synchronization/mutual exclusion and Deadlock"><i class="fa fa-chevron-left"></i> Operating System Learning Notes (3) Process Scheduling, Synchronization/mutual exclusion and Deadlock</a></div><div class="post-nav-item"> <a href="/en/2022/06/25/operating-system-note-10-xmind/" rel="next" title="operating system learning notes (ten) operating system knowledge points">operating system learning notes (ten) operating system knowledge points<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2022/06/12/unity-render-pipeline-10/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>