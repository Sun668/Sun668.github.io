<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="In Unity, we use HLSL syntax to write Shader Programs, but initially Unity used CG syntax, so some Unity keyword names (CGPROGRAM) and Enterprise Archive File (.cginc) were used. Although Unity no lon"><meta property="og:type" content="article"><meta property="og:title" content="Unity Rendering Principles (6) Unity HLSL"><meta property="og:url" content="https://sunra.top/en/2022/05/03/unity-render-pipeline-6/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="In Unity, we use HLSL syntax to write Shader Programs, but initially Unity used CG syntax, so some Unity keyword names (CGPROGRAM) and Enterprise Archive File (.cginc) were used. Although Unity no lon"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2022-05-03T07:19:22.000Z"><meta property="article:modified_time" content="2024-06-19T12:52:52.301Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/2022/05/03/unity-render-pipeline-6/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2022/05/03/unity-render-pipeline-6/","path":"2022/05/03/unity-render-pipeline-6/","title":"Unity Rendering Principles (6) Unity HLSL"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity Rendering Principles (6) Unity HLSL | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#preprocessing-instructions-in-hlsl"><span class="nav-number">1.</span> <span class="nav-text">Preprocessing instructions in HLSL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shader-semantics"><span class="nav-number">2.</span> <span class="nav-text">Shader semantics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vertex-shader-input-semantics"><span class="nav-number">2.1.</span> <span class="nav-text">Vertex shader input semantics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#element-shader-output-semantics"><span class="nav-number">2.2.</span> <span class="nav-text">Element shader output semantics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sv_targetn-multiple-rendering-targets"><span class="nav-number">2.3.</span> <span class="nav-text">SV_TargetN: Multiple Rendering Targets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sv_depth-pixel-shader-depth-output"><span class="nav-number">2.4.</span> <span class="nav-text">SV_Depth: Pixel Shader Depth Output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertex-shader-output-and-slice-element-shader-input"><span class="nav-number">2.5.</span> <span class="nav-text">Vertex shader output and slice element shader input</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-special-semantics"><span class="nav-number">2.6.</span> <span class="nav-text">Other special semantics</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#how-to-use-shader-properties"><span class="nav-number">3.</span> <span class="nav-text">How to use shader properties</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#how-to-provide-property-values-to-shaders"><span class="nav-number">3.1.</span> <span class="nav-text">How to provide property values to shaders</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serialization-and-runtime-material-properties"><span class="nav-number">3.2.</span> <span class="nav-text">Serialization and runtime material properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#special-texture-properties"><span class="nav-number">3.3.</span> <span class="nav-text">Special texture properties</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#texture-tiling-and-offset"><span class="nav-number">3.3.1.</span> <span class="nav-text">Texture tiling and offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#texture-size"><span class="nav-number">3.3.2.</span> <span class="nav-text">Texture size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#texture"><span class="nav-number">3.3.3.</span> <span class="nav-text">Texture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#color-space-and-colorvector-shader-data"><span class="nav-number">3.3.4.</span> <span class="nav-text">Color space and color&#x2F;vector shader data</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#providing-vertex-data-to-vertex-programs"><span class="nav-number">4.</span> <span class="nav-text">Providing vertex data to vertex programs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#built-in-macros-variables-helper-functions"><span class="nav-number">5.</span> <span class="nav-text">Built-in macros, variables, helper functions</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2022/05/03/unity-render-pipeline-6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity Rendering Principles (6) Unity HLSL | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity Rendering Principles (6) Unity HLSL</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-05-03 15:19:22" itemprop="dateCreated datePublished" datetime="2022-05-03T15:19:22+08:00">2022-05-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-06-19 20:52:52" itemprop="dateModified" datetime="2024-06-19T20:52:52+08:00">2024-06-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2022/05/03/unity-render-pipeline-6/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2022/05/03/unity-render-pipeline-6/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>In Unity, we use HLSL syntax to write Shader Programs, but initially Unity used CG syntax, so some Unity keyword names (CGPROGRAM) and Enterprise Archive File (.cginc) were used. Although Unity no longer uses Cg, these names are still used.</p><span id="more"></span><p>Put the HLSL code in the Code Block in the ShaderLab code. The shader program usually looks like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    //... General Channel Status Settings...</span><br><span class="line">    </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    //compile instructions for this code snippet, for example:</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">    //The shader program itself</span><br><span class="line">    </span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    //... the rest of the channel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The HLSL language has two syntaxes: the older DirectX 9 style syntax and the more modern DirectX 10 + style syntax. The main difference lies in the way the texture sampling function works:</p><ul><li>Legacy syntax uses sampler2D, tex2D () and similar functions. This syntax works on all platforms.</li><li>The DX10 + syntax uses the Texture2D, SamplerState, and .Sample () functions. Since textures and samplers are not different objects in OpenGL, some forms of this syntax are not valid on the OpenGL platform.</li></ul><h2 id="preprocessing-instructions-in-hlsl"><a class="markdownIt-Anchor" href="#preprocessing-instructions-in-hlsl"></a> Preprocessing instructions in HLSL</h2><p>Internally, shader assembly has multiple stages. The first stage is preprocessing, where a program called “preprocessor” prepares the compiled code. Preprocessor directives are instructions for preprocessors.</p><p>For details, please refer to<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/shader-preprocessor-directives.html">官方文档</a></p><h2 id="shader-semantics"><a class="markdownIt-Anchor" href="#shader-semantics"></a> Shader semantics</h2><p>When writing HLSL shader programs, input and output variables need to express their intent through semantics.</p><p>It should be noted that the semantics of variables are different from the type of variables, such as’float4 vertex: POSITION '. The type of this vertex variable is float4, but its semantics are POSITION, indicating that this variable represents the coordinates of the point in the clipping space</p><h3 id="vertex-shader-input-semantics"><a class="markdownIt-Anchor" href="#vertex-shader-input-semantics"></a> Vertex shader input semantics</h3><p>The primary vertex shader function (represented by the #pragma vertex directive) requires semantics on all input parameters. These correspond to individual mesh data elements such as vertex positions, normal meshes, and texture coordinates. See Vertex Program Inputs for more details.</p><p>Below is an example of a simple vertex shader that takes vertex position and texture coordinates as input. Pixel shaders visualize texture coordinates as colors.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Show UVs&quot;</span><br><span class="line">&#123;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f green (</span><br><span class="line">                Float4 vertex: POSITION,//vertex position input</span><br><span class="line">                Float2 uv: TEXCOORD0//First texture coordinate input</span><br><span class="line">                )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(vertex);</span><br><span class="line">                o.uv = uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return fixed4(i.uv, 0, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="element-shader-output-semantics"><a class="markdownIt-Anchor" href="#element-shader-output-semantics"></a> Element shader output semantics</h3><p>** Typically, chip element (pixel) shaders output colors with SV_Target semantics **. The chip element shader in the example above looks exactly like this:</p><p>fixed4 frag (v2f i) : SV_Target<br> The return type of function frag is fixed4 (low-precision RGBA color). Because it only returns one value, the semantics are indicated by the function itself: SV_Target.</p><p>** It is also possible to return a structure containing output. The above slice element shader can also be rewritten as follows, with exactly the same function **:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct fragOutput &#123;</span><br><span class="line">    fixed4 color : SV_Target;</span><br><span class="line">&#125;;</span><br><span class="line">fragOutput frag (v2f i)</span><br><span class="line">&#123;</span><br><span class="line">    fragOutput o;</span><br><span class="line">    o.color = fixed4(i.uv, 0, 0);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Returning structure from a chip element shader is very useful for shaders that return more than a single color. Other semantics supported by chip element shader output are as follows.</p><h3 id="sv_targetn-multiple-rendering-targets"><a class="markdownIt-Anchor" href="#sv_targetn-multiple-rendering-targets"></a> SV_TargetN: Multiple Rendering Targets</h3><p>SV_Target1, SV_Target2, etc.: These are additional colors written by the shader. This is used when rendering to multiple render targets at once (called “multi-render target” rendering technology, or MRT for short). SV_Target0 equivalent to SV_Target.</p><h3 id="sv_depth-pixel-shader-depth-output"><a class="markdownIt-Anchor" href="#sv_depth-pixel-shader-depth-output"></a> SV_Depth: Pixel Shader Depth Output</h3><p>Typically, slice-element shaders do not overwrite the Z buffer values and use the default values in regular triangle rasterization. However, for some effects, it is useful to output a custom Z buffer depth value per pixel.</p><p>Note that on many GPUs this turns off some deep buffer optimizations, ** so don’t override the Z buffer value without a good reason **. The cost incurred SV_Depth depends on the GPU architecture, but in general is very similar to the cost of Alpha testing (using the built-in clip () function in HLSL). Modify the depth after all regular opaque shaders by rendering shaders (e.g. render queues with AlphaTest).</p><p>The depth output value must be a single float.</p><h3 id="vertex-shader-output-and-slice-element-shader-input"><a class="markdownIt-Anchor" href="#vertex-shader-output-and-slice-element-shader-input"></a> Vertex shader output and slice element shader input</h3><p>The vertex shader needs to output the final clipped spatial position of the vertices so that the GPU knows the rasterized position on the screen and the depth. This output needs to have SV_POSITION semantics and be of type float4.</p><p>** All other outputs (“interpolators” or “variations”) generated by the vertex shader are required by your specific shader **. The values output from the vertex shader will be interpolated on the faces of the rendered triangles, and the value of each pixel will be passed as input to the chip shader.</p><p>Many modern GPUs don’t really care about the semantics of these variables; however, some older systems (most notably Shader Model 2 GPUs on Direct3D 9) have special rules about semantics:</p><p>Semantics such as TEXCOORD0 and TEXCOORD1 are used to indicate arbitrary high-precision data, such as texture coordinates and positions.<br> The COLOR0 and COLOR1 semantics of vertex outputs and slice-element inputs are used for low-precision data in the 0 to 1 range (such as simple color values).<br> For optimal cross-platform support, vertex output and slice-element input should be labeled with TEXCOORDn semantics.</p><p>Limit on the number of interpolators<br> There are some limitations on how many interpolator variables can be used in total to pass information from vertices to slice shaders. The limitations, depending on the platform and GPU, are as follows:</p><p>Up to 8 interpolators: OpenGL ES 2.0 (Android), Direct3D 11 9.x level (Windows Phone), and Direct3D 9 shader model 2.0 (old PC). The number is limited due to interpolators, but each interpolator can be a 4-component vector, so some shaders pack content together so as not to exceed the limit. For example, two textures, coordinates can be passed in a float4 variable (.xy for one coordinate, .zw for the second coordinate).<br> Up to 10 interpolators: Direct3D 9 Shader Model 3.0 (#pragma target 3.0).<br> Up to 16 interpolators: OpenGL ES 3.0 (Android) and Metal (iOS).<br> Up to 32 interpolators: Direct3D 10 Shader Model 4.0 (#pragma target 4.0).<br> Regardless of the specific target hardware, it is generally best to use as few interpolators as possible for performance reasons.</p><h3 id="other-special-semantics"><a class="markdownIt-Anchor" href="#other-special-semantics"></a> Other special semantics</h3><ol><li>Screen space pixel position: VPOS<br> Element shaders can receive the location of pixels rendered as special VPOS semantics. This feature only exists since shader model 3.0, so shaders need to have the #pragma target 3.0 compile directive.</li></ol><p>The base type of screen space location input will vary on different platforms, so for maximum portability, use UNITY_VPOS_TYPE type for it (float4 on most platforms, float2 on Direct3D 9).</p><p>Additionally, using pixel position semantics will make it difficult to have SV_POSITION and VPOS in the same vertex-to-slice meta structure. Vertex shaders should therefore output the clipped spatial position as a separate “out” variable.</p><ol start="2"><li>Facing direction: VFACE<br> Element shaders can receive a variable that indicates whether the rendered surface is facing or facing away from the camera. This is useful when rendering geometry that should be visible from both sides - typically for leaves and similar thin objects. The VFACE semantic input variable will contain positive values representing the front triangle, and negative values representing the back triangle.</li></ol><p>This feature only exists since Shader Model 3.0, so shaders need to have the #pragma target 3.0 compile directive.</p><ol start="3"><li>Vertex ID: SV_VertexID<br> Vertex shaders can receive variables with “vertex numbers” (unsigned integers). This is useful when you want to get additional per-vertex data from textures or ComputeBuffers.</li></ol><p>This feature only exists since DX10 (Shader Model 4.0) and GLCore/OpenGL ES 3, so shaders need to have the #pragma target 3.5 compile directive.</p><h2 id="how-to-use-shader-properties"><a class="markdownIt-Anchor" href="#how-to-use-shader-properties"></a> How to use shader properties</h2><p>Shaders declare material properties in the Properties Code Block. If you want to access some of these properties in the shader program, you need to declare Cg/HLSL variables with the same name and matching type.</p><p>For example, the following shader properties:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_MyColor (&quot;Some Color&quot;, Color) = (1,1,1,1) </span><br><span class="line">_MyVector (&quot;Some Vector&quot;, Vector) = (0,0,0,0) </span><br><span class="line">_MyFloat (&quot;My float&quot;, Float) = 0.5 </span><br><span class="line">_MyTexture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; </span><br><span class="line">_MyCubemap (&quot;Cubemap&quot;, CUBE) = &quot;&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><p>It can be declared for access through the following Cg/HLSL code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixed4 _MyColor;//low precision types are usually sufficient for color</span><br><span class="line">float4 _MyVector;</span><br><span class="line">float _MyFloat; </span><br><span class="line">sampler2D _MyTexture;</span><br><span class="line">samplerCUBE _MyCubemap;</span><br></pre></td></tr></table></figure><p>Cg/HLSL can also accept the uniform keyword, but this keyword is not required.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform float4 _MyColor;</span><br></pre></td></tr></table></figure><p>Property types in ShaderLab map to Cg/HLSL variable types as follows:</p><ul><li>Color and Vector properties map to float4, half4, or fixed4 variables.</li><li>The Range and Float properties map to float, half, or fixed variables.</li><li>For normal (2D) textures, the Texture property maps to the sampler2D variable; the Cubemap maps to samplerCUBE__; and the 3D texture maps to sampler3D__.</li></ul><h3 id="how-to-provide-property-values-to-shaders"><a class="markdownIt-Anchor" href="#how-to-provide-property-values-to-shaders"></a> How to provide property values to shaders</h3><p>Find the value of the shader property in the following locations and provide it to the shader:</p><p>The per-renderer value set in the MaterialPropertyBlock. This is usually “per-instance” data (for example, custom shading colors for many objects that all share the same material).<br> The value set in the Material used on the rendered object.<br> Global shader properties, set by the Unity rendering code itself (see Built-in Shader Variables), or set by your own scripts (such as Shader. SetGlobalTexture).<br> The order of precedence is as above: per-instance data overwrites everything; then material data is used; finally, if shader properties do not exist in these two places, global property values are used. Finally, if shader property values are not defined anywhere, “default values” will be provided (zero for floats, black for colors, white for textures).</p><h3 id="serialization-and-runtime-material-properties"><a class="markdownIt-Anchor" href="#serialization-and-runtime-material-properties"></a> Serialization and runtime material properties</h3><p>Materials can contain both serialized property values and property values set at runtime.</p><p>Serialized data are all properties defined in the Properties Code Block of the shader. Typically, these are values that need to be stored in the material and can be adjusted by the user in the material inspector.</p><p>Materials can also have some properties used by shaders, but not declared in the shader’s Properties Code Block. Usually, this applies to properties set at runtime from script code (for example, through Material. SetColor). Note that matrices and arrays can only exist as non-serialized runtime properties (as they cannot be defined in the Properties Code Block).</p><h3 id="special-texture-properties"><a class="markdownIt-Anchor" href="#special-texture-properties"></a> Special texture properties</h3><p>For each texture set to shader/material properties, Unity also sets some additional information in other vector properties.</p><h4 id="texture-tiling-and-offset"><a class="markdownIt-Anchor" href="#texture-tiling-and-offset"></a> Texture tiling and offset</h4><p>Materials usually have Tiling and Offset fields for their texture properties. This information is passed to the float4 {TextureName} _ST properties in the shader:</p><p>X contains X tile values<br> Y contains Y tile values<br> Z contains X offset values<br> W contains Y offset values<br> For example, if the shader contains a texture named _MainTex, the tile information will be in _MainTex_ST vector.</p><h4 id="texture-size"><a class="markdownIt-Anchor" href="#texture-size"></a> Texture size</h4><p>The {TextureName} _TexelSize - float4 property contains texture size information:</p><p>X contains 1.0/width<br> Y contains 1.0/height<br> Z contains width<br> W contains height</p><h4 id="texture"><a class="markdownIt-Anchor" href="#texture"></a> Texture</h4><p>{TextureName} _HDR - A float4 property that contains information about how to decode potential HDR (e.g. RGBM encoded) textures based on the color space used. See the DecodeHDR function in the UnityCG.cginc shader include file.</p><h4 id="color-space-and-colorvector-shader-data"><a class="markdownIt-Anchor" href="#color-space-and-colorvector-shader-data"></a> Color space and color/vector shader data</h4><p>When using linear color spaces, all material color properties are provided as sRGB colors, but are converted to linear values when passed to shaders.</p><p>For example, if the Properties shader Code Block contains a Color property named “MyColor”, the corresponding “MyColor” HLSL variable will get a linear color value.</p><p>** For properties marked as Float or Vector type, no color space conversion is done by default; instead, they are assumed to contain non-color data **. The [Gamma] attribute can be added to float/vector properties to indicate that they are specified in sRGB space, just like colors</p><h2 id="providing-vertex-data-to-vertex-programs"><a class="markdownIt-Anchor" href="#providing-vertex-data-to-vertex-programs"></a> Providing vertex data to vertex programs</h2><p>For Cg/HLSL vertex programs, mesh vertex data is passed as input to vertices, shader function. Each input needs to have specified semantics: for example, POSITION input represents vertex position, NORMAL represents vertex normal.</p><p>Usually, vertex data inputs are declared in structures, rather than listed one by one. In the UnityCG.cginc include file, several commonly used vertex structures are defined, and in most cases, using them alone is sufficient. These structures are:</p><ul><li>appdata_base: position, normals and a texture coordinate.</li><li>appdata_tan: position, tangent, normal and a texture coordinate.</li><li>appdata_full: position, tangent, normal, four texture coordinates and color.</li></ul><p>To access different vertex data, you need to declare the vertex structure yourself, or add input parameters to the vertex shader. Vertex data is identified by Cg/HLSL semantics and must come from the following list:</p><ul><li>POSITION is the vertex position, usually float3 or float4.</li><li>NORMAL is the vertex normal, usually float3.</li><li>TEXCOORD0 is the first UV coordinate, usually float2, float3, or float4.<br> TEXCOORD1, TEXCOORD2 and TEXCOORD3 are the 2nd, 3rd and 4th UV coordinates respectively.</li><li>TANGENT is a tangent vector (for normal maps), usually float4.</li><li>COLOR is the color per vertex, usually float4.<br> When the mesh data contains fewer components than the vertex shader input requires, the rest is padded with zeros, except for the .w component, which defaults to 1. For example, mesh texture coordinates are usually 2D vectors containing only x and y components. If the vertex shader declares a float4 input using TEXCOORD0 semantics, the value received by the vertex shader will contain (x, y, 0, 1).</li></ul><h2 id="built-in-macros-variables-helper-functions"><a class="markdownIt-Anchor" href="#built-in-macros-variables-helper-functions"></a> Built-in macros, variables, helper functions</h2><p>Unity has built in many common macros for us, such as judging the current platform, many variables, such as the transformation matrix of model space, and some helper functions, such as converting model coordinates to world coordinates.</p><p>For specific information, you can check the official doc:</p><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-BuiltinMacros.html">内置的宏</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-BuiltinFunctions.html">内置的helper函数</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-UnityShaderVariables.html">内置的变量</a></li></ul></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2022/05/03/unity-render-pipeline-6/" title="Unity Rendering Principles (6) Unity HLSL">https://sunra.top/en/2022/05/03/unity-render-pipeline-6/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2022/05/01/unity-render-pipeline-5/" rel="prev" title="Unity Rendering Principle (5) Shader Lab"><i class="fa fa-chevron-left"></i> Unity Rendering Principle (5) Shader Lab</a></div><div class="post-nav-item"> <a href="/en/2022/05/15/unity-render-pipeline-7/" rel="next" title="Unity Rendering Principle (7) Surface Shaders and Shader Graphs">Unity Rendering Principle (7) Surface Shaders and Shader Graphs<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2022/05/03/unity-render-pipeline-6/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>