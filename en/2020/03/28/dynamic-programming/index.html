<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="Recently, I encountered recursion when I was doing the question. I vaguely felt that it was a bit similar to the motion gauge, but I couldn’t explain it clearly, so I found a lot of articles. Here is"><meta property="og:type" content="article"><meta property="og:title" content="Dynamic Programming"><meta property="og:url" content="https://sunra.top/en/2020/03/28/dynamic-programming/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="Recently, I encountered recursion when I was doing the question. I vaguely felt that it was a bit similar to the motion gauge, but I couldn’t explain it clearly, so I found a lot of articles. Here is"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215195409_kdnd5s.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033688/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200116_wqfxvd.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361138/Algorithm/1b4485704cf963fd49d597040ffbb3b5d4d2ca923752c8c78d00042df66343a9_zzg5tk.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361160/Algorithm/7db5a80dbffaf2337c0e0323437442d007987bce16b7fa86affbc5ca0e1132d0_vctecf.jpg"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361182/Algorithm/b4e6cf1bb8e2284bfc01dfef6c1a60c19f9c78238061b65370ccc01822161e83_qgnjw5.jpg"><meta property="article:published_time" content="2020-03-28T01:56:08.000Z"><meta property="article:modified_time" content="2024-10-18T04:27:28.744Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215195409_kdnd5s.png"><link rel="canonical" href="https://sunra.top/en/2020/03/28/dynamic-programming/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2020/03/28/dynamic-programming/","path":"2020/03/28/dynamic-programming/","title":"Dynamic Programming"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Dynamic Programming | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#principle"><span class="nav-number">1.</span> <span class="nav-text">Principle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#example"><span class="nav-number">2.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fibonacci-sequence"><span class="nav-number">2.1.</span> <span class="nav-text">Fibonacci sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#change-problem"><span class="nav-number">2.2.</span> <span class="nav-text">Change problem</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-summary"><span class="nav-number">3.</span> <span class="nav-text">Final summary</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2020/03/28/dynamic-programming/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Dynamic Programming | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Dynamic Programming</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-03-28 09:56:08" itemprop="dateCreated datePublished" datetime="2020-03-28T09:56:08+08:00">2020-03-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2024-10-18 12:27:28" itemprop="dateModified" datetime="2024-10-18T12:27:28+08:00">2024-10-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2020/03/28/dynamic-programming/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2020/03/28/dynamic-programming/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Recently, I encountered recursion when I was doing the question. I vaguely felt that it was a bit similar to the motion gauge, but I couldn’t explain it clearly, so I found a lot of articles. Here is an excerpt of the most basic but also the most clear article. The original link is<a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/">这个</a>。</p><h2 id="principle"><a class="markdownIt-Anchor" href="#principle"></a> Principle</h2><p>The general form of Dynamic Programming problem is to find the best value. Dynamic Programming is actually an optimization method of operations research, but it is more used in computer problems, such as asking you to find the longest increasing sequence, the minimum editing distance, and so on.</p><p>Since it requires the most value, what is the core problem? The core problem of solving Dynamic Programming is exhaustion. Because the most value is required, you must exhaust all feasible answers and then find the most value among them.</p><p>Dynamic Programming is so simple, is it exhaustive? The Dynamic Programming problems I see are all very difficult!</p><p>First of all, the exhaustion of Dynamic Programming is a bit special, because there are “overlapping sub-problems” in this type of problem, and the efficiency will be extremely low if the brute force exhaustion is used, so “memo” or “DP table” is needed to optimize the exhaustion process and avoid unnecessary computation.</p><span id="more"></span><p>Moreover, the Dynamic Programming problem must have an “optimal substructure” in order to pass the most value of the subproblem to the most value of the original problem.</p><p>In addition, although the core idea of Dynamic Programming is to exhaust the maximum value, the problem can be ever-changing, and it is not an easy task to exhaust all feasible solutions. Only by listing the correct “state transition equation” can we correctly exhaust it.</p><p>The overlapping subproblems, optimal substructures, and state transition equations mentioned above are Dynamic Programming Three-factor Verification. What exactly it means will be explained in detail with examples, but in actual algorithm problems, writing state transition equations is the most difficult, which is why many friends find Dynamic Programming problems difficult. Let me provide a thinking framework I have researched to help you think about state transition equations:</p><p>Clear “state” - &gt; define the meaning of dp array/function - &gt; clear “selection” - &gt; clear base case.</p><p>The following explains the basic principles of Dynamic Programming through the Fibonacci sequence problem and the change problem. The former is mainly to let you understand what an overlapping subproblem is (Fibonacci sequence is not strictly a Dynamic Programming problem), and the latter mainly focuses on how to list state transition equations.</p><p>Readers are asked not to dismiss the simplicity of this example. Only simple examples can allow you to fully focus on the general ideas and techniques behind the algorithm, without being confused by those obscure details. For difficult examples, there are historical articles.</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="fibonacci-sequence"><a class="markdownIt-Anchor" href="#fibonacci-sequence"></a> Fibonacci sequence</h3><p>1 The recursion of violence</p><p>The mathematical form of the Fibonacci sequence is recursion, written in code like this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N  <span class="number">1</span> || N  <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(N - <span class="number">1</span>) + <span class="built_in">fib</span>(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Needless to say, school teachers seem to use this example when they talk about recursion. We also know that writing code like this is concise and easy to understand, but it is very inefficient. Where is the inefficiency? Assuming n = 20, please draw a recursion tree.</p><p>PS: Whenever you encounter a problem that requires recursion, it is best to draw a recursion tree, which will be of great help to you in analyzing the complexity of the algorithm and finding the reasons for the inefficiency of the algorithm.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215195409_kdnd5s.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/微信截图_20201215195409_kdnd5s.png"></p><p>How to understand this recursion tree? That is to say, if I want to calculate the original problem f (20), I have to first calculate the sub-problems f (19) and f (18), and then to calculate f (19), I have to first calculate the sub-problems f (18) and f (17), and so on. When you finally encounter f (1) or f (2), the result is known, and you can return the result directly, and the recursion tree will no longer grow downward.</p><p>How to calculate the time complexity of recursion algorithm? The number of subproblems multiplied by the time required to solve a subproblem.</p><p>The number of subproblems, that is, the total number of nodes in the recursion tree. Obviously, the total number of binary tree nodes is exponential, so the number of subproblems is O (2 ^ n).</p><p>The time to solve a subproblem, in this algorithm, there are no loops, only f (n - 1) + f (n - 2) an addition operation, and the time is O (1).</p><p>So, the time complexity of this algorithm is O (2 ^ n), exponential level, explosion.</p><p>Observing the recursion tree, it is obvious to find the reason for the inefficiency of the algorithm: there are a lot of repeated calculations, such as f (18) being calculated twice, and you can see that the recursion tree with f (18) as the root is huge, It will take a lot of time to calculate it again. What’s more, it’s not just the node f (18) that is repeatedly calculated, so this algorithm is extremely inefficient.</p><p>This is the first property of the Dynamic Programming problem: the overlapping subproblem. Below, we find a way to solve this problem.</p><ol start="2"><li>Recursion solution with memo</li></ol><p>If you clarify the problem, you have already solved half of the problem. Since the reason for the time-consuming is repeated calculation, then we can make a “memo” and don’t rush to return after calculating the answer to a certain sub-problem every time, write it down in the “memo” and then return; every time you encounter a sub-problem, go to the “memo” first Check it out. If you find that the problem has been solved before, take out the answer directly and use it instead of spending time calculating.</p><p>Usually an array is used as this “memo”, of course you can also use a hash table (dictionary), the idea is the same.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Memo is all initialized to 0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//initialize the simplest case</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; memo, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (n  <span class="number">1</span> || n  <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//already calculated</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo, n - <span class="number">1</span>) + </span><br><span class="line">                <span class="built_in">helper</span>(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, draw the recursion tree and you’ll know what the memo does.</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033688/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200116_wqfxvd.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033688/origin-of-ray/微信截图_20201215200116_wqfxvd.png"></p><p>In fact, the recursion algorithm with “memo” transforms a recursion tree with huge redundancy into a recursion graph without redundancy by “pruning”, which greatly reduces the number of sub-problems (that is, nodes in the recursion graph).</p><p>How to calculate the time complexity of the recursion algorithm? Multiply the number of subproblems by the time required to solve a subproblem.</p><p>The number of sub-problems, that is, the total number of nodes in the graph, since there is no redundant calculation in this algorithm, the sub-problems are f (1), f (2), f (3)… f (20), and the number is proportional to the input scale n = 20, so the number of sub-problems is O (n).</p><p>The time to solve a subproblem, as above, there is no loop, and the time is O (1).</p><p>Therefore, the time complexity of this algorithm is O (n). Compared with the brute force algorithm, it is a dimensionality reduction blow.</p><p>At this point, the efficiency of the recursion solution with memos is the same as that of the iterative Dynamic Programming solution. In fact, this solution is almost the same as the iterative Dynamic Programming solution, but this method is called “top-down” and Dynamic Programming is called “bottom-up”.</p><p>What is “top-down”? Note that the recursion tree (or graph) we just drew extends from top to bottom, starting from a large-scale original problem such as f (20), gradually decomposing the scale downward, Until f (1) and f (2) reach the bottom, and then return the answer layer by layer, this is called “top-down”.</p><p>What is “bottom-up”? In turn, we directly start from the bottom, the simplest, and the smallest problem size f (1) and f (2), and push up until we reach the answer f (20) we want. This is the idea of Dynamic Programming, which is why Dynamic Programming generally deviates from recursion, but completes the calculation by loop iteration.</p><ol start="3"><li>Iterative solution of dp array</li></ol><p>With the inspiration of the previous “memo”, we can separate this “memo” into a table, called DP table, on this table to complete the “bottom-up” calculation is not beautiful!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361138/Algorithm/1b4485704cf963fd49d597040ffbb3b5d4d2ca923752c8c78d00042df66343a9_zzg5tk.jpg" alt></p><p>Drawing a picture is easy to understand, and you find that this DP table is very similar to the result after the “pruning” before, but the other way around. In fact, the “memo” in the recursion solution with memos is the DP table after the final completion, so the two solutions are actually similar, and in most cases, the efficiency is basically the same.</p><p>Here, the term “state transition equation” is introduced, which is actually a mathematical form describing the structure of the problem:</p><p>f(n) = 1, n = 1, 2</p><p>f(n) = f(n -1) + f(n -2), n &gt;2</p><p>Why is it called the “state transition equation”? To sound high-end. You think of f (n) as a state n, which is transferred from the addition of state n - 1 and state n - 2, which is called state transition, nothing more.</p><p>You will find that all operations in the above several solutions, such as return f (n - 1) + f (n - 2), dp [i] = dp [i - 1] + dp [i - 2], and The initialization operation of the memo or DP table revolves around different representations of this equation. You can see the importance of listing the “state transition equation”, which is the core of solving the problem. It is easy to find that in fact, the state transition equation directly represents a brute force solution.</p><p>Never look down on the brute force solution. The most difficult thing about Dynamic Programming problems is to write the state transition equation, that is, the brute force solution. The optimization method is nothing more than using memos or DP tables, and there is no mystery at all.</p><p>At the end of this example, let’s talk about a detailed optimization. Careful readers will find that according to the state transition equation of the Fibonacci sequence, the current state is only related to the previous two states. In fact, it is not necessary to have such a long DP table to store all the states, just find a way to store the previous two states. Therefore, it can be further optimized to reduce the space complexity to O (1):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n  <span class="number">2</span> || n  <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Some people may ask, why is another important feature of Dynamic Programming, “optimal substructure”, not covered? It will be covered below. The Fibonacci sequence example is not strictly Dynamic Programming, because it does not involve finding the maximum value. The above is intended to demonstrate the process of spiraling up algorithm design. Next, look at the second example, the change problem.</p><h3 id="change-problem"><a class="markdownIt-Anchor" href="#change-problem"></a> Change problem</h3><p>Let’s take a look at the question first: Give you k kinds of coins with face value, the face value is c1, c2… ck, the number of each coin is unlimited, then give a total amount amount, and ask you how many coins you need at least to make up this amount, if it is impossible to make up, the algorithm returns -1. The function signature of the algorithm is as follows:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coins is the optional coin face value, amount is the target amount</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure><p>For example, k = 3, the face value is 1, 2, and 5 respectively, and the total amount = 11. Then at least 3 coins are needed to make up, that is, 11 = 5 + 5 + 1.</p><p>How do you think computers should solve this problem? Obviously, it is to exhaust all possible methods of coin collection, and then find out how many coins are needed at least.</p><p>1 The recursion of violence</p><p>First of all, this problem is a Dynamic Programming problem because it has an “optimal substructure”. To meet the “optimal substructure”, the subproblems must be independent of each other. What does independence mean? You definitely don’t want to see a mathematical proof, I’ll use an intuitive example to explain.</p><p>For example, your original question is to get the highest total score, then your sub-question is to get the highest Chinese test and the highest math test… In order to get the highest score in each class, you have to get the highest score for the corresponding multiple-choice questions in each class, and the highest score for fill-in-the-blank questions… Of course, in the end, you will get full marks in each class, which is the highest total score.</p><p>The correct result is obtained: the highest total score is the total score. Because this process conforms to the optimal substructure, the sub-problems of “highest in each subject” are independent of each other and do not interfere with each other.</p><p>However, if you add a condition: your Chinese score and math score will restrict each other, and the other will increase. In this case, it is obvious that the highest total score you can get will not reach the total score, and you will get the wrong result according to the idea just now. Because the sub-problems are not independent, the Chinese and math scores cannot be optimal at the same time, so the optimal substructure is destroyed.</p><p>Back to the coin-making problem, why is it said to conform to the optimal substructure? For example, if you want to find the minimum number of coins when amount = 11 (the original problem), if you know the minimum number of coins (the sub-problem) to make up amount = 10, you only need to add one to the answer to the sub-problem (choose another coin with a face value of 1) is the answer to the original problem, because the number of coins is unlimited, and there is no reciprocity between sub-problems, they are independent of each other.</p><p>So, now that you know this is a Dynamic Programming problem, you need to think about how to list the correct state transition equations?</p><p>First, determine the “state”, which is the variable that changes in the original problem and sub-problems. Since the number of coins is unlimited, the only state is the target amount.</p><p>Then determine the definition of the dp function: the current target amount is n, and at least dp (n) coins are required to make up the amount.</p><p>Then determine the “choice” and select the best, that is, for each state, what choice can be made to change the current state. Specific to this problem, no matter what the target amount is, the choice is to select a coin from the denomination list coins, and the target amount will be reduced:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pseudo-code framework</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span><br><span class="line">    Definition <span class="comment"># : To make up an amount of n, at least dp (n) coins are required</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment">#  make a choice, choose the outcome that requires the least amount of coins</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = <span class="built_in">min</span> (res, <span class="number">1</span> + dp (n - corner))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment">#  the question we are asking is dp (amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>Finally, clear the base case, obviously when the target amount is 0, the number of coins required is 0; when the target amount is less than 0, no solution, return -1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n  <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#  minimum, so initialize to positive infinity</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment">#  unsolved sub-problem, skip</span></span><br><span class="line">            <span class="keyword">if</span> subproblem  -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>At this point, the state transition equation has actually been completed, the above algorithm is already a violent solution, and the mathematical form of the above code is the state transition equation:</p><p>dp(n) = 0, n = 0</p><p>dp(n) = -1, n &lt; 0</p><p>dp(n) = min{dp(n - coin) + 1 | coin ∈ coins}, n &gt; 0</p><p>At this point, this problem is actually solved, but we need to eliminate the overlapping sub-problem. For example, when amount = 11, coins = {1,2,5}, draw a recursion tree to see:</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361160/Algorithm/7db5a80dbffaf2337c0e0323437442d007987bce16b7fa86affbc5ca0e1132d0_vctecf.jpg" alt></p><p>Time complexity analysis: total number of sub-problems x the time of each sub-problem.</p><p>The total number of subproblems is the number of recursion tree nodes, which is difficult to see. It is O (n ^ k), which is exponential in short. Each subproblem contains a for loop with complexity O (k). So the total time complexity is O (k * n ^ k), exponential.</p><ol start="2"><li>Recursion with memo</li></ol><p>With just a few modifications, you can eliminate sub-problems through memos.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="comment">#  memo</span></span><br><span class="line">    memo = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="comment">#  check memos to avoid double counting</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="keyword">if</span> n  <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                subproblem = dp(n - coin)</span><br><span class="line">                <span class="keyword">if</span> subproblem  -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#  in the memo</span></span><br><span class="line">            memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>Without drawing the picture, it is obvious that the “memo” greatly reduces the number of sub-problems and completely eliminates the redundancy of sub-problems, so the total number of sub-problems will not exceed the number of amounts n, that is, the number of sub-problems is O (n). The time to process a sub-problem remains the same, still O (k), so the total time complexity is O (kn).</p><ol start="3"><li>Iterative solution of dp array</li></ol><p>Of course, we can also use dp table from bottom to top to eliminate overlapping sub-problems. The definition of dp array is similar to that of dp function just now, and the definition is the same:</p><p>DP [i] = x means that at least x coins are needed when the target amount is i.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//The array size is amount + 1, and the initial value is also amount + 1.</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//the inner for is finding the minimum value of + 1 for all subproblems</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">//The sub-problem is unsolved, skip it.</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount]  amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361182/Algorithm/b4e6cf1bb8e2284bfc01dfef6c1a60c19f9c78238061b65370ccc01822161e83_qgnjw5.jpg" alt></p><p>PS: Why is the dp array initialized to amount + 1, because the number of coins that make up the amount can only be equal to amount at most (all 1 yuan face value coins), so initializing to amount + 1 is equivalent to initializing to positive infinity, which is convenient for subsequent Take the minimum value.</p><h2 id="final-summary"><a class="markdownIt-Anchor" href="#final-summary"></a> Final summary</h2><p>The first Fibonacci sequence problem explained how to optimize recursion trees using the “memo” or “dp table” method, and made it clear that these two methods are essentially the same, only top-down and bottom-up It’s just different.</p><p>The second change problem shows how to determine the “state transition equation” in a streamlined manner. As long as the violent recursion solution is written through the state transition equation, the rest is to optimize the recursion tree and eliminate overlapping sub-problems.</p><p>If you don’t know much about Dynamic Programming, you can still see it here. I really applaud you. I believe you have mastered the design skills of this algorithm.</p><p>In fact, there is no magic trick for computers to solve problems. Its only solution is to exhaust all possibilities. Algorithm design is nothing more than thinking about “how to exhaust” first, and then pursuing “how to exhaust intelligently”.</p><p>To list the dynamic transfer equations was to solve the problem of “how to exhaust”. The reason why it was difficult was because many exhaustions required recursion, and because some problems had complex solution spaces, it was not easy to exhaust them completely.</p><p>Memos and DP tables are pursuing “how to exhaust intelligently”. The idea of exchanging space for time is the only way to reduce the complexity of time. In addition, what else can you do?</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2020/03/28/dynamic-programming/" title="Dynamic Programming">https://sunra.top/en/2020/03/28/dynamic-programming/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2020/03/28/backtracking-algorithm/" rel="prev" title="Backtracking Algorithm"><i class="fa fa-chevron-left"></i> Backtracking Algorithm</a></div><div class="post-nav-item"> <a href="/en/2020/03/29/multisource-bfs/" rel="next" title="Multi-source Breadth First Search">Multi-source Breadth First Search<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2020/03/28/dynamic-programming/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>