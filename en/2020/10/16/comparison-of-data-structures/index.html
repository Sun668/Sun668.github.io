<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png"><link rel="mask-icon" href="/en/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/en/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/en/","images":"/en/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/en/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="** For a computer, it only knows how to use memory addresses to access variables in memory. We have artificially separated two storage forms, one is continuous storage (that is, arrays), and the other"><meta property="og:type" content="article"><meta property="og:title" content="Comparison of Several Basic Data Structures"><meta property="og:url" content="https://sunra.top/en/2020/10/16/comparison-of-data-structures/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="** For a computer, it only knows how to use memory addresses to access variables in memory. We have artificially separated two storage forms, one is continuous storage (that is, arrays), and the other"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2020-10-16T11:02:50.000Z"><meta property="article:modified_time" content="2025-01-24T05:50:52.431Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="Technology Sharing Using Tutorials Principles Front End Computer Graphics"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/en/2020/10/16/comparison-of-data-structures/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sunra.top/en/2020/10/16/comparison-of-data-structures/","path":"2020/10/16/comparison-of-data-structures/","title":"Comparison of Several Basic Data Structures"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Comparison of Several Basic Data Structures | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/en/js/third-party/analytics/google-analytics.js"></script><script src="/en/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/en/css/noscript.css"></noscript><link rel="alternate" href="/en/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/en/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Lift the fog of the Internet together</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-data-structure"><span class="nav-number">1.</span> <span class="nav-text">What is Data Structure?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#how-to-choose-to-design-a-data-structure"><span class="nav-number">2.</span> <span class="nav-text">How to choose to design a data structure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arrays-and-linked-lists"><span class="nav-number">3.</span> <span class="nav-text">Arrays and linked lists</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue"><span class="nav-number">4.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack"><span class="nav-number">5.</span> <span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jump-table"><span class="nav-number">6.</span> <span class="nav-text">Jump table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash-table"><span class="nav-number">7.</span> <span class="nav-text">Hash table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tree"><span class="nav-number">8.</span> <span class="nav-text">Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-search-tree"><span class="nav-number">8.1.</span> <span class="nav-text">Binary search tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#balanced-binary-search-tree"><span class="nav-number">8.2.</span> <span class="nav-text">Balanced binary search tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-complete-binary-tree"><span class="nav-number">8.3.</span> <span class="nav-text">Heap (complete binary tree)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#figure"><span class="nav-number">9.</span> <span class="nav-text">Figure</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">Lift the fog of the Internet together</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/en/archives/"><span class="site-state-item-count">268</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/en/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sunra.top/en/2020/10/16/comparison-of-data-structures/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="Lift the fog of the Internet together"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Comparison of Several Basic Data Structures | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Comparison of Several Basic Data Structures</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-10-16 19:02:50" itemprop="dateCreated datePublished" datetime="2020-10-16T19:02:50+08:00">2020-10-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2025-01-24 13:50:52" itemprop="dateModified" datetime="2025-01-24T13:50:52+08:00">2025-01-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/en/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/en/2020/10/16/comparison-of-data-structures/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/en/2020/10/16/comparison-of-data-structures/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>** For a computer, it only knows how to use memory addresses to access variables in memory. We have artificially separated two storage forms, one is continuous storage (that is, arrays), and the other is chained storage (linked lists). As for other data structures, they are actually the use of these two storage forms. Any data structure can be implemented in two storage forms, only the question of whether it is suitable or not, and there is no question of whether it is possible or not, because in the end, the memory address is used to access the memory. Queue, stack we usually use arrays to achieve, but can also use linked lists, such as trees we use linked lists in most cases, but in fact, like a complete binary tree array to achieve no problem.</p><p>This blog is mainly to analyze what features of data structures we need in these cases through some examples. In order to better meet these features, we need to use arrays or linked lists to implement. ** For all the content, I will not go into detail, let alone the specific implementation, because they are very basic, but if we really want to develop it, it will become a long talk. We mainly look at them from a higher level. some features.</p><span id="more"></span><h2 id="what-is-data-structure"><a class="markdownIt-Anchor" href="#what-is-data-structure"></a> What is Data Structure?</h2><p>I personally believe that data structures can be divided into two parts.</p><p>One is the storage structure of data, that is, sequential storage or chain storage.</p><p>One is the logical structure of data, the special relationship between a set of data of the same type, and a series of special additions, deletions, and changes defined to maintain this relationship.</p><h2 id="how-to-choose-to-design-a-data-structure"><a class="markdownIt-Anchor" href="#how-to-choose-to-design-a-data-structure"></a> How to choose to design a data structure</h2><p>Different data structures are suitable for different scenarios. The continuity of arrays allows us to efficiently access randomly, but insertion and deletion are time-consuming and troublesome to expand. Although linked lists cannot be efficiently accessed randomly, insertion and deletion are very simple. There is no such thing as expansion. When we design data structures, we repeatedly use these two points to make a fuss.</p><p>For example, zipped hash tables use hash functions to quickly obtain array subscripts, and then use linked lists to achieve quick insertion and deletion.</p><p>For example, using the heap (a complete binary tree) to simplify the O (n) of the linked list search to O (logn) and so on.</p><p>Our usual thinking process for choosing a data structure should be like this:</p><ul><li><p>What kind of algorithm do we need to choose in this scenario? For example, anti-Poland requires first-in and then-out</p></li><li><p>What characteristics of the data structure does this algorithm need? If you only need to push and exit the stack, then choose the stack.</p></li><li><p>According to our specific needs, whether we need frequent expansion and contraction, whether we have high requirements on access time, etc. ** Choose the appropriate storage method for data structure **.</p></li></ul><p>In fact, this process is the opposite of the process of data structure generation.</p><p>** Whether it is an array or a linked list, for the computer, the memory address is used to access the data in the memory **, but the memory address of the array is continuous, so we can directly calculate the first address plus the offset The memory address of the data to be accessed, while the memory address of the linked list is discontinuous, each node in the linked list needs to record the memory address of the next node, rather than calculating the offset.</p><p>Therefore, array or linked list is actually a different form of utilization of computer storage space.</p><p>And ** different data structures can be said that we give some special relationships between these same types of data, these relationships can help our algorithm execute more efficiently, so special insertion and deletion methods are needed to maintain this relationship **. For example, an array that can only be FIFO is called a queue, and the left sub-node must be less than the parent node, and the right child node is greater than the parent node, we call it a binary search tree.</p><h2 id="arrays-and-linked-lists"><a class="markdownIt-Anchor" href="#arrays-and-linked-lists"></a> Arrays and linked lists</h2><p>Arrays and linked lists are not only two ways to store data in computer memory, but also the most basic data structures used for the most basic data storage.</p><h2 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h2><p>The characteristic of the queue is first-in, first-out (FIFO). Its operation is to enter and leave the queue. Entering the queue is to add an item at the end of the queue, and leaving the queue is to pop up an item from the head of the queue.</p><p>For example, EventLoop in our JavaScript or nextTick in Vue are all in this form.</p><p>After each event is triggered, the callback function is put into a queue, and then the loop is continuously traversed from the beginning of the queue, and the callback function is taken out from the head to execute.</p><p>When we need to apply the first-in-first-out feature, we can use the data structure of queues.</p><p>The implementation of queues, using arrays and linked lists, is no problem. Normally, its insertion and deletion only require O (1).</p><p>However, if the array is used to achieve, due to the characteristics of the continuous memory of the array, we must specify the size of the array in advance, and then apply for a continuous memory, so if the length of the queue needs to exceed the initial queue length, then there is an expansion problem, we need to apply for a larger piece of memory, then copy the data, and then go back to release this piece of memory, this time the time complexity of insertion will become O (n).</p><p>If a linked list is used, there will be no expansion problem, because its memory is discontinuous, and we can apply for memory for the enlisted data separately when enqueuing. But because its memory is discontinuous, there is no way to calculate the address of each node by adding the first address and offset, so we need extra space to record the address of each node, that is, each node has to record the address of the next node.</p><p>So whether to use an array or a linked list depends on the specific needs. If the queue length is fixed or does not change much, it is better to use an array, because the continuous Memory Space is more friendly for caching, but if the queue length will continue to change, the data that needs to be stored It also requires much more space than a pointer. In fact, a linked list is better.</p><p>For other content about the queue, you can go to my other article<a href="https://sunra.top/posts/8a7b9568/">关于队列的文章</a></p><h2 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h2><p>The characteristic of the stack is that it is first in and then out. Its operation is to enter and exit the stack. Entering the stack can also be called pushing the stack, which is to push an item from the stack top, and leaving the stack is to pop an item from the stack top, that is, entering the stack and leaving the stack. The stack is from the same head.</p><p>For example, the one above leetcode<a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a>Its solution idea is the application of a very classic stack.</p><p>Similarly, the implementation of the stack can also be implemented with arrays or linked lists.</p><p>There is no more analysis about the stack. In fact, it is similar to the queue.</p><h2 id="jump-table"><a class="markdownIt-Anchor" href="#jump-table"></a> Jump table</h2><p>We also said above that the problem with chaining is that the time complexity for random access is O (n).</p><p>Even if the data in the linked list is already sorted from small to large, it is impossible to use dichotomy to find the required data in O (logn) time complexity like arrays.</p><p>In response to this problem, the classic space-for-time in the computer field has come. We can extract the first node up every k nodes to form a new linked list, and save a new pointer pointing to the original node in the extracted node.</p><p>In this way, we extract layer by layer until there is only one node left in a certain layer.</p><p>This time we go to find a data, you can first compare from the top, if greater than the current node value, put the pointer down one layer, and then compare back to find the last node is less than it, and then sink, until the last layer.</p><p>In this way, the time complexity of the search will drop to the logarithm of n with base k.</p><p>We often say that the Redis database uses jump tables.</p><h2 id="hash-table"><a class="markdownIt-Anchor" href="#hash-table"></a> Hash table</h2><p>About the introduction of hash tables, you can take a look at my article first.<a href="https://sunra.top/posts/9f1a9cb/">关于散列表的文章</a></p><p>After reading, we can probably summarize that the hash table can be just an array. The most important feature it utilizes is that the array can perform random access in O (1) time complexity according to the subscript, and calculate the data through the hash function. The subscript position of storage, but due to the pigeon cage principle (n + 1 pigeons are placed in n cages, there must be more than one pigeon in a cage), even if your hash function is well designed, hash conflicts are inevitable.</p><p>Then we have to find a way to solve the hash conflict, one is open addressing method, find another vacancy in the hash table through other methods, and the other is to use the characteristics of the linked list, use the zipper method, each item in the hash table is actually It is the head node of a linked list, and every time data is inserted in the linked list.</p><p>The zipper method combines the characteristics of arrays and linked lists well. First, the hash function is used to calculate the hash table subscript that the data should exist, and the advantage of random access in the array is used to quickly find the linked list that should exist, and then find or insert it in the linked list. As long as our hash function is well designed, the average length of this zipper will not be too long, and the time complexity can also be considered O (1).</p><h2 id="tree"><a class="markdownIt-Anchor" href="#tree"></a> Tree</h2><p>So far, we may feel that the hash table has been able to support our needs very well. Why do we still need trees?</p><p>Here we will talk about a few limitations of hash tables:</p><ul><li>The data in the hash is unordered, which means that if we want to find a specific value, the hash works well, but if we want to find all the data in a range, the hash table will not work</li><li>The hash function is difficult to design, so the performance of the hash table is very unstable, and if it involves expansion and contraction, it is more troublesome.</li><li>In order to avoid hash conflicts as much as possible, the load factor cannot be too large, so there will be some wasted space.</li></ul><h3 id="binary-search-tree"><a class="markdownIt-Anchor" href="#binary-search-tree"></a> Binary search tree</h3><p>For the first limitation just mentioned, we can use binary search tree (BST) to achieve</p><p>Binary Search Tree is born to achieve fast search. However, it not only supports fast search of a data, but also supports fast insertion and deletion of a data. How does it do this? These all depend on the special structure of Binary Search Tree. Binary Search Tree requires that any node in the tree, the value of each node in its left subtree is less than the value of this node, while the value of the right subtree node is greater than the value of this node.</p><p>In addition to insert, delete, and find operations, Binary Search Tree also supports fast search for the largest and smallest nodes, precursor nodes, and successor nodes. I won’t show these operations one by one. I will put the corresponding code on GitHub, you can implement it yourself first, and then go to it to see. In addition to supporting the above operations, Binary Search Tree has an important feature, which is to traverse the Binary Search Tree in order, which can output an ordered data series with O (n) time complexity, which is very efficient. Therefore, Binary Search Tree is also called binary sorted tree.</p><h3 id="balanced-binary-search-tree"><a class="markdownIt-Anchor" href="#balanced-binary-search-tree"></a> Balanced binary search tree</h3><p>The binary search tree mentioned above also looks good, but there are still problems. Suppose we have 1-9 nine trees, it is very likely that through a series of insert and delete operations, it will become a left sub-node from the root node to 0, then at this time the binary search tree will become a linked list, and the efficiency will be drastically degraded to O (n).</p><p>So we need to try to ensure that the height difference between the left and right subtrees is not too large, which leads to a balanced binary tree: the height difference between the left and right subtrees of any node in the binary tree cannot be greater than 1.</p><p>If our BST is still a balanced binary tree, it can solve the above problem very well.</p><p>Of course, what we may use in practice is ** Red-Black Tree **, an approximately balanced binary tree.</p><h3 id="heap-complete-binary-tree"><a class="markdownIt-Anchor" href="#heap-complete-binary-tree"></a> Heap (complete binary tree)</h3><p>A heap is a special kind of tree. Let’s take a look now, what kind of tree is a heap.</p><p>I listed two requirements, as long as these two points are met, it is a heap.</p><ul><li><p>The heap is a complete binary tree;</p></li><li><p>The value of each node in the heap must be greater than or equal to (or less than or equal to) the value of each node in its child tree.</p></li></ul><p>The first point is that the heap must be a complete binary tree. Remember the definition of a complete binary tree we talked about before? A complete binary tree requires that, except for the last layer, the number of nodes in all layers is full, and the nodes in the last layer are aligned to the left.</p><p>Second, each node in the heap must have a value greater than or equal to (or less than or equal to) the value of each node in its subtree. In fact, we can also put it another way, the value of each node in the heap is greater than or equal to (or less than or equal to) the values of its left and right sub-nodes. These two statements are equivalent.</p><p>For the heap where the value of each node is greater than or equal to the value of each node in the subtree, we call it “big top heap”. For the heap where the value of each node is less than or equal to the value of each node in the subtree, we call it “small top heap”.</p><p>For heap applications, it is very common to recommend keywords for TopK.</p><p>For this requirement, we can maintain a small top heap with a node number of K, and then traverse the number of keyword occurrences in turn. If the number of occurrences is less than the root node, it will continue, and if it is greater than the heap operation.</p><h2 id="figure"><a class="markdownIt-Anchor" href="#figure"></a> Figure</h2><p>Since a new data structure has emerged, there must be some problems that the above data structure cannot support well.</p><p>As another nonlinear data structure besides trees, the relationships that can be expressed in graphs are intersecting, and the relationships between nodes are not necessarily parent-child relationships.</p><p>For example, in our social network, everyone is a node. If there is a relationship between the two, they will be connected. This relationship cannot be expressed by trees.</p><p>Of course, the storage of the graph can also use arrays or linked lists. For arrays, we can use adjacency matrices, and for linked lists, we can use adjacency lists</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/en/2020/10/16/comparison-of-data-structures/" title="Comparison of Several Basic Data Structures">https://sunra.top/en/2020/10/16/comparison-of-data-structures/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/en/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/en/2020/10/12/hash-table/" rel="prev" title="Design and Application of Hash Table"><i class="fa fa-chevron-left"></i> Design and Application of Hash Table</a></div><div class="post-nav-item"> <a href="/en/2020/10/24/string-matching-algorithm/" rel="next" title="string matching algorithm study notes">string matching algorithm study notes<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/en/js/comments.js"></script><script src="/en/js/utils.js"></script><script src="/en/js/motion.js"></script><script src="/en/js/schemes/muse.js"></script><script src="/en/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/en/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/en/2020/10/16/comparison-of-data-structures/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>