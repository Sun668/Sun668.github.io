<!DOCTYPE html>
<html lang>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunra.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在内置渲染管线中，表面着色器是编写与光照交互的着色器的一种简化方式。 编写与光照交互的着色器非常复杂。有不同的光源类型，不同的阴影选项，不同的渲染路径（前向和延迟渲染）；着色器应该以某种方式应对所有这些复杂性。 表面着色器是一种代码生成方法，与使用低级顶点/像素着色器程序相比，可以更轻松地编写光照着色器。">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 渲染原理（七）表面着色器与Shader Graph">
<meta property="og:url" content="https://sunra.top/2022/05/15/unity-render-pipeline-7/index.html">
<meta property="og:site_name" content="Origin of Ray">
<meta property="og:description" content="在内置渲染管线中，表面着色器是编写与光照交互的着色器的一种简化方式。 编写与光照交互的着色器非常复杂。有不同的光源类型，不同的阴影选项，不同的渲染路径（前向和延迟渲染）；着色器应该以某种方式应对所有这些复杂性。 表面着色器是一种代码生成方法，与使用低级顶点/像素着色器程序相比，可以更轻松地编写光照着色器。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg">
<meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652600532/origin-of-ray/20018137-d2ff6da2b4e91a45.jpg_sdysuu.webp">
<meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652579914/origin-of-ray/screenshot-20220515-095732_izsvgx.png">
<meta property="og:updated_time" content="2022-05-21T00:16:36.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unity 渲染原理（七）表面着色器与Shader Graph">
<meta name="twitter:description" content="在内置渲染管线中，表面着色器是编写与光照交互的着色器的一种简化方式。 编写与光照交互的着色器非常复杂。有不同的光源类型，不同的阴影选项，不同的渲染路径（前向和延迟渲染）；着色器应该以某种方式应对所有这些复杂性。 表面着色器是一种代码生成方法，与使用低级顶点/像素着色器程序相比，可以更轻松地编写光照着色器。">
<meta name="twitter:image" content="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg">

<link rel="canonical" href="https://sunra.top/2022/05/15/unity-render-pipeline-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>Unity 渲染原理（七）表面着色器与Shader Graph | Origin of Ray</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Origin of Ray</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://sunra.top/2022/05/15/unity-render-pipeline-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
      <meta itemprop="name" content="Ray Sun">
      <meta itemprop="description" content="拨开互联网的迷雾">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Origin of Ray">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Unity 渲染原理（七）表面着色器与Shader Graph
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-15 09:26:47" itemprop="dateCreated datePublished" datetime="2022-05-15T09:26:47+08:00">2022-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-21 08:16:36" itemprop="dateModified" datetime="2022-05-21T08:16:36+08:00">2022-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在内置渲染管线中，表面着色器是编写与光照交互的着色器的一种简化方式。</p>
<p>编写与光照交互的着色器非常复杂。有不同的光源类型，不同的阴影选项，不同的渲染路径（前向和延迟渲染）；着色器应该以某种方式应对所有这些复杂性。</p>
<p>表面着色器是一种代码生成方法，与使用低级顶点/像素着色器程序相比，可以更轻松地编写光照着色器。</p>
<a id="more"></a>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>您可以定义一个“表面函数”，它将您需要的所有 UV 或数据作为输入，并填充输出结构 SurfaceOutput。SurfaceOutput 基本上描述了<em>表面的属性</em>（反照率颜色、法线、发光、镜面反射等）。<strong>需要使用 HLSL 编写此代码</strong>。</p>
<p>表面着色器编译器随后计算出需要的输入、填充的输出等等，并生成实际的顶点和像素着色器以及渲染通道来处理前向和延迟渲染。</p>
<h3 id="表面着色器的标准输出结构："><a href="#表面着色器的标准输出结构：" class="headerlink" title="表面着色器的标准输出结构："></a>表面着色器的标准输出结构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutput</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 Albedo;  // 漫射颜色</span><br><span class="line">    fixed3 Normal;  // 切线空间法线（如果已写入）</span><br><span class="line">    fixed3 Emission;</span><br><span class="line">    half Specular;  // 0..1 范围内的镜面反射能力</span><br><span class="line">    fixed Gloss;    // 镜面反射强度</span><br><span class="line">    fixed Alpha;    // 透明度 Alpha</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Unity 5 中，表面着色器还可以使用基于物理的光照模型。内置标准光照模型和标准镜面反射光照模型（见下文）分别使用以下输出结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct SurfaceOutputStandard</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 Albedo;      // 基础（漫射或镜面反射）颜色</span><br><span class="line">    fixed3 Normal;      // 切线空间法线（如果已写入）</span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Metallic;      // 0=非金属，1=金属</span><br><span class="line">    half Smoothness;    // 0=粗糙，1=平滑</span><br><span class="line">    half Occlusion;     // 遮挡（默认为 1）</span><br><span class="line">    fixed Alpha;        // 透明度 Alpha</span><br><span class="line">&#125;;</span><br><span class="line">struct SurfaceOutputStandardSpecular</span><br><span class="line">&#123;</span><br><span class="line">    fixed3 Albedo;      // 漫射颜色</span><br><span class="line">    fixed3 Specular;    // 镜面反射颜色</span><br><span class="line">    fixed3 Normal;      // 切线空间法线（如果已写入）</span><br><span class="line">    half3 Emission;</span><br><span class="line">    half Smoothness;    // 0=粗糙，1=平滑</span><br><span class="line">    half Occlusion;     // 遮挡（默认为 1）</span><br><span class="line">    fixed Alpha;        // 透明度 Alpha</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="表面着色器输入结构"><a href="#表面着色器输入结构" class="headerlink" title="表面着色器输入结构"></a>表面着色器输入结构</h2><p>输入结构 Input 通常具有着色器所需的所有纹理坐标。纹理坐标必须命名为“uv”后跟纹理名称的形式（如果要使用第二个纹理坐标集，则以“uv2”开头）。</p>
<p>可以放入输入结构的其他值：</p>
<ul>
<li>float3 viewDir - 包含视图方向，用于计算视差效果、边缘光照等等。</li>
<li>具有 COLOR 语义的 float4 - 包含插值的每顶点颜色。</li>
<li>float4 screenPos - 包含反射或屏幕空间效果的屏幕空间位置。请注意，这不适合 GrabPass；您需要使用 ComputeGrabScreenPos 函数自己计算自定义 UV。</li>
<li>float3 worldPos - 包含世界空间位置。</li>
<li>float3 worldRefl - 在<em>表面着色器不写入 o.Normal</em> 的情况下，包含世界反射矢量。有关示例，请参阅反光漫射 (Reflect-Diffuse) 着色器。</li>
<li>float3 worldNormal - 在<em>表面着色器不写入 o.Normal</em> 的情况下，包含世界法线矢量。</li>
<li>float3 worldRefl; INTERNAL<em>DATA - 在</em>表面着色器写入 o.Normal_ 的情况下，包含世界反射矢量。要获得基于每像素法线贴图的反射矢量，请使用 WorldReflectionVector (IN, o.Normal)。有关示例，请参阅反光凹凸 (Reflect-Bumped) 着色器。</li>
<li>float3 worldNormal; INTERNAL<em>DATA - 在</em>表面着色器写入 o.Normal_ 的情况下，包含世界法线矢量。要获得基于每像素法线贴图的法线矢量，请使用 WorldNormalVector (IN, o.Normal)。</li>
</ul>
<h2 id="表面着色器编译指令"><a href="#表面着色器编译指令" class="headerlink" title="表面着色器编译指令"></a>表面着色器编译指令</h2><p>就像任何其他着色器一样，表面着色器放置在 CGPROGRAM..ENDCG 代码块内。不同之处在于：</p>
<p><strong>它必须放在 SubShader 代码块内，不能在 Pass 内。表面着色器本身将编译为多个通道</strong>。<br>它使用 #pragma surface … 指令来指示自己是表面着色器。<br><code>#pragma surface</code> 指令为：</p>
<p><code># pragma surface surfaceFunction lightModel [optionalparams]</code></p>
<h3 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h3><ul>
<li>surfaceFunction - 具有表面着色器代码的 Cg 函数。该函数的格式应为 void surf (Input IN, inout SurfaceOutput o)，其中 Input 是您定义的结构。Input 应包含表面函数所需的任何纹理坐标和额外自动变量。</li>
<li>lightModel - 要使用的光照模型。内置光照模型是基于物理的 Standard 和 StandardSpecular，以及简单的非基于物理的 Lambert（漫射）和 BlinnPhong（镜面反射）。请参阅自定义光照模型页面以了解如何编写自己的光照模型。<ul>
<li>Standard 光照模型使用 SurfaceOutputStandard 输出结构，并与 Unity 中的标准（金属性工作流）着色器匹配。</li>
<li>StandardSpecular 光照模型使用 SurfaceOutputStandardSpecular 输出结构，并与 Unity 中的标准（镜面反射设置）着色器匹配。</li>
<li>Lambert 和 BlinnPhong 光照模型不是基于物理的（来自 Unity 4.x），但使用这两个光照模型的着色器在低端硬件上可以提高渲染速度。</li>
</ul>
</li>
</ul>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><blockquote>
<p>这些可选参数一开始关注下自定义函数修改器和代码生成选项就好</p>
</blockquote>
<h4 id="透明度和-Alpha-测试"><a href="#透明度和-Alpha-测试" class="headerlink" title="透明度和 Alpha 测试"></a>透明度和 Alpha 测试</h4><p>由 alpha 和 alphatest 指令控制。<br>透明度通常可以有两种：传统的 Alpha 混合（用于淡出对象）或更符合物理规律的“预乘混合”（允许半透明表面保留适当的镜面反射）。启用半透明度会使生成的表面着色器代码包含混合命令；而启用 Alpha 镂空将根据给定的变量在生成的像素着色器中执行片元废弃。</p>
<ul>
<li>alpha 或 alpha:auto - 对于简单的光照函数，将选择淡化透明度（与 alpha:fade 相同）；对于基于物理的光照函数，将选择预乘透明度（与 alpha:premul 相同）。</li>
<li>alpha:blend - 启用 Alpha 混合。</li>
<li>alpha:fade - 启用传统淡化透明度。</li>
<li>alpha:premul - 启用预乘 Alpha 透明度。</li>
<li>alphatest:VariableName - 启用 Alpha 镂空透明度。剪切值位于具有 VariableName 的浮点变量中。您可能还想使用 addshadow 指令生成正确的阴影投射物通道。</li>
<li>keepalpha - 默认情况下，无论输出结构的 Alpha 输出是什么，或者光照函数返回什么，不透明表面着色器都将 1.0（白色）写入 Alpha 通道。使用此选项可以保持光照函数的 Alpha 值，即使对于不透明的表面着色器也是如此。</li>
<li>decal:add - 附加贴花着色器（例如 terrain AddPass）。这适用于位于其他表面之上并使用附加混合的对象。请参阅表面着色器示例</li>
<li>decal:blend - 半透明贴花着色器。这适用于位于其他表面之上并使用 Alpha 混合的对象。请参阅表面着色器示例</li>
</ul>
<h4 id="自定义修改器函数"><a href="#自定义修改器函数" class="headerlink" title="自定义修改器函数"></a>自定义修改器函数</h4><p>可用于更改或计算传入的顶点数据，或更改最终计算的片元颜色。</p>
<ul>
<li>vertex:VertexFunction - 自定义顶点修改函数。在生成的顶点着色器的开始处调用此函数，并且此函数可以修改或计算每顶点数据。请参阅表面着色器示例。</li>
<li>finalcolor:ColorFunction - 自定义最终颜色修改函数。请参阅表面着色器示例。</li>
<li>finalgbuffer:ColorFunction - 用于更改 G 缓冲区内容的自定义延迟路径。</li>
<li>finalprepass:ColorFunction - 自定义预通道基本路径。</li>
</ul>
<h4 id="阴影和曲面细分"><a href="#阴影和曲面细分" class="headerlink" title="阴影和曲面细分"></a>阴影和曲面细分</h4><p>可以提供其他指令来控制阴影和曲面细分的处理方式。</p>
<ul>
<li>addshadow - 生成阴影投射物通道。常用于自定义的顶点修改，以便阴影投射也可以获得程序化顶点动画。通常情况下，着色器不需要任何特殊的阴影处理，因为它们可以通过回退机制来使用阴影投射物通道。</li>
<li>fullforwardshadows - Support all light shadow types in Forward rendering path. By default shaders only support shadows from one directional light in forward rendering (to save on internal shader variant count). If you need point or Spot Light shadows in forward rendering, use this directive.</li>
<li><p>tessellate:TessFunction - 使用 DX11 GPU 曲面细分；该函数计算曲面细分因子。有关详细信息，请参阅表面着色器曲面细分。</p>
<h4 id="代码生成选项"><a href="#代码生成选项" class="headerlink" title="代码生成选项"></a>代码生成选项</h4><p>默认情况下，生成的表面着色器代码会尝试处理所有可能的光照/阴影/光照贴图情况。但是在某些情况下，您知道您不需要其中的一部分，可以调整生成的代码以跳过它们。这样可以减小着色器，从而提高加载速度。</p>
</li>
<li><p>exclude_path:deferred、exclude_path:forward 和 exclude_path:prepass - 不为给定的渲染路径（分别对应延迟着色路径、前向路径和旧版延迟路径）生成通道。</p>
</li>
<li>noshadow - 禁用此着色器中的所有阴影接受支持。</li>
<li>noambient - 不应用任何环境光照或光照探针。</li>
<li>novertexlights - 在前向渲染中不应用任何光照探针或每顶点光源。</li>
<li>nolightmap - 禁用此着色器中的所有光照贴图支持。</li>
<li>nodynlightmap - 禁用此着色器中的运行时动态全局光照支持。</li>
<li>nodirlightmap - 禁用此着色器中的方向光照贴图支持。</li>
<li>nofog - 禁用所有内置雾效支持。</li>
<li>nometa - 不生成“Meta”通道（由光照贴图和动态全局光照用于提取表面信息）。</li>
<li>noforwardadd - 禁用前向渲染附加通道。这会使着色器支持一个完整方向光，所有其他光源均进行每顶点/SH 计算。也能减小着色器。</li>
<li>nolppv - 禁用此着色器中的光照探针代理体支持。</li>
<li><p>noshadowmask - 为此着色器禁用阴影遮罩支持（包括 Shadowmask 和 Distance Shadowmask）。</p>
<h4 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h4></li>
<li><p>softvegetation - 仅在开启 Soft Vegetation 时才渲染表面着色器。</p>
</li>
<li>interpolateview - 在顶点着色器中计算视图方向并进行插值；而不是在像素着色器中计算。这可以使像素着色器更快，但会额外消耗一个纹理插值器。</li>
<li>alfasview - 将半方向矢量传入光照函数而不是视图方向。计算半方向并按每个顶点对其进行标准化。这更快，但并不完全正确。</li>
<li>approxview - 在 Unity 5.0 中已删除。请改用 interpolateview。</li>
<li>dualforward - 在前向渲染路径中使用双光照贴图。</li>
<li>dithercrossfade - 使表面着色器支持抖动效果。然后，可将此着色器应用于使用细节级别组 (LOD Group) 组件（配置为交叉淡入淡出过渡模式）的游戏对象。</li>
</ul>
<h2 id="表面着色器的渲染路径"><a href="#表面着色器的渲染路径" class="headerlink" title="表面着色器的渲染路径"></a>表面着色器的渲染路径</h2><p>在内置渲染管线中，使用表面着色器时，如何应用光照以及使用着色器的哪些通道取决于使用的渲染路径。着色器中的每个通道均通过通道标签来表达其光照类型。</p>
<ul>
<li>在前向渲染中，将使用 ForwardBase 和 ForwardAdd 通道。</li>
<li>在延迟着色中，将使用 Deferred 通道。</li>
<li>在旧版延迟光照中，将使用 PrepassBase 和 PrepassFinal 通道。</li>
<li>在旧版顶点光照中，将使用 Vertex、VertexLMRGBM 和 VertexLM 通道。</li>
<li>在上述任何情况中，要渲染阴影或深度纹理，都将使用 ShadowCaster 通道。</li>
</ul>
<h2 id="表面着色器示例"><a href="#表面着色器示例" class="headerlink" title="表面着色器示例"></a>表面着色器示例</h2><h3 id="简单的着色器示例"><a href="#简单的着色器示例" class="headerlink" title="简单的着色器示例"></a>简单的着色器示例</h3><p>我们将从一个非常简单的着色器 (Shader) 开始，并在此基础上加以丰富。下面的着色器将表面颜色设置为“白色”。它使用内置的兰伯特（漫射）光照模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Diffuse Simple&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma surface surf Lambert</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        float4 color : COLOR;</span><br><span class="line">    &#125;;</span><br><span class="line">    void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure></p>
<p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SurfaceShaderSimple.jpg" alt></p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>一个全白的对象很无聊，所以让我们添加一个纹理。我们将向着色器添加 Properties 代码块，这样我们将在材质中看到纹理选择器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Diffuse Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma surface surf Lambert</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要理解这段代码需要明白UV是个什么概念，简单来说，就是模型上的每个点都有一个uv坐标，这个坐标对应的是贴图上的一个点，渲染模型上的这个点的时候，这个点的颜色就是通过这坐标去贴图上获取的。详细解释可以看：<a href="https://www.cnblogs.com/cancantrbl/p/14766502.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/cancantrbl/p/14766502.html</a></p>
<p>surf函数中用到了两个变量，大家可能会觉得有点迷惑，是怎么来的。<br>首先是<code>_MainTex</code>这个变量，是在HLSL代码里面定义的，找个变量的名字要和Properties中定义的属性名字完全相同才可以。<br>另一个变量是我们定义的结构体<code>Input</code>中的，叫做<code>uv_MainTex</code>，这个变量编译器会自动帮我们注入该点的uv坐标</p>
<blockquote>
<p>输入结构 Input 通常具有着色器所需的所有纹理坐标。纹理坐标必须命名为“uv”后跟纹理名称的形式（如果要使用第二个纹理坐标集，则以“uv2”开头）。</p>
</blockquote>
<h3 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Diffuse Bump&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">      _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">      _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">      Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">      CGPROGRAM</span><br><span class="line">      #pragma surface surf Lambert</span><br><span class="line">      struct Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float2 uv_BumpMap;</span><br><span class="line">      &#125;;</span><br><span class="line">      sampler2D _MainTex;</span><br><span class="line">      sampler2D _BumpMap;</span><br><span class="line">      void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</span><br><span class="line">      &#125;</span><br><span class="line">      ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Shader中，我们多了一个输入和一个输出，我们多输入了一个法线贴图，同时也给输出的法线变量赋予了有效值。</p>
<p>如果对法线贴图的概念不太清楚，可以看一下<a href="https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html" rel="external nofollow noopener noreferrer" target="_blank">法线贴图的官方文档</a></p>
<p>这里我们讲一下<code>o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</code>这一行代码</p>
<p>首先是<code>tex2D (_BumpMap, IN.uv_BumpMap)</code> 这一段，我们已经理解了，是根据这个点的uv坐标从法线贴图中获取对应的rgba（或者说xyzw）值，那么我们为什么不能直接把值赋给Normal呢？<br>首先要明白，Unity中的发现贴图的存储是经过打包的格式DXT5nm, 只有G和A通道是有用的，而我们的发现是一个三维向量，所以我们要把它恢复出来，这个时候我们再看看这个<code>UnpackNormal</code>的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline fixed3 UnpackNormal(fixed4 packednormal)</span><br><span class="line">&#123;</span><br><span class="line">#if defined(SHADER_API_GLES)  defined(SHADER_API_MOBILE)</span><br><span class="line">    return packednormal.xyz * 2 - 1;</span><br><span class="line">#else</span><br><span class="line">    fixed3 normal;</span><br><span class="line">    normal.xy = packednormal.wy * 2 - 1;</span><br><span class="line">    normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);</span><br><span class="line">    return normal;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边缘光照"><a href="#边缘光照" class="headerlink" title="边缘光照"></a>边缘光照</h3><p>现在，尝试添加一些边缘光照以突出游戏对象的边缘。我们将根据表面法线和视图方向之间的角度添加一些发射光照。为此，我们将使用内置的表面着色器变量 viewDir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Example/Rim&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _BumpMap (&quot;Bumpmap&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">    _RimColor (&quot;Rim Color&quot;, Color) = (0.26,0.19,0.16,0.0)</span><br><span class="line">    _RimPower (&quot;Rim Power&quot;, Range(0.5,8.0)) = 3.0</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">    Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma surface surf Lambert</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float2 uv_BumpMap;</span><br><span class="line">        float3 viewDir;</span><br><span class="line">    &#125;;</span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    sampler2D _BumpMap;</span><br><span class="line">    float4 _RimColor;</span><br><span class="line">    float _RimPower;</span><br><span class="line">    void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">        o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;</span><br><span class="line">        o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</span><br><span class="line">        half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal));</span><br><span class="line">        o.Emission = _RimColor.rgb * pow (rim, _RimPower);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">    &#125; </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码又多了两行，首先我们看第一行：<code>half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal));</code>，我们解读一下这段代码，首先是<code>normalize(IN.viewDir)</code>  ,将视角方向单位化，然后dot方法来和法线点乘，saturate函数的作用是，如果结果小于0则返回0，如果大于1，则返回1。那么这一段代码的结果就是，判断视角方向与这一点法线的方向，如果夹角大于90度，点乘结果就小于0，saturate结果就是0，那么rim的结果就是1，其他的大家可以自己自行推倒。</p>
<p>然后是第二行：<code>o.Emission = _RimColor.rgb * pow (rim, _RimPower);</code>，通过pow函数来对rim进行幂，获得该点的自发光强度，然后乘上我们设置给<code>_RimColor</code>的rgb值，最后赋值给<code>Emission</code>也就是该点的自发光属性。</p>
<blockquote>
<p>官方文档还有一些其他的示例，这里就不一一展开分析了，有兴趣可以继续看：<a href="https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaderExamples.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaderExamples.html</a></p>
</blockquote>
<h2 id="Unity背后做了什么"><a href="#Unity背后做了什么" class="headerlink" title="Unity背后做了什么"></a>Unity背后做了什么</h2><p>Unity在背后会根据表面着色器生成一个包含了很多Pass的顶点/片元着色器。</p>
<p>这些Pass有些是为了针对不同的渲染路径，例如，默认情况下Unity 会为前向渲染路径生成LightMode 为 ForwardBase 和 ForwardAdd 的Pass，为Unity 5 之前的延迟渲染路径生成LightMode 为PrePassBase 和 PrePassFinal 的Pass，为Unity5之后的延迟渲染路径生成LightMode 为 Deferred 的Pass。</p>
<p>还有一些Pass 是用于产生额外的信息。例如，为了给光照映射和动态全局光照提取表面信息，Unity 会生成一个LightMode 为 Meta 的Pass。这些Pass 的生成都是基于我们再表面着色器中的编译指令和自定义的函数，这是由规律可循的。Unity 提供了一个功能，让我们可以对表面着色器自动生成的代码一探究竟：在每个编译完成的表面着色器的面板上，有一个“Show generated code” 按钮，如下图所示。我们只需要单击一下就可以看到Unity为这个表面着色器生成的所有顶点/片元着色器。</p>
<p>以Unity生成的LightMode 为ForwardBase 的Pass为例，它的渲染流水线如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652600532/origin-of-ray/20018137-d2ff6da2b4e91a45.jpg_sdysuu.webp" alt></p>
<p>Unity对该Pass的自动生成过程大致如下：</p>
<ol>
<li>将表面着色器中CGPROGRAM和ENDCG之间的代码复制过来。</li>
<li>Unity根据上述代码生成结构体v2f_surf（顶点着色器的输出）。如果Input定义了一些变量但没有使用，生成的结构体也不会包含该变量。还会包含阴影纹理坐标、光照纹理坐标、逐顶点光照等。</li>
<li>生成顶点着色器。</li>
</ol>
<ul>
<li>如果定义了顶点修改函数，会先调用，或填充自定义Input结构体中的变量。Unity会分析该函数修改的数据，通过Input结构体把修改结果存储到v2f_surf相应变量。</li>
<li>计算v2f_surf中其他变量：顶点位置、纹理坐标、法线方向、逐顶点光照、光照纹理等。</li>
<li>把v2f_surf传递给片元着色器。</li>
</ul>
<ol>
<li>生成片元着色器。</li>
</ol>
<ul>
<li>将v2f_surf变量（纹理坐标、视角方向）填充到Input结构体。</li>
<li>调用自定义表面函数，填充SurfaceOutput结构体。</li>
<li>调用光照函数得到初始的颜色值。如果使用内置的Lambert或BlinnPhong光照函数，Unity还会计算动态全局光照，并添加到光照模型的计算。</li>
<li>进行其他颜色叠加。例如没有光照烘培，会添加逐顶点光照的影响。</li>
<li>调用最后的颜色修改函数。</li>
</ul>
<h2 id="Shader-Graph"><a href="#Shader-Graph" class="headerlink" title="Shader Graph"></a>Shader Graph</h2><p>为了简化我们编写顶点着色器和片元着色器的过程，Unity将他们抽象成了表面着色器。<br>但是这还不够，为了更加简化，Unity又提出了Shader Graph，它可以帮我们可视化的进行Shader的编写。</p>
<p>我们就简单拖拽一个出来：<br><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1652579914/origin-of-ray/screenshot-20220515-095732_izsvgx.png" alt></p>
<p>这个Shader Graph的功能就是从贴图中提取出每个点对应在贴图中的rgb值，然后分别赋值给表面着色器输出的，Albeo和Emission</p>
<p>这个Shader Graph存储时是以一个又一个节点的方式存储的，它会被编译成表面着色器，进而编译成顶点着色器和偏远着色器。</p>
<p>Shader Graph虽然方便，但是也有个问题，就是他默认添加了很多关键字，这会导致最终编译出的Shader变体过多，如果是简单的Shader，其实没必要用到Shader Graph</p>
<p>参考文章：<br><a href="https://www.jianshu.com/p/3d8a9f3f2430" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/3d8a9f3f2430</a><br><a href="https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaders.html" rel="external nofollow noopener noreferrer" target="_blank">https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaders.html</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Ray Sun
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://sunra.top/2022/05/15/unity-render-pipeline-7/" title="Unity 渲染原理（七）表面着色器与Shader Graph">https://sunra.top/2022/05/15/unity-render-pipeline-7/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/03/unity-render-pipeline-6/" rel="prev" title="Unity 渲染原理（六）Unity HLSL">
      <i class="fa fa-chevron-left"></i> Unity 渲染原理（六）Unity HLSL
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/21/unity-render-pipeline-8/" rel="next" title="Unity 渲染原理（八）Unity渲染顺序和渲染路径">
      Unity 渲染原理（八）Unity渲染顺序和渲染路径 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">1.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表面着色器的标准输出结构："><span class="nav-number">1.1.</span> <span class="nav-text">表面着色器的标准输出结构：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表面着色器输入结构"><span class="nav-number">2.</span> <span class="nav-text">表面着色器输入结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表面着色器编译指令"><span class="nav-number">3.</span> <span class="nav-text">表面着色器编译指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#必需参数"><span class="nav-number">3.1.</span> <span class="nav-text">必需参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选参数"><span class="nav-number">3.2.</span> <span class="nav-text">可选参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#透明度和-Alpha-测试"><span class="nav-number">3.2.1.</span> <span class="nav-text">透明度和 Alpha 测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义修改器函数"><span class="nav-number">3.2.2.</span> <span class="nav-text">自定义修改器函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阴影和曲面细分"><span class="nav-number">3.2.3.</span> <span class="nav-text">阴影和曲面细分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码生成选项"><span class="nav-number">3.2.4.</span> <span class="nav-text">代码生成选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他选项"><span class="nav-number">3.2.5.</span> <span class="nav-text">其他选项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表面着色器的渲染路径"><span class="nav-number">4.</span> <span class="nav-text">表面着色器的渲染路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表面着色器示例"><span class="nav-number">5.</span> <span class="nav-text">表面着色器示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的着色器示例"><span class="nav-number">5.1.</span> <span class="nav-text">简单的着色器示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纹理"><span class="nav-number">5.2.</span> <span class="nav-text">纹理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#法线贴图"><span class="nav-number">5.3.</span> <span class="nav-text">法线贴图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边缘光照"><span class="nav-number">5.4.</span> <span class="nav-text">边缘光照</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unity背后做了什么"><span class="nav-number">6.</span> <span class="nav-text">Unity背后做了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shader-Graph"><span class="nav-number">7.</span> <span class="nav-text">Shader Graph</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
  <p class="site-author-name" itemprop="name">Ray Sun</p>
  <div class="site-description" itemprop="description">拨开互联网的迷雾</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sun668" title="GitHub → https://github.com/Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <div class="wechat_channel" style="width: 50%;margin-left: 25%;">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src="/images/wechat_channel.png">
        <!-- <span>公众号</span> -->
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Sun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  <script src="/js/local-search.js"></script>












  

  

  

</body>
</html>
