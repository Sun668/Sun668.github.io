<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="在Unity中，我们使用HLSL的语法来写Shader Program，不过一开始Unity采用的是CG语法，因此会使用 Unity 某些关键字的名称 (CGPROGRAM) 和文件扩展名 (.cginc)。虽然Unity 不再使用 Cg，但这些名称仍在使用。"><meta property="og:type" content="article"><meta property="og:title" content="Unity 渲染原理（六）Unity HLSL"><meta property="og:url" content="https://sunra.top/2022/05/03/unity-render-pipeline-6/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="在Unity中，我们使用HLSL的语法来写Shader Program，不过一开始Unity采用的是CG语法，因此会使用 Unity 某些关键字的名称 (CGPROGRAM) 和文件扩展名 (.cginc)。虽然Unity 不再使用 Cg，但这些名称仍在使用。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-05-03T07:19:22.000Z"><meta property="article:modified_time" content="2023-06-06T23:56:37.735Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/2022/05/03/unity-render-pipeline-6/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunra.top/2022/05/03/unity-render-pipeline-6/","path":"2022/05/03/unity-render-pipeline-6/","title":"Unity 渲染原理（六）Unity HLSL"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity 渲染原理（六）Unity HLSL | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HLSL%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">HLSL中的预处理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">着色器语义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%85%A5%E8%AF%AD%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">顶点着色器输入语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%87%BA%E8%AF%AD%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">片元着色器输出语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SV-TargetN%EF%BC%9A%E5%A4%9A%E4%B8%AA%E6%B8%B2%E6%9F%93%E7%9B%AE%E6%A0%87"><span class="nav-number">2.3.</span> <span class="nav-text">SV_TargetN：多个渲染目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SV-Depth%EF%BC%9A%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8%E6%B7%B1%E5%BA%A6%E8%BE%93%E5%87%BA"><span class="nav-number">2.4.</span> <span class="nav-text">SV_Depth：像素着色器深度输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%87%BA%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E8%BE%93%E5%85%A5"><span class="nav-number">2.5.</span> <span class="nav-text">顶点着色器输出和片元着色器输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E8%AF%AD%E4%B9%89"><span class="nav-number">2.6.</span> <span class="nav-text">其他特殊语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9D%80%E8%89%B2%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">如何使用着色器属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%91%E7%9D%80%E8%89%B2%E5%99%A8%E6%8F%90%E4%BE%9B%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">如何向着色器提供属性值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">序列化和运行时材质属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%BA%B9%E7%90%86%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">特殊纹理属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%B9%B3%E9%93%BA%E5%92%8C%E5%81%8F%E7%A7%BB"><span class="nav-number">3.3.1.</span> <span class="nav-text">纹理平铺和偏移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86%E5%A4%A7%E5%B0%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">纹理大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B9%E7%90%86-HDR-%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">纹理 HDR 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E9%A2%9C%E8%89%B2-%E7%9F%A2%E9%87%8F%E7%9D%80%E8%89%B2%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.4.</span> <span class="nav-text">颜色空间和颜色&#x2F;矢量着色器数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%A1%B6%E7%82%B9%E7%A8%8B%E5%BA%8F%E6%8F%90%E4%BE%9B%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">向顶点程序提供顶点数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E5%AE%8F%EF%BC%8C%E5%8F%98%E9%87%8F%EF%BC%8Chelper%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">内置的宏，变量，helper函数</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">拨开互联网的迷雾</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">267</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sunra.top/2022/05/03/unity-render-pipeline-6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="拨开互联网的迷雾"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity 渲染原理（六）Unity HLSL | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity 渲染原理（六）Unity HLSL</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-03 15:19:22" itemprop="dateCreated datePublished" datetime="2022-05-03T15:19:22+08:00">2022-05-03</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-06-07 07:56:37" itemprop="dateModified" datetime="2023-06-07T07:56:37+08:00">2023-06-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline：</span><a title="waline" href="/2022/05/03/unity-render-pipeline-6/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/2022/05/03/unity-render-pipeline-6/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在Unity中，我们使用HLSL的语法来写Shader Program，不过一开始Unity采用的是CG语法，因此会使用 Unity 某些关键字的名称 (CGPROGRAM) 和文件扩展名 (.cginc)。虽然Unity 不再使用 Cg，但这些名称仍在使用。</p><span id="more"></span><p>将 HLSL 代码放在 ShaderLab 代码中的代码块中。着色器程序通常如下所示：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    // ... 常规通道状态设置 ...</span><br><span class="line">    </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    // 此代码片段的编译指令，例如：</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">    </span><br><span class="line">    // 着色器程序本身</span><br><span class="line">    </span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    // ... 通道的剩余部分 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HLSL 语言有两种语法：旧版的 DirectX 9 样式语法以及更现代的 DirectX 10+ 样式语法。不同之处主要在于纹理采样函数的工作方式：</p><ul><li>旧版语法使用 sampler2D、tex2D() 和类似函数。此语法适用于所有平台。</li><li>DX10+ 语法使用 Texture2D、SamplerState 和 .Sample() 函数。由于纹理和采样器在 OpenGL 中不是不同对象，因此该语法的某些形式在 OpenGL 平台上无效。</li></ul><h2 id="HLSL中的预处理指令"><a href="#HLSL中的预处理指令" class="headerlink" title="HLSL中的预处理指令"></a>HLSL中的预处理指令</h2><p>在内部，着色器汇编具有多个阶段。第一阶段是预处理，其中一个名为“预处理程序”的程序准备编译代码。预处理器指令是预处理器的说明。</p><p>详情可以参考<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/shader-preprocessor-directives.html">官方文档</a></p><h2 id="着色器语义"><a href="#着色器语义" class="headerlink" title="着色器语义"></a>着色器语义</h2><p>在编写HLSL着色器程序时，输入和输出变量需要通过语义来表明其意图.</p><p>需要说明的一点是，变量的语义和变量的类型不同，比如<code>float4 vertex : POSITION</code>，这个vertex变量的类型是float4，但是它的语义是POSITION，表示这个变量代表的是点在裁剪空间下的坐标</p><h3 id="顶点着色器输入语义"><a href="#顶点着色器输入语义" class="headerlink" title="顶点着色器输入语义"></a>顶点着色器输入语义</h3><p>主顶点着色器函数（由 #pragma vertex 指令表示）需要在所有输入参数上都有语义。 这些对应于各个网格数据元素，如顶点位置、法线网格和纹理坐标。 有关更多详细信息，请参阅顶点程序输入。</p><p>以下是一个简单的顶点着色器的示例，它采用顶点位置 和纹理坐标作为输入。像素着色器 将纹理坐标可视化为颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Show UVs&quot;</span><br><span class="line">&#123;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert (</span><br><span class="line">                float4 vertex : POSITION, // 顶点位置输入</span><br><span class="line">                float2 uv : TEXCOORD0 // 第一个纹理坐标输入</span><br><span class="line">                )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(vertex);</span><br><span class="line">                o.uv = uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                return fixed4(i.uv, 0, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片元着色器输出语义"><a href="#片元着色器输出语义" class="headerlink" title="片元着色器输出语义"></a>片元着色器输出语义</h3><p><strong>通常，片元（像素）着色器会输出颜色，并具有 SV_Target 语义</strong>。上面示例中的片元着色器 完全就是这样的：</p><p>fixed4 frag (v2f i) : SV_Target<br>函数 frag 的返回类型为 fixed4（低精度 RGBA 颜色）。因为它只返回一个值，所以语义 由函数自身指示: SV_Target。</p><p><strong>也可以返回包含输出的结构。 上面的片元着色器也可以按如下所示重写， 功能完全相同</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct fragOutput &#123;</span><br><span class="line">    fixed4 color : SV_Target;</span><br><span class="line">&#125;;</span><br><span class="line">fragOutput frag (v2f i)</span><br><span class="line">&#123;</span><br><span class="line">    fragOutput o;</span><br><span class="line">    o.color = fixed4(i.uv, 0, 0);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从片元着色器返回结构对于不止返回单个颜色的 着色器非常有用。片元着色器 输出支持的其他语义如下。</p><h3 id="SV-TargetN：多个渲染目标"><a href="#SV-TargetN：多个渲染目标" class="headerlink" title="SV_TargetN：多个渲染目标"></a>SV_TargetN：多个渲染目标</h3><p>SV_Target1、SV_Target2 等等：这些是着色器写入的附加颜色。这在一次渲染到多个渲染目标（称为“多渲染目标”渲染技术，简称 MRT）时使用。SV_Target0 等同于 SV_Target。</p><h3 id="SV-Depth：像素着色器深度输出"><a href="#SV-Depth：像素着色器深度输出" class="headerlink" title="SV_Depth：像素着色器深度输出"></a>SV_Depth：像素着色器深度输出</h3><p>通常情况下， 片元着色器不会覆盖 Z 缓冲区值，并使用 常规三角形栅格化中的默认值。但是， 对于某些效果，输出每个像素的自定义 Z 缓冲区深度值很有用。</p><p>请注意，在许多 GPU 上，这会关闭一些深度缓冲区优化，<strong>因此如果没有充分的理由，请不要覆盖 Z 缓冲区值</strong>。SV_Depth 产生的成本取决于 GPU 架构，但总体上与 Alpha 测试（使用 HLSL 中的内置 clip() 函数）的成本非常相似。通过渲染着色器在所有常规不透明着色器之后修改深度（例如，使用 AlphaTest 渲染队列）。</p><p>深度输出值必须为单个 float。</p><h3 id="顶点着色器输出和片元着色器输入"><a href="#顶点着色器输出和片元着色器输入" class="headerlink" title="顶点着色器输出和片元着色器输入"></a>顶点着色器输出和片元着色器输入</h3><p>顶点着色器需要输出顶点的最终裁剪空间位置，以便 GPU 知道屏幕上的栅格化位置以及深度。此输出需要具有 SV_POSITION 语义，并为 float4 类型。</p><p><strong>顶点着色器生成的所有其他输出（“插值器”或“变化”）都是您的特定着色器需要的</strong>。从顶点着色器输出的值将在渲染三角形的面上进行插值，并且每个像素的值将作为输入传递给片元着色器。</p><p>许多现代 GPU 并不真正关心这些变量的语义；然而，一些旧系统（最主要的是 Direct3D 9 上的着色器模型 2 GPU）存在关于语义的特殊规则：</p><p>TEXCOORD0、TEXCOORD1 等语义用于指示任意高精度数据，如纹理坐标和位置。<br>顶点输出和片元输入的 COLOR0 和 COLOR1 语义用于低精度 0 到 1 范围的数据（如简单的颜色值）。<br>为了获得最佳的跨平台支持，应将顶点输出和 片元输入标记为 TEXCOORDn 语义。</p><p>插值器数量限制<br>对于总共可以使用多少个插值器变量将信息 从顶点传递到片元着色器，存在一些限制。该限制 取决于平台和 GPU，一般准则如下：</p><p>最多 8 个插值器：OpenGL ES 2.0 (Android)、Direct3D 11 9.x 级别 (Windows Phone) 和 Direct3D 9 着色器模型 2.0（老旧 PC）。由于插值器 数量受到限制，但每个插值器可以是一个 4 分量矢量， 所以一些着色器将内容打包在一起以便不会超过限制。例如，两个纹理 坐标可以在一个 float4 变量中传递（.xy 表示一个坐标，.zw 表示第二个坐标）。<br>最多 10 个插值器：Direct3D 9 着色器模型 3.0 (#pragma target 3.0)。<br>最多 16 个插值器：OpenGL ES 3.0 (Android) 和 Metal (iOS)。<br>最多 32 个插值器：Direct3D 10 着色器模型 4.0 (#pragma target 4.0)。<br><strong>无论特定目标硬件如何，出于性能原因，通常最好使用尽可能少的插值器</strong>。</p><h3 id="其他特殊语义"><a href="#其他特殊语义" class="headerlink" title="其他特殊语义"></a>其他特殊语义</h3><ol><li>屏幕空间像素位置：VPOS<br>片元着色器可以接收渲染为特殊 VPOS 语义的像素的位置。 此功能仅从着色器模型 3.0 开始存在，因此着色器需要具有 #pragma target 3.0 编译指令。</li></ol><p>在不同的平台上，屏幕空间位置输入的基础类型会有所不同，因此为了获得最大的可移植性，请对其使用 UNITY_VPOS_TYPE 类型（在大多数平台上将是 float4，在 Direct3D 9 上将是 float2）。</p><p>另外，使用像素位置语义将导致难以让裁剪空间位置 (SV_POSITION) 和 VPOS 处于相同的顶点到片元结构中。因此顶点着色器应将裁剪空间位置输出为单独的“out”变量。</p><ol><li>面对方向：VFACE<br>片元着色器可以接收一种指示渲染表面是面向摄像机还是背对摄像机的变量。这在渲染应从两侧可见的几何体时非常有用 - 通常用于树叶和类似的薄型物体。VFACE 语义输入变量将包含表示正面三角形的正值，以及表示背面三角形的负值。</li></ol><p>此功能从着色器模型 3.0 开始才存在，因此着色器需要具有 #pragma target 3.0 编译指令。</p><ol><li>顶点 ID：SV_VertexID<br>顶点着色器可以接收具有“顶点编号”（为无符号整数）的变量。当您想要从纹理或 ComputeBuffers 中 获取额外的每顶点数据时，这非常有用。</li></ol><p>此功能从 DX10（着色器模型 4.0）和 GLCore/OpenGL ES 3 开始才存在，因此着色器需要具有 #pragma target 3.5 编译指令。</p><h2 id="如何使用着色器属性"><a href="#如何使用着色器属性" class="headerlink" title="如何使用着色器属性"></a>如何使用着色器属性</h2><p>着色器在 Properties 代码块中声明材质属性。如果要在着色器程序中访问其中一些属性，则需要声明具有相同名称和匹配类型的 Cg/HLSL 变量。</p><p>例如，以下着色器属性：<br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_MyColor (&quot;Some Color&quot;, Color) = (1,1,1,1) </span><br><span class="line">_MyVector (&quot;Some Vector&quot;, Vector) = (0,0,0,0) </span><br><span class="line">_MyFloat (&quot;My float&quot;, Float) = 0.5 </span><br><span class="line">_MyTexture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; </span><br><span class="line">_MyCubemap (&quot;Cubemap&quot;, CUBE) = &quot;&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><br>可通过如下 Cg/HLSL 代码进行声明以供访问：<p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fixed4 _MyColor; // 低精度类型对于颜色而言通常已经足够</span><br><span class="line">float4 _MyVector;</span><br><span class="line">float _MyFloat; </span><br><span class="line">sampler2D _MyTexture;</span><br><span class="line">samplerCUBE _MyCubemap;</span><br></pre></td></tr></table></figure><p>Cg/HLSL 还可以接受 uniform 关键字，但该关键字并不是必需的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform float4 _MyColor;</span><br></pre></td></tr></table></figure><p>ShaderLab 中的属性类型以如下方式映射到 Cg/HLSL 变量类型：</p><ul><li>Color 和 Vector 属性映射到 float4、half4 或 fixed4 变量。</li><li>Range 和 Float 属性映射到 float、half 或 fixed 变量。</li><li>对于普通 (2D) 纹理，Texture 属性映射到 sampler2D 变量；立方体贴图 (Cubemap) 映射到 samplerCUBE<strong>；3D 纹理映射到 sampler3D</strong>。</li></ul><h3 id="如何向着色器提供属性值"><a href="#如何向着色器提供属性值" class="headerlink" title="如何向着色器提供属性值"></a>如何向着色器提供属性值</h3><p>在下列位置中查找着色器属性值并提供给着色器：</p><p>MaterialPropertyBlock 中设置的每渲染器值。这通常是“每实例”数据（例如，全部共享相同材质的许多对象的自定义着色颜色）。<br>在渲染的对象上使用的材质中设置的值。<br>全局着色器属性，通过 Unity 渲染代码自身设置（请参阅内置着色器变量），或通过您自己的脚本来设置（例如 Shader.SetGlobalTexture）。<br>优先顺序如上所述：每实例数据覆盖所有内容；然后使用材质数据；最后，如果这两个地方不存在着色器属性，则使用全局属性值。最终，如果在任何地方都没有定义着色器属性值，则将提供“默认值”（浮点数的默认值为零，颜色的默认值为黑色，纹理的默认值为空的白色纹理）。</p><h3 id="序列化和运行时材质属性"><a href="#序列化和运行时材质属性" class="headerlink" title="序列化和运行时材质属性"></a>序列化和运行时材质属性</h3><p>材质可以同时包含序列化的属性值和运行时设置的属性值。</p><p>序列化的数据是在着色器的 Properties 代码块中定义的所有属性。通常，这些是需要存储在材质中的值，并且可由用户在材质检视面板中进行调整。</p><p>材质也可以具有着色器使用的一些属性，但不在着色器的 Properties 代码块中声明。通常，这适用于在运行时从脚本代码（例如，通过 Material.SetColor）设置的属性。请注意，矩阵和数组只能作为非序列化的运行时属性存在（因为无法在 Properties 代码块中定义它们）。</p><h3 id="特殊纹理属性"><a href="#特殊纹理属性" class="headerlink" title="特殊纹理属性"></a>特殊纹理属性</h3><p>对于设置为着色器/材质属性的每个纹理，Unity 还会在其他矢量属性中设置一些额外信息。</p><h4 id="纹理平铺和偏移"><a href="#纹理平铺和偏移" class="headerlink" title="纹理平铺和偏移"></a>纹理平铺和偏移</h4><p>材质通常具有其纹理属性的 Tiling 和 Offset 字段。此信息将传递到着色器中的 float4 {TextureName}_ST 属性：</p><p>x 包含 X 平铺值<br>y 包含 Y 平铺值<br>z 包含 X 偏移值<br>w 包含 Y 偏移值<br>例如，如果着色器包含名为 _MainTex 的纹理，则平铺信息将位于 _MainTex_ST 矢量中。</p><h4 id="纹理大小"><a href="#纹理大小" class="headerlink" title="纹理大小"></a>纹理大小</h4><p>{TextureName}_TexelSize - float4 属性包含纹理大小信息：</p><p>x 包含 1.0/宽度<br>y 包含 1.0/高度<br>z 包含宽度<br>w 包含高度</p><h4 id="纹理-HDR-参数"><a href="#纹理-HDR-参数" class="headerlink" title="纹理 HDR 参数"></a>纹理 HDR 参数</h4><p>{TextureName}_HDR - 一个 float4 属性，其中包含有关如何根据所使用的颜色空间解码潜在 HDR（例如 RGBM 编码）纹理的信息。请参阅 UnityCG.cginc 着色器 include 文件中的 DecodeHDR 函数。</p><h4 id="颜色空间和颜色-矢量着色器数据"><a href="#颜色空间和颜色-矢量着色器数据" class="headerlink" title="颜色空间和颜色/矢量着色器数据"></a>颜色空间和颜色/矢量着色器数据</h4><p><strong>使用线性颜色空间时，所有材质颜色属性均以 sRGB 颜色提供，但在传递到着色器时会转换为线性值</strong>。</p><p>例如，如果 Properties 着色器代码块包含名为“MyColor“的 Color 属性，则相应的”MyColor”HLSL 变量将获得线性颜色值。</p><p><strong>对于标记为 Float 或 Vector 类型的属性，默认情况下不进行颜色空间转换；而是假设它们包含非颜色数据</strong>。可为浮点/矢量属性添加 [Gamma] 特性，以表示它们是以 sRGB 空间指定，就像颜色一样</p><h2 id="向顶点程序提供顶点数据"><a href="#向顶点程序提供顶点数据" class="headerlink" title="向顶点程序提供顶点数据"></a>向顶点程序提供顶点数据</h2><p>对于 Cg/HLSL 顶点程序， 网格顶点数据作为输入传递给顶点 着色器函数。每个输入都需要有指定的语义：例如，POSITION 输入表示顶点位置，NORMAL 表示顶点法线。</p><p>通常，顶点数据输入在结构中声明，而不是 逐个列出。在 UnityCG.cginc include 文件中 定义了几个常用的顶点结构，在大多数情况下， 仅使用它们就足够了。这些结构为：</p><ul><li>appdata_base：位置、法线和一个纹理坐标。</li><li>appdata_tan：位置、切线、法线和一个纹理坐标。</li><li>appdata_full：位置、切线、法线、四个纹理坐标和颜色。</li></ul><p>要访问不同的顶点数据，您需要自己声明 顶点结构，或者将输入参数添加到 顶点着色器。顶点数据由 Cg/HLSL 语义标识，并且必须来自 以下列表：</p><ul><li>POSITION 是顶点位置，通常为 float3 或 float4。</li><li>NORMAL 是顶点法线，通常为 float3。</li><li>TEXCOORD0 是第一个 UV 坐标，通常为 float2、float3 或 float4。</li><li>TEXCOORD1、TEXCOORD2 和 TEXCOORD3 分别是第 2、第 3 和第 4 个 UV 坐标。</li><li>TANGENT 是切线矢量（用于法线贴图），通常为 float4。</li><li>COLOR 是每顶点颜色，通常为 float4。<br>当网格数据包含的分量少于顶点着色器输入所需 的分量时，其余部分用零填充，但默认值为 1 的 .w 分量除外。例如，网格纹理坐标 通常是仅包含 x 和 y 分量的 2D 矢量。如果 顶点着色器使用 TEXCOORD0 语义声明一个 float4 输入，则 顶点着色器接收的值将包含 (x,y,0,1)。</li></ul><h2 id="内置的宏，变量，helper函数"><a href="#内置的宏，变量，helper函数" class="headerlink" title="内置的宏，变量，helper函数"></a>内置的宏，变量，helper函数</h2><p>Unity为我们内置了很多常用的宏，比如判断当前的平台，很多变量，如模型空间的转换矩阵，还有一些helper函数，如将模型坐标转换到世界坐标。</p><p>具体信息可以查看官方文档：</p><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-BuiltinMacros.html">内置的宏</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-BuiltinFunctions.html">内置的helper函数</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.unity3d.com/cn/current/Manual/SL-UnityShaderVariables.html">内置的变量</a></li></ul></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Ray Sun</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://sunra.top/2022/05/03/unity-render-pipeline-6/" title="Unity 渲染原理（六）Unity HLSL">https://sunra.top/2022/05/03/unity-render-pipeline-6/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/05/01/unity-render-pipeline-5/" rel="prev" title="Unity 渲染原理（五）Shader Lab"><i class="fa fa-chevron-left"></i> Unity 渲染原理（五）Shader Lab</a></div><div class="post-nav-item"> <a href="/2022/05/15/unity-render-pipeline-7/" rel="next" title="Unity 渲染原理（七）表面着色器与Shader Graph">Unity 渲染原理（七）表面着色器与Shader Graph<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2022/05/03/unity-render-pipeline-6/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>