<!DOCTYPE html>
<html lang>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunra.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script>
  <meta name="description" content="随着使用的逐渐增多，慢慢受不了在对这些概念的模糊的情况下使用了，所以找了些官方文档来学习一下C#中的这些概念，主要是为了区分委托（Delegate），事件（Event）。 其实我个人在读文档之前一直是对这些概念很模糊的，甚至一度被网上的各种博客绕晕了，甚至把Action，Func和委托都混淆了。 终于在我去读了官方的文档之后，我才对这些概念有了一些认知。 首先抛出最重要的结论，委托和事件都是为了提">
<meta name="keywords" content="C# 委托 事件">
<meta property="og:type" content="article">
<meta property="og:title" content="C# 的委托和事件">
<meta property="og:url" content="https://sunra.top/posts/36409/index.html">
<meta property="og:site_name" content="Origin of Ray">
<meta property="og:description" content="随着使用的逐渐增多，慢慢受不了在对这些概念的模糊的情况下使用了，所以找了些官方文档来学习一下C#中的这些概念，主要是为了区分委托（Delegate），事件（Event）。 其实我个人在读文档之前一直是对这些概念很模糊的，甚至一度被网上的各种博客绕晕了，甚至把Action，Func和委托都混淆了。 终于在我去读了官方的文档之后，我才对这些概念有了一些认知。 首先抛出最重要的结论，委托和事件都是为了提">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-05-27T03:10:13.084Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C# 的委托和事件">
<meta name="twitter:description" content="随着使用的逐渐增多，慢慢受不了在对这些概念的模糊的情况下使用了，所以找了些官方文档来学习一下C#中的这些概念，主要是为了区分委托（Delegate），事件（Event）。 其实我个人在读文档之前一直是对这些概念很模糊的，甚至一度被网上的各种博客绕晕了，甚至把Action，Func和委托都混淆了。 终于在我去读了官方的文档之后，我才对这些概念有了一些认知。 首先抛出最重要的结论，委托和事件都是为了提">

<link rel="canonical" href="https://sunra.top/posts/36409/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>C# 的委托和事件 | Origin of Ray</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-KEJ1L66CKC');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Origin of Ray</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://sunra.top/posts/36409/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
      <meta itemprop="name" content="Ray Sun">
      <meta itemprop="description" content="拨开互联网的迷雾">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Origin of Ray">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C# 的委托和事件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-25 12:14:44" itemprop="dateCreated datePublished" datetime="2022-03-25T12:14:44+08:00">2022-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-27 11:10:13" itemprop="dateModified" datetime="2023-05-27T11:10:13+08:00">2023-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>随着使用的逐渐增多，慢慢受不了在对这些概念的模糊的情况下使用了，所以找了些官方文档来学习一下C#中的这些概念，主要是为了区分委托（Delegate），事件（Event）。</p>
<p>其实我个人在读文档之前一直是对这些概念很模糊的，甚至一度被网上的各种博客绕晕了，甚至把Action，Func和委托都混淆了。</p>
<p>终于在我去读了官方的文档之后，我才对这些概念有了一些认知。</p>
<p>首先抛出最重要的结论，委托和事件都是为了提供后处理函数的方式，事件其实也是基于委托的多播的，而每次使用委托都要定义一个新的委托类型不方便，所以又提供了两种强类型的委托，就是Action和Func。</p>
<a id="more"></a>
<h1 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h1><p>委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。 在实例化委托时，你可以将其实例与任何具有兼容签名和返回类型的方法相关联。 你可以通过委托实例调用方法。</p>
<p>委托用于将方法作为参数传递给其他方法。 事件处理程序就是通过委托调用的方法。 你可以创建一个自定义方法，当发生特定事件时，某个类（如 Windows 控件）就可以调用你的方法。 下面的示例演示了一个委托声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int PerformCalculation(int x, int y);</span><br></pre></td></tr></table></figure>
<p>可将任何可访问类或结构中与委托类型匹配的任何方法分配给委托。 该方法可以是静态方法，也可以是实例方法。 此灵活性意味着你可以通过编程方式来更改方法调用，还可以向现有类中插入新代码。</p>
<p>这段代码的作用是声明了一个新的委托，注意，是声明，效果相当于声明了一个新的类型，可以理解成声明了一个新的class，并没有实例化。</p>
<p>将方法作为参数进行引用的能力使委托成为定义回调方法的理想选择。 可编写一个比较应用程序中两个对象的方法。 该方法可用在排序算法的委托中。 由于比较代码与库分离，因此排序方法可能更常见。</p>
<p>委托具有以下属性：</p>
<ul>
<li><p>委托类似于 C++ 函数指针，但委托完全面向对象，不像 C++ 指针会记住函数，委托会同时封装对象实例和方法。</p>
</li>
<li><p>委托允许将方法作为参数进行传递。</p>
</li>
<li><p>委托可用于定义回调方法。</p>
</li>
<li><p>委托可以链接在一起；例如，可以对一个事件调用多个方法。</p>
</li>
<li><p>方法不必与委托类型完全匹配。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates" rel="external nofollow noopener noreferrer" target="_blank">使用委托中的变体</a>。</p>
</li>
<li><p>使用 Lambda 表达式可以更简练地编写内联代码块。 Lambda 表达式（在某些上下文中）可编译为委托类型。 若要详细了解 lambda 表达式，请参阅 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions" rel="external nofollow noopener noreferrer" target="_blank">lambda 表达式</a>。</p>
</li>
</ul>
<h1 id="委托的使用"><a href="#委托的使用" class="headerlink" title="委托的使用"></a>委托的使用</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types" rel="external nofollow noopener noreferrer" target="_blank">委托</a>是安全封装方法的类型，类似于 C 和 C++ 中的函数指针。 与 C 函数指针不同的是，委托是面向对象的、类型安全的和可靠的。 委托的类型由委托的名称确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Del(string message);</span><br></pre></td></tr></table></figure>
<p>委托对象通常可采用两种方式进行构造，一种是提供带有方法名的delegate，另一种是使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions" rel="external nofollow noopener noreferrer" target="_blank">lambda 表达式</a>。 对委托进行实例化后，对委托的调用会被委托传递给方法。 调用方传递到委托的参数将传递到该方法，并且委托会将方法的返回值（如果有）返回到调用方。 这被称为调用委托。 实例化的委托可以按封装的方法本身进行调用。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Create a method for a delegate.public static void DelegateMethod(string message)</span><br><span class="line">public static void DelegateMethod(string message)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;</span><br><span class="line">// 实例化一个委托</span><br><span class="line">Del handler = DelegateMethod;</span><br><span class="line"></span><br><span class="line">// Call the delegate.</span><br><span class="line">handler( Hello World );</span><br></pre></td></tr></table></figure>
<p>委托类型派生自 .NET 中的 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.delegate" rel="external nofollow noopener noreferrer" target="_blank">Delegate</a> 类。 委托类型是<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/sealed" rel="external nofollow noopener noreferrer" target="_blank">密封的</a>，它们不能被派生，也不能从其派生出自定义类。 由于实例化的委托是一个对象，因此可以作为参数传递或分配给一个属性。 这允许方法接受委托作为参数并在稍后调用委托。 这被称为异步回调，是在长进程完成时通知调用方的常用方法。 当以这种方式使用委托时，使用委托的代码不需要知道要使用的实现方法。 功能类似于封装接口提供的功能。</p>
<p>当委托构造为封装实例方法时，委托将同时引用实例和方法。 委托不知道除其所封装方法以外的实例类型，因此委托可以引用任何类型的对象，只要该对象上有与委托签名匹配的方法。 当委托构造为封装静态方法时，委托仅引用方法。 请考虑以下声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MethodClass</span><br><span class="line">&#123;</span><br><span class="line">    public void Method1(string message) &#123; &#125;</span><br><span class="line">    public void Method2(string message) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上之前显示的静态 <code>DelegateMethod</code>，我们现在已有三个 <code>Del</code> 实例可以封装的方法。</p>
<p>调用时，委托可以调用多个方法。 这被称为多播。 若要向委托的方法列表（调用列表）添加其他方法，只需使用加法运算符或加法赋值运算符（“+”或“+=”）添加两个委托。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = new MethodClass();</span><br><span class="line">Del d1 = obj.Method1;</span><br><span class="line">Del d2 = obj.Method2;</span><br><span class="line">Del d3 = DelegateMethod;</span><br><span class="line"></span><br><span class="line">//Both types of assignment are valid.</span><br><span class="line">Del allMethodsDelegate = d1 + d2;</span><br><span class="line">allMethodsDelegate += d3;</span><br></pre></td></tr></table></figure>
<p>此时，<code>allMethodsDelegate</code> 的调用列表中包含三个方法，分别为 <code>Method1</code>、<code>Method2</code> 和 <code>DelegateMethod</code>。 原有的三个委托（<code>d1</code>、<code>d2</code> 和 <code>d3</code>）保持不变。 调用 <code>allMethodsDelegate</code> 时，将按顺序调用所有三个方法。 如果委托使用引用参数，引用将按相反的顺序传递到所有这三个方法，并且一种方法进行的任何更改都将在另一种方法上见到。 当方法引发未在方法内捕获到的异常时，该异常将传递到委托的调用方，并且不会调用调用列表中的后续方法。 如果委托具有返回值和/或输出参数，它将返回上次调用方法的返回值和参数。 若要删除调用列表中的方法，请使用<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/subtraction-operator" rel="external nofollow noopener noreferrer" target="_blank">减法运算符或减法赋值运算符</a>（ 或 <code>-=</code>）。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//remove Method1</span><br><span class="line">allMethodsDelegate -= d1;</span><br><span class="line"></span><br><span class="line">// copy AllMethodsDelegate while removing d2</span><br><span class="line">Del oneMethodDelegate = allMethodsDelegate - d2;</span><br></pre></td></tr></table></figure>
<p>由于委托类型派生自 <code>System.Delegate</code>，因此可以在委托上调用该类定义的方法和属性。 例如，若要查询委托调用列表中方法的数量，你可以编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int invocationCount = d1.GetInvocationList().GetLength(0);</span><br></pre></td></tr></table></figure>
<p>调用列表中具有多个方法的委托派生自 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.multicastdelegate" rel="external nofollow noopener noreferrer" target="_blank">MulticastDelegate</a>，该类属于 <code>System.Delegate</code> 的子类。 由于这两个类都支持 <code>GetInvocationList</code>，因此在其他情况下，上述代码也将产生作用。</p>
<p>多播委托广泛用于事件处理中。 事件源对象将事件通知发送到已注册接收该事件的接收方对象。 若要注册一个事件，接收方需要创建用于处理该事件的方法，然后为该方法创建委托并将委托传递到事件源。 事件发生时，源调用委托。 然后，委托将对接收方调用事件处理方法，从而提供事件数据。 给定事件的委托类型由事件源确定。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/" rel="external nofollow noopener noreferrer" target="_blank">事件</a>。</p>
<p>更多的使用方式可以参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate" rel="external nofollow noopener noreferrer" target="_blank">如何声明，实例化和使用委托</a></p>
<h1 id="强类型委托：Action，Func"><a href="#强类型委托：Action，Func" class="headerlink" title="强类型委托：Action，Func"></a>强类型委托：Action，Func</h1><p>抽象的 Delegate 类提供用于松散耦合和调用的基础结构。 通过包含和实施添加到委托对象的调用列表的方法的类型安全性，具体的委托类型将变得更加有用。 使用 <code>delegate</code> 关键字并定义具体的委托类型时，编译器将生成这些方法。</p>
<p>实际上，无论何时需要不同的方法签名，这都会创建新的委托类型。 一段时间后此操作可能变得繁琐。 每个新功能都需要新的委托类型。</p>
<p>幸运的是，没有必要这样做。 .NET Core 框架包含几个在需要委托类型时可重用的类型。 这些是<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/generics" rel="external nofollow noopener noreferrer" target="_blank">泛型</a>定义，因此需要新的方法声明时可以声明自定义。</p>
<p>第一个类型是 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.action" rel="external nofollow noopener noreferrer" target="_blank">Action</a> 类型和一些变体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Action();</span><br><span class="line">public delegate void Action&lt;in T&gt;(T arg);</span><br><span class="line">public delegate void Action&lt;in T1, in T2&gt;(T1 arg1, T2 arg2);</span><br><span class="line">// Other variations removed for brevity.</span><br></pre></td></tr></table></figure>
<p><code>Action</code> 委托的变体可包含多达 16 个参数，如 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.action-16" rel="external nofollow noopener noreferrer" target="_blank">Action</a>。 重要的是这些定义对每个委托参数使用不同的泛型参数：这样可以具有最大的灵活性。 方法参数不需要但可能是相同的类型。</p>
<p>对任何具有 void 返回类型的委托类型使用一种 <code>Action</code> 类型。</p>
<p>此框架还包括几种可用于返回值的委托类型的泛型委托类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate TResult Func&lt;out TResult&gt;();</span><br><span class="line">public delegate TResult Func&lt;in T1, out TResult&gt;(T1 arg);</span><br><span class="line">public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);</span><br><span class="line">// Other variations removed for brevity</span><br></pre></td></tr></table></figure>
<p><code>Func</code> 委托的变体可包含多达 16 个输入参数，如 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.func-17" rel="external nofollow noopener noreferrer" target="_blank">Func</a>。 按照约定，结果的类型始终是所有 <code>Func</code> 声明中的最后一个类型参数。</p>
<p>对任何返回值的委托类型使用一种 <code>Func</code> 类型。</p>
<p>还有一种专门的委托类型 <a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.predicate-1" rel="external nofollow noopener noreferrer" target="_blank">Predicate</a>，此类型返回单个值的测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate bool Predicate&lt;in T&gt;(T obj);</span><br></pre></td></tr></table></figure>
<p>你可能会注意到对于任何 <code>Predicate</code> 类型，均存在一个在结构上等效的 <code>Func</code> 类型，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;string, bool&gt; TestForString;</span><br><span class="line">Predicate&lt;string&gt; AnotherTestForString;</span><br></pre></td></tr></table></figure>
<p>你可能认为这两种类型是等效的。 它们不是。 这两个变量不能互换使用。 一种类型的变量无法赋予另一种类型。 C# 类型系统使用的是已定义类型的名称，而不是其结构。</p>
<h1 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h1><p>和委托类似，事件是<em>后期绑定</em>机制。 实际上，事件是建立在对委托的语言支持之上的。</p>
<p>事件是对象用于（向系统中的所有相关组件）广播已发生事情的一种方式。 任何其他组件都可以订阅事件，并在事件引发时得到通知。</p>
<p>你可能已在某些编程中使用过事件。 许多图形系统都具有用于报告用户交互的事件模型。 这些事件会报告鼠标移动、按钮点击和类似的交互。 这是使用事件的最常见情景之一，但并非唯一的情景。</p>
<p>可以定义应针对类引发的事件。 使用事件时，需要注意的一点是特定事件可能没有任何注册的对象。 必须编写代码，以确保在未配置侦听器时不会引发事件。</p>
<p>通过订阅事件，还可在两个对象（事件源和事件接收器）之间创建耦合。 需要确保当不再对事件感兴趣时，事件接收器将从事件源取消订阅。</p>
<h2 id="事件支持的设计目标"><a href="#事件支持的设计目标" class="headerlink" title="事件支持的设计目标"></a>事件支持的设计目标</h2><p>事件的语言设计针对这些目标：</p>
<ul>
<li><p>在事件源和事件接收器之间启用非常小的耦合。 这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p>
</li>
<li><p>订阅事件并从同一事件取消订阅应该非常简单。</p>
</li>
<li><p>事件源应支持多个事件订阅服务器。 它还应支持不附加任何事件订阅服务器。</p>
</li>
</ul>
<p>你会发现事件的目标与委托的目标非常相似。 因此，事件语言支持基于委托语言支持构建。</p>
<h2 id="事件的语言支持"><a href="#事件的语言支持" class="headerlink" title="事件的语言支持"></a>事件的语言支持</h2><p>用于定义事件以及订阅或取消订阅事件的语法是对委托语法的扩展。</p>
<p>定义使用 <code>event</code> 关键字的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public event EventHandler&lt;FileListArgs&gt; Progress;</span><br></pre></td></tr></table></figure>
<p>该事件（在此示例中，为 <code>EventHandler&lt;FileListArgs&gt;</code>）的类型必须为委托类型。 声明事件时，应遵循许多约定。 通常情况下，事件委托类型具有无效的返回。 事件声明应为谓词或谓词短语。 当事件报告已发生的事情时，请使用过去时。 使用现在时谓词（例如 <code>Closing</code>）报告将要发生的事情。 通常，使用现在时表示类支持某种类型的自定义行为。 最常见的方案之一是支持取消。 例如，<code>Closing</code> 事件可能包括指示是否应继续执行关闭操作的参数。 其他方案可能会允许调用方通过更新事件参数的属性来修改行为。 你可以引发一个事件以指示算法将采取的建议的下一步操作。 事件处理程序可以通过修改事件参数的属性授权不同的操作。</p>
<p>想要引发事件时，使用委托调用语法调用事件处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Progress?.Invoke(this, new FileListArgs(file));</span><br></pre></td></tr></table></figure>
<p>如<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/delegates-patterns" rel="external nofollow noopener noreferrer" target="_blank">委托</a>部分中所介绍的那样，?. 运算符可以轻松确保在事件没有订阅服务器时不引发事件。</p>
<p>通过使用 <code>+=</code> 运算符订阅事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;FileListArgs&gt; onProgress = (sender, eventArgs) =&gt;</span><br><span class="line">    Console.WriteLine(eventArgs.FoundFile);</span><br><span class="line"></span><br><span class="line">fileLister.Progress += onProgress;</span><br></pre></td></tr></table></figure>
<p>处理程序方法通常为前缀“On”，后跟事件名称，如上所示。</p>
<p>使用 <code>-=</code> 运算符取消订阅：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileLister.Progress -= onProgress;</span><br></pre></td></tr></table></figure>
<p>请务必为表示事件处理程序的表达式声明局部变量。 这将确保取消订阅删除该处理程序。 如果使用的是 lambda 表达式的主体，则将尝试删除从未附加过的处理程序，此操作为无效操作。</p>
<p>更多的事件使用方式，如怎样取消事件的执行等，可以看：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/event-pattern" rel="external nofollow noopener noreferrer" target="_blank">标准.NET事件模式</a>以及<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/modern-events" rel="external nofollow noopener noreferrer" target="_blank">新的事件模式</a></p>
<p>新的事件模式主要是放开了事件参数的限制，可以不必须继承自EventArgs，并且注意异步事件处理器</p>
<h1 id="区分委托和事件"><a href="#区分委托和事件" class="headerlink" title="区分委托和事件"></a>区分委托和事件</h1><p>它们都提供了一个后期绑定方案：在该方案中，组件通过调用仅在运行时识别的方法进行通信。 它们都支持单个和多个订阅服务器方法。 这称为单播和多播支持。 二者均支持用于添加和删除处理程序的类似语法。 最后，引发事件和调用委托使用完全相同的方法调用语法。 它们甚至都支持与 <code>?.</code> 运算符一起使用的相同的 <code>Invoke()</code> 方法语法。</p>
<p>鉴于所有这些相似之处，很难确定何时使用何种语法</p>
<h2 id="侦听事件是可选的"><a href="#侦听事件是可选的" class="headerlink" title="侦听事件是可选的"></a>侦听事件是可选的</h2><p>在确定要使用的语言功能时，最重要的考虑因素为是否必须具有附加的订阅服务器。 如果代码必须调用订阅服务器提供的代码，则在需要实现回调时，应使用基于委托的设计。 如果你的代码在不调用任何订阅服务器的情况下可完成其所有工作，则应使用基于事件的设计。</p>
<p>请考虑本部分中生成的示例。 必须为使用 <code>List.Sort()</code> 生成的代码提供 comparer 函数，以便对元素进行正确排序。 必须与委托一起提供 LINQ 查询，以便确定要返回的元素。 二者均使用与委托一起生成的设计。</p>
<p>请考虑 <code>Progress</code> 事件。 它会报告任务进度。 无论是否具有侦听器，该任务将继续进行。 <code>FileSearcher</code> 是另一个示例。 即使没有附加事件订阅服务器，它仍将搜索和查找已找到的所有文件。 即使没有任何订阅服务器侦听事件，UX 控件仍正常工作。 它们都使用基于事件的设计。</p>
<h2 id="返回值需要委托"><a href="#返回值需要委托" class="headerlink" title="返回值需要委托"></a>返回值需要委托</h2><p>另一个注意事项是委托方法所需的方法原型。 如你所见，用于事件的委托均具有无效的返回类型。 你还看到，存在创建事件处理程序的惯用语，该事件处理程序通过修改事件参数对象的属性将信息传回到事件源。 虽然这些惯用语可发挥作用，但它们不像从方法返回值那样自然。</p>
<p>请注意，这两种试探法可能经常同时存在：如果委托方法返回值，则可能会以某种方式影响算法。</p>
<h2 id="事件具有专用调用"><a href="#事件具有专用调用" class="headerlink" title="事件具有专用调用"></a>事件具有专用调用</h2><p>包含事件的类以外的类只能添加和删除事件侦听器；只有包含事件的类才能调用事件。 事件通常是公共类成员。 相比之下，委托通常作为参数传递，并存储为私有类成员（如果它们全部存储）。</p>
<h2 id="事件侦听器通常具有较长的生存期"><a href="#事件侦听器通常具有较长的生存期" class="headerlink" title="事件侦听器通常具有较长的生存期"></a>事件侦听器通常具有较长的生存期</h2><p>事件侦听器通常具有较长的生存期的这一理由不太充分。 但是，你可能会发现，当事件源将在很长一段时间内引发事件时，基于事件的设计会更加自然。 可以在许多系统上看到基于事件的 UX 控件设计示例。 订阅事件后，事件源可能会在程序的整个生存期内引发事件。 （当不再需要事件时，可以取消订阅事件。）</p>
<p>将其与许多基于委托的设计（其中委托用作方法的参数，且在返回该方法后不再使用此委托）进行比较。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Ray Sun
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://sunra.top/posts/36409/" title="C# 的委托和事件">https://sunra.top/posts/36409/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/18231/" rel="prev" title="Unity 打包体积优化">
      <i class="fa fa-chevron-left"></i> Unity 打包体积优化
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/12773/" rel="next" title="Unity 内存最佳实践">
      Unity 内存最佳实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是委托"><span class="nav-number">1.</span> <span class="nav-text">什么是委托</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#委托的使用"><span class="nav-number">2.</span> <span class="nav-text">委托的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强类型委托：Action，Func"><span class="nav-number">3.</span> <span class="nav-text">强类型委托：Action，Func</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是事件"><span class="nav-number">4.</span> <span class="nav-text">什么是事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件支持的设计目标"><span class="nav-number">4.1.</span> <span class="nav-text">事件支持的设计目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件的语言支持"><span class="nav-number">4.2.</span> <span class="nav-text">事件的语言支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#区分委托和事件"><span class="nav-number">5.</span> <span class="nav-text">区分委托和事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#侦听事件是可选的"><span class="nav-number">5.1.</span> <span class="nav-text">侦听事件是可选的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回值需要委托"><span class="nav-number">5.2.</span> <span class="nav-text">返回值需要委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件具有专用调用"><span class="nav-number">5.3.</span> <span class="nav-text">事件具有专用调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件侦听器通常具有较长的生存期"><span class="nav-number">5.4.</span> <span class="nav-text">事件侦听器通常具有较长的生存期</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg">
  <p class="site-author-name" itemprop="name">Ray Sun</p>
  <div class="site-description" itemprop="description">拨开互联网的迷雾</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">266</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sun668" title="GitHub → https://github.com/Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <div class="wechat_channel" style="width: 50%;margin-left: 25%;">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src="/images/wechat_channel.png">
        <!-- <span>公众号</span> -->
      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Sun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  <script src="/js/local-search.js"></script>












  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'c96bd5b842ef25ec37b4',
      clientSecret: '3aa1379592bcb2a5fe84791458cb67d41fa75f3e',
      repo        : 'Sun668.github.io',
      owner       : 'Sun668',
      admin       : ['Sun668'],
      id          : '2140bf86607cd77cfd5ad83179143818',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
