<!DOCTYPE html><html lang="default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="这次的主题是Render Prop以及高阶组件。"><meta property="og:type" content="article"><meta property="og:title" content="React入门（四）Render Prop 与 HOC"><meta property="og:url" content="https://sunra.top/posts/10396/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="这次的主题是Render Prop以及高阶组件。"><meta property="og:locale"><meta property="article:published_time" content="2021-04-01T11:39:58.000Z"><meta property="article:modified_time" content="2023-06-04T23:21:21.186Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/posts/10396/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"default","comments":true,"permalink":"https://sunra.top/posts/10396/","path":"posts/10396/","title":"React入门（四）Render Prop 与 HOC"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>React入门（四）Render Prop 与 HOC | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="Search" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Render-Prop"><span class="nav-number">1.</span> <span class="nav-text">Render Prop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRender-Prop"><span class="nav-number">1.1.</span> <span class="nav-text">什么是Render Prop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Render-Props-%E6%9D%A5%E8%A7%A3%E5%86%B3%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%88Cross-Cutting-Concerns%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Props-%E8%80%8C%E9%9D%9E-render"><span class="nav-number">1.3.</span> <span class="nav-text">使用 Props 而非 render</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.4.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86-Render-Props-%E4%B8%8E-React-PureComponent-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E6%97%B6%E8%A6%81%E5%B0%8F%E5%BF%83"><span class="nav-number">1.4.1.</span> <span class="nav-text">将 Render Props 与 React.PureComponent 一起使用时要小心</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88HOC%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">高阶组件（HOC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-HOC-%E8%A7%A3%E5%86%B3%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">使用 HOC 解决横切关注点问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E6%94%B9%E5%8F%98%E5%8E%9F%E5%A7%8B%E7%BB%84%E4%BB%B6%E3%80%82%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E3%80%82"><span class="nav-number">2.2.</span> <span class="nav-text">不要改变原始组件。使用组合。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E5%AE%9A%EF%BC%9A%E5%B0%86%E4%B8%8D%E7%9B%B8%E5%85%B3%E7%9A%84-props-%E4%BC%A0%E9%80%92%E7%BB%99%E8%A2%AB%E5%8C%85%E8%A3%B9%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">约定：将不相关的 props 传递给被包裹的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E5%AE%9A%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%8C%96%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">约定：最大化可组合性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E5%AE%9A%EF%BC%9A%E5%8C%85%E8%A3%85%E6%98%BE%E7%A4%BA%E5%90%8D%E7%A7%B0%E4%BB%A5%E4%BE%BF%E8%BD%BB%E6%9D%BE%E8%B0%83%E8%AF%95"><span class="nav-number">2.5.</span> <span class="nav-text">约定：包装显示名称以便轻松调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">2.6.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8-render-%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8-HOC"><span class="nav-number">2.6.1.</span> <span class="nav-text">不要在 render 方法中使用 HOC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A1%E5%BF%85%E5%A4%8D%E5%88%B6%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.2.</span> <span class="nav-text">务必复制静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Refs-%E4%B8%8D%E4%BC%9A%E8%A2%AB%E4%BC%A0%E9%80%92"><span class="nav-number">2.6.3.</span> <span class="nav-text">Refs 不会被传递</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%BD%AC%E5%8F%91-refs"><span class="nav-number">3.</span> <span class="nav-text">在高阶组件中转发 refs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%92%8C%E6%AF%94%E8%BE%83"><span class="nav-number">4.</span> <span class="nav-text">总结和比较</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">拨开互联网的迷雾</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">267</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">categories</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="default"><link itemprop="mainEntityOfPage" href="https://sunra.top/posts/10396/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="拨开互联网的迷雾"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="React入门（四）Render Prop 与 HOC | Origin of Ray"><meta itemprop="description" content="这次的主题是Render Prop以及高阶组件。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> React入门（四）Render Prop 与 HOC</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-04-01 19:39:58" itemprop="dateCreated datePublished" datetime="2021-04-01T19:39:58+08:00">2021-04-01</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2023-06-05 07:21:21" itemprop="dateModified" datetime="2023-06-05T07:21:21+08:00">2023-06-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline:</span><a title="waline" href="/posts/10396/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/10396/" itemprop="commentCount"></span></a></span></div><div class="post-description">这次的主题是Render Prop以及高阶组件。</div></div></header><div class="post-body" itemprop="articleBody"><p>这篇博客继续来看高级指引。</p><p>这次的主题是Render Prop以及高阶组件。</p><h2 id="Render-Prop"><a href="#Render-Prop" class="headerlink" title="Render Prop"></a>Render Prop</h2><h3 id="什么是Render-Prop"><a href="#什么是Render-Prop" class="headerlink" title="什么是Render Prop"></a>什么是Render Prop</h3><p>术语 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">“render prop”</a> 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p><p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意这段描述，看起来这个<strong>render prop和普通的prop并没有什么区别</strong>，react并不会对一个叫做render的prop做什么特殊处理，你需要自己在组件内部去调用</p></blockquote><h3 id="使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）"><a href="#使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）" class="headerlink" title="使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）"></a>使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）</h3><p>组件是 React 代码复用的主要单元，但如何将一个组件封装的状态或行为共享给其他需要相同状态的组件并不总是显而易见。</p><p>例如，以下组件跟踪 Web 应用程序中的鼠标位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &#x27;100vh&#x27; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;当前的鼠标位置是 (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当光标在屏幕上移动时，组件在 <code>&lt;p&gt;</code> 中显示其（x，y）坐标。</p><p>现在的问题是：我们如何在另一个组件中复用这个行为？换个说法，若另一个组件需要知道鼠标位置，我们能否封装这一行为，以便轻松地与其他组件共享它？？</p><p>由于组件是 React 中最基础的代码复用单元，现在尝试重构一部分代码使其能够在 <code>&lt;Mouse&gt;</code> 组件中封装我们需要共享的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// &lt;Mouse&gt; 组件封装了我们需要的行为...</span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &#x27;100vh&#x27; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* ...但我们如何渲染 &lt;p&gt; 以外的东西? */&#125;</span><br><span class="line">        &lt;p&gt;The current mouse position is (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>&lt;Mouse&gt;</code> 组件封装了所有关于监听 <code>mousemove</code> 事件和存储鼠标 (x, y) 位置的行为，但其仍不是真正的可复用。</p><p>举个例子，假设我们有一个 <code>&lt;Cat&gt;</code> 组件，它可以呈现一张在屏幕上追逐鼠标的猫的图片。我们或许会使用 <code>&lt;Cat mouse=&#123; &#123; x, y &#125;&#125;</code> prop 来告诉组件鼠标的坐标以让它知道图片应该在屏幕哪个位置。</p><p>首先, 你或许会像这样，尝试在 <code>&lt;Mouse&gt;</code> 内部的渲染方法渲染 <code>&lt;Cat&gt;</code> 组件：:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &#x27;absolute&#x27;, left: mouse.x, top: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseWithCat extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &#x27;100vh&#x27; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          我们可以在这里换掉 &lt;p&gt; 的 &lt;Cat&gt;   ......</span><br><span class="line">          但是接着我们需要创建一个单独的 &lt;MouseWithSomethingElse&gt;</span><br><span class="line">          每次我们需要使用它时，&lt;MouseWithCat&gt; 是不是真的可以重复使用.</span><br><span class="line">        */&#125;</span><br><span class="line">        &lt;Cat mouse=&#123;this.state&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;MouseWithCat /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法适用于我们的特定用例，但我们还没有达到以可复用的方式真正封装行为的目标。现在，每当我们想要鼠标位置用于不同的用例时，我们必须创建一个新的组件（本质上是另一个 <code>&lt;MouseWithCat&gt;</code> ），它专门为该用例呈现一些东西.</p><blockquote><p>这段话的意思是，其实Cat这个组件还是写死在了<code>&lt;MouseWithCat&gt;</code>组件中，以后你可能还需要<code>&lt;MouseWithDog&gt;</code>，<code>&lt;MouseWithMonkey&gt;</code></p></blockquote><p>这也是 render prop 的来历：相比于直接将 <code>&lt;Cat&gt;</code> 写死在 <code>&lt;Mouse&gt;</code> 组件中，并且有效地更改渲染的结果，我们可以为 <code>&lt;Mouse&gt;</code> 提供一个函数 prop 来动态的确定要渲染什么 —— 一个 render prop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &#x27;absolute&#x27;, left: mouse.x, top: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &#x27;100vh&#x27; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          使用 `render`prop 动态决定要渲染的内容，</span><br><span class="line">          而不是给出一个 &lt;Mouse&gt; 渲染结果的静态表示</span><br><span class="line">        */&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们提供了一个 <code>render</code> 方法 让 <code>&lt;Mouse&gt;</code> 能够动态决定什么需要渲染，而不是克隆 <code>&lt;Mouse&gt;</code> 组件然后硬编码来解决特定的用例。</p><p>更具体地说，<strong>render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</strong></p><p>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有 <code>render</code> prop 的 <code>&lt;Mouse&gt;</code> 组件就能够告诉它当前鼠标坐标 (x, y) 要渲染什么。</p><p>关于 render prop 一个有趣的事情是你可以使用带有 render prop 的常规组件来实现大多数<a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a> (HOC)。 例如，如果你更喜欢使用 <code>withMouse</code> HOC而不是 <code>&lt;Mouse&gt;</code> 组件，你可以使用带有 render prop 的常规 <code>&lt;Mouse&gt;</code> 轻松创建一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果你出于某种原因真的想要 HOC，那么你可以轻松实现</span><br><span class="line">// 使用具有 render prop 的普通组件创建一个！</span><br><span class="line">function withMouse(Component) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，你可以将任一模式与 render prop 一起使用。</p><h3 id="使用-Props-而非-render"><a href="#使用-Props-而非-render" class="headerlink" title="使用 Props 而非 render"></a>使用 Props 而非 <code>render</code></h3><p>重要的是要记住，render prop 是因为模式才被称为 <em>render</em> prop ，你不一定要用名为 <code>render</code> 的 prop 来使用这种模式。事实上， <a target="_blank" rel="external nofollow noopener noreferrer" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce"><em>任何</em>被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”</a>.</p><p>尽管之前的例子使用了 <code>render</code>，我们也可以简单地使用 <code>children</code> prop！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mouse children=&#123;mouse =&gt; (</span><br><span class="line">  &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure><p>记住，<code>children</code> prop 并不真正需要添加到 JSX 元素的 “attributes” 列表中。相反，你可以直接放置到元素的<em>内部</em>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mouse&gt;</span><br><span class="line">  &#123;mouse =&gt; (</span><br><span class="line">    &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Mouse&gt;</span><br></pre></td></tr></table></figure><p>你将在 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/chenglou/react-motion">react-motion</a> 的 API 中看到此技术。</p><p>由于这一技术的特殊性，当你在设计一个类似的 API 时，你或许会要直接地在你的 propTypes 里声明 children 的类型应为一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mouse.propTypes = &#123;</span><br><span class="line">  children: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="将-Render-Props-与-React-PureComponent-一起使用时要小心"><a href="#将-Render-Props-与-React-PureComponent-一起使用时要小心" class="headerlink" title="将 Render Props 与 React.PureComponent 一起使用时要小心"></a>将 Render Props 与 React.PureComponent 一起使用时要小心</h4><p>如果你在 render 方法里创建函数，那么使用 render prop 会抵消使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent"><code>React.PureComponent</code></a> 带来的优势。因为浅比较 props 的时候总会得到 false，并且在这种情况下每一个 <code>render</code> 对于 render prop 将会生成一个新的值。</p><blockquote><p><code>React.PureComponent</code> 与 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 很相似。两者的区别在于 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 并未实现 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数，也就是说<code>React.PureComponent</code>更新之前会调用自己实现的shouldComponentUpdate方法，该方法会浅层比较state和prop，如果相同，就不更新。</p></blockquote><p>例如，继续我们之前使用的 <code>&lt;Mouse&gt;</code> 组件，如果 <code>Mouse</code> 继承自 <code>React.PureComponent</code> 而不是 <code>React.Component</code>，我们的例子看起来就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Mouse extends React.PureComponent &#123;</span><br><span class="line">  // 与上面相同的代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          这是不好的！</span><br><span class="line">          每个渲染的 `render` prop的值将会是不同的。</span><br><span class="line">        */&#125;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样例子中，每次 <code>&lt;MouseTracker&gt;</code> 渲染，它会生成一个新的函数作为 <code>&lt;Mouse render&gt;</code> 的 prop，因而在同时也抵消了继承自 <code>React.PureComponent</code> 的 <code>&lt;Mouse&gt;</code> 组件的效果！</p><blockquote><p>每次重新渲染<code>&lt;MouseTracker&gt;</code>都会重新生成一个新的函数赋值给render，所以虽然函数功能是相同的，但是已经是另一个函数了，浅比较的时候，比较的是内存内置，所以一定是false，但其实要做的事没有变化。</p></blockquote><p>为了绕过这一问题，有时你可以定义一个 prop 作为实例方法，类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  // 定义为实例方法，`this.renderTheCat`始终</span><br><span class="line">  // 当我们在渲染中使用它时，它指的是相同的函数</span><br><span class="line">  renderTheCat(mouse) &#123;</span><br><span class="line">    return &lt;Cat mouse=&#123;mouse&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;this.renderTheCat&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你无法静态定义 prop（例如，因为你需要关闭组件的 props 和/或 state），则 <code>&lt;Mouse&gt;</code> 应该继承自 <code>React.Component</code>。</p><h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p><h3 id="使用-HOC-解决横切关注点问题"><a href="#使用-HOC-解决横切关注点问题" class="headerlink" title="使用 HOC 解决横切关注点问题"></a>使用 HOC 解决横切关注点问题</h3><p>组件是 React 中代码复用的基本单元。但你会发现某些模式并不适合传统组件。</p><p>例如，假设有一个 <code>CommentList</code> 组件，它订阅外部数据源，用以渲染评论列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class CommentList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      // 假设 &quot;DataSource&quot; 是个全局范围内的数据源变量</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 订阅更改</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    // 清除订阅</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    // 当数据源更新时，更新组件状态</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.comments.map((comment) =&gt; (</span><br><span class="line">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BlogPost extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(this.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CommentList</code> 和 <code>BlogPost</code> 不同 - 它们在 <code>DataSource</code> 上调用不同的方法，且渲染不同的结果。但它们的大部分实现都是一样的：</p><ul><li>在挂载时，向 <code>DataSource</code> 添加一个更改侦听器。</li><li>在侦听器内部，当数据源发生变化时，调用 <code>setState</code>。</li><li>在卸载时，删除侦听器。</li></ul><p>你可以想象，在一个大型应用程序中，这种订阅 <code>DataSource</code> 和调用 <code>setState</code> 的模式将一次又一次地发生。我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p><p>对于订阅了 <code>DataSource</code> 的组件，比如 <code>CommentList</code> 和 <code>BlogPost</code>，我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。让我们调用函数 <code>withSubscription</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const BlogPostWithSubscription = withSubscription(</span><br><span class="line">  BlogPost,</span><br><span class="line">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第一个参数是被包装组件。第二个参数通过 <code>DataSource</code> 和当前的 props 返回我们需要的数据。</p><p>当渲染 <code>CommentListWithSubscription</code> 和 <code>BlogPostWithSubscription</code> 时， <code>CommentList</code> 和 <code>BlogPost</code> 将传递一个 <code>data</code> prop，其中包含从 <code>DataSource</code> 检索到的最新数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 此函数接收一个组件...</span><br><span class="line">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  // ...并返回另一个组件...</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.handleChange = this.handleChange.bind(this);</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      // ...负责订阅相关的操作...</span><br><span class="line">      DataSource.addChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      // ... 并使用新数据渲染被包装的组件!</span><br><span class="line">      // 请注意，我们可能还会传递其他属性</span><br><span class="line">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，<strong>HOC 通过将组件<em>包装</em>在容器组件中来<em>组成</em>新组件。HOC 是纯函数，没有副作用</strong>。</p><p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 <code>data</code> prop。<strong>HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的</strong>。</p><p>因为 <code>withSubscription</code> 是一个普通函数，你可以根据需要对参数进行增添或者删除。例如，您可能希望使 <code>data</code> prop 的名称可配置，以进一步将 HOC 与包装组件隔离开来。或者你可以接受一个配置 <code>shouldComponentUpdate</code> 的参数，或者一个配置数据源的参数。因为 HOC 可以控制组件的定义方式，这一切都变得有可能。</p><p>与组件一样，<code>withSubscription</code> 和包装组件之间的契约完全基于之间传递的 props。这种依赖方式使得替换 HOC 变得容易，只要它们为包装的组件提供相同的 prop 即可。例如你需要改用其他库来获取数据的时候，这一点就很有用。</p><h3 id="不要改变原始组件。使用组合。"><a href="#不要改变原始组件。使用组合。" class="headerlink" title="不要改变原始组件。使用组合。"></a>不要改变原始组件。使用组合。</h3><p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function logProps(InputComponent) &#123;</span><br><span class="line">  InputComponent.prototype.componentDidUpdate = function(prevProps) &#123;</span><br><span class="line">    console.log(&#x27;Current props: &#x27;, this.props);</span><br><span class="line">    console.log(&#x27;Previous props: &#x27;, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 返回原始的 input 组件，暗示它已经被修改。</span><br><span class="line">  return InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每次调用 logProps 时，增强组件都会有 log 输出。</span><br><span class="line">const EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure><p>这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 <code>componentDidUpdate</code> 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。</p><p>修改传入组件的 HOC 是一种糟糕的抽象方式。调用者必须知道他们是如何实现的，以避免与其他 HOC 发生冲突。</p><p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#x27;Current props: &#x27;, this.props);</span><br><span class="line">      console.log(&#x27;Previous props: &#x27;, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      // 将 input 组件包装在容器中，而不对其进行修改。Good!</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 HOC 与上文中修改传入组件的 HOC 功能相同，同时避免了出现冲突的情况。它同样适用于 class 组件和函数组件。而且因为它是一个纯函数，它可以与其他 HOC 组合，甚至可以与其自身组合。</p><h3 id="约定：将不相关的-props-传递给被包裹的组件"><a href="#约定：将不相关的-props-传递给被包裹的组件" class="headerlink" title="约定：将不相关的 props 传递给被包裹的组件"></a>约定：将不相关的 props 传递给被包裹的组件</h3><p>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。</p><p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 过滤掉非此 HOC 额外的 props，且不要进行透传</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; = this.props;</span><br><span class="line"></span><br><span class="line">  // 将 props 注入到被包装的组件中。</span><br><span class="line">  // 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  // 将 props 传递给被包装组件</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种约定保证了 HOC 的灵活性以及可复用性。</p><h3 id="约定：最大化可组合性"><a href="#约定：最大化可组合性" class="headerlink" title="约定：最大化可组合性"></a>约定：最大化可组合性</h3><p>并不是所有的 HOC 都一样。有时候它仅接受一个参数，也就是被包裹的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure><p>HOC 通常可以接收多个参数。比如在 Relay 中，HOC 额外接收了一个配置对象用于指定组件的数据依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure><p>最常见的 HOC 签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// React Redux 的 `connect` 函数</span><br><span class="line">const ConnectedComment = connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure><p><em>刚刚发生了什么？！</em>如果你把它分开，就会更容易看出发生了什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// connect 是一个函数，它的返回值为另外一个函数。</span><br><span class="line">const enhance = connect(commentListSelector, commentListActions);</span><br><span class="line">// 返回值为 HOC，它会返回已经连接 Redux store 的组件</span><br><span class="line">const ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure><p>换句话说，<code>connect</code> 是一个返回高阶组件的高阶函数！</p><p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性。 像 <code>connect</code> 函数返回的单参数 HOC 具有签名 <code>Component =&gt; Component</code>。 输出类型与输入类型相同的函数很容易组合在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 而不是这样...</span><br><span class="line">const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class="line"></span><br><span class="line">// ... 你可以编写组合工具函数</span><br><span class="line">// compose(f, g, h) 等同于 (...args) =&gt; f(g(h(...args)))</span><br><span class="line">const enhance = compose(</span><br><span class="line">  // 这些都是单参数的 HOC</span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line">const EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure><p>（同样的属性也允许 <code>connect</code> 和其他 HOC 承担装饰器的角色，装饰器是一个实验性的 JavaScript 提案。）</p><p>许多第三方库都提供了 <code>compose</code> 工具函数，包括 lodash （比如 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://lodash.com/docs/#flowRight"><code>lodash.flowRight</code></a>）， <a target="_blank" rel="external nofollow noopener noreferrer" href="https://redux.js.org/api/compose">Redux</a> 和 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://ramdajs.com/docs/#compose">Ramda</a>。</p><h3 id="约定：包装显示名称以便轻松调试"><a href="#约定：包装显示名称以便轻松调试" class="headerlink" title="约定：包装显示名称以便轻松调试"></a>约定：包装显示名称以便轻松调试</h3><p>HOC 创建的容器组件会与任何其他组件一样，会显示在 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/facebook/react-devtools">React Developer Tools</a> 中。为了方便调试，请选择一个显示名称，以表明它是 HOC 的产物。</p><p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 <code>withSubscription</code>，并且被包装组件的显示名称为 <code>CommentList</code>，显示名称应该为 <code>WithSubscription(CommentList)</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withSubscription(WrappedComponent) &#123;</span><br><span class="line">  class WithSubscription extends React.Component &#123;/* ... */&#125;</span><br><span class="line">  WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`;</span><br><span class="line">  return WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDisplayName(WrappedComponent) &#123;</span><br><span class="line">  return WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>高阶组件有一些需要注意的地方，对于 React 新手来说可能并不容易发现。</p><h4 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h4><p>React 的 diff 算法（称为<a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a>）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 <code>render</code> 返回的组件与前一个渲染中的组件相同（<code>===</code>），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p><p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 每次调用 render 函数都会创建一个新的 EnhancedComponent</span><br><span class="line">  // EnhancedComponent1 !== EnhancedComponent2</span><br><span class="line">  const EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span><br><span class="line">  return &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p><p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p><p>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p><h4 id="务必复制静态方法"><a href="#务必复制静态方法" class="headerlink" title="务必复制静态方法"></a>务必复制静态方法</h4><p>有时在 React 组件上定义静态方法很有用。例如，Relay 容器暴露了一个静态方法 <code>getFragment</code> 以方便组合 GraphQL 片段。</p><p>但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义静态函数</span><br><span class="line">WrappedComponent.staticMethod = function() &#123;/*...*/&#125;</span><br><span class="line">// 现在使用 HOC</span><br><span class="line">const EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line">// 增强组件没有 staticMethod</span><br><span class="line">typeof EnhancedComponent.staticMethod === &#x27;undefined&#x27; // true</span><br></pre></td></tr></table></figure><p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  // 必须准确知道应该拷贝哪些方法 :(</span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a> 自动拷贝所有非 React 静态方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import hoistNonReactStatic from &#x27;hoist-non-react-statics&#x27;;</span><br><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用这种方式代替...</span><br><span class="line">MyComponent.someFunction = someFunction;</span><br><span class="line">export default MyComponent;</span><br><span class="line"></span><br><span class="line">// ...单独导出该方法...</span><br><span class="line">export &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line">// ...并在要使用的组件中，import 它们</span><br><span class="line">import MyComponent, &#123; someFunction &#125; from &#x27;./MyComponent.js&#x27;;</span><br></pre></td></tr></table></figure><h4 id="Refs-不会被传递"><a href="#Refs-不会被传递" class="headerlink" title="Refs 不会被传递"></a>Refs 不会被传递</h4><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 <code>ref</code> 实际上并不是一个 prop - 就像 <code>key</code> 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p><p>这个问题的解决方案是通过使用 <code>React.forwardRef</code> API</p><h2 id="在高阶组件中转发-refs"><a href="#在高阶组件中转发-refs" class="headerlink" title="在高阶组件中转发 refs"></a>在高阶组件中转发 refs</h2><p>这个技巧对<a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件</a>（也被称为 HOC）特别有用。让我们从一个输出组件 props 到控制台的 HOC 示例开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;  class LogProps extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#x27;old props:&#x27;, prevProps);</span><br><span class="line">      console.log(&#x27;new props:&#x27;, this.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return LogProps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“logProps” HOC 透传（pass through）所有 <code>props</code> 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class FancyButton extends React.Component &#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们导出 LogProps，而不是 FancyButton。</span><br><span class="line">// 虽然它也会渲染一个 FancyButton。</span><br><span class="line">export default logProps(FancyButton);</span><br></pre></td></tr></table></figure><p>下面的示例有一点需要注意：<strong>refs 将不会透传下去。这是因为 <code>ref</code> 不是 prop 属性</strong>。就像 <code>key</code> 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</p><p>这意味着用于我们 <code>FancyButton</code> 组件的 refs 实际上将被挂载到 <code>LogProps</code> 组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import FancyButton from &#x27;./FancyButton&#x27;;</span><br><span class="line"></span><br><span class="line">const ref = React.createRef();</span><br><span class="line">// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。</span><br><span class="line">// 尽管渲染结果将是一样的，</span><br><span class="line">// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！</span><br><span class="line">// 这意味着我们不能调用例如 ref.current.focus() 这样的方法</span><br><span class="line">&lt;FancyButton</span><br><span class="line">  label=&quot;Click Me&quot;</span><br><span class="line">  handleClick=&#123;handleClick&#125;</span><br><span class="line">  ref=&#123;ref&#125;/&gt;;</span><br></pre></td></tr></table></figure><p>幸运的是，我们可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到内部的 <code>FancyButton</code> 组件。<code>React.forwardRef</code> 接受一个渲染函数，其接收 <code>props</code> 和 <code>ref</code> 参数并返回一个 React 节点。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function logProps(Component) &#123;</span><br><span class="line">  class LogProps extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#x27;old props:&#x27;, prevProps);</span><br><span class="line">      console.log(&#x27;new props:&#x27;, this.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123;forwardedRef, ...rest&#125; = this.props;</span><br><span class="line">      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span><br><span class="line">      return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;;    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注意 React.forwardRef 回调的第二个参数 “ref”。</span><br><span class="line">  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span><br><span class="line">  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span><br><span class="line">  return React.forwardRef((props, ref) =&gt; &#123;    </span><br><span class="line">      return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;·</span><br></pre></td></tr></table></figure><p><code>logProps</code>组件是<code>React.forwardRef</code>返回的Ref转发组件，传入它的ref属性会一层层传递到一个它被传入到ref属性的组件中。</p><p>这样说比较绕，就说是，我们创建一个refA，赋值给<code>logProps</code>，但因为它是转发组件，所以这个时候并不会给refA赋值，而是直接透传到<code>forwardedRef</code>属性，再透传到<code>Component</code>组件的<code>ref</code>属性，如果这个组件不是转发组件，那这个时候才会对这个refA真正赋值。</p><h2 id="总结和比较"><a href="#总结和比较" class="headerlink" title="总结和比较"></a>总结和比较</h2><p>无论是Render Prop还是HOC，都是为了解决横切关注点问题。</p><p>那么首先，我们要理解下什么是横切关注点</p><blockquote><p>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。</p></blockquote><p>这样说好像还是特别抽象？那我们举个例子。</p><p><strong>日志功能</strong>就是<strong>横切关注点</strong>的一个典型案例。日志功能往往横跨系统中的每个业务模块，即“<strong>横切</strong>”所有需要日志功能的类和方法体。所以我们说日志成为了<strong>横切</strong>整个系统对象结构的<strong>关注点</strong> —— 也就叫做<strong>横切关注点</strong>啦。</p><blockquote><p>说的实际一点，就是说这两个东西都是为了解决重复代码问题的。</p><p>对于重复的代码部分，我们把它抽取成一个组件，并给不同的部分预留好位置：</p><ul><li>对于HOC来讲，它是利用函数的入参（至少有一个是公共组件）去通过函数逻辑构造新的组件</li><li>对于Render Prop来讲，它是在公共组件中预留一个地方去调用未来传入的Render Prop。</li></ul><p>对于不同的部分：</p><ul><li>对于HOC来讲，我们可以通过HOC来利用一个函数去利用重复的部分去去生成一个新的组件。</li><li>对于Render Prop来讲，可以通过Render Prop直接传入生成我们要渲染的组件的函数，然后在公共部分中调用这个函数去渲染不同的组件部分。</li></ul></blockquote><p>这二者都不是什么React的特殊语法糖，也就是这两个并不是React的源码会做特殊处理的，都只是React基本语法的使用方式，Render Prop就是个普通的prop，只要你传入的prop是个返回组件的函数（设为A），并且在该组件（设为B）的某个地方调用并渲染了这个组件A，那这个prop就是Render Prop。</p><p>而HOC就是个函数而已，只不过这个函数的入参和返回都是组件，你可以利用入参的组件去创建一个新的组件，但是请不要去改变入参的组件。</p><p>区别的话，HOC更加灵活，函数中可以有很多逻辑，Render Prop就只能传入一个Render函数给Prop。</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>Post author:</strong> Ray Sun</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="https://sunra.top/posts/10396/" title="React入门（四）Render Prop 与 HOC">https://sunra.top/posts/10396/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="followme"> <span>Welcome to my other publishing channels</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/30069/" rel="prev" title="React 入门系列（三）Context"><i class="fa fa-chevron-left"></i> React 入门系列（三）Context</a></div><div class="post-nav-item"> <a href="/posts/5/" rel="next" title="React入门（五）错误边界">React入门（五）错误边界<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/posts/10396/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>