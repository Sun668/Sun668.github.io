<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="总述 本文大概总结下一些三维空间的坐标数据是如何通过渲染流水线变为屏幕上不同颜色的像素的，阅读之时，需要注意，图元，片元，和像素三者的区别。 下图是一个总体的流程图，具体细节可以看后面的解释。"><meta property="og:type" content="article"><meta property="og:title" content="Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点"><meta property="og:url" content="https://sunra.top/posts/63218/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="总述 本文大概总结下一些三维空间的坐标数据是如何通过渲染流水线变为屏幕上不同颜色的像素的，阅读之时，需要注意，图元，片元，和像素三者的区别。 下图是一个总体的流程图，具体细节可以看后面的解释。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646000/origin-of-ray/render_pipeline_gnuamz.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646124/origin-of-ray/asynccode_q28ocq.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646148/origin-of-ray/asynccode_ginlkt.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646175/origin-of-ray/asynccode_kopbkx.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646237/origin-of-ray/asynccode_kgktgg.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646263/origin-of-ray/asynccode_s4tmq5.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646294/origin-of-ray/asynccode_re54bh.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646323/origin-of-ray/asynccode_b7gtzl.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646357/origin-of-ray/asynccode_viggia.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646391/origin-of-ray/asynccode_wyxw6o.png"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646424/origin-of-ray/asynccode_dk5lwg.png"><meta property="article:published_time" content="2021-12-16T09:21:28.000Z"><meta property="article:modified_time" content="2024-11-22T23:46:50.448Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646000/origin-of-ray/render_pipeline_gnuamz.png"><link rel="canonical" href="https://sunra.top/posts/63218/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunra.top/posts/63218/","path":"posts/63218/","title":"Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点 | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">2.</span> <span class="nav-text">什么是渲染流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.1.</span> <span class="nav-text">渲染流水线的任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5%E9%98%B6%E6%AE%B5"><span class="nav-number">2.2.</span> <span class="nav-text">渲染流水线的三个概念阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">应用阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5"><span class="nav-number">2.2.2.</span> <span class="nav-text">几何阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">2.2.3.</span> <span class="nav-text">光栅化阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cpu%E5%92%8Cgpu%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">3.</span> <span class="nav-text">CPU和GPU之间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E5%AD%98%E4%B8%AD"><span class="nav-number">3.1.</span> <span class="nav-text">把数据加载到显存中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.</span> <span class="nav-text">设置渲染状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8draw-call"><span class="nav-number">3.3.</span> <span class="nav-text">调用Draw call</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gpu%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">4.</span> <span class="nav-text">GPU流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">顶点着色器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%81%E5%89%AA"><span class="nav-number">4.2.</span> <span class="nav-text">裁剪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.</span> <span class="nav-text">屏幕映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%BE%E7%BD%AE"><span class="nav-number">4.4.</span> <span class="nav-text">三角形设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="nav-number">4.5.</span> <span class="nav-text">三角形遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">片元着色器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E7%89%87%E5%85%83%E6%93%8D%E4%BD%9C"><span class="nav-number">4.7.</span> <span class="nav-text">逐片元操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E6%B5%8B%E8%AF%95"><span class="nav-number">4.7.1.</span> <span class="nav-text">模版测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="nav-number">4.7.2.</span> <span class="nav-text">深度测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6"><span class="nav-number">4.7.3.</span> <span class="nav-text">合并</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">一起探索互联网的秘密</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">321</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sunra.top/posts/63218/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="一起探索互联网的秘密"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点 | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-16 17:21:28" itemprop="dateCreated datePublished" datetime="2021-12-16T17:21:28+08:00">2021-12-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-11-23 07:46:50" itemprop="dateModified" datetime="2024-11-23T07:46:50+08:00">2024-11-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline：</span><a title="waline" href="/posts/63218/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/63218/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="总述"><a class="markdownIt-Anchor" href="#总述"></a> 总述</h1><p>本文大概总结下一些三维空间的坐标数据是如何通过渲染流水线变为屏幕上不同颜色的像素的，阅读之时，需要注意，图元，片元，和像素三者的区别。</p><p>下图是一个总体的流程图，具体细节可以看后面的解释。</p><span id="more"></span><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646000/origin-of-ray/render_pipeline_gnuamz.png" alt></p><h1 id="什么是渲染流水线"><a class="markdownIt-Anchor" href="#什么是渲染流水线"></a> 什么是渲染流水线</h1><h2 id="渲染流水线的任务"><a class="markdownIt-Anchor" href="#渲染流水线的任务"></a> 渲染流水线的任务</h2><p>渲染流水线的工作就是，从一个三维场景出发，渲染出一张二维图像。</p><p>也就是说，需要从一系列三维空间信息，如顶点数据，纹理等信息出发，把这些信息最终转化为一张人眼可以看到的二维图像。</p><p>而这个工作通常是由CPU和GPU共同完成的。</p><h2 id="渲染流水线的三个概念阶段"><a class="markdownIt-Anchor" href="#渲染流水线的三个概念阶段"></a> 渲染流水线的三个概念阶段</h2><p>注意，这三个阶段只是概念上的阶段，每个阶段内部还有很多步骤，通常也是一个流水线系统。</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646124/origin-of-ray/asynccode_q28ocq.png" alt="img"></p><h3 id="应用阶段"><a class="markdownIt-Anchor" href="#应用阶段"></a> 应用阶段</h3><p>之所以叫应用阶段，是因为这个阶段是的工作是在我们应用中进行的，通常在CPU中执行，开发者对这个阶段有着绝对的控制权。</p><p>在这一阶段，开发者主要有三个任务：</p><ol><li><p>准备好场景数据，例如摄像机的位置，视锥体，场景中的模型的点信息，光源的位置强度等信息。</p></li><li><p>有了以上信息之后，为了提高渲染性能，我们要做一个粗粒度的剔除（culling）工作，以把那些不可见的物体剔除出去，这样就不需要交给几何阶段处理了。</p></li></ol><p>注意剔除不同于后面的裁剪，将完全不在视锥体中的物体信息完全剔除，直接将物体的信息丢弃就好，而后面讲的裁剪，指的是哪些一半在视锥体内，一半不在的，对于这种，我们在丢弃一部分点信息的同时，还要为物体和视锥体相交时的交点信息加上。</p><ol><li>最后，我们要设置好每个模型的渲染状态，这些状态包括但不限于材质（漫反射颜色，高光反射颜色），纹理，Shader等。这一阶段最重要的是输出渲染所需的几何信息，即渲染图元（rendering primitives）。通俗来讲，渲染图元可以是点，线，三角面等。</li></ol><p>应用阶段的结果就是所有需要被渲染的3D信息。</p><h3 id="几何阶段"><a class="markdownIt-Anchor" href="#几何阶段"></a> 几何阶段</h3><p>几何阶段用于处理所有和我们要绘制的几何相关的事情。例如，决定需要绘制的图元是什么，怎么绘制它们，在哪里绘制它们，这一阶段通常在GPU上进行</p><p>几何阶段负责和每个渲染图元打交道，然后进行逐顶点，逐多边形的操作，这个阶段可以进一步划分为更加小的流水线阶段。</p><p>几何阶段的一个重要任务就是把顶点坐标变换到屏幕坐标中，再交给光栅器进行处理。</p><p>通过对输入的图元进行多步处理之后，这一阶段将会输出屏幕空间的二维顶点坐标，每个顶点对应的深度值，着色等相关信息，并传递给下一个阶段。</p><h3 id="光栅化阶段"><a class="markdownIt-Anchor" href="#光栅化阶段"></a> 光栅化阶段</h3><p>这一阶段将会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</p><p>这一阶段也是在GPU上运行。</p><p>光栅化的任务主要是决定每个渲染图元的哪些像素应该被绘制在屏幕上，它需要对上一个阶段得到的逐顶点数据（如纹理坐标，顶点颜色）进行插值，然后进行逐像素处理。</p><p>上一步得到的结果的点，并不是和屏幕上的像素点一一对应的，比如假设屏幕上像素点的坐标都是整数的，而上一步计算的屏幕坐标很有可能是小数位的，我们不能直接简单粗暴的把这个点的值选择一个最近的像素点赋予，而是要进行插值计算。</p><h1 id="cpu和gpu之间的通信"><a class="markdownIt-Anchor" href="#cpu和gpu之间的通信"></a> CPU和GPU之间的通信</h1><p>渲染流水线的起点是CPU，即应用阶段。应用阶段大致可分为三个阶段：</p><ol><li><p>把数据加载到显存中。</p></li><li><p>设置渲染状态</p></li><li><p>调用Draw Call通知GPU。</p></li></ol><h2 id="把数据加载到显存中"><a class="markdownIt-Anchor" href="#把数据加载到显存中"></a> 把数据加载到显存中</h2><p>所有渲染所需的数据都需要从硬盘中加载到系统内存。然后网格和纹理等数据又被加载到显卡上的存储空间——显存。这是因为，显卡对于显存的访问速度更快，而大多数显卡对于内存没有直接访问的权利。</p><p>当把数据加载到显存中后，RAM中的数据就可以移除了。但对于一些数据来说，CPU仍然需要访问它们（例如，我们希望CPU可以访问网格数据来检测碰撞），那么我们可能就不希望这些数据被移除。</p><h2 id="设置渲染状态"><a class="markdownIt-Anchor" href="#设置渲染状态"></a> 设置渲染状态</h2><p>什么是渲染状态？一个通俗的解释就是，这些状态定义了场景中的网格是怎么被渲染的，例如使用了哪个顶点着色器，片元着色器，光源属性，材质等。</p><p>如果我们没有更改渲染状态，那么所有网格都将使用同一种渲染状态。</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646148/origin-of-ray/asynccode_ginlkt.png" alt="img"></p><h2 id="调用draw-call"><a class="markdownIt-Anchor" href="#调用draw-call"></a> 调用Draw call</h2><p>准备好上述所有工作后，CPU就需要调用一个渲染命令来告诉GPU，让GPU按照设置好的渲染数据和渲染状态来工作。</p><p>当接收了一个Draw call时，GPU就会根据渲染状态（如材质，纹理，着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的像素。</p><h1 id="gpu流水线"><a class="markdownIt-Anchor" href="#gpu流水线"></a> GPU流水线</h1><p>应用阶段结束后，CPU通过Draw call命令通知GPU根据CPU产生的数据进行渲染，接下来，就进入到了GPU流水线。</p><p>对于概念阶段的后两个阶段，即几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，其实现的载体是GPU。GPU通过实现流水线化，大大加快了渲染速度。</p><p>虽然我们没办法完全控制这两个阶段的实现细节，但是GPU向开发者开放了很多控制权</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646175/origin-of-ray/asynccode_kopbkx.png" alt="img"></p><p>从图中可以看出，GPU的渲染流水线接收顶点数据作为输入，。这些顶点数据是由应用阶段加载到显存中，再由Draw call指定，这些数据随后被传递给顶点着色器。</p><ul><li><p>顶点着色器。是完全可编程的，它通常用于实现顶点的空间变化，顶点着色等功能。</p></li><li><p>曲面细分着色器。是一个可选的着色器，它用于细分图元。</p></li><li><p>几何着色器。是一个可选的着色器，用于执行逐图元的着色操作，或者产生更多的图元。</p></li><li><p>裁剪。这一阶段的目的是将那些不在摄像机视野内的顶点裁掉，并剔除某些三角图元的面片。这个阶段是可配置的，例如我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角形图元的正面还是背面。</p></li><li><p>屏幕映射。不可配置和编程，负责把每个图元的坐标转换到屏幕坐标系中。</p></li><li><p>三角形设置和三角形遍历。固定函数阶段</p></li><li><p>片元着色器。逐片元着色操作。</p></li><li><p>逐片元操作。负责执行很多重要操作，如修改颜色，深度缓冲，混合等，不可编程，但是可高度配置。</p></li></ul><h2 id="顶点着色器"><a class="markdownIt-Anchor" href="#顶点着色器"></a> 顶点着色器</h2><p>流水线的第一个阶段，输入来自CPU，顶点着色器的处理单位是顶点。</p><p>也就是说，输入进来的每个顶点都会调用一次顶点着色器。</p><p>顶点着色器本身不可以创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如我们无法得知两个顶点是否属于同一个三角网络。但正是因为这种独立性，GPU可以利用自身的特性进行并行化处理每一个顶点而不会被其他顶点阻塞。</p><p>顶点着色器的主要功能有：坐标变化与逐顶点光照。</p><p>当然，除了这两个主要任务，顶点着色器还可以输出后续阶段所需的数据</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646237/origin-of-ray/asynccode_kgktgg.png" alt="img"></p><p>坐标转化。顾名思义，就是对顶点的坐标进行某种变换。顶点着色器可以在这一步中改变顶点的位置，这在顶点动画中非常有用。例如，我们可以通过改变顶点位置来模拟水面，布料等。但是需要注意的是，无论我们在顶点着色器中怎样改变顶点，一个顶点着色器必须完成的一个工作是：将顶点坐标从模型空间转换到<a target="_blank" rel="external nofollow noopener noreferrer" href="https://gameinstitute.qq.com/community/detail/117556">齐次裁剪空间</a></p><p>我们经常可以在顶点着色器中看到如下代码：</p><p>o.pos = mul(UNITY_MVP, v.position);</p><p>这段代码的作用就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Normalized Device Coordinate, NDC）</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646263/origin-of-ray/asynccode_s4tmq5.png" alt="img"></p><p>注意，上图给出的坐标范围是OpenGL同时也是Unity的NDC，它的z分量的范围是[-1,1]之间，而在DirectX中，NDC的z分量的范围是[0,1]。顶点着色器可以有不同的输出方式。</p><p>最常见的输出路径是经过光栅化后交给片元着色器进行处理。而在现代的Shader Model中，可以把数据发送给曲面细分着色器或几何着色器。</p><h2 id="裁剪"><a class="markdownIt-Anchor" href="#裁剪"></a> 裁剪</h2><p>由于我们的场景很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，一个很自然的想法就是那些不在视野范围的物体不需要被处理，而裁剪（Clipping）就是为了这个。</p><p>一个图元和摄像机视野的关系有三种：完全在视野内，部分在视野内，完全在视野外。</p><p>完全在视野内的就传给下一个流水线，完全在视野外的就不需要传递。</p><p>部分在视野内的就需要裁剪。</p><p>由于上一步我们已经将所有顶点归一化到了一个立方体内，因此裁剪就变得很简单：只需要将图元裁剪到单位立方体内：</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646294/origin-of-ray/asynccode_re54bh.png" alt="img"></p><p>和顶点着色器不同，这一步不可编程，即我们无法通过编程来控制裁剪的过程。</p><h2 id="屏幕映射"><a class="markdownIt-Anchor" href="#屏幕映射"></a> 屏幕映射</h2><p>这一步输入的坐标仍然是三维坐标系下的坐标（范围在单位立方体内）。屏幕映射的任务是将每个图元的x和y转换到屏幕坐标系下（二维坐标系），它和我们显示画面分辨率有很大关系</p><p>假设，我们需要把场景渲染到一个窗口上，窗口的范围是从小的窗口坐标（x1,y1），到最大的窗口坐标（x2,y2），由于我们的输入坐标在-1到1，由此可以想象到，这个过程实际是一个缩放的过程，这个过程中z坐标保持不变。</p><p>屏幕映射不会对z坐标做出任何处理，而屏幕坐标系和z坐标一起构成一个新的坐标系，这个叫窗口坐标系，这些值一起被传递到光栅化阶段</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646323/origin-of-ray/asynccode_b7gtzl.png" alt="img"></p><h2 id="三角形设置"><a class="markdownIt-Anchor" href="#三角形设置"></a> 三角形设置</h2><p>从这一步就进入了光栅化阶段。</p><p>上一个阶段输出的信息是屏幕坐标系下的顶点位置以及和它们相关的额外信息，如深度值（z坐标），法线方向，视角方向等。</p><p>光栅化有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</p><p>光栅化的第一个流水线阶段是三角形设置。这个阶段会计算光栅化一个三角形网格所需要的信息。</p><p>具体来讲，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个顶点。但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。</p><p>为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。</p><p>这样一个计算三角形网格表示数据的过程就叫做三角形设置。它的输出为下一个阶段做准备。</p><h2 id="三角形遍历"><a class="markdownIt-Anchor" href="#三角形遍历"></a> 三角形遍历</h2><p>会检查每个像素（屏幕上的像素）是否被一个三角形网格覆盖，如果被覆盖，就会产生一个片元。而这样一个找到哪些像素被三角形网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换。</p><p>三角形遍历阶段会根据上一个阶段的结果来判断一个三角网格覆盖了哪些像素，并使用三角网格的三个顶点信息对整个覆盖区域的像素进行插值计算。</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646357/origin-of-ray/asynccode_viggia.png" alt="img"></p><p>这一步的结果就是一个片元序列。</p><p>一个片元对应一个像素，但还不是真正意义上的一个像素，只是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括但不限于它的屏幕坐标，深度信息以及其他从几何阶段输出的顶点信息，如法线，纹理坐标等。</p><h2 id="片元着色器"><a class="markdownIt-Anchor" href="#片元着色器"></a> 片元着色器</h2><p>一个非常重要的可编程着色器阶段，也被称为<strong>像素着色器</strong>，但是片元着色器更合适，因为片元目前还不是一个真正意义上的像素。</p><p>前面的光栅化阶段并不会影响屏幕上的像素，而是会产生一系列数据，用来描述一个三角网格是如何覆盖每个像素的。而每个片元存放的就是这样的一系列数据。</p><p>真正对像素产生影响的是下一个流水线阶段——逐片元操作。</p><p>片元着色器的输入是上一个阶段对顶点信息差值得到的结果。</p><p>这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样，为了在片元着色器中进行纹理采样，我们通常会在顶点着色器中输出每个顶点的纹理坐标，然后经过光栅化阶段对三角网格三个顶点对应的纹理坐标进行插值，就可以得到其覆盖的片元的纹理坐标。</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646391/origin-of-ray/asynccode_wyxw6o.png" alt="img"></p><h2 id="逐片元操作"><a class="markdownIt-Anchor" href="#逐片元操作"></a> 逐片元操作</h2><p>这一步是渲染流水线的最后一步，也被称为输出合并阶段。</p><p>这一阶段有几个主要任务：</p><ul><li><p>决定每个片元的可见性，这涉及到很多测试工作，如深度测试，模板测试等。</p></li><li><p>如果一个片元通过了所有测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区的颜色进行合并，也就是混合。</p></li></ul><p>逐片元操作首先需要解决每个片元的可见性。这需要一系列测试，如果无法通过测试，该片元会被直接丢弃，前面的工作都会白费。</p><p>简单介绍下模版测试和深度测试</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1639646424/origin-of-ray/asynccode_dk5lwg.png" alt="img"></p><h3 id="模版测试"><a class="markdownIt-Anchor" href="#模版测试"></a> 模版测试</h3><p>与之相关的是模版缓冲，这个东西与颜色缓冲，或者深度缓冲一样，可以理解为操作系统中的寄存器之类的东西，用于临时存储。</p><p>开启了模版测试，GPU会先读取模版缓冲区中该片元位置的模版值（通过掩码方式，类似子网掩码），然后将该值和读取到的参考值比较。</p><p>这个比较函数可以由开发者指定，如小于时舍弃该片元，或者大于时舍弃</p><h3 id="深度测试"><a class="markdownIt-Anchor" href="#深度测试"></a> 深度测试</h3><p>如果开启深度测试，GPU会把该片元的深度值与深度缓冲区的深度值进行比较，这个比较与模版测试相同，也可以由开发者指定，通常这个比较函数是小于等于的关系，因为我们一般情况下只想显示离摄像机近的点。</p><p>通过了模版测试之后，开发者还可以指定是否用该值更新模版缓冲区内容。</p><h3 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h3><p>我们的渲染是一个物体接着一个物体画到屏幕上的，而每个像素的颜色值存储在颜色缓冲中。</p><p>当我们执行这次渲染的时候，颜色缓冲中往往有了上次的结果，那么我们是直接覆盖还是通过某种方式混合，这就是合并解决的问题。</p><p>对于不透明物体，直接关闭混合，覆盖就好。</p><p>但是对于半透明物体，我们就需要结合缓冲区的内容，进行混合。</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Ray Sun</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://sunra.top/posts/63218/" title="Unity 渲染原理 (一) 渲染流水线：从模型上的点到屏幕上的点">https://sunra.top/posts/63218/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/33455/" rel="prev" title="Unity性能优化总结"><i class="fa fa-chevron-left"></i> Unity性能优化总结</a></div><div class="post-nav-item"> <a href="/posts/28755/" rel="next" title="操作系统学习笔记（五）文件管理系统基础">操作系统学习笔记（五）文件管理系统基础<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/posts/63218/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>