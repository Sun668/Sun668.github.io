<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="函数式编程和函数式组件是现在开发的一个趋势，过去一直在用，但是没有从概念上理解，本文就把二者放在一起总结一下并进行一定的对比。 函数式编程是一种编程范式，而函数式组件是这种范式下的一种产物。"><meta property="og:type" content="article"><meta property="og:title" content="函数式组件与函数式编程"><meta property="og:url" content="https://sunra.top/posts/9244/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="函数式编程和函数式组件是现在开发的一个趋势，过去一直在用，但是没有从概念上理解，本文就把二者放在一起总结一下并进行一定的对比。 函数式编程是一种编程范式，而函数式组件是这种范式下的一种产物。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-12-10T00:51:27.000Z"><meta property="article:modified_time" content="2025-02-19T13:05:40.539Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://sunra.top/posts/9244/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunra.top/posts/9244/","path":"posts/9244/","title":"函数式组件与函数式编程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>函数式组件与函数式编程 | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">编程范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">函数式编程是一种编程范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">什么叫函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么叫表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%94%E7%AE%97%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">演算：变量的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%94%E7%AE%97%E4%BB%A3%E6%8D%A2%E5%92%8C%E5%BD%92%E7%BA%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">演算：代换和归约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javascript%E4%B8%AD%E7%9A%84%CE%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">JavaScript中的λ表达式：箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%83-%E6%9F%AF%E9%87%8C%E5%8C%96%E5%92%8Cpoint-free"><span class="nav-number">1.3.5.</span> <span class="nav-text">函数式编程基础：函数的元、柯里化和Point-Free</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%83"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">函数的元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0%E5%87%BD%E6%95%B0%E5%85%83%E9%99%8D%E7%BB%B4%E6%8A%80%E6%9C%AF"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">柯里化函数：函数元降维技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#point-free%E6%97%A0%E5%8F%82%E9%A3%8E%E6%A0%BC%E5%87%BD%E6%95%B0%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E5%90%88"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">Point-Free｜无参风格：函数的高阶组合</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">函数式组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">什么叫函数式组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">为什么要用函数式组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2-%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">Vue2 的函数式组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">模版语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jsx%E8%AF%AD%E6%B3%95"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">JSX语法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">Vue3 的函数式组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">2.5.</span> <span class="nav-text">React 的函数式组件</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">一起探索互联网的秘密</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">327</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sunra.top/posts/9244/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="一起探索互联网的秘密"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="函数式组件与函数式编程 | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 函数式组件与函数式编程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-12-10 08:51:27" itemprop="dateCreated datePublished" datetime="2022-12-10T08:51:27+08:00">2022-12-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-02-19 21:05:40" itemprop="dateModified" datetime="2025-02-19T21:05:40+08:00">2025-02-19</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline：</span><a title="waline" href="/posts/9244/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/posts/9244/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>函数式编程和函数式组件是现在开发的一个趋势，过去一直在用，但是没有从概念上理解，本文就把二者放在一起总结一下并进行一定的对比。</p><p>函数式编程是一种编程范式，而函数式组件是这种范式下的一种产物。</p><span id="more"></span><h1 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h1><h2 id="编程范式"><a class="markdownIt-Anchor" href="#编程范式"></a> 编程范式</h2><p>编程范型、编程范式或程序设计法（英语：Programming paradigm），是指软件工程中的一类典型的编程风格。常见的编程范型有：函数式编程、指令式编程、过程式编程、面向对象编程等等。</p><p>编程范型提供并决定了程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，由于方法论的不同，面向对象编程范型又分为基于类编程和基于原型编程，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。</p><blockquote><p>编程范式与编程语言不同，比如面向对象语言，只是说该语言提供了比较方便的封装，继承，多态的语法，不代表你只能写出面向对象的代码，也不代表你写出来的代码符合面向对象的范式</p></blockquote><p>编程范式还有很多，这里贴一下维基百科的目录：</p><ul><li>指令式<ul><li>过程式</li><li>块结构</li><li>结构化</li><li>模块化</li></ul></li><li>函数式<ul><li>头等函数</li><li>纯函数式</li><li>隐式</li><li>模式匹配</li><li>推导式</li></ul></li><li>面向对象<ul><li>基于类</li><li>基于原型</li><li>契约式</li><li>面向切面</li><li>面向代理</li></ul></li><li>阵列式</li><li>数据流程<ul><li>同步式</li><li>响应式</li><li>流处理</li><li>基于流程</li></ul></li></ul><h2 id="函数式编程是一种编程范式"><a class="markdownIt-Anchor" href="#函数式编程是一种编程范式"></a> 函数式编程是一种编程范式</h2><p>函数式编程，或称函数程序设计、泛函编程（英语：Functional programming），是一种编程范型，它将电脑运算视为函数运算，并且避免使用程序状态以及可变对象。</p><p><strong>在函数式编程中，函数是头等对象即头等函数，这意味着一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值</strong>，被修改或者被分配给一个变量。λ演算是这种范型最重要的基础，λ演算的函数可以接受函数作为输入参数和输出返回值。</p><p><strong>比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程</strong>。</p><h2 id="什么叫函数式编程"><a class="markdownIt-Anchor" href="#什么叫函数式编程"></a> 什么叫函数式编程</h2><p>从上面那段定义可以提取出这几个关键词：</p><ol><li>避免状态变更</li><li>函数作为输入输出</li><li>和λ演算有关</li></ol><p>关于这段定义，如果只是想简单理解函数式编程的表现形式是怎样的，可以看一下<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html">阮一峰的这篇博客</a></p><p>如果想深入理解，也建议先读读上面那个博客，很短，但是有助于理解下面的某些公式的形式。</p><p>避免状态变更和函数作为输入输出都比较好理解，，那什么叫做lambda演算呢？要理解lambda演算，就会扯出图灵完备，图灵机。接下来我简单和大家解释一下。</p><h3 id="什么叫表达式"><a class="markdownIt-Anchor" href="#什么叫表达式"></a> 什么叫表达式</h3><p>λ演算（英语：lambda calculus，λ-calculus）是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。<strong>lambda演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程</strong>；尽管如此，lambda演算强调的是变换规则的运用，而非实现它们的具体机器。</p><p><strong>lambda演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式</strong>。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如Lisp、ML语言和Haskell语言。在1936年邱奇利用λ演算给出了对于判定性问题（Entscheidungsproblem）的否定：关于两个lambda表达式是否等价的命题，无法由一个“通用的算法”判断，这是不可判定性能够证明的头一个问题，甚至还在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh.m.wikipedia.org/zh-cn/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">停机问题</a>之先。</p><p>lambda演算包括了建构lambda项，和对lambda项执行归约的操作。在最简单的lambda演算中，只使用以下的规则来建构lambda项：</p><table><thead><tr><th>语法</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>变量</td><td>用字符或字符串来表示参数或者数学上的值或者表示逻辑上的值</td></tr><tr><td>(λx.M)</td><td>抽象化</td><td>一个完整的函数定义（M是一个 lambda 项），在表达式中的 x 都会绑定为变量 x。</td></tr><tr><td>(M N)</td><td>应用</td><td>将函数M作用于参数N。 M 和 N 是 lambda 项。</td></tr></tbody></table><p>产生了诸如：(λx.λy.(λz.(λx.zx)(λy.zy))(x y))的表达式。如果表达式是明确而没有歧义的，则括号可以省略。对于某些应用，其中可能包括了逻辑和数学的常量以及相关操作。</p><p><strong>λ演算是图灵完备的，也就是说，这是一个可以用于模拟任何图灵机的通用模型</strong>。λ也被用在λ表达式和λ项中，用来表示将一个变量绑定在一个函数上。</p><p>λ演算可以是有类型或者无类型的，在有类型λ演算中（上文所述是无类型的），函数只能在参数类型和输入类型符合时被应用。有类型λ演算比无类型λ演算要弱——后者是这个条目的主要部分——因为有类型的λ运算能表达的比无类型λ演算少；与此同时，前者使得更多定理能被证明。例如，在简单类型λ演算中，运算总是能够停止，然而无类型λ演算中这是不一定的（因为停机问题）。目前有许多种有类型λ演算的一个原因是它们被期望能做到更多（做到某些以前的有类型λ演算做不到的）的同时又希望能用以证明更多定理。</p><p>λ演算在数学、哲学、语言学和计算机科学中都有许多应用。它在编程语言理论中占有重要地位，函数式编程实现了λ演算支持。λ演算在范畴论中也是一个研究热点。</p><p>λ演算式就三个要点：</p><ul><li>绑定关系。变量任意性，x、y和z都行，它仅仅是具体数据的代称。</li><li>递归定义。λ项递归定义，M可以是一个λ项。</li><li>替换归约。λ项可应用，空格分隔表示对M应用N，N可以是一个λ项。</li></ul><p>通过变量代换（substitution）和归约（reduction），我们可以像化简方程一样处理我们的演算。</p><p>举个例子，刚才我们说的<code>(λx.λy.(λz.(λx.zx)(λy.zy))(x y))</code>，首先<code>(λx.zx)</code>表示<code>f(x) = zx</code>，那么 <code>(λx.zx) 3</code> 就是<code>3z</code></p><h3 id="演算变量的含义"><a class="markdownIt-Anchor" href="#演算变量的含义"></a> 演算：变量的含义</h3><p>在λ演算中我们的表达式只有一个参数，那它怎么实现两个数字的二元操作呢？比如加法a + b，需要两个参数。</p><p>这时，我们要把函数本身也视为值，可以通过把一个变量绑定到上下文，然后返回一个新的函数，来实现数据（或者说是状态）的保存和传递，被绑定的变量可以在需要实际使用的时候从上下文中引用到。</p><p>比如：<code>λm.λn.m + n 5 = λn.5 + n</code>,第一次函数调用传入m=5，返回一个新函数，这个新函数接收一个参数n，并返回m + n的结果。像这种情况产生的上下文，<strong>就是Closure（闭包，函数式编程常用的状态保存和引用手段）</strong>，我们称变量m是被绑定（binding）到了第二个函数的上下文。</p><p>除了绑定的变量，λ演算也支持自由的变量，比如这个y：<code>λm.λn.m + n + y</code>,这里的y是一个没有绑定到参数位置的变量，被称为一个自由变量。</p><p>绑定变量和自由变量是函数的两种状态来源，一个可以被代换，另一个不能。实际程序中，<strong>通常把绑定变量实现为局部变量或者参数，自由变量实现为全局变量或者环境变量</strong>。</p><h3 id="演算代换和归约"><a class="markdownIt-Anchor" href="#演算代换和归约"></a> 演算：代换和归约</h3><p>演算分为Alpha代换和Beta归约。 前面章节我们实际上已经涉及这两个概念，下面来介绍一下它们。</p><p>Alpha代换指的是变量的名称是不重要的，你可以写λm.λn.m + n，也可以写λx.λy.x + y，在演算过程中它们表示同一个函数。也就是说我们只关心计算的形式，而不关心细节用什么变量去实现。这方便我们不改变运算结果的前提下去修改变量命名，以方便在函数比较复杂的情况下进行化简操作。实际上，连整个lambda演算式的名字也是不重要的，我们只需要这种形式的计算，而不在乎这个形式的命名。</p><p>Beta归约指的是如果你有一个函数应用（函数调用），那么你可以对这个函数体中与标识符对应的部分做代换（substitution），方式为使用参数（可能是另一个演算式）去替换标识符。听起来有点绕口，但是它实际上就是函数调用的参数替换。比如：<code>(λm.λn.m + n) 1 3 = (λn.1 + n) 3 = 1 + 3 = 4</code></p><p>可以使用1替换m，3替换n，那么整个表达式可以化简为4。这也是函数式编程里面的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://caowenwei.github.io/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/pure-function-rt/">引用透明性</a>的由来。需要注意的是，这里的1和3表示表达式运算值，可以替换为其他表达式。比如把1替换为(λm.λn.m + n 1 3)，这里就需要做两次归约</p><h3 id="javascript中的λ表达式箭头函数"><a class="markdownIt-Anchor" href="#javascript中的λ表达式箭头函数"></a> JavaScript中的λ表达式：箭头函数</h3><p>ECMAScript 2015规范引入了箭头函数，它没有this，没有arguments。只能作为一个表达式（expression）而不能作为一个声明式（statement），表达式产生一个箭头函数引用，该箭头函数引用仍然有name和length属性，分别表示箭头函数的名字、形参（parameters）长度。一个箭头函数就是一个单纯的运算式，箭头函数我们也可以称为lambda函数，它在书写形式上就像是一个λ演算式。</p><p>可以利用箭头函数做一些简单的运算，下例比较了四种箭头函数的使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add_1</span> = (<span class="params">x, y</span>) =&gt; x + y; <span class="comment">// 全部为局部变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add_2</span> = x =&gt; x + y; <span class="comment">// y为全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add_3</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y; <span class="comment">// 闭包串联参数，柯里化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add_4</span> = b =&gt; <span class="function"><span class="params">a</span> =&gt;</span> a + b; <span class="comment">// 参数命名和表达式结果无关</span></span><br></pre></td></tr></table></figure><p>这是直接针对数字（基本数据类型）的情况，如果是针对函数做运算（引用数据类型），事情就变得有趣起来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn_1</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> <span class="title function_">x</span>(y);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn_2</span> = f =&gt; <span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(x);</span><br><span class="line"><span class="keyword">const</span> add_1 = (<span class="function"><span class="params">f</span> =&gt;</span> <span class="title function_">f</span>(<span class="number">5</span>))(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> add_2 = (<span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> x + y)(<span class="number">2</span>)(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> add_3 = (<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>fn_x类型，表明我们可以利用函数内的函数，当函数被当作数据传递的时候，就可以对函数进行应用（apply），生成更高阶的操作。 并且x =&gt; y =&gt; x(y)可以有两种理解，一种是x =&gt; y函数传入X =&gt; x(y)，另一种是x传入y =&gt; x(y)。</p><p>add_x类型表明，一个运算式可以有很多不同的路径来实现。</p><h3 id="函数式编程基础函数的元-柯里化和point-free"><a class="markdownIt-Anchor" href="#函数式编程基础函数的元-柯里化和point-free"></a> 函数式编程基础：函数的元、柯里化和Point-Free</h3><p>回到JavaScript本身，我们要探究函数本身能不能带给我们更多的东西？我们在JavaScript中有很多创建函数的方式：</p><p>可以通过声明式，表达式，箭头函数，new Function等方式</p><p>虽然函数有这么多定义，但function关键字声明的函数带有arguments和this关键字，这让他们看起来更像是对象方法（method），而不是函数（function） 。</p><p>况且function定义的函数大多数还能被构造（比如new Array）。</p><p>接下来我们将只研究箭头函数，因为它更像是数学意义上的函数（仅执行计算过程）。</p><ul><li>没有arguments和this。</li><li>不可以被构造new。</li></ul><h4 id="函数的元"><a class="markdownIt-Anchor" href="#函数的元"></a> 函数的元</h4><p>不论使用何种方式去构造一个函数，这个函数都有两个固定的信息可以获取：</p><ul><li>name 表示当前标识符指向的函数的名字。</li><li>length 表示当前标识符指向的函数定义时的参数列表长度。</li></ul><p>在数学上，我们定义f(x) = x是一个一元函数，而f(x, y) = x + y是一个二元函数。在JavaScript中我们可以使用函数定义时的length来定义它的元。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">one</span> = a =&gt; a;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">two</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">three</span> = (<span class="params">a, b, c</span>) =&gt; a + b + c;</span><br></pre></td></tr></table></figure><p>定义函数的元的意义在于，我们可以对函数进行归类，并且可以明确一个函数需要的确切参数个数。函数的元在编译期（类型检查、重载）和运行时（异常处理、动态生成代码）都有重要作用。</p><p>如果我给你一个二元函数，你就知道需要传递两个参数。比如+就可以看成是一个二元函数，它的左边接受一个参数，右边接受一个参数，返回它们的和（或字符串连接）。</p><p>在一些其他语言中，+确实也是由抽象类来定义实现的，比如Rust语言的trait Add。</p><p>但我们上面看到的λ演算，每个函数都只有一个元。为什么呢？</p><p>只有一个元的函数方便我们进行代数运算。λ演算的参数列表使用λx.λy.λz的格式进行分割，返回值一般都是函数，如果一个二元函数，调用时只使用了一个参数，则返回一个「不完全调用函数」。这里用三个例子解释“不完全调用”。</p><h4 id="柯里化函数函数元降维技术"><a class="markdownIt-Anchor" href="#柯里化函数函数元降维技术"></a> 柯里化函数：函数元降维技术</h4><p>柯里化（curry）函数是一种把函数的元降维的技术，这个名词是为了纪念我们上文提到的数学家阿隆佐·邱奇。</p><p>柯里化函数帮助我们把一个多元函数变成一个不完全调用，利用Closure的魔法，把函数调用变成延迟的偏函数(不完全调用函数)调用。这在函数组合、复用等场景非常有用</p><h4 id="point-free无参风格函数的高阶组合"><a class="markdownIt-Anchor" href="#point-free无参风格函数的高阶组合"></a> Point-Free｜无参风格：函数的高阶组合</h4><p>函数式编程中有一种Point-Free风格，中文语境大概可以把point认为是参数点，对应λ演算中的函数应用（Function Apply），或者JavaScript中的函数调用（Function Call），所以可以理解Point-Free就指的是无参调用。</p><p>来看一个日常的例子，把二进制数据转换为八进制数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strNums = [<span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;1110&#x27;</span>];</span><br><span class="line">strNums.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x, <span class="number">2</span>)).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toString</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>这段代码运行起来没有问题，但我们为了处理这个转换，需要了解 parseInt(x, 2) 和 toString(8) 这两个函数（为什么有魔法数字2和魔法数字8），并且要关心数据（函数类型a -&gt; b）在每个节点的形态（关心数据的流向）。有没有一种方式，可以让我们只关心入参和出参，不关心数据流动过程呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">toBinary</span> = x =&gt; <span class="built_in">parseInt</span>(x,  <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> toString0x =&gt; <span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toString</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pipe</span> = (<span class="params">...fns</span>) =&gt; <span class="function"><span class="params">x</span> =&gt;</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> <span class="title function_">fn</span>(acc), x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strNums = [<span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;1110&#x27;</span>];</span><br><span class="line">strNums.<span class="title function_">map</span>(<span class="title function_">pipe</span>(toBinary, toString0x));</span><br></pre></td></tr></table></figure><h1 id="函数式组件"><a class="markdownIt-Anchor" href="#函数式组件"></a> 函数式组件</h1><h2 id="什么叫函数式组件"><a class="markdownIt-Anchor" href="#什么叫函数式组件"></a> 什么叫函数式组件</h2><p>函数式组件就是函数是组件，组件是函数，它的特征是没有内部状态、没有生命周期钩子函数、没有this（不需要实例化的组件）。</p><p>在日常开发中，我们经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是：</p><p>只要你传入数据，我就进行展现。</p><p>不需要有内部状态，不需要在生命周期钩子函数里面做处理。</p><p>这时候你就可以用函数式组件。</p><h2 id="为什么要用函数式组件"><a class="markdownIt-Anchor" href="#为什么要用函数式组件"></a> 为什么要用函数式组件</h2><p>函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</p><p>函数式组件结构更简单，代码结构更清晰</p><h2 id="vue2-的函数式组件"><a class="markdownIt-Anchor" href="#vue2-的函数式组件"></a> Vue2 的函数式组件</h2><ol><li><p>函数式组件需要在声明组件是指定functional。</p></li><li><p>函数式组件不需要实例化，所以没有this，this通过render函数的第二个参数来代替。</p></li><li><p>函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等。</p></li><li><p>函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件。</p></li><li><p>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement。</p></li><li><p>函数式组件的props可以只声明一部分或者全都不声明，所有没有在props里面声明的属性都会被自动隐式解析为prop，而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)。</p></li></ol><p>上面已经反复强调，凡是不需要实例化，无状态，没有生命周期的组件，除了props之外没有别的配置项，都可以改写成函数式组件。</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><h4 id="模版语法"><a class="markdownIt-Anchor" href="#模版语法"></a> 模版语法</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">func</span> <span class="attr">text</span>=<span class="string">&quot;aaaaaaaa&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> func <span class="keyword">from</span> <span class="string">&#x27;@/components/func.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    func</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;props.text ? props.text : &#x27;哈哈&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意，没有<code>&lt;script&gt;...&lt;/script&gt;</code>部分。</p></blockquote><h4 id="jsx语法"><a class="markdownIt-Anchor" href="#jsx语法"></a> JSX语法</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 渲染函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">h</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; context 函数式组件没有this, props, slots等都在context上面挂着</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h, context</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context);</span><br><span class="line">    <span class="keyword">const</span> &#123; props &#125; = context</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">text</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>哈哈嗝<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vue3-的函数式组件"><a class="markdownIt-Anchor" href="#vue3-的函数式组件"></a> Vue3 的函数式组件</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.javascriptc.com/vue3js/guide/migration/functional-components.html#%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6">Vue3 函数式组件</a></p><h2 id="react-的函数式组件"><a class="markdownIt-Anchor" href="#react-的函数式组件"></a> React 的函数式组件</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://zh-hans.reactjs.org/docs/components-and-props.html">React 函数式组件</a></p><p>参考文章：</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html">https://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Ray Sun</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://sunra.top/posts/9244/" title="函数式组件与函数式编程">https://sunra.top/posts/9244/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2336/" rel="prev" title="JavaScript 设计模式学习与实践（二）"><i class="fa fa-chevron-left"></i> JavaScript 设计模式学习与实践（二）</a></div><div class="post-nav-item"> <a href="/posts/20273/" rel="next" title="Vue Router 源码解析（一）内部路由配置的生成">Vue Router 源码解析（一）内部路由配置的生成<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/posts/9244/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>