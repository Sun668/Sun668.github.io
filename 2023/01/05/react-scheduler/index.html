<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="7yRqtT6cCpC-_R-rzM9gUoQGmheV9OZAUKIXrbAsyqE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"sunra.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8623125811074939" crossorigin="anonymous"></script><script>!function(e,p,s,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var d,t=p.getElementsByTagName(s)[0];(d=p.createElement(s)).id="webpushr-jssdk",d.async=1,d.src="https://cdn.webpushr.com/app.min.js",t.parentNode.appendChild(d)}}(window,document,"script"),webpushr("setup",{key:"BEQjc-0d1Q1CubrYZ2e2XXv5Is0ZCd3CtrNLet06owkUWK68qkxHpho2mKdnj2vpGdxddRDxRYthLuMwrTqfSB4"})</script><meta name="description" content="之前一篇博客讲过React的更新过程，不过在那个博客中，任务调度使用的是浏览器的requestIdleCallback，而实际上React使用的自己实现的一个任务调度器，我们这次就开分析一下它的源码，以及React为什么要自己实现任务调度器。 本文基于React仓库中的16.18.6分支进行解读。"><meta property="og:type" content="article"><meta property="og:title" content="React Scheduler 源码解析"><meta property="og:url" content="https://sunra.top/2023/01/05/react-scheduler/index.html"><meta property="og:site_name" content="Origin of Ray"><meta property="og:description" content="之前一篇博客讲过React的更新过程，不过在那个博客中，任务调度使用的是浏览器的requestIdleCallback，而实际上React使用的自己实现的一个任务调度器，我们这次就开分析一下它的源码，以及React为什么要自己实现任务调度器。 本文基于React仓库中的16.18.6分支进行解读。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1672979542/origin-of-ray/screenshot-20230106-123045_zosxud.png"><meta property="article:published_time" content="2023-01-05T12:31:36.000Z"><meta property="article:modified_time" content="2024-11-22T23:34:10.854Z"><meta property="article:author" content="Ray Sun"><meta property="article:tag" content="技术分享 使用教程 原理 前端 计算机图形学"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1672979542/origin-of-ray/screenshot-20230106-123045_zosxud.png"><link rel="canonical" href="https://sunra.top/2023/01/05/react-scheduler/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunra.top/2023/01/05/react-scheduler/","path":"2023/01/05/react-scheduler/","title":"React Scheduler 源码解析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>React Scheduler 源码解析 | Origin of Ray</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-KEJ1L66CKC"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KEJ1L66CKC","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?cc2e15dfd66849cf1d7843d0d532438e"></script><link rel="dns-prefetch" href="https://blog-comments-3w44.vercel.app/"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Origin of Ray" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Origin of Ray</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一起探索互联网的秘密</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-english"><a href="https://sunra.top/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a></li><li class="menu-item menu-item-中文"><a href="https://sunra.top/" rel="section"><i class="fa fa-language fa-fw"></i>中文</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">任务执行方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mock%E7%8E%AF%E5%A2%83"><span class="nav-number">1.1.</span> <span class="nav-text">Mock环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%B5%8F%E8%A7%88%E7%8E%AF%E5%A2%83%E6%88%96%E8%80%85%E4%B8%8D%E6%94%AF%E6%8C%81messagechannel%E6%97%B6"><span class="nav-number">1.2.</span> <span class="nav-text">非浏览环境或者不支持MessageChannel时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%94%E6%94%AF%E6%8C%81messagechannel"><span class="nav-number">1.3.</span> <span class="nav-text">浏览器环境且支持MessageChannel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%B8%8A%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.</span> <span class="nav-text">利用上面定义的三个函数实现根据优先级调度任务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#flushfirstcallback"><span class="nav-number">2.1.</span> <span class="nav-text">flushFirstCallback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ensurehostcallbackisscheduled"><span class="nav-number">2.2.</span> <span class="nav-text">ensureHostCallbackIsScheduled</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flushwork"><span class="nav-number">2.3.</span> <span class="nav-text">flushWork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flushimmediatework"><span class="nav-number">2.4.</span> <span class="nav-text">flushImmediateWork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">对外暴露的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unstable_schedulecallback"><span class="nav-number">3.1.</span> <span class="nav-text">unstable_scheduleCallback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unstable_cancelcallback"><span class="nav-number">3.2.</span> <span class="nav-text">unstable_cancelCallback</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Ray Sun" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><p class="site-author-name" itemprop="name">Ray Sun</p><div class="site-description" itemprop="description">一起探索互联网的秘密</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">321</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Sun668" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sun668" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:947692259@qq.com" title="E-Mail → mailto:947692259@qq.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="wechat_channel" style="width:50%;margin-left:25%;margin-bottom:5px"><br> <img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="wechat_channel" style="width:50%;margin-left:25%"><br> <span>一站式程序员工具平台</span> <img src="https://origin-of-ray.oss-cn-shenzhen.aliyuncs.com/rannie_share.png"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sunra.top/2023/01/05/react-scheduler/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592617514/avatar_rpap6c.jpg"><meta itemprop="name" content="Ray Sun"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Origin of Ray"><meta itemprop="description" content="一起探索互联网的秘密"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="React Scheduler 源码解析 | Origin of Ray"><meta itemprop="description" content></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> React Scheduler 源码解析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-05 20:31:36" itemprop="dateCreated datePublished" datetime="2023-01-05T20:31:36+08:00">2023-01-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-11-23 07:34:10" itemprop="dateModified" datetime="2024-11-23T07:34:10+08:00">2024-11-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Waline：</span><a title="waline" href="/2023/01/05/react-scheduler/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/2023/01/05/react-scheduler/" itemprop="commentCount"></span></a></span></div></div></header><div class="post-body" itemprop="articleBody"><p>之前一篇博客讲过React的更新过程，不过在那个博客中，任务调度使用的是浏览器的requestIdleCallback，而实际上React使用的自己实现的一个任务调度器，我们这次就开分析一下它的源码，以及React为什么要自己实现任务调度器。</p><p>本文基于React仓库中的16.18.6分支进行解读。</p><span id="more"></span><p>Scheduler的源码并不是很多，大概也就700多行，从作用上可以分为三部分：</p><ul><li>根据实际运行的环境差异定义 <code>requestHostCallback</code>，<code>cancelHostCallback</code>，<code>shouldYieldToHost</code>三个函数来实现任务的执行和取消。</li><li>利用上面定义的三个函数实现根据优先级调度任务</li><li>对外暴露一些接口可以添加，删除，插入一些任务</li></ul><h1 id="任务执行方法"><a class="markdownIt-Anchor" href="#任务执行方法"></a> 任务执行方法</h1><p>关于这段代码的作用，在源码的注释里面讲过的比较清楚了，如果不想具体了解是做了什么，可以看一下它的这注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The remaining code is essentially a polyfill for requestIdleCallback. It</span></span><br><span class="line"><span class="comment">// works by scheduling a requestAnimationFrame, storing the time for the start</span></span><br><span class="line"><span class="comment">// of the frame, then scheduling a postMessage which gets scheduled after paint.</span></span><br><span class="line"><span class="comment">// Within the postMessage handler do as much work as possible until time + frame</span></span><br><span class="line"><span class="comment">// rate. By separating the idle call into a separate event tick we ensure that</span></span><br><span class="line"><span class="comment">// layout, paint and other browser work is counted against the available time.</span></span><br><span class="line"><span class="comment">// The frame rate is dynamically adjusted.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We capture a local reference to any global, in case it gets polyfilled after</span></span><br><span class="line"><span class="comment">// this module is initially evaluated. We want to be using a</span></span><br><span class="line"><span class="comment">// consistent implementation.</span></span><br></pre></td></tr></table></figure><p>翻译一下就是：剩下的代码本质上是requestIdleCallback的填充。它的工作原理是调度requestAnimationFrame，存储帧开始的时间，然后调度绘制后调度的postMessage。在postMessage处理程序中做尽可能多的工作，直到time +帧速率。通过将空闲调用分离为一个单独的事件标记，我们确保布局、绘制和其他浏览器工作被计入可用时间。帧速率是动态调整的。我们捕获对任何全局变量的局部引用，以防它在这个模块初始计算后被填充。我们希望使用一致的实现。</p><p>接下来我们正式看一下代码，首先是几个根据当前环境判断的结果来赋值setTimeout等方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> localDate = <span class="title class_">Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This initialization code may run even on server environments if a component</span></span><br><span class="line"><span class="comment">// just imports ReactDOM (e.g. for findDOMNode). Some environments might not</span></span><br><span class="line"><span class="comment">// have setTimeout or clearTimeout. However, we always expect them to be defined</span></span><br><span class="line"><span class="comment">// on the client. https://github.com/facebook/react/pull/13088</span></span><br><span class="line"><span class="keyword">var</span> localSetTimeout = <span class="keyword">typeof</span> <span class="built_in">setTimeout</span> === <span class="string">&#x27;function&#x27;</span> ? <span class="built_in">setTimeout</span> : <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> localClearTimeout =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">clearTimeout</span> === <span class="string">&#x27;function&#x27;</span> ? <span class="built_in">clearTimeout</span> : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t expect either of these to necessarily be defined, but we will error</span></span><br><span class="line"><span class="comment">// later if they are missing on the client.</span></span><br><span class="line"><span class="keyword">var</span> localRequestAnimationFrame =</span><br><span class="line">  <span class="keyword">typeof</span> requestAnimationFrame === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? requestAnimationFrame</span><br><span class="line">    : <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> localCancelAnimationFrame =</span><br><span class="line">  <span class="keyword">typeof</span> cancelAnimationFrame === <span class="string">&#x27;function&#x27;</span> ? cancelAnimationFrame : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getCurrentTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requestAnimationFrame does not run when the tab is in the background. If</span></span><br><span class="line"><span class="comment">// we&#x27;re backgrounded we prefer for that work to happen so that the page</span></span><br><span class="line"><span class="comment">// continues to load in the background. So we also schedule a &#x27;setTimeout&#x27; as</span></span><br><span class="line"><span class="comment">// a fallback.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Need a better heuristic for backgrounded work.</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">ANIMATION_FRAME_TIMEOUT</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> rAFID;</span><br><span class="line"><span class="keyword">var</span> rAFTimeoutID;</span><br><span class="line"><span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">  rAFID = <span class="title function_">localRequestAnimationFrame</span>(<span class="keyword">function</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    <span class="comment">// cancel the setTimeout</span></span><br><span class="line">    <span class="title function_">localClearTimeout</span>(rAFTimeoutID);</span><br><span class="line">    <span class="title function_">callback</span>(timestamp);</span><br><span class="line">  &#125;);</span><br><span class="line">  rAFTimeoutID = <span class="title function_">localSetTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">    <span class="title function_">localCancelAnimationFrame</span>(rAFID);</span><br><span class="line">    <span class="title function_">callback</span>(<span class="title function_">getCurrentTime</span>());</span><br><span class="line">  &#125;, <span class="variable constant_">ANIMATION_FRAME_TIMEOUT</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasNativePerformanceNow) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Performance</span> = performance;</span><br><span class="line">  getCurrentTime = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Performance</span>.<span class="title function_">now</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  getCurrentTime = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> localDate.<span class="title function_">now</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据运行环境不同，定义 <code>requestHostCallback</code>，<code>cancelHostCallback</code>，<code>shouldYieldToHost</code>三个函数</p><h2 id="mock环境"><a class="markdownIt-Anchor" href="#mock环境"></a> Mock环境</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestHostCallback;</span><br><span class="line"><span class="keyword">var</span> cancelHostCallback;</span><br><span class="line"><span class="keyword">var</span> shouldYieldToHost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalValue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  globalValue = <span class="variable language_">window</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  globalValue = <span class="variable language_">global</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (globalValue &amp;&amp; globalValue.<span class="property">_schedMock</span>) &#123;</span><br><span class="line">  <span class="comment">// Dynamic injection, only for testing purposes.</span></span><br><span class="line">  <span class="keyword">var</span> globalImpl = globalValue.<span class="property">_schedMock</span>;</span><br><span class="line">  requestHostCallback = globalImpl[<span class="number">0</span>];</span><br><span class="line">  cancelHostCallback = globalImpl[<span class="number">1</span>];</span><br><span class="line">  shouldYieldToHost = globalImpl[<span class="number">2</span>];</span><br><span class="line">  getCurrentTime = globalImpl[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们给全局对象挂载了<code>_schedMock</code>对象，就会进入mock的判断，然后使用我们传入的方法来定义任务执行需要的几个函数。</p><h2 id="非浏览环境或者不支持messagechannel时"><a class="markdownIt-Anchor" href="#非浏览环境或者不支持messagechannel时"></a> 非浏览环境或者不支持MessageChannel时</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="comment">// If Scheduler runs in a non-DOM environment, it falls back to a naive</span></span><br><span class="line">  <span class="comment">// implementation using setTimeout.</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;undefined&#x27;</span> ||</span><br><span class="line">  <span class="comment">// Check if MessageChannel is supported, too.</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="title class_">MessageChannel</span> !== <span class="string">&#x27;function&#x27;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,</span></span><br><span class="line">  <span class="comment">// fallback to a naive implementation.</span></span><br><span class="line">  <span class="keyword">var</span> _callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> _flushCallback = <span class="keyword">function</span>(<span class="params">didTimeout</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">_callback</span>(didTimeout);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _callback = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  requestHostCallback = <span class="keyword">function</span>(<span class="params">cb, ms</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Protect against re-entrancy.</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(requestHostCallback, <span class="number">0</span>, cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _callback = cb;</span><br><span class="line">      <span class="built_in">setTimeout</span>(_flushCallback, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  cancelHostCallback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _callback = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  shouldYieldToHost = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码做了如下几件事：</p><ul><li>声明了一个新的变量<code>_callback</code>,用于存储当前正在执行的callback</li><li><code>_flushCallback</code>函数，当<code>_callback</code>不为空时，执行<code>_callback</code>，然后讲<code>_callback</code>置为空，表明当前没有正在执行的任务，可以执行其他的任务了</li><li><code>requestHostCallback</code>函数，先是判断<code>_callback</code>是否为空，如果不为空，说明当前有正在执行的任务，那么就利用setTimeout来添加一个宏任务，继续执行<code>requestHostCallback</code>本身，这里虽然看起来像是递归调用，但是因为使用的是setTimeout，其实调用栈并不会增长。如果<code>_callback</code>为空，说明当前没有正在执行的任务，那么先赋值<code>_callback</code>，再添加宏任务去执行<code>_flushCallback</code>。</li><li><code>cancelHostCallback</code>函数则是将<code>_callback</code>置为空，取消当前的任务。其实如果当前的任务已经加入了宏任务队列，通过这种方式是没法取消的，但注意，我们宏任务队列中加入的是<code>_flushCallback</code>函数，如果<code>_callback</code>为空，其实什么都不会做。</li><li><code>shouldYieldToHost</code>在这种情况下一定返回false。</li></ul><p>总的来说，<code>requestHostCallback</code>是每次都会判断当前有没有<code>_callback</code>在执行，如果有就等等（这个等也是通过宏任务回调自己的方式来实现的），如果没有就添加一个宏任务，最终都会添加一个宏任务去执行<code>_flushCallback</code>，也就是说，理论上当有一个<code>_callback</code>在执行的时候，其他的<code>requestHostCallback</code>都在通过宏任务排队，最终执行的顺序也是<code>requestHostCallback</code>的顺序。</p><p>但是如果在<code>requestHostCallback</code>成功添加宏任务之后，执行添加的宏任务之前，清空微任务队列的时候，调用了<code>cancelHostCallback</code>，那其实在执行<code>_flushCallback</code>的时候就什么都不会做，具体可以看一下下图：</p><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1672979542/origin-of-ray/screenshot-20230106-123045_zosxud.png" alt></p><p>上图中的每一个方框都代表一个宏任务，方块中有两个信息，一个是当前宏任务执行的函数，一个是当前<code>_callback</code>的值是多少。</p><p>第一行表明的是正常情况，我们请求了两个任务，然后依次执行。第二行的是特殊情况，在执行<code>_flushCallback</code>之前cancel掉会发生什么</p><h2 id="浏览器环境且支持messagechannel"><a class="markdownIt-Anchor" href="#浏览器环境且支持messagechannel"></a> 浏览器环境且支持MessageChannel</h2><p>首先是打印报错信息，如果当前环境不支持requestAnimationFrame会打印报错信息，但也只是打印报错信息而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">console</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Remove fb.me link</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> localRequestAnimationFrame !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">&quot;This browser doesn&#x27;t support requestAnimationFrame. &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;Make sure that you load a &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;polyfill in older browsers. https://fb.me/react-polyfills&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> localCancelAnimationFrame !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">&quot;This browser doesn&#x27;t support cancelAnimationFrame. &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;Make sure that you load a &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;polyfill in older browsers. https://fb.me/react-polyfills&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是几个变量，理解这几个变量的作用对于理解接下来的代码比较重要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scheduledHostCallback = <span class="literal">null</span>; <span class="comment">// 当前正在执行的任务，可以类比为上面的_callback</span></span><br><span class="line"><span class="keyword">var</span> isMessageEventScheduled = <span class="literal">false</span>; <span class="comment">// 是否有正在处理的MessageChannel消息</span></span><br><span class="line"><span class="keyword">var</span> timeoutTime = -<span class="number">1</span>; <span class="comment">// 当然任务的超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isAnimationFrameScheduled = <span class="literal">false</span>; <span class="comment">// 是否有任务被requestAnimationFrame加入宏任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isFlushingHostCallback = <span class="literal">false</span>; <span class="comment">// 是否有任务正在执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> frameDeadline = <span class="number">0</span>; <span class="comment">// 记录当前帧的到期时间，他等于rafTime + activeFrameTime，也就是requestAnimationFrame回调传入的时间，加上一帧的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We start out assuming that we run at 30fps but then the heuristic tracking</span></span><br><span class="line"><span class="comment">// will adjust this value to a faster fps if we get more frequent animation</span></span><br><span class="line"><span class="comment">// frames.</span></span><br><span class="line"><span class="keyword">var</span> previousFrameTime = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">var</span> activeFrameTime = <span class="number">33</span>;</span><br></pre></td></tr></table></figure><p>理解了这几个变量之后，我们看一下几个工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animationTick = <span class="keyword">function</span>(<span class="params">rafTime</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">    <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">    <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">    <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">    <span class="comment">// frame ensures it&#x27;s fired within the earliest possible frame. If we</span></span><br><span class="line">    <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">    <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">    <span class="comment">// after that.</span></span><br><span class="line">    <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No pending work. Exit.</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">    previousFrameTime &lt; activeFrameTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// Defensive coding. We don&#x27;t support higher frame rates than 120hz.</span></span><br><span class="line">      <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">      nextFrameTime = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">    <span class="comment">// If two frames are short in a row, then that&#x27;s an indication that we</span></span><br><span class="line">    <span class="comment">// actually have a higher frame rate than what we&#x27;re currently optimizing.</span></span><br><span class="line">    <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we&#x27;re</span></span><br><span class="line">    <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">    <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">    <span class="comment">// missed frame deadlines.</span></span><br><span class="line">    activeFrameTime =</span><br><span class="line">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    previousFrameTime = nextFrameTime;</span><br><span class="line">  &#125;</span><br><span class="line">  frameDeadline = rafTime + activeFrameTime;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">undefined</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法主要就是做了两件事：</p><ul><li>只要<code>scheduledHostCallback</code>不为空，就说明当前有任务在执行，就不断通过<code>requestAnimationFrameWithTimeout</code>继续调用自身来重新计算每一帧的用时，也就是更新<code>previousFrameTime</code>和<code>activeFrameTime</code>，如果当前的<code>scheduledHostCallback</code>为空，那就直接return，也就是停止更新每一帧的用时。</li><li>同时每次执行过程中，如果<code>isMessageEventScheduled</code>为false，那就触发一次MessageChannel的消息。</li></ul><p>然后是MessageChannel的处理消息的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">  <span class="keyword">var</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  timeoutTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> didTimeout = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no time left in this idle period. Check if the callback has</span></span><br><span class="line">    <span class="comment">// a timeout and whether it&#x27;s been exceeded.</span></span><br><span class="line">    <span class="keyword">if</span> (prevTimeoutTime !== -<span class="number">1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// Exceeded the timeout. Invoke the callback even though there&#x27;s no</span></span><br><span class="line">      <span class="comment">// time left.</span></span><br><span class="line">      didTimeout = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No timeout.</span></span><br><span class="line">      <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">        <span class="comment">// Schedule another animation callback so we retry later.</span></span><br><span class="line">        isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Exit without invoking the callback.</span></span><br><span class="line">      scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">      timeoutTime = prevTimeoutTime;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">prevScheduledCallback</span>(didTimeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个处理函数主要做的事情是：</p><ul><li>判断当前时间是否已经超过了这一帧我们的规定的结束时间<ul><li>如果超过了判断当前任务是否有timeout并且已经开始执行了<ul><li>如果有并且开始执行了，那就继续执行完</li><li>如果没有，那就下一帧再执行下一个任务</li></ul></li></ul></li></ul><p>现在我们可以看一下这个条件下的任务执行函数了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">requestHostCallback = <span class="keyword">function</span>(<span class="params">callback, absoluteTimeout</span>) &#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line">  <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t wait for the next frame. Continue working ASAP, in a new event.</span></span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">    <span class="comment">// If rAF didn&#x27;t already schedule one, we need to schedule a frame.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> If this rAF doesn&#x27;t materialize because the browser throttles, we</span></span><br><span class="line">    <span class="comment">// might want to still have setTimeout trigger rIC as a backup to ensure</span></span><br><span class="line">    <span class="comment">// that we keep performing work.</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">requestAnimationFrameWithTimeout</span>(animationTick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cancelHostCallback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">  timeoutTime = -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="利用上面定义的三个函数实现根据优先级调度任务"><a class="markdownIt-Anchor" href="#利用上面定义的三个函数实现根据优先级调度任务"></a> 利用上面定义的三个函数实现根据优先级调度任务</h1><p>首先是声明部分变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ImmediatePriority</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">UserBlockingPriority</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NormalPriority</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LowPriority</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IdlePriority</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Times out immediately</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">USER_BLOCKING_PRIORITY</span> = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IDLE_PRIORITY</span> = maxSigned31BitInt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Callbacks are stored as a circular, doubly linked list.</span></span><br><span class="line"><span class="keyword">var</span> firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentDidTimeout = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line"><span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentPriorityLevel = <span class="title class_">NormalPriority</span>;</span><br><span class="line"><span class="keyword">var</span> currentEventStartTime = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> currentExpirationTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is set when a callback is being executed, to prevent re-entrancy.</span></span><br><span class="line"><span class="keyword">var</span> isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNativePerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> performance.<span class="property">now</span> === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="flushfirstcallback"><a class="markdownIt-Anchor" href="#flushfirstcallback"></a> flushFirstCallback</h2><p>首先明白一点，所有的callbackNode组成的是一个双向的环，也就是说每个node都有previous和next，并且最后一个node的next是第一个节点，第一个节点的previous是最后一个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushFirstCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 保存firstCallbackNode为flushedNode等会使用</span></span><br><span class="line">  <span class="keyword">var</span> flushedNode = firstCallbackNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the node from the list before calling the callback. That way the</span></span><br><span class="line">  <span class="comment">// list is in a consistent state even if the callback throws.</span></span><br><span class="line">  <span class="keyword">var</span> next = firstCallbackNode.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === next) &#123;</span><br><span class="line">    <span class="comment">// This is the last callback in the list.</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 通过让firstCallbackNode的previous指向firstCallbackNode的next来将firstCallbackNode从任务环中删除</span></span><br><span class="line">    <span class="comment">// 同时让firstCallbackNode指向下一个节点</span></span><br><span class="line">    <span class="keyword">var</span> lastCallbackNode = firstCallbackNode.<span class="property">previous</span>;</span><br><span class="line">    firstCallbackNode = lastCallbackNode.<span class="property">next</span> = next;</span><br><span class="line">    next.<span class="property">previous</span> = lastCallbackNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flushedNode为当前要执行的任务节点</span></span><br><span class="line">  flushedNode.<span class="property">next</span> = flushedNode.<span class="property">previous</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now it&#x27;s safe to call the callback.</span></span><br><span class="line">  <span class="comment">// 执行当前节点的callback</span></span><br><span class="line">  <span class="keyword">var</span> callback = flushedNode.<span class="property">callback</span>;</span><br><span class="line">  <span class="keyword">var</span> expirationTime = flushedNode.<span class="property">expirationTime</span>;</span><br><span class="line">  <span class="keyword">var</span> priorityLevel = flushedNode.<span class="property">priorityLevel</span>;</span><br><span class="line">  <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">var</span> previousExpirationTime = currentExpirationTime;</span><br><span class="line">  currentPriorityLevel = priorityLevel;</span><br><span class="line">  currentExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">var</span> continuationCallback;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    continuationCallback = <span class="title function_">callback</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    currentExpirationTime = previousExpirationTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A callback may return a continuation. The continuation should be scheduled</span></span><br><span class="line">  <span class="comment">// with the same priority and expiration as the just-finished callback.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="attr">continuationNode</span>: <span class="title class_">CallbackNode</span> = &#123;</span><br><span class="line">      <span class="attr">callback</span>: continuationCallback,</span><br><span class="line">      priorityLevel,</span><br><span class="line">      expirationTime,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">previous</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the new callback into the list, sorted by its expiration. This is</span></span><br><span class="line">    <span class="comment">// almost the same as the code in `scheduleCallback`, except the callback</span></span><br><span class="line">    <span class="comment">// is inserted into the list *before* callbacks of equal expiration instead</span></span><br><span class="line">    <span class="comment">// of after.</span></span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">      firstCallbackNode = continuationNode.<span class="property">next</span> = continuationNode.<span class="property">previous</span> = continuationNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> nextAfterContinuation = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">expirationTime</span> &gt;= expirationTime) &#123;</span><br><span class="line">          <span class="comment">// This callback expires at or after the continuation. We will insert</span></span><br><span class="line">          <span class="comment">// the continuation *before* this callback.</span></span><br><span class="line">          nextAfterContinuation = node;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextAfterContinuation === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No equal or lower priority callback was found, which means the new</span></span><br><span class="line">        <span class="comment">// callback is the lowest priority callback in the list.</span></span><br><span class="line">        nextAfterContinuation = firstCallbackNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextAfterContinuation === firstCallbackNode) &#123;</span><br><span class="line">        <span class="comment">// The new callback is the highest priority callback in the list.</span></span><br><span class="line">        firstCallbackNode = continuationNode;</span><br><span class="line">        <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> previous = nextAfterContinuation.<span class="property">previous</span>;</span><br><span class="line">      previous.<span class="property">next</span> = nextAfterContinuation.<span class="property">previous</span> = continuationNode;</span><br><span class="line">      continuationNode.<span class="property">next</span> = nextAfterContinuation;</span><br><span class="line">      continuationNode.<span class="property">previous</span> = previous;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要做了如下几件事：</p><ul><li>从任务节点的双向环中找出<code>firstCallbackNode</code>指向的节点，把它从环中取出来并执行</li><li>如果执行的结果还是一个函数，也就是说callback返回了一个函数，那么就用返回的函数创建一个callbackNode，然后把它插入到环中，具体的位置就是代码中<code>nextAfterContinuation</code>节点之前，具体<code>nextAfterContinuation</code>如何得到的可以看上面的源码<ul><li>这里需要注意的一点是，如果<code>nextAfterContinuation</code>是<code>firstCallbackNode</code>，也就是说当前callback返回的函数所创建的新的任务节点需要插入到<code>firstCallbackNode</code>之前的时候，需要执行<code>ensureHostCallbackIsScheduled</code></li></ul></li></ul><h2 id="ensurehostcallbackisscheduled"><a class="markdownIt-Anchor" href="#ensurehostcallbackisscheduled"></a> ensureHostCallbackIsScheduled</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t schedule work yet; wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Schedule the host callback using the earliest expiration in the list.</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = firstCallbackNode.<span class="property">expirationTime</span>;</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Cancel the existing host callback.</span></span><br><span class="line">    <span class="title function_">cancelHostCallback</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestHostCallback</span>(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是如果当前正在执行某个callback，也就是<code>isExecutingCallback</code>为true，就什么都不做。否则就取消当前的hostcallback，然后把flushWork加入任务队列中</p><h2 id="flushwork"><a class="markdownIt-Anchor" href="#flushwork"></a> flushWork</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params">didTimeout</span>) &#123;</span><br><span class="line">  <span class="comment">// Exit right away if we&#x27;re currently paused</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousDidTimeout = currentDidTimeout;</span><br><span class="line">  currentDidTimeout = didTimeout;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">      <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// TODO Wrap in feature flag</span></span><br><span class="line">        <span class="comment">// Read the current time. Flush all the callbacks that expire at or</span></span><br><span class="line">        <span class="comment">// earlier than that time. Then read the current time again and repeat.</span></span><br><span class="line">        <span class="comment">// This optimizes for as few performance.now calls as possible.</span></span><br><span class="line">        <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode.<span class="property">expirationTime</span> &lt;= currentTime) &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">          &#125; <span class="keyword">while</span> (</span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            firstCallbackNode.<span class="property">expirationTime</span> &lt;= currentTime &amp;&amp;</span><br><span class="line">            !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Keep flushing callbacks until we run out of time in the frame.</span></span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">        &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYieldToHost</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">    currentDidTimeout = previousDidTimeout;</span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">      <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">    <span class="title function_">flushImmediateWork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码直接看注释就好，然后<code>flushImmediateWork</code>的作用其实也是注释里说的，运行所有优先级为immediate的任务</p><h2 id="flushimmediatework"><a class="markdownIt-Anchor" href="#flushimmediatework"></a> flushImmediateWork</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushImmediateWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// Confirm we&#x27;ve exited the outer most event handler</span></span><br><span class="line">    currentEventStartTime === -<span class="number">1</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    firstCallbackNode.<span class="property">priorityLevel</span> === <span class="title class_">ImmediatePriority</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="title function_">flushFirstCallback</span>();</span><br><span class="line">      &#125; <span class="keyword">while</span> (</span><br><span class="line">        <span class="comment">// Keep flushing until there are no more immediate callbacks</span></span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode.<span class="property">priorityLevel</span> === <span class="title class_">ImmediatePriority</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">        <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对外暴露的方法"><a class="markdownIt-Anchor" href="#对外暴露的方法"></a> 对外暴露的方法</h1><p>这里我们主要讲两个方法，一个是<code>unstable_scheduleCallback</code>，一个是<code>unstable_cancelCallback</code></p><h2 id="unstable_schedulecallback"><a class="markdownIt-Anchor" href="#unstable_schedulecallback"></a> unstable_scheduleCallback</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> startTime =</span><br><span class="line">    currentEventStartTime !== -<span class="number">1</span> ? currentEventStartTime : <span class="title function_">getCurrentTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options.<span class="property">timeout</span> === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">    expirationTime = startTime + deprecated_options.<span class="property">timeout</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">USER_BLOCKING_PRIORITY</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">IDLE_PRIORITY</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        expirationTime = startTime + <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">    callback,</span><br><span class="line">    <span class="attr">priorityLevel</span>: currentPriorityLevel,</span><br><span class="line">    expirationTime,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">previous</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the new callback into the list, ordered first by expiration, then</span></span><br><span class="line">  <span class="comment">// by insertion. So the new callback is inserted any other callback with</span></span><br><span class="line">  <span class="comment">// equal expiration.</span></span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">    firstCallbackNode = newNode.<span class="property">next</span> = newNode.<span class="property">previous</span> = newNode;</span><br><span class="line">    <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">expirationTime</span> &gt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// The new callback expires before this one.</span></span><br><span class="line">        next = node;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No callback with a later expiration was found, which means the new</span></span><br><span class="line">      <span class="comment">// callback has the latest expiration in the list.</span></span><br><span class="line">      next = firstCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The new callback has the earliest expiration in the entire list.</span></span><br><span class="line">      firstCallbackNode = newNode;</span><br><span class="line">      <span class="title function_">ensureHostCallbackIsScheduled</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> previous = next.<span class="property">previous</span>;</span><br><span class="line">    previous.<span class="property">next</span> = next.<span class="property">previous</span> = newNode;</span><br><span class="line">    newNode.<span class="property">next</span> = next;</span><br><span class="line">    newNode.<span class="property">previous</span> = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来很长，其实就是做了两件事：</p><ul><li>创建一个新的callbackNode</li><li>将新的callbackNode根据时间和优先级加入到callbackNode的双向环中</li></ul><h2 id="unstable_cancelcallback"><a class="markdownIt-Anchor" href="#unstable_cancelcallback"></a> unstable_cancelCallback</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_cancelCallback</span>(<span class="params">callbackNode</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> next = callbackNode.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already cancelled.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === callbackNode) &#123;</span><br><span class="line">    <span class="comment">// This is the only scheduled callback. Clear the list.</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Remove the callback from its position in the list.</span></span><br><span class="line">    <span class="keyword">if</span> (callbackNode === firstCallbackNode) &#123;</span><br><span class="line">      firstCallbackNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> previous = callbackNode.<span class="property">previous</span>;</span><br><span class="line">    previous.<span class="property">next</span> = next;</span><br><span class="line">    next.<span class="property">previous</span> = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callbackNode.<span class="property">next</span> = callbackNode.<span class="property">previous</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也比较简单，就是从callbackNode的双向环中找出要取消的任务，然后从环中把它去掉。</p><blockquote><p>最新版本的Scheduler的主要改动是：已经不是使用双向链表的方式存储所有任务了，而是使用了两个最小堆，分别叫timerQueue和taskQueue，任务会先放到timerQueue中，每次执行完taskQueue中的任务后，后检查timerQueue中有没有已经到期的任务，如果有，放入taskQueue中，然后重新开始遍历执行taskQueue中的任务，遍历过程中如果需要yield就暂时退出，然后开启设置宏任务下次继续执行</p></blockquote></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"> <strong>本文作者：</strong> Ray Sun</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://sunra.top/2023/01/05/react-scheduler/" title="React Scheduler 源码解析">https://sunra.top/2023/01/05/react-scheduler/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"> <span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><span class="social-link"><span class="icon"><i class="fab fa-weixin"></i></span> <span class="label">WeChat</span></span> <img class="social-item-img" src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1685836114/origin-of-ray/wechat_channel_zmg0hw.jpg"></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/04/leetcode-1802/" rel="prev" title="二分法解决有界区间的最值问题"><i class="fa fa-chevron-left"></i> 二分法解决有界区间的最值问题</a></div><div class="post-nav-item"> <a href="/2023/01/13/hungary-algorithm/" rel="next" title="匈牙利算法">匈牙利算法<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Ray Sun</span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css" integrity="sha256-hLTCMFlKxdNgPXyWlSSxYN0ykJmxxq9Yt3MNfdRGWeA=" crossorigin="anonymous"><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-comments-3w44.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"欢迎大家交流学习","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2023/01/05/react-scheduler/"}</script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script></body></html>