<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARP病毒原理及防御</title>
    <url>/2019/09/15/ARP/</url>
    <content><![CDATA[<p>ARP病毒原理及防御以及如何快速定位ARP病毒源。</p>
<a id="more"></a>

<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p> ARP协议（address resolution protocol）地址解析协议</p>
<p>一台主机和另一台主机通信，要知道目标的IP地址，但是在局域网中传输数据的网卡却不能直接识别IP地址，所以用ARP解析协议将IP地址解</p>
<p>析成MAC地址。ARP协议的基本功能就是通过目标设备的IP地址，来查询目标设备的mac地址。</p>
<p>在局域网的任意一台主机中，都有一个ARP缓存表，里面保存本机已知的此局域网中各主机和路由器的IP地址和MAC地址的对照关系。ARP缓存</p>
<p>表的生命周期是有时限的（一般不超过20分钟）。</p>
<p>假设局域网中有A,B,C,D四台主机</p>
<p>主机A想和主机B通信</p>
<p>主机A会先查询自己的ARP缓存表里有没有B的联系方式，有的话，就将mac-b地址封装到数据包外面，发送出去。没有的话，A会向全网络发送一个</p>
<p>ARP广播包，大声询问：我的IP地址是192.168.0.2，硬件地址是mac-a，我想知道IP地址是192.168.0.3的硬件地址是多少？   此时，局域网内所有</p>
<p>主机都收到了，B收到后会单独私密回应：我是192.168.0.3，我的硬件地址是mac-b，其他主机不会理A的</p>
<p>此时A知道了B的信息，同时也会动态的更新自身的缓存表</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>ARP协议是建立在信任局域网内所有节点的基础上的，他的效率很高。但是不安全。它是无状态的协议。他不会检查自己是否发过请求包，</p>
<p>也不知道自己是否发过请求包。他也不管是否合法的应答，只要收到目标mac地址是自己的ARP reply或者ARP广播包（包括ARP reply和ARP request），</p>
<p>都会接受并缓存。</p>
<h2 id="ARP攻击原理"><a href="#ARP攻击原理" class="headerlink" title="ARP攻击原理"></a>ARP攻击原理</h2><p>ARP欺骗攻击建立在局域网主机间相互信任的基础上的</p>
<p>当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？</p>
<p>此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b，</p>
<p>可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。</p>
<p>所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表</p>
<p>这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。</p>
<p>假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ＩＰ是１９２.１６８.０.１，我的硬件地址是ｍａｃ－ｃ，</p>
<p>此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。</p>
<h2 id="如何快速找到病毒源"><a href="#如何快速找到病毒源" class="headerlink" title="如何快速找到病毒源"></a>如何快速找到病毒源</h2><h3 id="使用Sniffer抓包"><a href="#使用Sniffer抓包" class="headerlink" title="使用Sniffer抓包　　"></a>使用Sniffer抓包　　</h3><p>在网络内任意一台主机上运行抓包软件，捕获所有到达本机的数据包。如果发现有某个IP不断发送请求包，那么这台电脑一般就是病毒源。原理：无论何种ARP病毒变种，行为方式有两种，一是欺骗网关，二是欺骗网内的所有主机。</p>
<h3 id="使用arp-a命令"><a href="#使用arp-a命令" class="headerlink" title="使用arp -a命令　"></a>使用arp -a命令　</h3><p>任意选两台不能上网的主机，在DOS命令窗口下运行arp -a命令。例如在结果中，两台电脑除了网关的IP，MAC地址对应项，都包含了192.168.0.186的这个IP，则可以断定192.168.0.186这台主机就是病毒源。原理：一般情况下，网内的主机只和网关通信。</p>
<h3 id="使用tracert命令"><a href="#使用tracert命令" class="headerlink" title="使用tracert命令"></a>使用tracert命令</h3><p>在任意一台受影响的主机上，在DOS命令窗口下运行如下命令：tracert 61.135.179.148。　假定设置的缺省网关为10.8.6.1，在跟踪一个外网地址时，第一跳却是10.8.6.186，那么，10.8.6.186就是病毒源。原理：中毒主机在受影响主机和网关之间，扮演了“中间人”的角色。所有本应该到达网关的数据包，由于错误的MAC地址，均被发到了中毒主机。此时，中毒主机越俎代庖，起了缺省网关的作用。</p>
<h2 id="ARP防御"><a href="#ARP防御" class="headerlink" title="ARP防御"></a>ARP防御</h2><h3 id="ARP双向绑定"><a href="#ARP双向绑定" class="headerlink" title="ARP双向绑定"></a>ARP双向绑定</h3><p> 在pc端上 IP+mac 绑定</p>
<p> 在网络设备（交换路由）上 采用ip+mac+端口绑定</p>
<p>网关也进行IP和mac的静态绑定</p>
<h3 id="建立DHCP服务器"><a href="#建立DHCP服务器" class="headerlink" title="建立DHCP服务器"></a>建立DHCP服务器</h3><p>ARP攻击一般先攻击网关，将DHCP服务器建立在网关上</p>
<h3 id="划分安全区域"><a href="#划分安全区域" class="headerlink" title="划分安全区域"></a>划分安全区域</h3><p>ARP广播包是不能跨子网或网段传播的，网段可以隔离广播包。VLAN就是一个逻辑广播域，通过VLAN技术可以在局域网中创建多个子网，就在局域网中隔离了广播,缩小感染范围。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>非对称加密原理探索</title>
    <url>/2019/10/19/Asymmetric_Encryption/</url>
    <content><![CDATA[<p>今天阅读https原理的时候，发现它采用了非对称加密的知识，于是去探索了一下非对称加密的基本原理。</p>
<a id="more"></a>

<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>在非对称加密算法中，有公钥和私钥两种密钥，其中，公钥是公开的，不需要保密，私钥由个人持有，必须妥善保管和注意保密。加密和解密使用两种不同的密钥，是它得名的原因。</p>
<p>每一个公钥都对应一个私钥。<br>密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。 </p>
<p>如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。<br>如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 </p>
<p>A与B之间进行通信，如果他们不想通信的内容被他人知道，就可以对通信的内容进行非对称的加密。</p>
<p>比如BC架构中，浏览器与服务器之间进行数据通信，服务器可以将自己的公钥发送给浏览器，浏览器就可以将自己想要发送给服务器的信息利用公钥进行加密，当服务器收到该信息时，利用自己的私钥对信息进行解密就可以获取加密之前的内容，同时保证了其他任何人获取到该信息都无法破解。</p>
<p>同时服务器也可以利用自己的私钥对返回的信息进行加密，浏览器就可以利用私钥进行解密。</p>
<h2 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h2><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p> 在公钥加密、解密里面描述的通讯过程看似简单，但想想这个问题：在上述过程中，A怎么知道B在给他的回信在传递过程中，有没有被人修改？这就涉及到数字签名的概念。 </p>
<p>要达到这个目的，一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。 接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送。</p>
<p>下面通过例子来说明这个过程：<br>B给A回信时，采用了数字签名的方式<br>1、B先用hash函数，生成信件的摘要(digest)<br>2、B使用自己的私钥，对这个摘要加密，这样就生成了数字签名(signature)<br>3、B将这个签名附在要回复的信息后面，一起发给A<br>4、A收到B的信息后，取下数字签名，并通过B的公钥解密，得到信件的摘要信息<br>5、A在对B发送的信息本身使用B指定的hash函数，将得到的结果同上一步解密得到的摘要进行对比，如果两者一致，就说明B发过来的信息未被修改过。</p>
<p>问题就这样结束了吗？远没有，试想，虽然A确定了B回给他的信息是未修改过的，但是怎么确定给他回信息的就是B？如果有不怀好意的C把A保存的B的公钥偷偷换成自己的，并冒用B的名义给A发信息呢？<br>要解决这个问题，A只要能确定自己持有的公钥到底是不是B的就行了，这就需要用到数字证书。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书是用来验证公钥所属的用户身份。在日常生活中，如果我们要验证一个人的身份，通常的做法是查看他的身份证。我们信任身份证颁发机构即政府机构的公信力，因此只要验证一个人的身份证不是伪造的，我们就相信这个人的身份和身份证上所描述的是一致的。<br>数字证书就是一个人或者组织在网络世界中的身份证，其发证机关是证书管理机构(certificate authority,CA)。CA用自己的私钥对用户的身份信息(主要是用户名和该用户的公钥)进行签名，该签名和用户的身份信息一起就形成了证书。</p>
<p>数字证书一般由数字证书认证机构签发，需要</p>
<ul>
<li>申请者通过<strong>非对称加密算法（RSA）</strong> 生成一对<strong>公钥</strong>和<strong>密钥</strong>，然后把需要的申请信息（国家，域名等）连同公钥发送给 <strong>证书认证机构（CA）</strong></li>
<li>CA构确认无误后通过<strong>消息摘要算法</strong>（MD5，SHA) 生成整个申请信息的摘要签名M， 然后 把 <strong>签名M和使用的摘要算法</strong> 用 <strong>CA自己的私钥</strong> 进行加密</li>
</ul>
<h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ol>
<li>证书的发布机构（Issuer）<br>指出是什么机构发布的这个证书，也就是指明这个证书是哪个证书中心（certificate authority，简称CA）发布的的(只是创建证书，不是指证书的使用者)。</li>
<li>证书的有效期（Valid from , Valid to）<br>也就是证书的有效时间，或者说证书的使用期限。 过了有效期限，证书就会作废，不能使用了。</li>
<li>公钥 （Public key）<br>这个我们在前面介绍公钥密码体制时介绍过，公钥是用来对消息进行加密解密的，是很长的一串数字。</li>
<li>证书所有者（Subject）<br>这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。</li>
<li>签名所使用的算法 （Signature algorithm）<br>指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名</li>
<li>指纹以及指纹算法 （Thumbprint, Thumbprint algorithm）<br>这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。</li>
</ol>
<p>其实任何个体/组织都可以成为CA（自签证书），但是你发发布的证书客户端是不信任的，也是就前文提及的需要权威。比如 <strong>Symantec、Comodo、Godaddy、Digicert</strong>。</p>
<p>客户端信任这些CA，就会在其本地保持这些CA的 <strong>根证书</strong>（<strong>root certificate</strong>），<strong>根证书是CA自己的证书</strong>，是证书验证链的开头。根证书没有机构（已经是权威了）再为其做数字签名，所以都是自签证书。</p>
<p>CA会通过 <strong>中介证书（intermediate-certificate）</strong> 替代根证书的去做服务器端的证书签名，确保根证书密钥绝对不可访问。</p>
<h4 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h4><p>前文提到，在向CA 申请证书时是需要 <strong>CA的私钥</strong> 去对整个证书的签名摘要做非对称加密的，也就是证书是可以通过 <strong>CA的公钥</strong> 去解密得到<strong>证书的签名摘要</strong>的。当我们再次用 <strong>相同的摘要算法</strong>（证书里面有保存所使用的算法）对整个证书做签名，如果得到的签名和证书上的签名是一致的，说明这个证书是可信任的。</p>
<p>同理，中介证书 也是可以被这样的方式证明其可信任。这样的一整个流程称为 <strong>信任链</strong>（Chain of trust）。</p>
<p>就是我<strong>绝对</strong>相信你（A&gt;B）；你<strong>绝对</strong>相信他（B&gt;C）；等于我<strong>绝对</strong>相信他（A&gt;C）</p>
<p>客户端得到服务端返回的证书，通过读取得到 <strong>服务端证书的发布机构（Issuer）</strong></p>
<p>客户端去操作系统查找这个发布机构的的证书，如果是不是根证书就继续递归下去 <strong>直到拿到根证书</strong>（一般都存储在比较安全的地方，比如框架的源码等地方）。</p>
<p>用 <strong>根证书的公钥</strong> 去 <strong>解密验证</strong> 上一层证书的<strong>合法性</strong>，再拿上一层证书的公钥去验证更上层证书的合法性；递归回溯。</p>
<p>最后验证服务器端的证书是 <strong>可信任</strong> 的。</p>
<h2 id="RSA原理简介"><a href="#RSA原理简介" class="headerlink" title="RSA原理简介"></a>RSA原理简介</h2><table>
<thead>
<tr>
<th>1</th>
<th>找出质数</th>
<th>P 、Q</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>计算公共模数</td>
<td>N = P * Q</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>欧拉函数</td>
<td>φ(N) = (P-1)(Q-1)</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>计算公钥E</td>
<td>1 &lt; E &lt; φ(N)</td>
<td>E的取值必须是整数 E 和 φ(N) 必须是互质数</td>
</tr>
<tr>
<td>5</td>
<td>计算私钥D</td>
<td>E * D % φ(N) = 1</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>加密</td>
<td>C ＝ M E mod N</td>
<td>C：密文  M：明文</td>
</tr>
<tr>
<td>7</td>
<td>解密</td>
<td>M ＝C D mod N</td>
<td>C：密文  M：明文</td>
</tr>
</tbody></table>
<p>参考文章： </p>
<p><a href="https://blog.csdn.net/wzzvictory/article/details/9015155" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/wzzvictory/article/details/9015155</a> </p>
<p><a href="https://cloud.tencent.com/developer/article/1130051" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1130051</a> </p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Azure Key Vault</title>
    <url>/2019/11/30/Azure-Key-Vault/</url>
    <content><![CDATA[<p>Azure Key Vault is a tool for securely storing and accessing secrets. A secret is anything that you want to tightly control access to, such as API keys, passwords, or certificates. A vault is logical group of secrets.</p>
<a id="more"></a>

<p>上面这一段是Azure官方文档的描述，作者在阅读了Microsoft Azure文档之后，对其基本的概念进行了提取和总结，并在原文中加入了一些自己的理解。阅读完中文就能对key vault有个大概的认识，英文原文是比较专业的描述，不影响理解，如果想进一步了解可以去阅读文末提供的链接。</p>
<h2 id="What-is-Azure-Key-Vault"><a href="#What-is-Azure-Key-Vault" class="headerlink" title="What is Azure Key Vault"></a>What is Azure Key Vault</h2><p>简单来讲，Azure Key Vault 就是提供了一个能够安全存储你的敏感数据的地方，想要获取这些数据就必须通过身份校验以及权限校验，我们可以把类似于证书，数据库配置等敏感信息放在这里，而不需要硬编码到代码中。在使用时我们将敏感信息存储到key vault上后，会获取对应的名称，我们只需要通过api去key vault中通过名字（也可以添加版本信息）获取对应的信息就好，这些信息可以是密钥（只能get公钥），证书信息，或者一些配置信息。当然这些信息并不是任何人直接去调用api就可以获取的，而是需要你的Identity信息被用于创建该Key Vault的Tenant下面的Subscription所承认，获取承认的方式有很多种，可以通过id-token，或者密码等。</p>
<p>Azure Key Vault帮助解决以下问题：</p>
<ul>
<li><strong>秘密管理</strong> -Azure Key Vault可用于安全存储和严格控制对令牌，密码，证书，API密钥和其他秘密的访问。</li>
<li><strong>密钥管理</strong> -Azure Key Vault也可以用作密钥管理解决方案。使用Azure Key Vault可以轻松创建和控制用于加密数据的加密密钥。</li>
<li><strong>证书管理</strong> -Azure Key Vault也是一项服务，使您可以轻松地调配，管理和部署公共和私有安全套接字层/传输层安全性（SSL / TLS）证书，以与Azure和内部连接的资源一起使用。</li>
<li><strong>存储由硬件安全模块支持</strong>的机密-机密和密钥可以通过软件或FIPS 140-2 2级验证HSM进行保护。</li>
</ul>
<p>使用Azure Key Vault 可以集中存储应用程序的机密数据并可以控制这些数据的分发。而且由于开发人员可以不用在程序中硬编码安全信息，大大提高了程序的安全性。</p>
<p>存储在Azure Key Vault中的信息会被可靠的加密算法保存。</p>
<p>同时Azure Key Vault可以基于Azure AD进行访问的权限控制，同时可以记录下来是谁在什么时间访问了哪一条数据。</p>
<h2 id="Azure-Key-Vault-basic-concepts"><a href="#Azure-Key-Vault-basic-concepts" class="headerlink" title="Azure Key Vault basic concepts"></a>Azure Key Vault basic concepts</h2><ul>
<li><strong>承租人/租户</strong>( <strong>Tenant</strong> )：承租人是拥有和管理Microsoft云服务的特定实例的组织。最常用于指组织的Azure和Office 365服务集。</li>
<li><strong>保管库所有者</strong>( <strong>Vault owner</strong> )：保管库所有者可以创建密钥保管库并获得对其的完全访问权和控制权。保管库所有者还可以设置审核以记录谁访问了机密和密钥。管理员可以控制密钥生命周期。他们可以滚动到密钥的新版本，进行备份并执行相关任务。</li>
<li><strong>保管箱使用者</strong>( <strong>Vault consumer</strong> )：当保管库所有者授予使用者访问权时，<strong>保管箱使用者</strong>可以对密钥保管库内的资产执行操作。可用的操作取决于所授予的权限。</li>
<li><strong>资源</strong>( <strong>Resource</strong> )：资源是可通过Azure进行管理的项目。常见示例包括虚拟机，存储帐户，Web应用程序，数据库和虚拟网络。还有更多。</li>
<li><strong>资源组</strong>( <strong>Resource group</strong> )：资源组是一个容器，其中包含Azure解决方案的相关资源。资源组可以包含解决方案的所有资源，也可以仅包含您要作为组进行管理的资源。您可以根据对组织最有意义的决定来决定如何向资源组分配资源。</li>
<li><strong>服务主体</strong>( <strong>Service principal</strong> )：Azure服务主体是用户创建的应用程序，服务和自动化工具用来访问特定Azure资源的安全身份。可以将其视为具有特定角色且受到严格控制的权限的“用户身份”（用户名，密码或证书）。与一般用户身份不同，服务主体只需要做特定的事情。如果仅授予它执行管理任务所需的最低权限级别，则可以提高安全性。</li>
<li>Azure Active Directory（Azure AD）：Azure AD是租户的Active Directory服务。每个目录都有一个或多个域。一个目录可以有许多与之关联的订阅，但只能有一个租户。每个组织可以有一个租户，这个租户有自己的ID用于标识自己，每个Tenant都有自己的一个或者多个SubScription，Subscription与Azure AD directory是多对一的关系。每个人都可以去Azure上申请自己的账号，这个账号在Azure上叫做Identity，每个Identity可以创建Azure AD account。如果你的Azure AD account在某个Tenant的Azure AD directory中，并且Tenant授予了你某个Subscription的权限，你就可以使用该Subscription下的Services。具体可以去查看<a href="https://docs.microsoft.com/en-us/azure/active-directory/active-directory-whatis" rel="external nofollow noopener noreferrer" target="_blank">文档</a></li>
<li><strong>Azure租户ID</strong>( <strong>Azure tenant ID</strong> )：租户ID是在Azure订阅中标识Azure AD实例的独特方法。</li>
<li><strong>托管身份</strong>( <strong>Managed identities</strong> )：Azure Key Vault提供了一种安全存储凭据以及其他密钥和机密的方法，但是您的代码需要通过Key Vault进行身份验证才能检索它们。通过使用托管身份，可以通过在Azure AD中为Azure服务提供自动托管身份来简化解决此问题的步骤。您可以使用此身份对Key Vault或支持Azure AD身份验证的任何服务进行身份验证，而无需在代码中包含任何凭据。</li>
</ul>
<p><strong>Anybody with an Azure subscription can create and use key vaults</strong>. Although Key Vault benefits developers and security administrators, it can be implemented and managed by an organization’s administrator who manages other Azure services. </p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p> 这一部分主要讲的就是Azure Key Vault是如何确保你的信息只能被你授权的人看到。</p>
<p>对于Key Vault的管理有两种级别，也对应着两种access model，第一种级别叫做management plane，这种级别的关系可以对Key Vault本身进行操作，可以创建和删除一个Key Vault，第二种级别就是对Key Vault中的数据进行管理。但是不管那种级别，其身份校验都是通过Azure AD来实现的，通过基于<strong>角色的权限控制（RBAC）</strong>来判断一个用户可以对Key Vault做出怎样的操作。</p>
<p>在不同级别之下做出的RBAC只适用于该级别之下的用户，比如你在Subscription的级别下做出的RBAC就只适用于该Subscription下的用户。</p>
<p>同时对于secret， key，certificate的权限管理是分开的，也就是说你同一个Subscription下的用户在同一个Key Vault中可能对secret有访问权限，但是对于key却没有。</p>
<p>You need to protect encryption keys and secrets like certificates, connection strings, and passwords in the cloud so you are using Azure Key Vault. Since you are storing sensitive and business critical data, you need to take steps to maximize the security of your vaults and the data stored in them. </p>
<h3 id="Identity-and-access-management"><a href="#Identity-and-access-management" class="headerlink" title="Identity and access management"></a>Identity and access management</h3><p>When you create a key vault in an Azure subscription, it’s automatically associated with the Azure AD tenant of the subscription. Anyone trying to manage or retrieve content from a vault must be authenticated by Azure AD.</p>
<ul>
<li>Authentication establishes the identity of the caller.</li>
<li>Authorization determines which operations the caller can perform. Authorization in Key Vault uses a combination of <a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/overview" rel="external nofollow noopener noreferrer" target="_blank">Role based access control</a> (RBAC) and Azure Key Vault access policies.</li>
</ul>
<h4 id="Access-model-overview"><a href="#Access-model-overview" class="headerlink" title="Access model overview"></a>Access model overview</h4><p>Access to vaults takes place through two interfaces or planes. These planes are the management plane and the data plane.</p>
<ul>
<li>The <em>management plane</em> is where you manage Key Vault itself and it is the interface used to create and delete vaults. You can also read key vault properties and manage access policies.</li>
<li>The <em>data plane</em> allows you to work with the data stored in a key vault. You can add, delete, and modify keys, secrets, and certificates.</li>
</ul>
<p>To access a key vault in either plane, all callers (users or applications) must be authenticated and authorized. Both planes use Azure Active Directory (Azure AD) for authentication. For authorization, the management plane uses role-based access control (RBAC) and the data plane uses a Key Vault access policy.</p>
<p>The model of a single mechanism for authentication to both planes has several benefits:</p>
<ul>
<li>Organizations can control access centrally to all key vaults in their organization.</li>
<li>If a user leaves, they instantly lose access to all key vaults in the organization.</li>
<li>Organizations can customize authentication by using the options in Azure AD, such as to enable multi-factor authentication for added security</li>
</ul>
<h4 id="Managing-administrative-access-to-Key-Vault"><a href="#Managing-administrative-access-to-Key-Vault" class="headerlink" title="Managing administrative access to Key Vault"></a>Managing administrative access to Key Vault</h4><p>When you create a key vault in a resource group, you manage access by using Azure AD. You grant users or groups the ability to manage the key vaults in a resource group. You can grant access at a specific scope level by assigning the appropriate RBAC roles. To grant access to a user to manage key vaults, you assign a predefined <code>key vault Contributor</code> role to the user at a specific scope. The following scopes levels can be assigned to an RBAC role:</p>
<ul>
<li><strong>Subscription</strong>: An RBAC role assigned at the subscription level applies to all resource groups and resources within that subscription.</li>
<li><strong>Resource group</strong>: An RBAC role assigned at the resource group level applies to all resources in that resource group.</li>
<li><strong>Specific resource</strong>: An RBAC role assigned for a specific resource applies to that resource. In this case, the resource is a specific key vault.</li>
</ul>
<h4 id="Controlling-access-to-Key-Vault-data"><a href="#Controlling-access-to-Key-Vault-data" class="headerlink" title="Controlling access to Key Vault data"></a>Controlling access to Key Vault data</h4><p>Key Vault access policies grant permissions separately to keys, secrets, or certificate. You can grant a user access only to keys and not to secrets. Access permissions for keys, secrets, and certificates are managed at the vault level.</p>
<h4 id="Network-access"><a href="#Network-access" class="headerlink" title="Network access"></a>Network access</h4><p>You can reduce the exposure of your vaults by specifying which IP addresses have access to them. The virtual network service endpoints for Azure Key Vault allow you to restrict access to a specified virtual network. The endpoints also allow you to restrict access to a list of IPv4 (internet protocol version 4) address ranges. Any user connecting to your key vault from outside those sources is denied access.</p>
<p>After firewall rules are in effect, users can only read data from Key Vault when their requests originate from allowed virtual networks or IPv4 address ranges. This also applies to accessing Key Vault from the Azure portal. Although users can browse to a key vault from the Azure portal, they might not be able to list keys, secrets, or certificates if their client machine is not in the allowed list. This also affects the Key Vault Picker by other Azure services. Users might be able to see list of key vaults, but not list keys, if firewall rules prevent their client machine.</p>
<h3 id="Azure-Key-Vault-security-worlds-and-geographic-boundaries"><a href="#Azure-Key-Vault-security-worlds-and-geographic-boundaries" class="headerlink" title="Azure Key Vault security worlds and geographic boundaries"></a>Azure Key Vault security worlds and geographic boundaries</h3><p>Azure Key Vault 是一个多租户服务，同一个Azure Location使用同一个HSM，享有相同的安全边界，也就是在同一个安全世界中。</p>
<p>同时Azure Key Vault可以对数据进行备份，但是备份需要满足两个条件：</p>
<ul>
<li>两个Azure locations 在同一地理位置</li>
<li>两个key vaults 属于同一个订阅</li>
</ul>
<h3 id="Secure-access-to-a-key-vault"><a href="#Secure-access-to-a-key-vault" class="headerlink" title="Secure access to a key vault"></a>Secure access to a key vault</h3><h4 id="Access-model-overview-1"><a href="#Access-model-overview-1" class="headerlink" title="Access model overview"></a>Access model overview</h4><p>对密钥库的访问通过两个接口进行控制:管理平面和数据平面。管理平面是您管理密钥库本身的地方。此平面中的操作包括创建和删除密钥保险库、检索密钥保险库属性和更新访问策略。数据平面是处理存储在密钥库中的数据的地方。您可以添加、删除和修改密钥、秘密和证书。<br>要访问任一平面中的密钥库，所有调用方(用户或应用程序)必须具有适当的身份验证和授权。身份验证建立</p>
<h4 id="Active-Directory-authentication"><a href="#Active-Directory-authentication" class="headerlink" title="Active Directory authentication"></a>Active Directory authentication</h4><p>When you create a key vault in an Azure subscription, it’s automatically associated with the Azure AD tenant of the subscription. All callers in both planes must register in this tenant and authenticate to access the key vault. In both cases, applications can access Key Vault in two ways:</p>
<ul>
<li><strong>User plus application access</strong>: The application accesses Key Vault on behalf of a signed-in user. Examples of this type of access include Azure PowerShell and the Azure portal. User access is granted in two ways. Users can access Key Vault from any application, or they must use a specific application (referred to as <em>compound identity</em>).</li>
<li><strong>Application-only access</strong>: The application runs as a daemon service or background job. The application identity is granted access to the key vault.</li>
</ul>
<p>For both types of access, the application authenticates with Azure AD. The application uses any <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-scenarios" rel="external nofollow noopener noreferrer" target="_blank">supported authentication method</a> based on the application type. The application acquires a token for a resource in the plane to grant access. The resource is an endpoint in the management or data plane, based on the Azure environment. The application uses the token and sends a REST API request to Key Vault. To learn more, review the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow" rel="external nofollow noopener noreferrer" target="_blank">whole authentication flow</a>.</p>
<p>The model of a single mechanism for authentication to both planes has several benefits:</p>
<ul>
<li>Organizations can control access centrally to all key vaults in their organization.</li>
<li>If a user leaves, they instantly lose access to all key vaults in the organization.</li>
<li>Organizations can customize authentication by using the options in Azure AD, such as to enable multi-factor authentication for added security.</li>
</ul>
<h4 id="Resource-endpoints"><a href="#Resource-endpoints" class="headerlink" title="Resource endpoints"></a>Resource endpoints</h4><p> 应用程序通过端点访问两个平面。 </p>
<p>The access controls for the two planes work independently. To grant an application access to use keys in a key vault, you grant data plane access by using a Key Vault access policy. To grant a user read access to Key Vault properties and tags, but not access to data (keys, secrets, or certificates), you grant management plane access with RBAC. **</p>
<h2 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h2><h3 id="About-keys-secrets-and-certificates"><a href="#About-keys-secrets-and-certificates" class="headerlink" title="About keys, secrets, and certificates"></a>About keys, secrets, and certificates</h3><p>Azure Key Vault使Microsoft Azure应用程序和用户能够存储和使用几种类型的秘密/密钥数据</p>
<ul>
<li>加密密钥（Cryptographic key）：支持多种密钥类型和算法，并允许对高价值密钥使用硬件安全模块（HSM）。我们通过api其实只能获取到公钥。</li>
<li>机密(Secrets)：提供机密的安全存储，例如密码和数据库连接字符串。</li>
<li>证书(Certificates)：支持基于密钥和机密构建的证书，并添加了自动续订功能。</li>
<li>Azure存储(Azure Storage)：可以为您管理Azure存储帐户的密钥。在内部，Key Vault可以使用Azure存储帐户列出（同步）密钥，并定期重新生成（旋转）密钥。</li>
</ul>
<h4 id="Key-Vaults-keys"><a href="#Key-Vaults-keys" class="headerlink" title="Key Vaults keys"></a>Key Vaults keys</h4><p>Key Vault中的加密密钥表示为JSON Web密钥[JWK]对象。JWK / JWA基本规范也得到了扩展，以启用Key Vault实施所特有的密钥类型。例如，使用特定于HSM供应商的包装导入密钥，可以安全地运输只能在Key Vault HSM中使用的密钥。</p>
<ul>
<li><strong>“软”密钥</strong>：Key Vault在软件中处理过的密钥，但是使用HSM中的系统密钥在静止状态下进行了加密。客户可以导入现有的RSA或EC（椭圆曲线）密钥，或请求Key Vault生成一个。</li>
<li><strong>“硬”键</strong>：在HSM（硬件安全模块）中处理的键。这些密钥在Key Vault HSM安全世界之一（每个地理区域都有一个安全世界以保持隔离）中受到保护。客户端可以以软形式或通过从兼容的HSM设备导出来导入RSA或EC密钥。客户还可以请求Key Vault生成密钥。此密钥类型将key_hsm属性添加到JWK获取以携带HSM密钥材料。</li>
</ul>
<p>在密钥库中创建密钥后，可以使用该密钥执行以下加密操作：</p>
<ul>
<li><strong>签名并验证</strong>：严格来说，此操作是“签名哈希”或“验证哈希”，因为Key Vault不支持内容哈希作为签名创建的一部分。应用程序应对要在本地签名的数据进行哈希处理，然后请求Key Vault对哈希进行签名。对于可能无法访问[公开]密钥材料的应用程序，为方便操作提供了对签名哈希的验证的支持。为了获得最佳的应用程序性能，请验证是否在本地执行操作。</li>
<li><strong>密钥加密/包装</strong>：可以将存储在Key Vault中的密钥用于保护另一个密钥，通常是对称内容加密密钥（CEK）。当Key Vault中的密钥不对称时，将使用密钥加密。例如，RSA-OAEP和WRAPKEY / UNWRAPKEY操作等效于ENCRYPT / DECRYPT。如果“密钥保管库”中的密钥是对称的，则使用密钥包装。例如，AES-KW。支持WRAPKEY操作是为了方便无法访问[公开]密钥资料的应用程序。为了获得最佳的应用程序性能，WRAPKEY操作应在本地执行。</li>
<li><strong>加密和解密</strong>：存储在Key Vault中的密钥可用于加密或解密单个数据块。块的大小由密钥类型和所选的加密算法确定。为方便起见，提供了Encrypt操作，用于可能无法访问[公开]密钥资料的应用程序。为了获得最佳的应用程序性能，应在本地执行加密操作。</li>
</ul>
<h4 id="Key-Vault-secrets"><a href="#Key-Vault-secrets" class="headerlink" title="Key Vault secrets"></a>Key Vault secrets</h4><p>From a developer’s perspective, Key Vault APIs accept and return secret values as strings. Internally, Key Vault stores and manages secrets as sequences of octets (8-bit bytes), with a maximum size of 25k bytes each. The Key Vault service doesn’t provide semantics for secrets. It merely accepts the data, encrypts it, stores it, and returns a secret identifier (“id”). The identifier can be used to retrieve the secret at a later time.</p>
<p>For highly sensitive data, clients should consider additional layers of protection for data. Encrypting data using a separate protection key prior to storage in Key Vault is one example.</p>
<p>Key Vault also supports a contentType field for secrets. Clients may specify the content type of a secret to assist in interpreting the secret data when it’s retrieved. The maximum length of this field is 255 characters. There are no pre-defined values. The suggested usage is as a hint for interpreting the secret data. For instance, an implementation may store both passwords and certificates as secrets, then use this field to differentiate. There are no predefined values.</p>
<h4 id="Key-Vault-Certificates"><a href="#Key-Vault-Certificates" class="headerlink" title="Key Vault Certificates"></a>Key Vault Certificates</h4><p>Key Vault certificates support provides for management of your x509 certificates and the following behaviors:</p>
<ul>
<li>Allows a certificate owner to create a certificate through a Key Vault creation process or through the import of an existing certificate. Includes both self-signed and Certificate Authority generated certificates.</li>
<li>Allows a Key Vault certificate owner to implement secure storage and management of X509 certificates without interaction with private key material.</li>
<li>Allows a certificate owner to create a policy that directs Key Vault to manage the life-cycle of a certificate.</li>
<li>Allows certificate owners to provide contact information for notification about life-cycle events of expiration and renewal of certificate.</li>
<li>Supports automatic renewal with selected issuers - Key Vault partner X509 certificate providers / certificate authorities.</li>
</ul>
<p>本文章只是对于Azure Key Vault的基本概念的及其之间关系的简介，对于更加详细的信息，比如Key Vault具体是如何监控，节流，身份验证，请求参数之类的详细信息可以去查看文末的官方文档。</p>
<p>参考文章：</p>
<p> <a href="https://docs.microsoft.com/en-us/azure/key-vault/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/key-vault/</a> </p>
<p> <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-whatis" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-whatis</a> </p>
<p> <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-subscriptions-associated-directory" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-subscriptions-associated-directory</a> </p>
<p> <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-manage-groups" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-manage-groups</a> </p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>HSTS</title>
    <url>/2020/06/18/HSTS/</url>
    <content><![CDATA[<h3 id="缘起：启用HTTPS也不够安全"><a href="#缘起：启用HTTPS也不够安全" class="headerlink" title="缘起：启用HTTPS也不够安全"></a>缘起：启用HTTPS也不够安全</h3><p>有不少网站只通过HTTPS对外提供服务，但用户在访问某个网站的时候，在浏览器里却往往直接输入网站域名（例如<a href="https://link.zhihu.com/?target=http%3A//www.example.com" rel="external nofollow noopener noreferrer" target="_blank">Example Domain</a>），而不是完整的URL（例如<a href="https://link.zhihu.com/?target=https%3A//www.example.com" rel="external nofollow noopener noreferrer" target="_blank">Example Domain</a>），不过浏览器依然能正确的使用HTTPS发起请求。这背后多亏了服务器和浏览器的协作，如下图所示。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034077/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200744_st7ygu.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034077/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200744_st7ygu.png"></p>
<p>图1：服务器和浏览器在背后帮用户做了很多工作</p>
<p>简单来讲就是，浏览器向网站发起一次HTTP请求，在得到一个重定向响应后，发起一次HTTPS请求并得到最终的响应内容。所有的这一切对用户而言是完全透明的，所以在用户看来，在浏览器里直接输入域名却依然可以用HTTPS协议和网站进行安全的通信，是个不错的用户体验。</p>
<p>一切看上去都是那么的完美，但其实不然，由于在建立起HTTPS连接之前存在一次明文的HTTP请求和重定向（上图中的第1、2步），使得攻击者可以以中间人的方式劫持这次请求，从而进行后续的攻击，例如窃听数据、篡改请求和响应、跳转到钓鱼网站等。</p>
<a id="more"></a>

<p>以劫持请求并跳转到钓鱼网站为例，其大致做法如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034304/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201136_l7n9kr.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034304/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201136_l7n9kr.png"></p>
<p>图2：劫持HTTP请求，阻止HTTPS连接，并进行钓鱼攻击</p>
<ul>
<li>第1步：浏览器发起一次明文HTTP请求，但实际上会被攻击者拦截下来</li>
<li>第2步：攻击者作为代理，把当前请求转发给钓鱼网站</li>
<li>第3步：钓鱼网站返回假冒的网页内容</li>
<li>第4步：攻击者把假冒的网页内容返回给浏览器</li>
</ul>
<p>这个攻击的精妙之处在于，攻击者直接劫持了HTTP请求，并返回了内容给浏览器，根本不给浏览器同真实网站建立HTTPS连接的机会，因此浏览器会误以为真实网站通过HTTP对外提供服务，自然也就不会向用户报告当前的连接不安全。于是乎攻击者几乎可以神不知鬼不觉的对请求和响应动手脚。</p>
<h3 id="解决之道：使用HSTS"><a href="#解决之道：使用HSTS" class="headerlink" title="解决之道：使用HSTS"></a>解决之道：使用HSTS</h3><p>既然建立HTTPS连接之前的这一次HTTP明文请求和重定向有可能被攻击者劫持，那么解决这一问题的思路自然就变成了如何避免出现这样的HTTP请求。我们期望的浏览器行为是，当用户让浏览器发起HTTP请求的时候，浏览器将其转换为HTTPS请求，直接略过上述的HTTP请求和重定向，从而使得中间人攻击失效，以规避风险。其大致流程如下：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034428/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201341_n2jssi.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034428/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201341_n2jssi.png"></p>
<p>图3：略过HTTP请求和重定向，直接发送HTTPS请求</p>
<ul>
<li>第1步：用户在浏览器地址栏里输入网站域名，浏览器得知该域名应该使用HTTPS进行通信</li>
<li>第2步：浏览器直接向网站发起HTTPS请求</li>
<li>第3步：网站返回相应的内容</li>
</ul>
<p>那么问题来了，浏览器是如何做到这一点的呢？它怎么知道哪个网站应该发HTTPS请求，哪个网站应该用HTTP请求呢？此时就该HSTS闪亮登场了。</p>
<h4 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h4><p>HSTS的全称是HTTP Strict-Transport-Security，它是一个Web安全策略机制（web security policy mechanism）。</p>
<p>HSTS最早于2015年被纳入到ThoughtWorks技术雷达，并且在2016年的最新一期技术雷达里，它直接从“评估（Trial）”阶段进入到了“采用（Adopt）“阶段，这意味着ThoughtWorks强烈主张业界积极采用这项安全防御措施，并且ThoughtWorks已经将其应用于自己的项目。</p>
<p>HSTS最为核心的是一个HTTP响应头（HTTP Response Header）。正是它可以让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。</p>
<p>HSTS Header的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。</li>
<li>includeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。</li>
<li>preload是可选参数，只有当你申请将自己的域名加入到浏览器内置列表的时候才需要使用到它。关于浏览器内置列表，下文有详细介绍。</li>
</ul>
<h4 id="让浏览器直接发起HTTPS请求"><a href="#让浏览器直接发起HTTPS请求" class="headerlink" title="让浏览器直接发起HTTPS请求"></a>让浏览器直接发起HTTPS请求</h4><p>只要在服务器返回给浏览器的响应头中，增加Strict-Transport-Security这个HTTP Header（下文简称HSTS Header），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=31536000; includeSubDomains</span><br></pre></td></tr></table></figure>

<p>就可以告诉浏览器，在接下来的31536000秒（1年）内，对于当前域名及其子域名的后续通信应该强制性的只使用HTTPS，直到超过有效期为止。</p>
<p>完整的流程如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034571/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201603_mijchx.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608034571/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215201603_mijchx.png"></p>
<p>图4：完整的HSTS流程</p>
<p>只要是在有效期内，浏览器都将直接强制性的发起HTTPS请求，但是问题又来了，有效期过了怎么办？其实不用为此过多担心，因为HSTS Header存在于每个响应中，随着用户和网站的交互，这个有效时间时刻都在刷新，再加上有效期通常都被设置成了1年，所以只要用户的前后两次请求之间的时间间隔没有超过1年，则基本上不会出现安全风险。更何况，就算超过了有效期，只要用户和网站再进行一次新的交互，用户的浏览器又将开启有效期为1年的HSTS保护。</p>
<h4 id="强制拒绝不安全的链接，不给用户选择的机会"><a href="#强制拒绝不安全的链接，不给用户选择的机会" class="headerlink" title="强制拒绝不安全的链接，不给用户选择的机会"></a>强制拒绝不安全的链接，不给用户选择的机会</h4><p>在没有HSTS保护的情况下，当浏览器发现当前网站的证书出现错误，或者浏览器和服务器之间的通信不安全，无法建立HTTPS连接的时候，浏览器通常会警告用户，但是却又允许用户继续不安全的访问。如下图所示，用户可以点击图中红色方框中的链接，继续在不安全的连接下进行访问。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b69590c9522f75bbd8ef0c73382e0a57_720w.jpg" alt="img"></p>
<p>图5：浏览器依然允许用户进行不安全的访问</p>
<p>理论上而言，用户看到这个警告之后就应该提高警惕，意识到自己和网站之间的通信不安全，可能被劫持也可能被窃听，如果访问的恰好是银行、金融类网站的话后果更是不堪设想，理应终止后续操作。然而现实很残酷，就我的实际观察来看，有不少用户在遇到这样的警告之后依然选择了继续访问。</p>
<p>不过随着HSTS的出现，事情有了转机。对于启用了浏览器HSTS保护的网站，如果浏览器发现当前连接不安全，它将仅仅警告用户，而不再给用户提供是否继续访问的选择，从而避免后续安全问题的发生。例如，当访问Google搜索引擎的时候，如果当前通信连接存在安全问题，浏览器将会彻底阻止用户继续访问Google，如下图所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b9df0eb3dcc8da972eec57f0051c2f3b_720w.jpg" alt="img"></p>
<p>图6：浏览器彻底阻止用户继续进行不安全的访问</p>
<h3 id="道高一尺魔高一丈：攻击者依然有可乘之机"><a href="#道高一尺魔高一丈：攻击者依然有可乘之机" class="headerlink" title="道高一尺魔高一丈：攻击者依然有可乘之机"></a>道高一尺魔高一丈：攻击者依然有可乘之机</h3><p>细心的你可能发现了，HSTS存在一个比较薄弱的环节，那就是浏览器没有当前网站的HSTS信息的时候，或者第一次访问网站的时候，依然需要一次明文的HTTP请求和重定向才能切换到HTTPS，以及刷新HSTS信息。而就是这么一瞬间却给攻击者留下了可乘之机，使得他们可以把这一次的HTTP请求劫持下来，继续中间人攻击。</p>
<h4 id="Preload-List：让防御更加彻底"><a href="#Preload-List：让防御更加彻底" class="headerlink" title="Preload List：让防御更加彻底"></a>Preload List：让防御更加彻底</h4><p>针对上面的攻击，HSTS也有应对办法，那就是在浏览器里内置一个列表，只要是在这个列表里的域名，无论何时、何种情况，浏览器都只使用HTTPS发起连接。这个列表由Google Chromium维护，FireFox、Safari、IE等主流浏览器均在使用。</p>
<h3 id="一些Tips"><a href="#一些Tips" class="headerlink" title="一些Tips"></a>一些Tips</h3><p><strong>Tip 1：如何配置HSTS</strong></p>
<p>很多地方都可以进行HSTS的配置，例如反向代理服务器、应用服务器、应用程序框架，以及应用程序中自定义Header。你可以根据实际情况进行选择。<br>常见的是在代理服务器中进行配置，以Nginx为例，只需在配置文件中加上下面这条指令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;</span><br></pre></td></tr></table></figure>

<p>不过需要特别注意的是，在生产环境下使用HSTS应当特别谨慎，因为一旦浏览器接收到HSTS Header（假如有效期是1年），但是网站的证书又恰好出了问题，那么用户将在接下来的1年时间内都无法访问到你的网站，直到证书错误被修复，或者用户主动清除浏览器缓存。</p>
<p>因此，建议在生产环境开启HSTS的时候，先将max-age的值设置小一些，例如5分钟，然后检查HSTS是否能正常工作，网站能否正常访问，之后再逐步将时间延长，例如1周、1个月，并在这个时间范围内继续检查HSTS是否正常工作，最后才改到1年。</p>
<p><strong>Tip 2：如何加入到HSTS Preload List</strong></p>
<p>根据官方说明，你的网站在具备以下几个条件后，可以提出申请加入到这个列表里。</p>
<ul>
<li>具备一个有效的证书</li>
<li>在同一台主机上提供重定向响应，以及接收重定向过来的HTTPS请求</li>
<li>所有子域名均使用HTTPS</li>
<li>在根域名的HTTP响应头中，加入HSTS Header，并满足下列条件：<ul>
<li>过期时间最短不得少于18周（10886400秒）</li>
<li>必须包含includeSubDomains参数</li>
<li>必须包含preload参数<br>当你准好这些之后，可以在HSTS Preload List的官网上（<a href="https://link.zhihu.com/?target=https%3A//hstspreload.org" rel="external nofollow noopener noreferrer" target="_blank">https://hstspreload.org</a>）提交申请，或者了解更多详细的内容。</li>
</ul>
</li>
</ul>
<p><strong>Tip 3：如何查询域名是否加入到了Preload List</strong></p>
<p>从提交申请到完成审核，成功加入到内置列表，中间可能需要等待几天到几周不等的时间。可通过官网<a href="https://link.zhihu.com/?target=https%3A//hstspreload.org" rel="external nofollow noopener noreferrer" target="_blank">https://hstspreload.org</a>或在Chrome地址栏里输入chrome://net-internals/#hsts查询状态。</p>
<h3 id="HSTS-存在的坑"><a href="#HSTS-存在的坑" class="headerlink" title="HSTS 存在的坑"></a>HSTS 存在的坑</h3><ul>
<li>纯 IP 的请求，HSTS 没法处理，比如 <code>http://2.2.2.2</code> ， 即便响应头中设置了 STS，浏览器也不会理会（未测试）</li>
<li>HSTS 只能在 80 和 443 端口之间切换，如果服务是 8080 端口，即便设置了 STS，也无效（未测试）</li>
<li>如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了</li>
<li>如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。</li>
<li>HSTS 能让你的网站在 ssllab 上到 A+（这不是坑）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随着越来越多的网站开始使用HTTPS，甚至是开启全站HTTPS，数据在传输过程中的安全性能够得到极大的保障。与此同时，通过HSTS的帮助，避免遭受到SSL Stripping或者中间人的攻击，能够使得数据通信变得更加安全。本篇文章希望通过对HSTS的解析，使得更多的开发团队将HSTS运用到自己的项目中。</p>
<p>转载文章出处：</p>
<p><a href="https://zhuanlan.zhihu.com/p/63674248" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/63674248</a></p>
<p><a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" rel="external nofollow noopener noreferrer" target="_blank">https://www.barretlee.com/blog/2015/10/22/hsts-intro/</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>InfineScroll 无限加载bug</title>
    <url>/2019/11/01/InfineScroll/</url>
    <content><![CDATA[<p>最近使用了一下elementUI最新版本中的无限加载组件，在使用过程中有的情况下可能会发生加载函数无限调用的情况，于是去研究了一下源码。</p>
<a id="more"></a>

<p>阅读源码之前，首先要对两个函数了解一下，分别是MutationObserver和throttle函数</p>
<h3 id="MutationObserver函数"><a href="#MutationObserver函数" class="headerlink" title="MutationObserver函数"></a>MutationObserver函数</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p>监视 DOM 变动的接口</p>
<p>当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。</p>
</li>
<li><p>类似于事件，但是异步触发</p>
<p>添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver 是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。</p>
</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br></pre></td></tr></table></figure>

<p> callback，即回调函数接收两个参数，第一个参数是一个包含了所有 <code>MutationRecord</code> 对象的数组，第二个参数则是这个MutationObserver 实例本身。 </p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="Observe"><a href="#Observe" class="headerlink" title="Observe"></a>Observe</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Observe(Node target, optional MutationObserverInit options);</span><br></pre></td></tr></table></figure>

<p>给 MutationObserver 实例添加要观察的 DOM 节点，并可通过一个可选的 options 参数来配置观察哪些变动，该 options 为一个名为 <code>MutationObserverInit</code> 的对象。</p>
<p>以下是 <code>MutationObserverInit</code> 对象的各属性及其描述：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>childList</td>
<td>Boolean</td>
<td>是否观察子节点的变动</td>
</tr>
<tr>
<td>attributes</td>
<td>Boolean</td>
<td>是否观察属性的变动</td>
</tr>
<tr>
<td>characterData</td>
<td>Boolean</td>
<td>是否节点内容或节点文本的变动</td>
</tr>
<tr>
<td>subtree</td>
<td>Boolean</td>
<td>是否观察所有后代节点的变动</td>
</tr>
<tr>
<td>attributeOldValue</td>
<td>Boolean</td>
<td>观察 attributes 变动时，是否记录变动前的属性值</td>
</tr>
<tr>
<td>characterDataOldValue</td>
<td>Boolean</td>
<td>观察 characterData 变动时，是否记录变动前的属性值</td>
</tr>
<tr>
<td>attributeFilter</td>
<td>Array</td>
<td>表示需要观察的特定属性（比如[‘class’,’src’]），不在此数组中的属性变化时将被忽略</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li>不能单独观察 subtree 变动，必须同时指定 childList、attributes 和 characterData 中的一种或多种。</li>
<li>为同一个 DOM 节点多次添加同一个 MutationObserver 是无效的，回调函数将只被触发一次。但如果指定不同的 options 对象（即观察不同的变动），即被视为不同的 MutationObserver。</li>
</ul>
<h5 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h5><p>该方法用来停止观察。后续如果 DOM 节点发生变动将不再触发回调函数。</p>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<p>其他更多的介绍可以参考文章最后的链接</p>
<h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p> debounce 与 <code>throttle</code> 是开发中常用的高阶函数，作用都是为了防止函数被高频调用，换句话说就是，用来控制某个函数在一定时间内执行多少次。</p>
<p><strong>使用场景</strong>：比如绑定响应鼠标移动、窗口大小调整、滚屏等事件时，绑定的函数触发的频率会很频繁。若稍处理函数微复杂，需要较多的运算执行时间和资源，往往会出现延迟，甚至导致假死或者卡顿感。为了优化性能，这时就很有必要使用<code>debounce</code>或<code>throttle</code>了。 </p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.throttle(func, [wait=0], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<p>节流函数，在 wait 秒内最多执行 fn 一次的函数。<br>与不同的是，会有一个阀值，当到达阀值时，fn一定会执行。</p>
<h3 id="InfineScroll源码解析"><a href="#InfineScroll源码解析" class="headerlink" title="InfineScroll源码解析"></a>InfineScroll源码解析</h3><h4 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> attributes = &#123;</span><br><span class="line">  delay: &#123;  <span class="comment">// 延迟时间，用于throttle函数的阈值</span></span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  distance: &#123;  <span class="comment">// 每次滚动后如果距离大于这个值才触发加载函数</span></span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  disabled: &#123;  <span class="comment">//是否不允许加载新的数据</span></span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  immediate: &#123;  <span class="comment">//是否在页面初始化就立即调用一次数据加载</span></span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="获取配置函数"><a href="#获取配置函数" class="headerlink" title="获取配置函数"></a>获取配置函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getScrollOptions = <span class="function">(<span class="params">el, vm</span>) =&gt;</span> &#123;   <span class="comment">// 获取组件传入的配置，如果没有传入取配置的默认值</span></span><br><span class="line">  <span class="keyword">if</span> (!isHtmlElement(el)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entries(attributes).reduce(<span class="function">(<span class="params">map, [key, option]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, <span class="attr">default</span>: defaultValue &#125; = option;</span><br><span class="line">    <span class="keyword">let</span> value = el.getAttribute(<span class="string">`infinite-scroll-<span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">    value = isUndefined(vm[value]) ? value : vm[value];</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">Number</span>:</span><br><span class="line">        value = <span class="built_in">Number</span>(value);</span><br><span class="line">        value = <span class="built_in">Number</span>.isNaN(value) ? defaultValue : value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">Boolean</span>:</span><br><span class="line">        value = isDefined(value) ? value === <span class="string">'false'</span> ? <span class="literal">false</span> : <span class="built_in">Boolean</span>(value) : defaultValue;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        value = type(value);</span><br><span class="line">    &#125;</span><br><span class="line">    map[key] = value;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'InfiniteScroll'</span>,</span><br><span class="line">  inserted(el, binding, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = binding.value;  <span class="comment">// 组件传入的加载数据的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vm = vnode.context;</span><br><span class="line">    <span class="comment">// only include vertical scroll</span></span><br><span class="line">    <span class="keyword">const</span> container = getScrollContainer(el, <span class="literal">true</span>);  <span class="comment">// 获取滚动条的容器</span></span><br><span class="line">    <span class="keyword">const</span> &#123; delay, immediate &#125; = getScrollOptions(el, vm);  <span class="comment">//获取组建的配置，接下来有解释</span></span><br><span class="line">    <span class="keyword">const</span> onScroll = throttle(delay, handleScroll.bind(el, cb));  <span class="comment">// 发生滚动时的回调函数，利用的是throttle，throttle第一个参数是一个阈值，第二个参数是函数，它能够控制在阈值时间内最多执行一次第二个参数传入的函数</span></span><br><span class="line"></span><br><span class="line">    el[scope] = &#123; el, vm, container, onScroll &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (container) &#123;</span><br><span class="line">      container.addEventListener(<span class="string">'scroll'</span>, onScroll);  <span class="comment">// 添加滚动的监听事件</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;  </span><br><span class="line">          <span class="comment">// 是否立即触发数据加载，它能够保证数据纵向填满容器，具体是因为MutationObserver监听了container的dom变化，一旦变化立即触发数据加载，而数据加载又会改变dom，导致循环调用数据加载函数，直到某一次调用滚动条到底，就会调用MutationObserver.disconnect(),停止监听dom变化</span></span><br><span class="line">        <span class="keyword">const</span> observer = el[scope].observer = <span class="keyword">new</span> MutationObserver(onScroll);</span><br><span class="line">        observer.observe(container, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">        onScroll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  unbind(el) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; container, onScroll &#125; = el[scope];</span><br><span class="line">    <span class="keyword">if</span> (container) &#123;</span><br><span class="line">      container.removeEventListener(<span class="string">'scroll'</span>, onScroll);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="监听到滚动事件时的回调函数"><a href="#监听到滚动事件时的回调函数" class="headerlink" title="监听到滚动事件时的回调函数"></a>监听到滚动事件时的回调函数</h4><p>这个函数不仅在出发滚动时会调用，如果设置了immidate为true，组件会在加载之初显式调用用于加载数据直到填满容器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scope = <span class="string">'ElInfiniteScroll'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getElementTop = <span class="function"><span class="params">el</span> =&gt;</span> el.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleScroll = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;  <span class="comment">//数据加载函数，会先判断滚动条是否到底并且disabled参数是否允许加载</span></span><br><span class="line">  <span class="keyword">const</span> &#123; el, vm, container, observer &#125; = <span class="keyword">this</span>[scope];</span><br><span class="line">  <span class="keyword">const</span> &#123; distance, disabled &#125; = getScrollOptions(el, vm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disabled) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shouldTrigger = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否滚动到底部</span></span><br><span class="line">  <span class="keyword">if</span> (container === el) &#123;</span><br><span class="line">    <span class="comment">// be aware of difference between clientHeight &amp; offsetHeight &amp; window.getComputedStyle().height</span></span><br><span class="line">    <span class="keyword">const</span> scrollBottom = container.scrollTop + getClientHeight(container);</span><br><span class="line">    shouldTrigger = container.scrollHeight - scrollBottom &lt;= distance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> heightBelowTop = getOffsetHeight(el) + getElementTop(el) - getElementTop(container);</span><br><span class="line">    <span class="keyword">const</span> offsetHeight = getOffsetHeight(container);</span><br><span class="line">    <span class="keyword">const</span> borderBottom = <span class="built_in">Number</span>.parseFloat(getStyleComputedProperty(container, <span class="string">'borderBottomWidth'</span>));</span><br><span class="line">    shouldTrigger = heightBelowTop - offsetHeight + borderBottom &lt;= distance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrigger &amp;&amp; isFunction(cb)) &#123;</span><br><span class="line">    cb.call(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">    <span class="comment">// 当调用某次数据加载函数但是滚动条还没有到底，并且用MutationObserver监听了组件的dom变化时，把该监听关闭，只会出现在 immediate 为 true ，组件注册时注册了MutationObserver导致循环调用数据加载函数时有效</span></span><br><span class="line">    observer.disconnect();</span><br><span class="line">    <span class="keyword">this</span>[scope].observer = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>所以说当container初始没有height，并且设置了immediate时，会显式触发一次滚动回调函数，同时为容器添加MutationObserver，而这样一来就会使得容器初始化的时候数据就加载到充满容器。但是因为scrollTop一直为0，导致没办法判断到滚动条到底，所以数据加载函数中关于disconnect MutationObserver 的逻辑不会被调用到，就会陷入调用数据加载，容器改变，再调用，再改变的循环之中。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>直接就将immidate设置为false，就不会注册MutationObserve</li>
<li>对容器赋予一个高度。</li>
</ol>
<p>参考文章：</p>
<p> <a href="https://juejin.im/entry/5a9d4eea518825556b6c440d" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/5a9d4eea518825556b6c440d</a> </p>
<p> <a href="https://juejin.im/entry/57de3fc30bd1d00057f2ea33" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/57de3fc30bd1d00057f2ea33</a> </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>OAuth and OIDC</title>
    <url>/2019/11/16/OAuth%20and%20OIDC/</url>
    <content><![CDATA[<h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>OAuth 是一个关于授权（Authorization）的开放网络标准，在全世界得到了广泛的应用，目前的版本是2.0</p>
<a id="more"></a>


<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client）。</p>
</li>
<li><p><strong>HTTP Service</strong>：HTTP服务提供商，本文中简称”服务提供商”。</p>
</li>
<li><p><strong>Resource Owner</strong>：资源所S有者，本文中又称”用户”（user）。</p>
</li>
<li><p><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
</li>
<li><p><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
</li>
<li><p><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</li>
</ul>
<p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><ol>
<li><p>用户打开客户端以后，客户端要求用户给予授权。</p>
</li>
<li><p>用户同意给予客户端授权。</p>
</li>
<li><p>客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
</li>
<li><p>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
</li>
<li><p>客户端使用令牌，向资源服务器申请获取资源。</p>
</li>
<li><p>资源服务器确认令牌无误，同意向客户端开放资源。</p>
</li>
</ol>
<p>这几步中的关键就是客户端如何获取授权，OAuth2.0定义了四种不同的获取授权的方式。</p>
<h3 id="获取授权的四种方式"><a href="#获取授权的四种方式" class="headerlink" title="获取授权的四种方式"></a>获取授权的四种方式</h3><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
<p>A步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>C步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p> 简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 </p>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
<h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><p> 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 </p>
<h3 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h3><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<h2 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h2><p>OpenID Connect是基于OAuth 2.0规范族的可互操作的身份验证协议。它使用简单的REST / JSON消息流来实现，和之前任何一种身份认证协议相比，开发者可以轻松集成。</p>
<p>OpenID Connect允许开发者验证跨网站和应用的用户，而无需拥有和管理密码文件。OpenID Connect允许所有类型的客户,包括基于浏览器的<a href="https://link.jianshu.com?t=http://lib.csdn.net/base/javascript" rel="external nofollow noopener noreferrer" target="_blank">JavaScript</a>和本机移动应用程序,启动登录流动和接收可验证断言对登录用户的身份。</p>
<p> 简要而言，<em>OIDC</em>是一种安全机制，用于应用连接到身份认证服务器（Identity Service）获取用户信息，并将这些信息以安全可靠的方法返回给应用。 </p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p> <strong>OpenID</strong>是<em>Authentication</em>，即认证，对用户的身份进行认证，判断其身份是否有效，也就是让网站知道“你是你所声称的那个用户”； </p>
<p><strong>OAuth</strong>是<em>Authorization</em>，即授权，在已知用户身份合法的情况下，经用户授权来允许某些操作，也就是让网站知道“你能被允许做那些事情”。<br> 由此可知，授权要在认证之后进行，只有确定用户身份只有才能授权。</p>
<p><em>OpenID Connect</em>是“认证”和“授权”的结合，因为其基于<em>OAuth</em>协议，所以<em>OpenID-Connect</em>协议中也包含了<strong>client_id</strong>、<strong>client_secret</strong>还有<strong>redirect_uri</strong>等字段标识。这些信息被保存在“身份认证服务器”，以确保特定的客户端收到的信息只来自于合法的应用平台。这样做是目的是为了防止<em>client_id</em>泄露而造成的恶意网站发起的<em>OIDC</em>流程。</p>
<h3 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h3><p><em>OAuth2</em>提供了<em>Access Token</em>来解决授权第三方客户端访问受保护资源的问题；相似的，<em>OIDC</em>在这个基础上提供了<em>ID Token</em>来解决第三方客户端标识用户身份认证的问题。<em>OIDC</em>的核心在于在<em>OAuth2</em>的授权流程中，一并提供用户的身份认证信息（<em>ID-Token</em>）给到第三方客户端，<em>ID-Token</em>使用<strong>JWT</strong>格式来包装，得益于 <a href="https://sunra.top/2019/10/26/jwt/">JWT</a>的自包含性，紧凑性以及防篡改机制，使得<em>ID-Token</em>可以安全的传递给第三方客户端程序并且容易被验证。应有服务器，在验证<em>ID-Token</em>正确只有，使用<em>Access-Token</em>向<em>UserInfo</em>的接口换取用户的更多的信息。</p>
<p>有上述可知，<em>OIDC</em>是遵循<em>OAuth</em>协议流程，在申请<em>Access-Token</em>的同时，也返回了<em>ID-Token</em>来验证用户身份。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>EU</strong>：End User，用户。</p>
<p> <strong>RP</strong>：Relying Party ，用来代指<em>OAuth2</em>中的受信任的客户端，身份认证和授权信息的消费方；</p>
<p> <strong>OP</strong>：OpenID Provider，有能力提供EU身份认证的服务方（比如<em>OAuth2</em>中的授权服务），用来为RP提供EU的身份认证信息；</p>
<p> <strong>ID-Token</strong>：JWT格式的数据，包含EU身份认证的信息。</p>
<p> <strong>UserInfo Endpoint</strong>：用户信息接口（受<em>OAuth2</em>保护），当RP使用<em>Access-Token</em>访问时，返回授权用户的信息，此接口必须使用<em>HTTPS</em>。</p>
<h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>如果是JS应用，其所有的代码都会被加载到浏览器而暴露出来，没有后端可以保证<em>client_secret</em>的安全性，则需要是使用<strong>默认模式流程</strong>(Implicit Flow)。</p>
<p>如果是传统的客户端应用，后端代码和用户是隔离的，能保证<em>client_secret</em>的不被泄露，就可以使用<strong>授权码模式流程</strong>（Authentication Flow）。</p>
<p>此外还有<strong>混合模式流程</strong>(Hybrid Flow)，简而言之就是以上二者的融合。</p>
<h4 id="授权码流程"><a href="#授权码流程" class="headerlink" title="授权码流程"></a>授权码流程</h4><p>RP发送一个<strong>认证请求</strong>给OP，其中附带<em>client_id</em>；</p>
<p>OP对EU进行身份认证；</p>
<p>OP返回响应，发送授权码给RP；</p>
<p>RP使用授权码向OP索要ID-Token和Access-Token，RP验证无误后返回给RP；</p>
<p>RP使用Access-Token发送一个请求到<em>UserInfo EndPoint</em>； UserInfo EndPoint返回EU的Claims。</p>
<h5 id="认证请求"><a href="#认证请求" class="headerlink" title="认证请求"></a>认证请求</h5><p>RP使用OAuth2的Authorization-Code的方式来完成用户身份认证，所有的Token都是通过OP的Token EndPoint（<a href="https://link.jianshu.com?t=https://tools.ietf.org/html/rfc6749#section-3.2" rel="external nofollow noopener noreferrer" target="_blank">OAuth2中定义</a>）来发放的。构建一个OIDC的Authentication Request需要提供如下的参数：</p>
<ul>
<li>scope：必须。OIDC的请求必须包含值为“openid”的scope的参数。</li>
<li>response_type：必选。同OAuth2。</li>
<li>client_id：必选。同OAuth2。</li>
<li>redirect_uri：必选。同OAuth2。</li>
<li>state：推荐。同OAuth2。防止CSRF, XSRF。</li>
</ul>
<p>在OP接收到认证请求之后，需要对请求参数做严格的验证，具体的规则参见<a href="https://link.jianshu.com?t=http://openid.net/specs/openid-connect-core-1_0.html#AuthRequestValidation" rel="external nofollow noopener noreferrer" target="_blank">http://openid.net/specs/openid-connect-core-1_0.html#AuthRequestValidation</a>，验证通过后引导EU进行身份认证并且同意授权。在这一切都完成后，会重定向到RP指定的回调地址(<em>redirect_uri</em>)，并且把<strong>code</strong>和<strong>state</strong>参数传递过去。</p>
<p>RP使用上一步获得的<em>code</em>来请求Token EndPoint，这一步桶<em>OAuth2</em>，就不再展开细说了。然后Token EndPoint会返回响应的Token，其中除了<em>OAuth2</em>规定的部分数据外，还会附加一个<em>id_token</em>的字段。<em>id_token</em>字段就是上面提到的<em>ID Token</em>。</p>
<h6 id="ID-Token"><a href="#ID-Token" class="headerlink" title="ID-Token"></a>ID-Token</h6><p>上面提到过<em>OIDC</em>对<em>OAuth2</em>最主要的扩展就是提供了<em>ID-Token</em>。下面我们就来看看<em>ID-Token</em>的主要构成：</p>
<ul>
<li><strong>iss = Issuer Identifier</strong>：必须。提供认证信息者的唯一标识。一般是Url的host+path部分；</li>
<li><strong>sub = Subject Identifier</strong>：必须。iss提供的EU的唯一标识；最长为255个ASCII个字符；</li>
<li><strong>aud = Audience(s)</strong>：必须。标识<em>ID-Token</em>的受众。必须包含<em>OAuth2</em>的client_id；</li>
<li><strong>exp = Expiration time</strong>：必须。<em>ID-Token</em>的过期时间；</li>
<li><strong>iat = Issued At Time</strong>：必须。JWT的构建的时间。</li>
<li><strong>auth_time = AuthenticationTime</strong>：EU完成认证的时间。如果RP发送认证请求的时候携带<em>max_age</em>的参数，则此Claim是必须的。</li>
<li><strong>nonce</strong>：RP发送请求的时候提供的随机字符串，用来减缓重放攻击，也可以来关联<em>ID-Token</em>和RP本身的Session信息。</li>
<li><strong>acr = Authentication Context Class Reference</strong>：可选。表示一个认证上下文引用值，可以用来标识认证上下文类。</li>
<li><strong>amr = Authentication Methods References</strong>：可选。表示一组认证方法。</li>
<li><strong>azp = Authorized party</strong>：可选。结合aud使用。只有在被认证的一方和受众（aud）不一致时才使用此值，一般情况下很少使用。</li>
</ul>
<h4 id="默认流程"><a href="#默认流程" class="headerlink" title="默认流程"></a>默认流程</h4><p>默认流程和<em>OAuth</em>中的类似，只不过也是添加了<em>ID-Token</em>的相关内容。</p>
<p>这里需要说明的是：<em>OIDC</em>的说明文档里很明确的说明了用户的相关信息都要使用<strong>JWT</strong>形式编码。在<em>JWT</em>中，不应该在载荷里面加入任何敏感的数据。如果传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。</p>
<h3 id="UserInfo-Endpoint"><a href="#UserInfo-Endpoint" class="headerlink" title="UserInfo Endpoint"></a>UserInfo Endpoint</h3><p>可能有的读者发现了，<em>ID-Token</em>只有sub是和EU相关的，这在一般情况下是不够的，必须还需要EU的用户名，头像等其他的资料，<em>OIDC</em>提供了一组公共的cliams，来提供更多用户的信息，这就是——UserIndo EndPoin。</p>
<p>在RP得到Access Token后可以请求此资源，然后获得一组EU相关的Claims，这些信息可以说是<em>ID-Token</em>的扩展，<em>ID-Token</em>中只需包含EU的唯一标识sub即可（避免ID Token过于庞大和暴露用户敏感信息），然后在通过此接口获取完整的EU的信息。此资源<strong>必须部署在TLS之上</strong></p>
<h2 id="关于OAuth的一点思考"><a href="#关于OAuth的一点思考" class="headerlink" title="关于OAuth的一点思考"></a>关于OAuth的一点思考</h2><p>User：用户</p>
<p>User Agent：用户代理，如浏览器</p>
<p>Consumer：信息消费者，如Leetcode</p>
<p>Service Provider：分为两个，分别是身份认证提供者（Identity Provider， IDP）,如QQ，以及资源提供者（Resource Provider），不过这二者一般是相同的</p>
<p>OAuth并不是为了解决安全或者性能问题。</p>
<p>OAuth也并不会帮我们保存在Consumer的登录态。</p>
<p>OAuth出现的目的就是为了帮我们用一个第三方的账号关联多个应用的账号，它是user赋予consumer在SP的权限，而不是赋予user在consumer的权限。我们的账号一个没少，只不过建立起了一对多的关系，就类似于如果我们想去考驾照，就需要用身份证，授权驾校用我们的身份证信息去公安局证实我们这个人的存在并取回一些其他信息。但是也就到此为止，接下来的事情与OAuth并无关系。</p>
<p>单凭OAuth无法完成在consumer创建账户，IDP不可能也没有责任保存user在consumer的任何信息，它只是在user授权情况下告诉consumer一些信息而已。</p>
<p>为什么一开始就要发送个redirect_uri给IDP？第一次是为了IDP设置返回地302中的Location，可以不验证是不是consumer设置好的，第二次就是验证这个redirect_uri是不是你当初在IDP这里设置的，与第一次过来的是否一样，这一步必须要验证，因为这一步是最关键的，这一步才会返回token。</p>
<p>为什么要绕这么一大圈，为什么要多一步code换access_token？说到底还是信不过浏览器同志，让他当个工具人，让它帮自己地后台去第三方申请一个授权码，然后把这个授权码给自己的后台，再然后自己的后台用这个code去第三方申请token，完事还不告诉浏览器这个token是什么，自己留下了，也就是说浏览器同志从头到尾都没见过token。</p>
<p>Secret有什么用？原因是IDP不信任何人，就信自己给出去的secret。因为redirect_uri是域名，最终到哪里还是要靠IP地址，如果域名是对的，但是域名被攻击者指向了自己的IP，攻击者就会收到token。怎么修改这个DNS指向就涉及DNS污染了，因为DNS会层层缓存，但是又有时间，如果你一直广播告诉路由器或者主机我是leetcode，我是leetcode，时间长了你在这一片局域网中就被认为是leetcode了。但是如果有了secret，就算你带着code过来了IDP，没有我给你的secret，IDP也不会给出token。所以client_id表明自己是谁，只有给了client_secret，IDP才会相信你说的话，并给你token，所以这个secret非常重要，我们的后台又不会相信浏览器同志了，所以我们的浏览器同志从头到尾也没摸过secret。</p>
<p>State又有什么用呢？类似于防御CSRF，保证请求设备的一致性，不过不像CSRF是伪造受害者的请求，而是让受害者登录自己的账号，如果受害者在里面存个比特币账号岂不美哉？具体实现就是攻击者登录之后，正常申请，但是到了IDP返回302以后把请求拦下，不让浏览器发送请求给自己的后台，然后把这个带code的请求链接给受害人，受害人点进去之后就可以拿到access_token成功登录，如果不注意这个账号是不是自己的就上传敏感信息，就很happy。如果有了state，不同的设备我后台都生成一个随机的字符串给前端，攻击者就算把请求发给受害者，他也不知道受害者设备中的state，后台一看你的state和刚开始说好的不一样，就会直接把这个请求丢掉，当然硬要说攻击者把你的state从庞大的互联网的某个请求中给偷到了，那也是绝了，这就属于定点爆破了，就是要搞你，那这个人多半已经混在你的身边了。</p>
<p>为什么最后会返回两个token？因为一个代表你是谁，一个代表你能做什么，你能做的事情随时可以被管理员改变，但是你是谁是固定的，而且一般access_token过期时间都比较短，如果我用着用着就过期了，总不能让用户重新登陆吧，那岂不是回到了起点？</p>
<p>说了半天，这些设计都停留在传输层以上，那我要是搞你的网络层呢？我再散布个ARP病毒呢？搞链路层就有点夸张了。</p>
<p>参考文章：</p>
<p>[<a href="https://sunra.top/2019/11/16/OAuth%20and%20OIDC/]">https://sunra.top/2019/11/16/OAuth%20and%20OIDC/]</a>(<a href="https://sunra.top/2019/11/16/OAuth">https://sunra.top/2019/11/16/OAuth</a> and OIDC/) ：OAuth，OIDC简介</p>
<p><a href="https://sunra.top/2020/03/27/routing-protocol/">https://sunra.top/2020/03/27/routing-protocol/</a>  ：路由协议</p>
<p><a href="https://sunra.top/2019/09/15/ARP/">https://sunra.top/2019/09/15/ARP/</a> ：ARP原理与防御</p>
<p><a href="https://www.jianshu.com/p/0db71eb445c8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0db71eb445c8</a> ：OAuth认证流程举例</p>
<p><a href="https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html</a> ：OAuth2.0中的安全考虑</p>
<p><a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/linianhui/p/openid-connect-core.html</a> ：OIDC文档</p>
<p><a href="https://www.zhihu.com/question/19851243" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/19851243</a> ：OAuth1.0与2.0区别</p>
<p><a href="https://docs.azure.cn/zh-cn/active-directory/azuread-dev/v1-protocols-openid-connect-code" rel="external nofollow noopener noreferrer" target="_blank">https://docs.azure.cn/zh-cn/active-directory/azuread-dev/v1-protocols-openid-connect-code</a> ：OIDC + AAD</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S2215098617316750" rel="external nofollow noopener noreferrer" target="_blank">https://www.sciencedirect.com/science/article/pii/S2215098617316750</a> ：云服务中面临的安全问题</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a> ：同源策略</p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>TCP协议简介</title>
    <url>/2020/04/18/TCP/</url>
    <content><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>TCP是<strong>面向连接</strong>的运输层协议。也就是说，应用程序在使用TCP连接之前，必须建立TCP连接。数据传输完毕之后，必须释放TCP连接。</li>
<li>每一条TCP连接只能有两个端点，每个TCP连接都是<strong>点对点</strong>的。</li>
<li>TCP提供<strong>可靠交付服务</strong>，也就是说数据是无差错，不丢失，不重复，按照顺序到达。</li>
<li>TCP提供<strong>全双工通信</strong>，允许通信双方在任何时候都能够发送数据，<strong>TCP双方都设有发送缓存和接收缓存</strong>，用来临时存放双方通信的数据。</li>
<li><strong>面向字节流</strong>。TCP中的<strong>“流”</strong>指的是<strong>流入到进程或从进程流出的字节序列</strong>。面向字节流的含义是：虽然应用程序和TCP交互是一次一个数据块，但是TCP把应用程序交下来的数据仅仅看成是一连串<strong>无结构的字节流</strong>。TCP并不知道所传送的字节流的含义，也不保证接收方收到的数据块大小与发送方的数据块大小有什么对应关系，有可能发送发10个数据块的数据在接收方被整理成4个数据块交付给上层。</li>
</ul>
<a id="more"></a>

<p>TCP与udp在发送报文的时候采用的方式完全不同，TCP并不关心应用进程一次把多长的报文发送到TCP连接的缓存中，而是根据对方给出的窗口值和当前网络的拥塞状况决定来决定每一个报文应该包含多少字节（UDP的报文长度是应用进程给出的，应用进程给出的报文，UDP只是简单的加上头部就交给下一层）。</p>
<p>目前我的理解是：<strong>上层分多个大小不同的数据块将字节流存入缓存中后，TCP会根据窗口值和拥塞状况等重新切割字节流去发送报文，只要保证最终所有字节按顺序到达即可</strong>。</p>
<h2 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h2><p>TCP把连接作为最基本的抽象，TCP的许多特性都是建立在面向连接这个基础之上的，所以我们要搞清楚TCP连接到底是什么。</p>
<p>每个TCP连接都有两个端点，也叫作套接字或者插口，套接字其实就是将端口号拼接到IP地址后面组成的。TCP连接的端点是个很抽象的套接字，同一个IP地址可以有多个不同的TCP连接，而同一个端口号可以出现在多个不同的TCP连接中。TCP连接其实就是有协议软件提供的一种基于套接字的抽象。</p>
<p>置于为什么说TCP是面向连接的，目前我的理解是：<strong>TCP连接需要占用连接双方的端口，在占用期间，这个端口传送的数据只属于这条TCP连接，所以对于双方来说像是一条链路，但是并不是说TCP连接之间的所有路由器都要为这条连接做什么特殊的处理。</strong></p>
<p><strong>当你在阅读下面内容的时候如果产生了：凭什么TCP这样设计就可以实现这种效果的时候，想一下它面向连接这个特性</strong>。</p>
<h2 id="可靠传输的原理"><a href="#可靠传输的原理" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h2><p>TCP协议下面的网络提供的是不可靠的传输，因此TCP必须采取一些措施去对一些意外情况进行补救，使得运输层之间的传输变得可靠。</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>停止等待协议非常简单，</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200418085415_bobkzr.jpg" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587171346/computer_network/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200418085415_bobkzr.jpg"></p>
<ul>
<li><p><strong>无差错情况</strong>。A发送完分组M1之后就暂停发送，等待B的确认。B收到了M1就向A发送确认，A在收到对M1的确认之后再继续发送下一个分组M2。</p>
</li>
<li><p><strong>出现差错</strong>。B收到M1时检测出了差错，就直接将M1<strong>丢弃，然后什么都不做</strong>。A只要一段时间内没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就必须在每发送完成一个分组，就设置一个<strong>超时计时器</strong>，如果在计时结束之前收到了确认，就撤销计时器。这里要注意三点：</p>
<ul>
<li>A在发送完成一个分组后，必须<strong>暂存已发送的分组的副本</strong>，直到收到确认才可以将其删除。</li>
<li>分组和确认分组都必须设置编号，这样才能知道是哪一个分组收到了确认，哪一个没有。</li>
<li>超时计时器设置的<strong>重传时间，应当比数据在分组传输时的平均往返时间稍微长一点</strong>。</li>
</ul>
</li>
<li><p><strong>确认丢失和迟到</strong>。如果B发送的对M1的确认丢失了，A在设定的超时时间内没有收到确认，无法知道是自己发送的分组出现错误，丢失，或者是B发送的确认丢失，因此在超时计时器到期后A就要重传M1，假定B又一次收到了M1，则采取两个行动：</p>
<ul>
<li>丢弃这个重复的分组M1，不向上层交付。</li>
<li>再次向A发送交付确认，不能认为已经发送过的确认就不再发送。</li>
</ul>
</li>
<li><p>信道利用率。停止等待协议的优点是简单，缺点是信道利用率太低</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587195669/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418154042_tktoqj.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587195669/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418154042_tktoqj.png"></p>
<p>假定A发送分组需要的时间是TD，显然TD等于分组长度除以数据率。再假定分组正确到达B后，处理时间可以忽略不计，同时立即发送确认。假定B发送确认分组需要时间TA。如果A处理确认分组的时间也可以忽略不计，那么A在经过时间（TD + RTT + TA）后才可以发送下一个分组。因为仅在TD内才用来传送有用的数据，因此信道利用率U可以表示为<br>$$<br>U = \frac{T_D}{T_D + RTT + T_A}<br>$$<br>为了提高传输效率，发送方可以 不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。</p>
<p>当使用流水线传输时，就要使用连续<strong>ARQ协议</strong>和<strong>滑动窗口协议</strong>。</p>
</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587196595/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418155614_iod7dv.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587196595/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418155614_iod7dv.png"></p>
<p>上图表示发送方维持的发送窗口，它的意义是：位于发送窗口的5个分组都可以连续发送出去，而不需要等待对方的确认。</p>
<p>在讨论滑动窗口时，我们应当注意到，图中还有一个时间坐标。按照习惯，向前是指向着时间增大的方向，而向后指的是向着时间减少的方向。分组发送是按照分组序号从小到大发送的。</p>
<p>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p>接收方一般采取<strong>累计确认</strong>方法，也就是说接收方不必对收到的分组逐个发送确认，而是在收到几个分组，<strong>对按序到达的最后一个分组发送确认</strong>。</p>
<h2 id="TCP报文段首部"><a href="#TCP报文段首部" class="headerlink" title="TCP报文段首部"></a>TCP报文段首部</h2><p>TCP虽然是面向字节流的，但是TCP传输的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部的各字段的作用。因此只有掌握TCP首部各个字段的作用，才能够掌握TCP的工作原理。</p>
<p>TCP首部的前面20个字节是固定的，后面4n个字节是根据需要增加的选项。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587197557/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418161217_djnuqg.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587197557/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418161217_djnuqg.png"></p>
<h3 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h3><p>各占两个字节，分别写入远端口号和目的端口号。</p>
<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>占四个字节，序号范围是[0, 2^32 - 1]，序号增大到最大后，就是用取模运算。</p>
<p>在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段指的是本报文段发送的数据的第一个字节序号。</p>
<h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>占四个字节，是<strong>期望收到对方的下一个报文段第一个数据字节的序号</strong>。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节，这表明B正确收到了A发送的到序号700的为止的数据。因此B期望A下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701 。总之，<strong>如果确认号等于N，则表明到序号N-1为止的所有数据都已经正确收到</strong>。</p>
<p>一般情况下，可保证当序号重复使用时，旧序号的数据早已通过网络到达终点。</p>
<h3 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h3><p>占4位，它指出的是TCP报文段首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移是必要的。这个字段单位是<strong>32位（4字节）</strong>。由于4位二进制数能够表达的最大数为15，因此数据偏移最大值是60字节。</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>占6位，保留为今后使用，目前置为0</p>
<h3 id="紧急URG（URGent）"><a href="#紧急URG（URGent）" class="headerlink" title="紧急URG（URGent）"></a>紧急URG（URGent）</h3><p>当URG为1时，表明紧急指针字段有效，它告诉系统此报文中有紧急数据，应当尽快传送，而不要按照原来的排队书序来传送。例如如果在远程控制某个程序的运行时需要中断，用户从键盘发出Ctrl + C。如果不采用紧急数据，那么这两个字符将存储在接受TCP的缓存末尾。只有在所有的数据都被处理完成之后这两个字符才会被交给接受方的应用程序。</p>
<p>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要发送，于是TCP就把紧急数据插入到本报文段数据的最前方，而后配合另一个首部字段<strong>紧急指针字段表明紧急数据的长度，然后剩下的数据仍然是普通的数据</strong>。</p>
<h3 id="确认ACK"><a href="#确认ACK" class="headerlink" title="确认ACK"></a>确认ACK</h3><p>只有在ACK = 1时，确认号字段才有效，当ACK = 0时，确认号无效，<strong>TCP规定，在连接建立之后所有传送的报文都必须把ACK置为1</strong></p>
<h3 id="推送PSH（PuSH）"><a href="#推送PSH（PuSH）" class="headerlink" title="推送PSH（PuSH）"></a>推送PSH（PuSH）</h3><p>当两个应用进程进行交互式的通信时，有时一端的应用进程希望在加入一个命令后立即能够收到对方的响应，这个时候就可以使用推送操作。这时发送方将PSH置为1，并立即创建一个报文段发送出去，接收方收到PSH为1的报文，就尽快交给接受程序，而不用等缓存填满之后再一起交付。</p>
<h3 id="复位RST"><a href="#复位RST" class="headerlink" title="复位RST"></a>复位RST</h3><p>当出现重大差错时，必须释放连接然后建立新的连接。或者用于拒绝一个非法的报文或拒绝打开一个连接。</p>
<h3 id="同步SYN"><a href="#同步SYN" class="headerlink" title="同步SYN"></a>同步SYN</h3><p>在建立连接时用于同步序号，当SYN = 1而ACK = 0时，表明这是一个连接请求报文，对方如果同意建立连接，则在响应报文中使用SYN = 1，ACK = 1 。因此，SYN置为1就表明这是一个<strong>连接请求或者连接建立报文</strong>。</p>
<h3 id="终止FIN"><a href="#终止FIN" class="headerlink" title="终止FIN"></a>终止FIN</h3><p>用于释放一个连接，当FIN = 1时，表明此报文段的发送方数据应经发送完毕，并要求释放运输连接。</p>
<p><strong>也就是说理论上不发送这个字段为1的报文，TCP连接就不会中断。</strong></p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>占2字节，窗口值是[0, 2^16 - 1]之间的整数。窗口值得是发送本报文段的一方的接收窗口。窗口值告诉对方的是：<strong>从本报文段首部确认号算起，接收方目前允许对方发送的数据量（以字节为单位）</strong>，窗口值是作为接收方让发送方设置其发送窗口的依据。</p>
<p>窗口字段之处了现在允许对方发送的数据量，窗口值经常在变动。</p>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>占2字节，检验和字段检验范围包括首部和数据两部分。具体如何计算比较复杂，有兴趣可以自己搜索一下</p>
<h3 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h3><p>占2字节，仅在URG = 1时才有意义，指出了本报文段中紧急数据的长度，<strong>当所有紧急数据都处理完成之后，对本报文段中接下来的正常数据就会恢复到正常操作</strong>。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>长度可变，最长可达40字节，当没有使用选项时，首部长度就是20字节。</p>
<p>最初的时候只规定了<strong>MSS（最大报文段长度，Maximum Segment Size）</strong> 。MSS应该尽量大一些，只要在IP层传输的时候不要再分片就好，当然由于IP层经历的路径是动态变化的，这个MSS也很难确定。</p>
<p>在连接建立过程中，双方可以把自己支持的MSS写入这一字段，以后就按照这个字段进行传送，两个传送方向可以有不同大小的MSS。如果主机没有填写这一项，默认就是536，所有互联网主机都应该能够接受的MSS是536 + 20（固定首部长度） = 556字节。</p>
<h2 id="TCP可靠传输的原理"><a href="#TCP可靠传输的原理" class="headerlink" title="TCP可靠传输的原理"></a>TCP可靠传输的原理</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>TCP的滑动窗口都是以字节为单位的，假定A收到了B发来的确认报文段，其中窗口值是20，而确认号是31（这表明B期望收到的下一个序号是31，而序号30为止的数据已经收到了），根据这两个数据，A就构造出自己的发送窗口。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587202028/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418172540_by140j.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587202028/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418172540_by140j.png"></p>
<blockquote>
<p>这里可能会有人和我同样突然有点疑惑，如果每次都要等B返回确认A才能改变窗口位置和大小，然后把窗口数据发送出去，这和停止等待协议有什么区别？目前我能看出的区别就在于窗口大小可能远超MSS，需要多个分组才能发送完成，而每次的确认也不是说整个窗口都被确认了。</p>
</blockquote>
<p>对于A的发送窗口，在没有收到B的确认之前，A可以连续把窗口内的数据都发送出去。凡是已经发送的数据，在未收到确认之前都必须暂存，以便超时重传时使用。</p>
<p>发送窗口里面的序号表示允许发送的序号，显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可以获取更高的数据传输效率。</p>
<p>发送窗口后沿的后面部分表示已经发送并且收到了确认，这些数据显然不需要再保留了。而前沿的前面部分表示不允许发送，因为接收方没有为这部分数据保留临时存放的缓存空间。</p>
<p>发送窗口的位置由前沿和后沿共同确定。后沿的变化有两种情况，即不动（没有收到新的确认），和前移（收到了新的确认），后沿不可能向后移动，因为不能撤销已经收到的确认。前沿可以不断向前移动，也可以不动，不动的情况分为两种，一种是没有收到新的确认，多让通知的窗口大小也不变，二是收到了新的确认，但是对方通知的窗口缩小了，正好使得前沿不动。当然前沿也可以向后收缩，但是<strong>TCP标准强烈不建议这么做</strong>。</p>
<p>现在假定A发送了序号31-41的数据，这个时候发送窗口位置并没有改变，窗口内靠后的11个字节表示已发送但是未收到确认，前面的9个字节表示允许发送但是尚未发送。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587203074/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418174406_itnljo.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587203074/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418174406_itnljo.png"></p>
<p>从上图可以看出，要描述一个发送窗口的状态需要三个指针，P1,P2,P3，小于P1的是已发送并且已经接收的部分，大于P3的是不允许发送的部分。</p>
<p>再看B的接受窗口。B的接受窗口大小是20，在接收窗口之外，到30号为止的所有数据都已经确认发送过了，并且已经交付给主机了，因此B可以不再保留这些数据。31-50之间的是允许接收的。</p>
<p>在上图中<strong>32,33已经被B接收，但是没有按序到达，因为31没有收到，这个时候B只能对按序收到的最高序号给出确认，也就是说现在B返回的报文中确认号仍然是31</strong>.</p>
<p>如果B收到了31号，并把31-33交付给主机后，B删除这些数据后，把接收窗口向前移动三个序号，同时给A发送确认，窗口值为20，确认号是34 。A收到后，P1,P3向前移动三个序号，P2不变。</p>
<p>接下来如果A把42-53发送，<strong>指针P2和P3重合，窗口内数据发送完成，还没有再收到确认，就需要停止发送</strong>。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>发送方的应用进程把字节流写入TCP的发送缓存中，接收方的应用程序从TCP的接收缓存中读取字节流</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587209077/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418192408_lz3rfp.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587209077/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418192408_lz3rfp.png"></p>
<p>需要明确的是：缓存空间和序号都是有限的，循环使用的。</p>
<p>发送缓存用于暂时存放：</p>
<ul>
<li>发送应用程序传送给发送方TCP准备发送的数据。</li>
<li>TCP已发送但尚未确认的部分。</li>
</ul>
<p><strong>发送窗口通常只是发送缓存的一部分，已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的</strong>。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中被写入的字节数。</p>
<p>接收缓存用来暂时存放：</p>
<ul>
<li>按序到达的、尚未被接收应用程序读取的数据</li>
<li>未按序到达的数据。</li>
</ul>
<p>如果应用程序来不及读取收到的数据，接收缓存最终就会被填满，接收窗口就会减小到0.</p>
<p>在这里还要<strong>强调三点</strong>：</p>
<ul>
<li>虽然A的发送窗口是根据B的接受窗口设置的，但是<strong>同一时刻，A的发送窗口大小并不是和B的接收窗口一样大</strong>。因为网络的传输时有延迟的，而且A的发送窗口还要受到网络拥塞状况的限制，当发生拥塞时，应适当减小自己发送窗口的值。</li>
<li>对于不按序到达的数据，TCP通常是先将不按序到达的数据<strong>存放在缓存</strong>中，等字节流中<strong>所缺少的字节收到后，再按序交付到上层的应用进程</strong>。</li>
<li>TCP要求接收方必须有累计确认功能。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时将确认信息顺带捎上，但是确认的推迟时间不应该超过0.5秒。</li>
</ul>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>TCP的超时重传时间采用了一种自适应算法。它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间差就是报文段往返时间RTT，TCP保存了RTT的一个加权平均往返时间RTT<sub>s</sub> ，又称为<strong>平滑往返时间</strong>。</p>
<p>当第一次测量到RTT样本时，RTT<sub>s</sub>就取值为RTT样本值，接下来每一次受到RTT就重新计算一次：</p>
<p><u>新的RTT<sub>s</sub> = （1 - α）* （旧的RTT<sub>s</sub>） + α * 新的RTT样本</u></p>
<p>其中的α建议为0.125</p>
<p>显然超时重传时间RTO（RetransmissionTime-Out）应该略大于RTT<sub>s</sub>，</p>
<p><u>RTO = RTT<sub>s</sub> + 4 * RTT<sub>D</sub></u></p>
<p>RTT<sub>D</sub>是RTT<sub>s</sub>的偏差的加权平均值，第一次测量时，RTT<sub>D</sub>取值为RTT的一半，接下来采用如下算法：</p>
<p><u>新的RTT<sub>D</sub> = （1 - β）*（旧的RTT<sub>D</sub>）+ β * |RTT<sub>s</sub> - 新的RTT样本|</u></p>
<p>β推荐值为0.25</p>
<p>现在有存在一个问题，当设置的重传时间到了，还是没有收到确认，于是重传报文，经过一段时间之后收到了确认，<strong>如何确认这个确认是对先前发送的报文的确认还是对重传的报文的确认？</strong>，这个对于RTT<sub>s</sub>计算的影响很大。</p>
<p>对于这种情况，目前的方法是：报文每重传一次，就把RTO增加为两倍</p>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>如果收到的报文段没有差错，只是<strong>没有按序到达</strong>，中间还缺少一些序号的数据，<strong>能否想个办法只传送缺少的数据而不传送已经正确收到的数据呢？</strong></p>
<p>答案是可以的，就是SACK，这里只是简单讲一下原理。</p>
<p>假设收到的报文序号是1 - 1000,1501 - 3000,3501 - 4500，中间缺少了两部分，如果<strong>这些字节的序号都在接收窗口之内</strong>，那就先把这些数据收下，但是要想个办法通知发送发我已经收到了。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211176/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418195848_xt17r1.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211176/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418195848_xt17r1.png"></p>
<p>从上图我们可以看出，每一个和前后字节不连续的字节块都有两个边界，图中用L1，R1，L2,R2来表示这四个边界</p>
<p>我们知道，TCP的首部没有那个字段能够填进去这种边界数值，</p>
<p>如果想要使用SACK就要在TCP建立阶段在首部中添加<strong>允许SACK选项</strong>，如果确认使用，原有的确认号字段用法不变，只是在选项中添加了SACK选项。但是在选项中最多指明4个字节块的信息，因为序号有32位，需要四个字节，一个字节块需要两个序号，8个字节，而同时需要两个字节来指明哪些是SACK选项，4个字节块就会用掉34个字节，而选项最长为40字节，再加一个字节块就会超过。</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>所谓的流量控制就是让发送方不要发送太快，而让接收方来得及接收。</p>
<p>利用滑动窗口可以很方便地实现对发送方的流量控制。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211807/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418200900_kruofd.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587211807/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418200900_kruofd.png"></p>
<p>上图的流程可以总结为：</p>
<ul>
<li>在连接建立时，B告诉A：我的接收窗口是rwnd = 400，因此<strong>发送方的发送窗口不能超过接收方给出的接收窗口个</strong>，注意，TCP窗口单位是字节而不是报文段。</li>
<li>设每个报文段的长度为100字节，初始序号为1，ACK是确认位，ack是确认号。</li>
<li>B进行了三次流量控制，第一次把rwnd减到300，第二次减到100，最后减到0.</li>
</ul>
<p>思考一个问题，如果A在发送了零窗口的报文段后不久，B的接受缓存又有了空间，于是向A发送rwnd = 400，但是这个报文丢失了，A一直在等待B发送非零窗口的通知，B也一直在等待A的数据，就会产生死锁。</p>
<p>为了解决这个问题，TCP为每一个连接设置持续计时器，只要TCP一方收到了零窗口通知，就开启计时器，到时就发送一个探测报文，如果返回的结果不是0，就可以打破死锁。</p>
<h3 id="TCP报文段的发送时机"><a href="#TCP报文段的发送时机" class="headerlink" title="TCP报文段的发送时机"></a>TCP报文段的发送时机</h3><p>应用进程会把数据传送到TCP的发送缓存中，剩下的任务就交给TCP了。可以用不同的机制去控制TCP报文段的发送时机。</p>
<ul>
<li>第一种是利用MSS，只要缓存中存放的数据达到了MSS就封装成一个报文段发送出去。</li>
<li>第二种是应用程序指明发送，如PSH操作</li>
<li>第三种就是发送方设置一个计时器，到时后就把缓存中的数据打包发送出去。</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在计算机网络中，链路容量，交换节点中的缓存和处理机等都是网络的资源，当对网络中某一资源的需求超过该资源所能提供的可用部分时，网络性能就要变化，这种情况就叫做拥塞。</p>
<p><strong>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载</strong>。</p>
<p><strong>拥塞控制是一个全局性的过程</strong>，涉及到所有的主机，路由器以及所有与降低网络传输性能有关的因素，而<strong>流量控制</strong>往往指的是点对点的通信量的控制，是个<strong>端到端的问题</strong>。</p>
<p>TCP的拥塞控制算法有四种，即我们非常熟悉的<strong>慢开始，拥塞避免，快重传和快恢复</strong>。</p>
<p>发送方维护一个叫做拥塞窗口cwnd的值，拥塞窗口的大小事取决于网络的拥塞程度，并且在动态变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</p>
<p>发送方控制cwnd的原则是：只要没有出现拥塞，就将cwnd扩大一些，只要出现了拥塞或者可能出现拥塞，就减小cwnd。而<strong>判断网络出现拥塞的依据就是出现了超时</strong>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们还用这张经典的图来说明：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587214008/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418204614_kprnwt.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587214008/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418204614_kprnwt.png"></p>
<p><strong>慢开始的思路</strong>是这样的：当主机一开始发送数据的时候，并不清楚网络的负载情况，如果立刻将大量数据注入到网络，就可能发生拥塞，于是就从小到大增大cwnd。</p>
<ul>
<li><p>在刚开始发送报文时，先把拥塞窗口cwnd设置为2至4个发送方最大报文段SMSS。</p>
</li>
<li><p>没受到一个确认报文，就把cwnd增大最多一个SMSS。</p>
<p>cwnd每次的增加量 = min(N, SMSS)，N是原先未被确认，刚收到的确认报文段中确认的报文字节数。</p>
</li>
</ul>
<p>我们用下面这个例子说明慢开始的原理，为了方便说明 ，我们用报文段的个数作为cwnd的单位，实际上单位应该是字节数。</p>
<ul>
<li><p>一开始发送方设置cwnd为 1，发送第一个报文M1，接收方收到M1后返回确认。发送方收到M1的确认后，将cwnd从1增大为2，接着发送M2和M3，收到二者的确认后，cwnd就从2增大到4，也就是慢开始算法，<strong>每经过一个传输轮次，cwnd就加倍</strong>。一个传输轮次经过的时间其实就是一个RTT</p>
</li>
<li><p>为了防止cwnd增长过快，还需要设置一个<strong>慢开始门限ssthresh</strong>。</p>
<ul>
<li>当cwnd &lt; ssthresh时，使用慢开始算法。</li>
<li>当cwnd &gt; ssthresh时，使用拥塞避免算法</li>
<li>当cwnd = ssthresh时，二者均可以。</li>
</ul>
<p>拥塞避免的思路是让cwnd的增长变慢，每经过一个RTT就让cwnd加1。当cwnd增长到ssthresh时（图中1点）就从慢开始改为拥塞控制算法。</p>
</li>
<li><p>当出现超时（图中2点）后，发送方判断网络出现拥塞，调整ssthresh = cwnd / 2, cwnd = 1，重新进入慢开始。</p>
</li>
<li><p>有时候发送方会连续收到三个ACK（图中4点），出现这种情况是以为有时候，个别报文段会在网络中丢失，实际上网络并未发生拥塞，如果发送方迟迟未收到确认，就会产生超时，认为发生了拥塞，就会导致发送方错误地开启慢开始。采用<strong>快重传算法可以让发送方尽早知道个别报文丢失了</strong>。</p>
<p>快重传算法要求接收方不要等待自己发送数据时才稍待确认，而是要<strong>立即发送确认</strong>。即使收到了失序的报文也要立即发出对已收到报文的重复确认。假设接收方收到了M1和M2，并及时确认，现在假定接收方没有收到M3却收到了M4，接收方累计确认只能发送M2的确认，之后又收到了M5和M6，又分别重发了两次对M2的确认，发送方一共收到了4个对M2的确认，其中3个是重复的，就知道接收方确实没收到M2就应当启动立即重传。</p>
</li>
<li><p>在图中4点，发送方知道只是丢失了个别的报文段，就不执行慢开始，而是执行快恢复，ssthresh = cwnd / 2, cwnd = ssthresh。</p>
</li>
</ul>
<p>上述的过程可以不断调整cwnd的大小，因而发送窗口的大小会受到拥塞程度的控制，但是实际上接收方缓存空间有限，接收方根据自己的接受能力设置了rwnd（接收方窗口，又名通知窗口），并把这值写入了TCP头部的窗口字段，从接受方角度考虑，发送方的发送窗口不能超过rwnd，因此，<strong>发送方的发送窗口上限应该是rwnd和cwnd中的最小值</strong>。</p>
<h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><p>我们从开始就说TCP是面向连接的，它的很多设计也是基于这个前提才能够正常运行的，那么TCP又是如何建立和维持这个连接的呢？</p>
<p>在建立TCP连接过程中要解决三个问题：</p>
<ul>
<li>要让每一方都能够确认对方的存在</li>
<li>要允许双方商定一些数值，如最大窗口值</li>
<li>能够最运输实体资源进行分配。</li>
</ul>
<h3 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h3><p>TCP建立连接的过程叫做握手，需要客户端和服务器之间交换三个TCP报文</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587215346/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418210855_mpcozg.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587215346/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418210855_mpcozg.png"></p>
<ul>
<li>最初两端都处于关闭状态，在上图中是A主动打开连接，B被动打开连接。</li>
<li>一开始B的TCP服务器就创建传输控制块TCB，准备接受客户进程的连接，然后服务器就处于LISTIN状态。</li>
<li>A的TCP客户端创建TCB，在建立连接之前，首先向B发送连接请求报文，同步位SYN = 1，同时选择一个初始序号seq = x，TCP规定，SYN报文不能携带数据，但是要消耗掉一个序号，TCP客户端进入SYN-SENT状态</li>
<li>B收到请求报文后，如果同意建立连接，向A发送确认，将SYN和ACK都置为1，ack置为 x + 1，并为自己选择一个初始序号seq = y，这个报文段也不能携带数据，但是要消耗掉一个序号。</li>
<li>A的TCP客户端收到B的确认之后还要向B给出确认，ACK为1，ack = y +1，seq = x + 1，而这个时候，ACK报文段就可以携带数据了。这个时候A已经进入了ESTABLISHED（已建立连接）状态，B收到确认后也进入ESTABLISHED状态。</li>
</ul>
<p>上述过程叫做三次握手，但是B发送给A的报文段也可以拆分为两个报文段，先发送一个ACK = 1，ack = x + 1，在发送一个同步报文（SYN = 1, seq = y）,<strong>这样就变成了四次握手。</strong></p>
<p><strong>那么为什么A最后还要发送一次确认呢？主要是为了防止已经失效的连接请求报文突然又到了B</strong>。这种情况一般都产生在A发送的第一个连接请求报文超时后，A再次发送了一次，B收到了第二次的请求，完成建立连接并发送数据，之后释放连接以后第一个请求又到了，这个时候如果B没有收到A的第二个确认，是不会管这第一个请求的。</p>
<h3 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h3><p>释放过程与建立过程类似，只是更加复杂，并且使用的头部字段是FIN</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587216170/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418212241_j13fkc.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587216170/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418212241_j13fkc.png"></p>
<ul>
<li><p>A的应用进程首先向其TCP发送连接释放报文，并停止发送数据，主动关闭TCP连接</p>
</li>
<li><p>A将连接释放报文的首部字段FIN置为1，序号seq = u，它等于前面已传送的所有数据最后一个字节的序号加1，此时A进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文不携带数据，但是消耗一个序号。</p>
</li>
<li><p>B收到连接释放报文后发出确认，ack = u + 1，自身的序号seq = v，等于B传送的数据最后一个字节的序号加1，然后B进入CLOSE-WAIT（关闭等待）状态。这时TCP进入<strong>半关闭状态</strong>，即A已经没有数据要发送了，但是B若要发送数据，A可以接受，也就是说从<strong>B到A的连接并未关闭</strong>。</p>
</li>
<li><p>A收到B的确认手进入FIN-WAIT-2状态，等待B发出的释放报文。</p>
</li>
<li><p>若B已经没有数据要发送了，其应用进程通知TCP释放连接，这个时候B发送FIN报文，seq = w（假定B在半关闭状态有发送了一些数据），ack仍然为 u + 1.</p>
</li>
<li><p>A收到连接释放报文后，必须对此发出确认，ACK = 1，ack = w + 1，seq = u + 1，然后进入TIME-WAIT状态，经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL之后，A进入CLOSED状态，MSL叫做最长报文段寿命（Maximum Segment Lifetime）。</p>
<p>之所以要等待这个时间，有两个理由：</p>
<ul>
<li>保证A发送的最后一个ACK报文到达B，这个报文有可能丢失，所以B可能会重传上个FIN报文，这个时候就需要A重传一次确认然后重启2MSL计时器。</li>
<li>防止上面说的已失效连接，等待2MSL可以保证本连接持续时间内所产生的所有报文从网络中消失，</li>
<li>除了时间等待计时器外，还有个保活计时器（keepalive timer），服务器没收到一次客户数据，就重置它，时间是两个小时，如果两小时没收到数据，就发送探测报文，每隔75秒发一个，如果连续10个都没有回复，那就关闭这个连接。</li>
</ul>
</li>
</ul>
<h2 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587217099/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418213810_lbd6iv.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587217099/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200418213810_lbd6iv.png"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>TamperMonkey</title>
    <url>/2020/05/23/TamperMonkey/</url>
    <content><![CDATA[<p>各类实用的 Chrome 扩展是不少人选择 Chrome 浏览器的重要原因，经过多年发展，Chrome 的扩展种类已经非常丰富，除了那些「即装即用」的小工具之外，也有很多被誉为「神器」的强大扩展程序。</p>
<a id="more"></a>

<p>「油猴」也可以通过安装各类脚本对网站进行定制。不过它能定制的不仅仅是网站的样式，还能实现更多更强大的功能，例如：</p>
<ul>
<li>直接下载百度网盘文件</li>
<li>重新定制繁杂的微博页面</li>
<li>去掉视频播放广告</li>
<li>将网站默认的「二维码登录」改回「账号密码登录」</li>
<li>绕过搜索引擎的跳转提示</li>
<li>还原清新的小说阅读模式</li>
<li>豆瓣和 IMDb 互相显示评分</li>
</ul>
<h2 id="TamperMonkey简介"><a href="#TamperMonkey简介" class="headerlink" title="TamperMonkey简介"></a>TamperMonkey简介</h2><p>TamperMonkey可以让我们编写一些js脚本来帮助我们做一些特定的工作，它的脚本的编写与普通的js代码无异，但是还是有一些自己的特性。</p>
<p>全部的特性可以直接去看官方文档：<a href="https://www.tampermonkey.net/documentation.php?ext=dhdg" rel="external nofollow noopener noreferrer" target="_blank">https://www.tampermonkey.net/documentation.php?ext=dhdg</a></p>
<p>这里就简单介绍几个常用的：</p>
<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>油猴脚本的名字</td>
<td></td>
</tr>
<tr>
<td>namespace</td>
<td>命名空间，类似于Java的包名，用来区分相同名称的脚本，一般写成作者名字或者网址就可以了</td>
<td></td>
</tr>
<tr>
<td>version</td>
<td>脚本版本，油猴脚本的更新会读取这个版本号</td>
<td></td>
</tr>
<tr>
<td>description</td>
<td>描述，用来告诉用户这个脚本是干什么用的</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td>作者名字</td>
<td></td>
</tr>
<tr>
<td>match</td>
<td>只有匹配的网址才会执行对应的脚本，例如<code>*</code>、<code>http://*</code>、<code>http://www.baidu.com/*</code>等，参见<a href="https://developer.chrome.com/extensions/match_patterns" rel="external nofollow noopener noreferrer" target="_blank">谷歌开发者文档</a></td>
<td></td>
</tr>
<tr>
<td>grant</td>
<td>指定脚本运行所需权限，如果脚本拥有相应的权限，就可以调用油猴扩展提供的API与浏览器进行交互。如果设置为<code>none</code>的话，则不使用沙箱环境，脚本会直接运行在网页的环境中，这时候无法使用大部分油猴扩展的API。如果不指定的话，油猴会默认添加几个最常用的API</td>
<td></td>
</tr>
<tr>
<td>require</td>
<td>如果脚本依赖其他js库的话，可以使用require指令，在运行脚本之前先加载其他库，常见用法是加载jquery</td>
<td></td>
</tr>
<tr>
<td>connect</td>
<td>当用户使用<a href="https://www.tampermonkey.net/documentation.php?version=4.9&ext=dhdg&show=dhdg#GM_xmlhttpRequest" rel="external nofollow noopener noreferrer" target="_blank">GM_xmlhttpRequest</a>请求远程数据的时候，需要使用connect指定允许访问的域名，支持域名、子域名、IP地址以及<code>*</code>通配符</td>
<td></td>
</tr>
<tr>
<td>updateURL</td>
<td>脚本更新网址，当油猴扩展检查更新的时候，会尝试从这个网址下载脚本，然后比对版本号确认是否更新</td>
<td></td>
</tr>
</tbody></table>
<h2 id="举例：时间掌控者"><a href="#举例：时间掌控者" class="headerlink" title="举例：时间掌控者"></a>举例：时间掌控者</h2><p>tamperMonkey上有一款非常火的脚本叫做时间掌控者，可以以任意倍速播放视频，我们就简单分析一下它的工作原理</p>
<p>首先是一些头部的特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @name        计时器掌控者|视频广告跳过|视频广告加速器</span></span><br><span class="line"><span class="comment">// @name:en      TimerHooker</span></span><br><span class="line"><span class="comment">// @name:zh-CN   计时器掌控者|视频广告跳过|视频广告加速器</span></span><br><span class="line"><span class="comment">// @namespace    https://gitee.com/HGJing/everthing-hook/</span></span><br><span class="line"><span class="comment">// @version      1.0.39</span></span><br><span class="line"><span class="comment">// @description       控制网页计时器速度|加速跳过页面计时广告|视频快进（慢放）|跳过广告|支持几乎所有网页.</span></span><br><span class="line"><span class="comment">// @description:en  it can hook the timer speed to change.</span></span><br><span class="line"><span class="comment">// @description:zh-CN  控制网页计时器速度|加速跳过页面计时广告|跳过广告|支持几乎所有网页.</span></span><br><span class="line"><span class="comment">// @include      *</span></span><br><span class="line"><span class="comment">// @require      https://greasyfork.org/scripts/372672-everything-hook/code/Everything-Hook.js?version=784972</span></span><br><span class="line"><span class="comment">// @author       Cangshi</span></span><br><span class="line"><span class="comment">// @match        http://*/*</span></span><br><span class="line"><span class="comment">// @run-at       document-start</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @license      GPL-3.0-or-later</span></span><br></pre></td></tr></table></figure>

<p>其中最主要的就是require特性，它引入了一个叫做everything-hook的插件，可以劫持所有浏览器的方法</p>
<p>这个组件中大部分代码都是用来在页面中插入几个按钮，或者注册一些快捷键的，另外就是用everything-hook劫持setTimeout和setInterval方法。</p>
<p>但是其中最重要，最后发挥作用的就是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">changeVideoSpeed: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> rate = <span class="number">1</span> / <span class="keyword">this</span>._percentage;</span><br><span class="line">                    rate &gt; <span class="number">16</span> &amp;&amp; (rate = <span class="number">16</span>);</span><br><span class="line">                    rate &lt; <span class="number">0.065</span> &amp;&amp; (rate = <span class="number">0.065</span>);</span><br><span class="line">                    <span class="keyword">var</span> videos = querySelectorAll(<span class="built_in">document</span>, <span class="string">'video'</span>, <span class="literal">true</span>) || [];</span><br><span class="line">                    <span class="keyword">if</span> (videos.length) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; videos.length; i++) &#123;</span><br><span class="line">                            videos[i].playbackRate = rate;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>获取页面中所有的video标签，改变其playbackRate，来修改其播放速率。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>既然了解了如何编写一个油猴脚本，我们就简单尝试一下。</p>
<p>作为一个程序员，我们平时开发时肯定会同时在不同环境开发测试不同的平台，这些大量的url我们一般都是找个地方存起来，或者存在本地，或者存在浏览器，那我们是不是可以写个插件将所有url配置起来，每次需要的时候把插件打开，然后根据配置名去直接打开。</p>
<p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         URL Manager</span></span><br><span class="line"><span class="comment">// @namespace    https://sunra.top/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  Manage URL!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        http://*/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @require      https://res.cloudinary.com/dvtfhjxi4/raw/upload/v1590135992/url_rpyrxm.js</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="string">'q'</span> &amp;&amp; e.ctrlKey) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">"gsbn_urls"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addEnvironmentFormToBody();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&lt;form id="gsbn_urls"&gt;</span></span><br><span class="line"><span class="string">    &lt;label&gt;Platform:&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;select id="openPlatform"&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="built_in">Object</span>.keys(urls).map((platform) =&gt; &#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            <span class="keyword">return</span> <span class="string">`&lt;option value="<span class="subst">$&#123;platform&#125;</span>"&gt;<span class="subst">$&#123;platform&#125;</span>&lt;/option&gt;`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>).join('\n')&#125;</span></span><br><span class="line"><span class="string">&lt;/select&gt;</span></span><br><span class="line"><span class="string">    &lt;label&gt;Environment:&lt;/label&gt;</span></span><br><span class="line"><span class="string">    &lt;select id="openUrl"&gt;</span></span><br><span class="line"><span class="string">    &lt;/select&gt;</span></span><br><span class="line"><span class="string">    &lt;button id="openBtn"&gt;open&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/form&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addEnvironmentFormToBody</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> form = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        form.style = <span class="string">"position:absolute;width:600px;height:100px;top:200px;"</span></span><br><span class="line">        form.innerHTML = generateForm();</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line">        addChangeEventListenerToPlatformSelect();</span><br><span class="line">        addClickEventListenerToOpenButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addClickEventListenerToOpenButton</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'openBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> urlSelect = <span class="built_in">document</span>.getElementById(<span class="string">"openUrl"</span>);</span><br><span class="line">            <span class="keyword">var</span> index = urlSelect.selectedIndex;</span><br><span class="line">            <span class="built_in">window</span>.open(urlSelect.options[index].value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addChangeEventListenerToPlatformSelect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> platformSelect = <span class="built_in">document</span>.getElementById(<span class="string">'openPlatform'</span>);</span><br><span class="line">        <span class="keyword">var</span> urlSelect = <span class="built_in">document</span>.getElementById(<span class="string">"openUrl"</span>);</span><br><span class="line">        platformSelect.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> index = platformSelect.selectedIndex;</span><br><span class="line">            urlSelect.innerHTML = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">var</span> urlOptions = urls[platformSelect.options[index].value];</span><br><span class="line">            urlSelect.innerHTML = <span class="built_in">Object</span>.keys(urlOptions).map(<span class="function">(<span class="params">env</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">`&lt;option value='<span class="subst">$&#123;urlOptions[env]&#125;</span>'&gt;<span class="subst">$&#123;env&#125;</span>&lt;/option&gt;`</span>;</span><br><span class="line">            &#125;).join(<span class="string">'\n'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fireChange(platformSelect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fireChange</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"createEvent"</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> evt = <span class="built_in">document</span>.createEvent(<span class="string">"HTMLEvents"</span>);</span><br><span class="line">            evt.initEvent(<span class="string">"change"</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            element.dispatchEvent(evt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            element.fireEvent(<span class="string">"onchange"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面的代码中url是通过require属性从cdn中导入了脚本中定义的，大致格式就是这样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = &#123;</span><br><span class="line">	pm_console: &#123;</span><br><span class="line">		dev2: <span class="string">""</span>,</span><br><span class="line">		dev: <span class="string">""</span></span><br><span class="line">	&#125;,</span><br><span class="line">	hm_console: &#123;</span><br><span class="line">		dev2: <span class="string">""</span>,</span><br><span class="line">		prod: <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果就是，在任意页面输入快捷键Ctrl + Q就会出现下面这个简陋的界面，可以在左边选择了</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1590193109/Devtools/WeChat_Screenshot_20200523081809_llx9zu.png" alt></p>
<h3 id="一些小坑"><a href="#一些小坑" class="headerlink" title="一些小坑"></a>一些小坑</h3><ul>
<li>每次修改脚本如果想要立即生效，请重启浏览器。</li>
<li>fireEvent在谷歌浏览器中不好使，需要用dispatchEvent。</li>
<li>需要在脚本的设置页面设置哪些网站不使用本脚本，或者哪些使用，符合规则的脚本才会生效。</li>
</ul>
<p>还有大量优秀的插件等我们去发现，最大的插件共享网站：<a href="https://greasyfork.org/zh-CN" rel="external nofollow noopener noreferrer" target="_blank">https://greasyfork.org/zh-CN</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Azure 基本概念梳理</title>
    <url>/2020/06/25/azure-fundamental-concepts/</url>
    <content><![CDATA[<p>最近在看Azure文档的时候，被文档中的许多概念搞得非常困惑，就去查看了一些官方文档，算是一个临时的理解和总结。</p>
<a id="more"></a>

<p>首先上一段我认为最能解决我疑惑的<a href="https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/fundamental-concepts" rel="external nofollow noopener noreferrer" target="_blank">原文档</a>：</p>
<h2 id="Azure-terminology"><a href="#Azure-terminology" class="headerlink" title="Azure terminology"></a>Azure terminology</h2><p>It’s helpful to know the following definitions as you begin your Azure cloud adoption efforts:</p>
<ul>
<li><strong>Resource:</strong> An entity that’s managed by Azure. Examples include Azure Virtual Machines, virtual networks, and storage accounts.</li>
<li><strong>Subscription:</strong> A logical container for your resources. Each Azure resource is associated with only one subscription. Creating a subscription is the first step in adopting Azure.</li>
<li><strong>Azure account:</strong> The email address that you provide when you create an Azure subscription is the Azure account for the subscription. The party that’s associated with the email account is responsible for the monthly costs that are incurred by the resources in the subscription. When you create an Azure account, you provide contact information and billing details, like a credit card. You can use the same Azure account (email address) for multiple subscriptions. Each subscription is associated with only one Azure account.</li>
<li><strong>Account administrator:</strong> The party associated with the email address that’s used to create an Azure subscription. The account administrator is responsible for paying for all costs that are incurred by the subscription’s resources.</li>
<li><strong>Azure Active Directory (Azure AD):</strong> The Microsoft cloud-based identity and access management service. Azure AD allows your employees to sign in and access resources.</li>
<li><strong>Azure AD tenant:</strong> A dedicated and trusted instance of Azure AD. An Azure AD tenant is automatically created when your organization first signs up for a Microsoft cloud service subscription like Microsoft Azure, Microsoft Intune, or Office 365. An Azure tenant represents a single organization.</li>
<li><strong>Azure AD directory:</strong> Each Azure AD tenant has a single, dedicated, and trusted directory. The directory includes the tenant’s users, groups, and apps. The directory is used to perform identity and access management functions for tenant resources. A directory can be associated with multiple subscriptions, but each subscription is associated with only one directory.</li>
<li><strong>Resource groups:</strong> Logical containers that you use to group related resources in a subscription. Each resource can exist in only one resource group. Resource groups allow for more granular grouping within a subscription, and are commonly used to represent a collection of assets required to support a workload, application, or specific function within a subscription.</li>
<li><strong>Management groups:</strong> Logical containers that you use for one or more subscriptions. You can define a hierarchy of management groups, subscriptions, resource groups, and resources to efficiently manage access, policies, and compliance through inheritance.</li>
<li><strong>Region:</strong> A set of Azure datacenters that are deployed inside a latency-defined perimeter. The datacenters are connected through a dedicated, regional, low-latency network. Most Azure resources run in a specific Azure region.</li>
</ul>
<h2 id="Azure-administrative-roles"><a href="#Azure-administrative-roles" class="headerlink" title="Azure administrative roles"></a>Azure administrative roles</h2><p>Azure defines three types of roles for administering subscriptions, identities, and resources:</p>
<ul>
<li>Classic subscription administrator roles.</li>
<li>Azure role-based access control (RBAC) roles.</li>
<li>Azure Active Directory (Azure AD) administrator roles.</li>
</ul>
<p>The account administrator role for an Azure subscription is assigned to the email account that’s used to create the Azure subscription. The account administrator is the billing owner of the subscription. The account administrator can manage the subscription details in the <a href="https://account.azure.com/subscriptions" rel="external nofollow noopener noreferrer" target="_blank">Azure account center</a>.</p>
<p>By default, the service administrator role for a subscription also is assigned to the email account that’s used to create the Azure subscription. The service administrator has permissions to the subscription equivalent to the RBAC-based Owner role. The service administrator also has full access to the Azure portal. The account administrator can change the service administrator to a different email account.</p>
<p>When you create an Azure subscription, you can associate it with an existing Azure AD tenant. Otherwise, a new Azure AD tenant with an associated directory is created. The role of global administrator in the Azure AD directory is assigned to the email account that’s used to create the Azure AD subscription.</p>
<p>An email account can be associated with multiple Azure subscriptions. The account administrator can transfer a subscription to another account.</p>
<p>For a detailed description of the roles defined in Azure, see <a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/rbac-and-directory-admin-roles" rel="external nofollow noopener noreferrer" target="_blank">Classic subscription administrator roles, Azure RBAC roles, and Azure AD administrator roles</a>.</p>
<h2 id="Subscriptions-and-regions"><a href="#Subscriptions-and-regions" class="headerlink" title="Subscriptions and regions"></a>Subscriptions and regions</h2><p>Every Azure resource is logically associated with only one subscription. When you create a resource, you choose which Azure subscription to deploy that resource to. You can move a resource to another subscription later.</p>
<p>While a subscription isn’t tied to a specific Azure region, each Azure resource is deployed to only one region. You can have resources in multiple regions that are associated with the same subscription.</p>
<p>就是是说同一个订阅中的资源可以在不同的地区，如东亚和北欧服务器中的资源可以在同一个资源组中。</p>
<h2 id="Tenancy-in-Azure-Active-Directory"><a href="#Tenancy-in-Azure-Active-Directory" class="headerlink" title="Tenancy in Azure Active Directory"></a>Tenancy in Azure Active Directory</h2><p>Azure Active Directory (Azure AD) organizes objects like users and apps into groups called <em>tenants</em>. Tenants allow an administrator to set policies on the users within the organization and the apps that the organization owns to meet their security and operational policies.</p>
<h3 id="Who-can-sign-in-to-your-app"><a href="#Who-can-sign-in-to-your-app" class="headerlink" title="Who can sign in to your app?"></a>Who can sign in to your app?</h3><p>When it comes to developing apps, developers can choose to configure their app to be either single-tenant or multi-tenant during app registration in the <a href="https://portal.azure.com/" rel="external nofollow noopener noreferrer" target="_blank">Azure portal</a>.</p>
<ul>
<li>Single-tenant apps are only available in the tenant they were registered in, also known as their home tenant.</li>
<li>Multi-tenant apps are available to users in both their home tenant and other tenants.</li>
</ul>
<p>In the Azure portal, you can configure your app to be single-tenant or multi-tenant by setting the audience as follows.</p>
<table>
<thead>
<tr>
<th align="left">Audience</th>
<th align="left">Single/multi-tenant</th>
<th align="left">Who can sign in</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accounts in this directory only</td>
<td align="left">Single tenant</td>
<td align="left">All user and guest accounts in your directory can use your application or API. <em>Use this option if your target audience is internal to your organization.</em></td>
</tr>
<tr>
<td align="left">Accounts in any Azure AD directory</td>
<td align="left">Multi-tenant</td>
<td align="left">All users and guests with a work or school account from Microsoft can use your application or API. This includes schools and businesses that use Office 365. <em>Use this option if your target audience is business or educational customers.</em></td>
</tr>
<tr>
<td align="left">Accounts in any Azure AD directory and personal Microsoft accounts (such as Skype, Xbox, Outlook.com)</td>
<td align="left">Multi-tenant</td>
<td align="left">All users with a work or school, or personal Microsoft account can use your application or API. It includes schools and businesses that use Office 365 as well as personal accounts that are used to sign in to services like Xbox and Skype. <em>Use this option to target the widest set of Microsoft accounts.</em></td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些文档大概解释了这些概念的定义以及大致的关系，可以让我们有个总体上模糊的认识。</p>
<p>总的来说，就是Azure AD是微软的一个身份认证服务，而每个组织可以利用它创建租户（Azure AD的一个实例），也就是tenant，每个租户都有自己唯一一个Azure AD 目录，每个目录都可以有多个订阅。可以通过资源组对订阅中的资源进行逻辑分组。</p>
<p>Azure Active Directory（Azure AD）将诸如用户和应用程序之类的对象组织到称为“ <em>租户”的</em>组中。租户允许管理员为组织内的用户以及组织拥有的应用程序设置策略，以满足他们的安全和运营策略。</p>
<p>每个应用可以设置多租户或者单租户，单租户的应用只能本租户中的用户才有可能访问到。</p>
<p>参考文档：</p>
<p><a href="https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/fundamental-concepts" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/considerations/fundamental-concepts</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/accounts-overview" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/develop/accounts-overview</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-create-new-tenant" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-create-new-tenant</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/single-and-multi-tenant-apps" rel="external nofollow noopener noreferrer" target="_blank">https://docs.microsoft.com/en-us/azure/active-directory/develop/single-and-multi-tenant-apps</a></p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>深入Babel原理系列（一）Babel工作流程与项目结构简介</title>
    <url>/2021/06/22/babel-1/</url>
    <content><![CDATA[<p>最近接触了一点关于Babel的知识，产生了一些兴趣，于是就打算看一看Babel的原理，然后总结学习下，这东西太复杂了，就分多个博客来写吧，这篇博客主要讲两件事，第一，简单描述下Babel的工作流程，第二，简单介绍下Babel的项目结构，也就是微内核模式。</p>
<a id="more"></a>

<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1624407593/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210623081837_ikbdn8.png" alt></p>
<blockquote>
<p>这里提前提一下，图中Traverser调用多个Transformer的这个结构就是微内核。</p>
<p>也就是说其实Babel的核心代码只包括左边那一列，Parser已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的ECMAScript规范。目前为了执行效率，parser是<a href="https://babeljs.io/docs/en/babel-parser#faq" rel="external nofollow noopener noreferrer" target="_blank">不支持扩展的</a>。</p>
<p>其他的附加功能，都是一个个Transformer通过插件的形式实现的，只是Babel实现了一些内置的Transformer去实现一些常用的功能，如转换es2015+代码。</p>
</blockquote>
<h3 id="解析（Tokenizer-Parser）"><a href="#解析（Tokenizer-Parser）" class="headerlink" title="解析（Tokenizer + Parser）"></a>解析（Tokenizer + Parser）</h3><p>对于源码，此时我们就把它看出一个字符串，对其分析的第一步，肯定是先把源码转换成AST，才好后续操作。</p>
<p>有一个<a href="https://astexplorer.net/" rel="external nofollow noopener noreferrer" target="_blank">在线AST转换器</a>，我们在这上面可以做实验，写出的代码，它就帮我们翻译成AST：</p>
<p>我什么都不写，AST就有一个根结点了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AST</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"end"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"body"</span>: [],</span><br><span class="line">  <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">&#125; <span class="comment">// 可以看成是一个对象，有一些字段，这代码树的根结点。</span></span><br></pre></td></tr></table></figure>

<p>然后我在写一句<code>const text = &#39;Hello World&#39;;</code>，就变成了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"end"</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="string">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">      <span class="string">"start"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"end"</span>: <span class="number">27</span>,</span><br><span class="line">      <span class="string">"declarations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">          <span class="string">"start"</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="string">"end"</span>: <span class="number">26</span>,</span><br><span class="line">          <span class="string">"id"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="string">"start"</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="string">"end"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"text"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"init"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">            <span class="string">"start"</span>: <span class="number">13</span>,</span><br><span class="line">            <span class="string">"end"</span>: <span class="number">26</span>,</span><br><span class="line">            <span class="string">"value"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">            <span class="string">"raw"</span>: <span class="string">"'Hello World'"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"kind"</span>: <span class="string">"const"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个结构我们可以简单看一下AST节点的结构。</p>
<p>每个节点都有type，start和end，type表明了节点的类型，就像根节点的类型就是Program，就是所有的代码，所以它的start是0，end是最后；</p>
<p>而不同类型的节点可能会有自己不同的定义，如<code>VariableDeclaration</code>节点就有kind属性，表示是通过const还是var，let来声明变量的， declarations属性，表示具体的内容，它是个数组，也就是说一个<code>VariableDeclaration</code>可以声明多个节点，每个节点的init属性表示该变量初始化的数据是什么。</p>
<p>总结AST树的特点：</p>
<ol>
<li>节点是有类型的。我们学习树这种数据结构时，节点都是最简单的，这里复杂了，有类型。</li>
<li>节点与子节点的关系，是通过节点的属性链接的。我们学习的树结构，都是left、right左孩子右孩子的。但是AST树，不同类型的节点，属性不同，Program类型节点的子节点是它的body属性，VariableDeclaration类型的子节点，是它的declarations、kind属性。也就是节点的属性看作是节点的子节点，并且子节点也可能有类型，近而形成一个树。</li>
<li>父节点是所有子节点的组合，我们可以看到VariableDeclaration代表的const text = ‘Hello World’被拆分成了下面两个子节点，子节点又继续拆分。</li>
</ol>
<p>希望能从上面的分析中，让大家对AST有一个最直观的认识，就是节点有类型的树。</p>
<p>那么节点的类型系统就很必要了解了，这里是<a href="https://github.com/babel/babylon/blob/master/ast/spec.md" rel="external nofollow noopener noreferrer" target="_blank">Babel的AST类型系统说明</a>。大家可以看看，可以说类型系统是抽象了代码的各种成员，标识符、字面量、声明、表达式。所以拥有这些类型的节点的树结构，可以用来表达我们的代码。</p>
<h3 id="Travese"><a href="#Travese" class="headerlink" title="Travese"></a>Travese</h3><p>第二步：转换。得到ast了，该操作它了，Babel中的babel-traverse用来干这个事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install --save babel-traverse</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实验代码</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const text = 'Hello World';`</span>;</span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code);</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'path'</span>, path);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ast'</span>, ast);</span><br></pre></td></tr></table></figure>

<p>babel-traverse库暴露了traverse方法，第一个参数是ast，第二个参数是一个对象，我们写了一个enter方法，方法的参数是个path，咋不是个node呢？我们看一下输出：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/4/16c5b8506c9e8e8d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>其实这个path中包含了node属性，同时也包含了很多用于其他分析的属性，如分析作用域的scope属性等。</p>
<h3 id="生成器-babel-generator"><a href="#生成器-babel-generator" class="headerlink" title="生成器 babel-generator"></a>生成器 babel-generator</h3><p>第三步：生成。得到操作后的ast，该生成新代码了。Babel中的babel-generator用来干这个事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save babel-generator</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入babel-generator</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">"babel-types"</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const text = 'Hello World';`</span>;</span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code);</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">"text"</span> &#125;)) &#123;</span><br><span class="line">      path.node.name = <span class="string">'alteredText'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genCode = generate(ast, &#123;&#125;, code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'genCode'</span>, genCode);</span><br></pre></td></tr></table></figure>

<h2 id="微内核与插件"><a href="#微内核与插件" class="headerlink" title="微内核与插件"></a>微内核与插件</h2><p>上面我们讲过了Babel的工作流程，我们发现Babel的核心功能不大，很小其实是分四步走，把代码拆分为token，把token序列构建成AST，对AST进行一些操作，最后再把处理后的AST转化为新的代码。</p>
<p>这个核心功能不大，但是又为了能支持复杂的功能，所以在第三步对AST的处理提供了插件机制（这个插件机制是通过<a href="https://refactoringguru.cn/design-patterns/visitor" rel="external nofollow noopener noreferrer" target="_blank">访问者模式</a>实现的），而这种架构方式就叫做微内核。</p>
<p>具体的解释可以看这篇博客：<a href="https://bobi.ink/2019/10/01/babel/#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">https://bobi.ink/2019/10/01/babel/#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F</a></p>
<p>参考链接：</p>
<p><a href="https://juejin.cn/post/6844903905961181191" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.cn/post/6844903905961181191</a></p>
<p><a href="https://www.babeljs.cn/docs/" rel="external nofollow noopener noreferrer" target="_blank">https://www.babeljs.cn/docs/</a></p>
]]></content>
      <categories>
        <category>Babel</category>
      </categories>
  </entry>
  <entry>
    <title>深入Babel原理系列（二）Parser代码结构简介</title>
    <url>/2021/06/28/babel-parser-introduction/</url>
    <content><![CDATA[<p>上一篇文章分析 Babel 编译流程的时候，提到 Babel 会将 JS 代码转换成 AST（抽象语法树）。这种行为是一种通用的行为，无论什么编程语言都会将源代码解析成 AST，<strong>AST 不是 Babel 特有的，更不是 JS 特有的</strong>。</p>
<p>为什么要这么做呢？原始的 JS 文件是计算机是无法理解的，计算机也很难直接修改 JS 代码，但是转换成 AST 后，由于 AST 本质上是一组表示程序结构的对象，我们可以通过修改这个对象，间接的实现修改代码的目的。chrome V8 引擎也是这么做的，比起 Bable 更进一步的是，V8 引擎会编译 AST 生成字节码。</p>
<p>Parser的过程分为两步，第一步，词法分析，也就是编译原理中的有限状态机，将一段代码拆分为一个个Token，第二步，语法分析，将Token数组，转换为AST树。</p>
<p>这次我就看一下<a href="https://github.com/babel/babel/tree/main/packages/babel-parser" rel="external nofollow noopener noreferrer" target="_blank">源码</a>，简单分析一下这个过程。</p>
<a id="more"></a>

<p>首先看下Babel-Parser的目录结构</p>
<p>主要是个四个文件夹，util，plugins，tokeinzer，parser</p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">input: string, options?: Options</span>): <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options?.sourceType === <span class="string">"unambiguous"</span>) &#123;</span><br><span class="line">    options = &#123;</span><br><span class="line">      ...options,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      options.sourceType = <span class="string">"module"</span>;</span><br><span class="line">      <span class="keyword">const</span> parser = getParser(options, input);</span><br><span class="line">      <span class="keyword">const</span> ast = parser.parse();   </span><br><span class="line">        </span><br><span class="line">      <span class="comment">//省略部分其他代码</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">return</span> ast;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (moduleError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        options.sourceType = <span class="string">"script"</span>;</span><br><span class="line">        <span class="keyword">return</span> getParser(options, input).parse();</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> moduleError;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getParser(options, input).parse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码核心就是通过<code>getParser</code>方法获取一个parser，然后用获取的parser去进行解析。</p>
<p>我们再来看一下这个<code>getParser</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParser</span>(<span class="params">options: ?Options, input: string</span>): <span class="title">Parser</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取Parser</span></span><br><span class="line">  <span class="keyword">let</span> cls = Parser;</span><br><span class="line">  <span class="comment">// 如果options中声明了插件，首先校验插件的声明方式是否合理，如果合理，则开启插件功能</span></span><br><span class="line">  <span class="comment">// 是的，开启插件功能，Parser的插件都是内置的，只能通过配置去选择是否开启这些插件</span></span><br><span class="line">  <span class="keyword">if</span> (options?.plugins) &#123;</span><br><span class="line">    validatePlugins(options.plugins);</span><br><span class="line">    cls = getParserClass(options.plugins);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cls(options, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parserClassCache: &#123; [key: string]: Class&lt;Parser&gt; &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a Parser class with plugins applied. */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParserClass</span>(<span class="params">pluginsFromOptions: PluginList</span>): <span class="title">Class</span>&lt;<span class="title">Parser</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// mixinPluginNames就是所有内置插件的名称</span></span><br><span class="line">  <span class="keyword">const</span> pluginList = mixinPluginNames.filter(<span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">    hasPlugin(pluginsFromOptions, name),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对当前的插件组合进行缓存</span></span><br><span class="line">  <span class="keyword">const</span> key = pluginList.join(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">let</span> cls = parserClassCache[key];</span><br><span class="line">  <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">    cls = Parser;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> pluginList) &#123;</span><br><span class="line">      cls = mixinPlugins[plugin](cls);</span><br><span class="line">    &#125;</span><br><span class="line">    parserClassCache[key] = cls;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parser解析流程"><a href="#Parser解析流程" class="headerlink" title="Parser解析流程"></a>Parser解析流程</h2><p>到现在，我们搞清楚了入口文件的逻辑，主要就是两部分，第一部分声明Parser，第二部分，如果配置了插件，为Parser开启插件功能。</p>
<p>那我们就继续看一下Parser的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parser</span> <span class="keyword">extends</span> <span class="title">StatementParser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options: ?Options, input: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parse(): File &#123;</span><br><span class="line">    <span class="keyword">this</span>.enterInitialScopes();</span><br><span class="line">    <span class="keyword">const</span> file = <span class="keyword">this</span>.startNode();</span><br><span class="line">    <span class="keyword">const</span> program = <span class="keyword">this</span>.startNode();</span><br><span class="line">    <span class="keyword">this</span>.nextToken();</span><br><span class="line">    file.errors = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.parseTopLevel(file, program);</span><br><span class="line">    file.errors = <span class="keyword">this</span>.state.errors;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中都是一些准备工作，先不关注，主要逻辑还是在这个parse函数中</p>
<h3 id="1-enterInitialScopes"><a href="#1-enterInitialScopes" class="headerlink" title="1.enterInitialScopes"></a>1.enterInitialScopes</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enterInitialScopes() &#123;</span><br><span class="line">    <span class="keyword">let</span> paramFlags = PARAM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasPlugin(<span class="string">"topLevelAwait"</span>) &amp;&amp; <span class="keyword">this</span>.inModule) &#123;</span><br><span class="line">      paramFlags |= PARAM_AWAIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.scope.enter(SCOPE_PROGRAM);</span><br><span class="line">    <span class="keyword">this</span>.prodParam.enter(paramFlags);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这一步，就是初始化一开始的根节点，以及对应的参数和作用域</p>
<h3 id="2-startNode"><a href="#2-startNode" class="headerlink" title="2. startNode"></a>2. startNode</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">startNode&lt;T: NodeType&gt;(): T &#123;</span><br><span class="line">    <span class="comment">// $FlowIgnore</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="keyword">this</span>, <span class="keyword">this</span>.state.start, <span class="keyword">this</span>.state.startLoc);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-nextToken"><a href="#3-nextToken" class="headerlink" title="3. nextToken"></a>3. nextToken</h3><p>这部分就是解析的重点了，这一部分的代码会比较复杂，解析过程中会一个个字符得向后解析，利用有限状态机的状态转移去判断不同的状态，最终在到达某种状态，去产生一个token。</p>
<p>如读取到123456这个数字的6时，判断后面是空格或者分号，就生成一个数字的token。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nextToken(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="comment">// curContext = this.state.context[this.state.context.length - 1];</span></span><br><span class="line">    <span class="keyword">const</span> curContext = <span class="keyword">this</span>.curContext();</span><br><span class="line">    <span class="comment">// 内部会不断循环跳过所有的空格，如空格，tab等</span></span><br><span class="line">    <span class="keyword">if</span> (!curContext.preserveSpace) <span class="keyword">this</span>.skipSpace();</span><br><span class="line">    <span class="keyword">this</span>.state.start = <span class="keyword">this</span>.state.pos;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isLookahead) <span class="keyword">this</span>.state.startLoc = <span class="keyword">this</span>.state.curPosition();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.pos &gt;= <span class="keyword">this</span>.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.finishToken(tt.eof);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curContext === ct.template) &#123;</span><br><span class="line">      <span class="comment">// 读取模板字符串Token</span></span><br><span class="line">      <span class="keyword">this</span>.readTmplToken();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 读取普通Token，codePointAtPos返回的是pos位置的字符的ASCII码</span></span><br><span class="line">      <span class="keyword">this</span>.getTokenFromCode(<span class="keyword">this</span>.codePointAtPos(<span class="keyword">this</span>.state.pos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-parseTopLevel"><a href="#4-parseTopLevel" class="headerlink" title="4. parseTopLevel"></a>4. parseTopLevel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseTopLevel(file: N.File, <span class="attr">program</span>: N.Program): N.File &#123;</span><br><span class="line">    file.program = <span class="keyword">this</span>.parseProgram(program);</span><br><span class="line">    file.comments = <span class="keyword">this</span>.state.comments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.tokens) file.tokens = babel7CompatTokens(<span class="keyword">this</span>.tokens);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.finishNode(file, <span class="string">"File"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里会继续调用<code>parseProgram</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseProgram(</span><br><span class="line">    program: N.Program,</span><br><span class="line">    end: TokenType = tt.eof,</span><br><span class="line">    sourceType: SourceType = <span class="keyword">this</span>.options.sourceType,</span><br><span class="line">  ): N.Program &#123;</span><br><span class="line">    program.sourceType = sourceType;</span><br><span class="line">    program.interpreter = <span class="keyword">this</span>.parseInterpreterDirective();</span><br><span class="line">    <span class="keyword">this</span>.parseBlockBody(program, <span class="literal">true</span>, <span class="literal">true</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.inModule &amp;&amp;</span><br><span class="line">      !<span class="keyword">this</span>.options.allowUndeclaredExports &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>.scope.undefinedExports.size &gt; <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> [name] <span class="keyword">of</span> <span class="built_in">Array</span>.from(<span class="keyword">this</span>.scope.undefinedExports)) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="keyword">this</span>.scope.undefinedExports.get(name);</span><br><span class="line">        <span class="comment">// $FlowIssue</span></span><br><span class="line">        <span class="keyword">this</span>.raise(pos, Errors.ModuleExportUndefined, name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.finishNode&lt;N.Program&gt;(program, <span class="string">"Program"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再调用<code>parseBlockBody</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseBlockBody(</span><br><span class="line">    node: N.BlockStatementLike,</span><br><span class="line">    allowDirectives: ?boolean,</span><br><span class="line">    topLevel: boolean,</span><br><span class="line">    end: TokenType,</span><br><span class="line">    afterBlockParse?: <span class="function">(<span class="params">hasStrictModeDirective: boolean</span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = (node.body = []);</span><br><span class="line">    <span class="keyword">const</span> directives = (node.directives = []);</span><br><span class="line">    <span class="keyword">this</span>.parseBlockOrModuleBlockBody(</span><br><span class="line">      body,</span><br><span class="line">      allowDirectives ? directives : <span class="literal">undefined</span>,</span><br><span class="line">      topLevel,</span><br><span class="line">      end,</span><br><span class="line">      afterBlockParse,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继续调用<code>parseBlockOrModuleBlockBody</code>，最终进入递归，通过parserStatement，next等函数去不断递归调用nextToken，直到将一开始parser方法传入的字符串完全解析完。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseBlockOrModuleBlockBody(</span><br><span class="line">    body: N.Statement[],</span><br><span class="line">    directives: ?(N.Directive[]),</span><br><span class="line">    topLevel: boolean,</span><br><span class="line">    end: TokenType,</span><br><span class="line">    afterBlockParse?: <span class="function">(<span class="params">hasStrictModeDirective: boolean</span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> oldStrict = <span class="keyword">this</span>.state.strict;</span><br><span class="line">    <span class="keyword">let</span> hasStrictModeDirective = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> parsedNonDirective = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.match(end)) &#123;</span><br><span class="line">      <span class="keyword">const</span> stmt = <span class="keyword">this</span>.parseStatement(<span class="literal">null</span>, topLevel);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (directives &amp;&amp; !parsedNonDirective) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isValidDirective(stmt)) &#123;</span><br><span class="line">          <span class="keyword">const</span> directive = <span class="keyword">this</span>.stmtToDirective(stmt);</span><br><span class="line">          directives.push(directive);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            !hasStrictModeDirective &amp;&amp;</span><br><span class="line">            directive.value.value === <span class="string">"use strict"</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            hasStrictModeDirective = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.setStrict(<span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parsedNonDirective = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// clear strict errors since the strict mode will not change within the block</span></span><br><span class="line">        <span class="keyword">this</span>.state.strictErrors.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      body.push(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afterBlockParse) &#123;</span><br><span class="line">      afterBlockParse.call(<span class="keyword">this</span>, hasStrictModeDirective);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldStrict) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setStrict(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.next();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用一个简单的图来表示，大概就是这样，省略了很多细节</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1625014272/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210630085034_nq6abs.png" alt></p>
<h2 id="nextToken方法解析"><a href="#nextToken方法解析" class="headerlink" title="nextToken方法解析"></a>nextToken方法解析</h2><h3 id="readTmplToken读取模板字符串"><a href="#readTmplToken读取模板字符串" class="headerlink" title="readTmplToken读取模板字符串"></a>readTmplToken读取模板字符串</h3><p>这是我根据代码分析出来的状态机</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1625100732/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210701085141_jdhpvd.png" alt></p>
<p>我们尝试下看看结果</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1625101028/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210701085657_sxvzrs.png" alt></p>
<h3 id="getTokenFromCode"><a href="#getTokenFromCode" class="headerlink" title="getTokenFromCode"></a>getTokenFromCode</h3><p>这个函数逻辑上来讲不复杂，但是条件分之特别多，因为需要适配各种不同的字符去判断，简单展示下：</p>
<h4 id="charcodes"><a href="#charcodes" class="headerlink" title="charcodes"></a>charcodes</h4><p>代码中用到的各种charCodes，是另外一个仓库的内容，这是链接：<a href="https://github.com/xtuc/charcodes/blob/master/packages/charcodes/src/index.js" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/xtuc/charcodes/blob/master/packages/charcodes/src/index.js</a></p>
<h4 id="TokenType"><a href="#TokenType" class="headerlink" title="TokenType"></a>TokenType</h4><p>而finishToken的参数其实是一个个内置好的TokenType，如<code>tt.parentL</code>其实就是<code>parenL: new TokenType(&quot;(&quot;, { beforeExpr, startsExpr }),</code></p>
<p>这些TokenType就是所有babel内置的token类型，而TokenType来源有两个， 一个是Tokenizer内置的，另一种就是parser的plugin提供的，但是我们也说过，parser的plugin对于用户来说只是个开关，所以本质上，所有的TokenType都是babel-praser一开始内置好的。</p>
<p>主要分为四类，一类是变量类型，如number，string，一类是符号，如括号，冒号之类，一类是表达式，如等于，大于，最后就是关键字，如switch，case等</p>
<h4 id="函数逻辑"><a href="#函数逻辑" class="headerlink" title="函数逻辑"></a>函数逻辑</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getTokenFromCode(code: number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">      <span class="comment">// The interpretation of a dot depends on whether it is followed</span></span><br><span class="line">      <span class="comment">// by a digit or another two dots.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> charCodes.dot:</span><br><span class="line">        <span class="keyword">this</span>.readToken_dot();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Punctuation tokens.</span></span><br><span class="line">      <span class="keyword">case</span> charCodes.leftParenthesis:</span><br><span class="line">        ++<span class="keyword">this</span>.state.pos;</span><br><span class="line">        <span class="keyword">this</span>.finishToken(tt.parenL);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> charCodes.rightParenthesis:</span><br><span class="line">        ++<span class="keyword">this</span>.state.pos;</span><br><span class="line">        <span class="keyword">this</span>.finishToken(tt.parenR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> charCodes.semicolon:</span><br><span class="line">        ++<span class="keyword">this</span>.state.pos;</span><br><span class="line">        <span class="keyword">this</span>.finishToken(tt.semi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> charCodes.comma:</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这里省略几十种条件</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (isIdentifierStart(code)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.readWord(code);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">this</span>.raise(</span><br><span class="line">      <span class="keyword">this</span>.state.pos,</span><br><span class="line">      Errors.InvalidOrUnexpectedToken,</span><br><span class="line">      <span class="built_in">String</span>.fromCodePoint(code),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="parseTopLevel方法解析"><a href="#parseTopLevel方法解析" class="headerlink" title="parseTopLevel方法解析"></a>parseTopLevel方法解析</h2><p>在一开始的流程解析中，我们要看到了，这个函数的主要逻辑在<code>parseBlockOrModuleBlockBody</code>函数中，我们就先来看看这个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseBlockOrModuleBlockBody(</span><br><span class="line">    body: N.Statement[],</span><br><span class="line">    directives: ?(N.Directive[]),</span><br><span class="line">    topLevel: boolean,</span><br><span class="line">    end: TokenType,</span><br><span class="line">    afterBlockParse?: <span class="function">(<span class="params">hasStrictModeDirective: boolean</span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">  ): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> oldStrict = <span class="keyword">this</span>.state.strict;</span><br><span class="line">    <span class="keyword">let</span> hasStrictModeDirective = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> parsedNonDirective = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.match(end)) &#123;</span><br><span class="line">      <span class="keyword">const</span> stmt = <span class="keyword">this</span>.parseStatement(<span class="literal">null</span>, topLevel);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (directives &amp;&amp; !parsedNonDirective) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isValidDirective(stmt)) &#123;</span><br><span class="line">          <span class="keyword">const</span> directive = <span class="keyword">this</span>.stmtToDirective(stmt);</span><br><span class="line">          directives.push(directive);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            !hasStrictModeDirective &amp;&amp;</span><br><span class="line">            directive.value.value === <span class="string">"use strict"</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            hasStrictModeDirective = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.setStrict(<span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parsedNonDirective = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// clear strict errors since the strict mode will not change within the block</span></span><br><span class="line">        <span class="keyword">this</span>.state.strictErrors.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      body.push(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (afterBlockParse) &#123;</span><br><span class="line">      afterBlockParse.call(<span class="keyword">this</span>, hasStrictModeDirective);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldStrict) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setStrict(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.next();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数看起来不短，但是主要逻辑就是while循环，只要满足<code>!this.match(end)</code>就会一直解析，这个end其实就是tt.eof，也就是我们刚才TokenType中的一种，表示文件结束。</p>
<p>循环体 主要内容就是两个<code>const stmt = this.parseStatement(null, topLevel);</code>和<code>body.push(stmt);</code>，这个stmt就是一个AST的Node</p>
<h3 id="parseStatement"><a href="#parseStatement" class="headerlink" title="parseStatement"></a>parseStatement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseStatement(context: ?string, topLevel?: boolean): N.Statement &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.match(tt.at)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseDecorators(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseStatementContent(context, topLevel);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第一行就是判断当前是否是@，如果是，那就是装饰器，这个暂时不管</p>
<p>我们看看这个<code>parseStatementContent</code></p>
<h3 id="parseStatementContent"><a href="#parseStatementContent" class="headerlink" title="parseStatementContent"></a>parseStatementContent</h3><p>这个函数就很像刚才的Tokenizer中的<code>getTokenFromCode</code>了，<code>getTokenFromCode</code>是根据code生成各种不同类型的token，而<code>parseStatementContent</code>是根据不同类型的token去生成AST Node。</p>
<p>然后在解析过程中，有些特殊情况，会重新去调用Tokenizer的nextToken继续去生成新的token，比如解析到import</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseStatementContent(context: ?string, <span class="attr">topLevel</span>: ?boolean): N.Statement &#123;</span><br><span class="line">    <span class="keyword">let</span> starttype = <span class="keyword">this</span>.state.type;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">this</span>.startNode();</span><br><span class="line">    <span class="keyword">let</span> kind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isLet(context)) &#123;</span><br><span class="line">      starttype = tt._var;</span><br><span class="line">      kind = <span class="string">"let"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most types of statements are recognized by the keyword they</span></span><br><span class="line">    <span class="comment">// start with. Many are trivial to parse, some require a bit of</span></span><br><span class="line">    <span class="comment">// complexity.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (starttype) &#123;</span><br><span class="line">      <span class="keyword">case</span> tt._break:</span><br><span class="line">      <span class="keyword">case</span> tt._continue:</span><br><span class="line">        <span class="comment">// $FlowFixMe</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseBreakContinueStatement(node, starttype.keyword);</span><br><span class="line">      <span class="keyword">case</span> tt._debugger:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseDebuggerStatement(node);</span><br><span class="line">      <span class="keyword">case</span> tt._do:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseDoStatement(node);</span><br><span class="line">      <span class="keyword">case</span> tt._for:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parseForStatement(node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略各种tokenType的判断</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isAsyncFunction()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (context) &#123;</span><br><span class="line">            <span class="keyword">this</span>.raise(</span><br><span class="line">              <span class="keyword">this</span>.state.start,</span><br><span class="line">              Errors.AsyncFunctionInSingleStatementContext,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.next(); <span class="comment">// 这里又会去调用Tokenizer的nextToken方法</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.parseFunctionStatement(node, <span class="literal">true</span>, !context);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the statement does not start with a statement keyword or a</span></span><br><span class="line">    <span class="comment">// brace, it's an ExpressionStatement or LabeledStatement. We</span></span><br><span class="line">    <span class="comment">// simply start parsing an expression, and afterwards, if the</span></span><br><span class="line">    <span class="comment">// next token is a colon and the expression was a simple</span></span><br><span class="line">    <span class="comment">// Identifier node, we switch to interpreting it as a label.</span></span><br><span class="line">    <span class="keyword">const</span> maybeName = <span class="keyword">this</span>.state.value;</span><br><span class="line">    <span class="keyword">const</span> expr = <span class="keyword">this</span>.parseExpression();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      starttype === tt.name &amp;&amp;</span><br><span class="line">      expr.type === <span class="string">"Identifier"</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>.eat(tt.colon)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.parseLabeledStatement(node, maybeName, expr, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.parseExpressionStatement(node, expr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Babel</category>
      </categories>
  </entry>
  <entry>
    <title>深入Babel原理系列（三）Tokenizer</title>
    <url>/2021/07/03/babel-tokenizer/</url>
    <content><![CDATA[<p>上一个博客大概讲了下babel-parser的工作流程，主要有两个内容，一个是Tokenizer把代码字符串拆分成Token数组，一个是parser把Token数组转换为AST树。</p>
<p>这一次就来仔细看看Tokenizer的逻辑。</p>
<a id="more"></a>

<p>Tokenizer的源码只有四个文件，分别是context.js，index.js，state.js，type.js，我们一个个来分析。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>首先是type.js，顾名思义，这个文件中定义了所有Token的type</p>
<p>先看看TokenType的定义，注意，官方注释很重要，便于我们理解这些变量存在的意义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The `beforeExpr` property is used to disambiguate between 1) binary</span></span><br><span class="line"><span class="comment">// expression (&lt;) and JSX Tag start (&lt;name&gt;); 2) object literal and JSX</span></span><br><span class="line"><span class="comment">// texts. It is set on the `updateContext` function in the JSX plugin.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The `startsExpr` property is used to determine whether an expression</span></span><br><span class="line"><span class="comment">// may be the “argument” subexpression of a `yield` expression or</span></span><br><span class="line"><span class="comment">// `yield` statement. It is set on all token types that may be at the</span></span><br><span class="line"><span class="comment">// start of a subexpression.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `isLoop` marks a keyword as starting a loop, which is important</span></span><br><span class="line"><span class="comment">// to know when parsing a label, in order to allow or disallow</span></span><br><span class="line"><span class="comment">// continue jumps to that label.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beforeExpr = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> startsExpr = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> isLoop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> isAssign = <span class="literal">true</span>; <span class="comment">// 该Token可以是否标志着赋值，如=</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="literal">true</span>; <span class="comment">// 该Token是否可以是一个一元表达式的前缀，如！</span></span><br><span class="line"><span class="keyword">const</span> postfix = <span class="literal">true</span>; <span class="comment">// 该Token是否可以是一个一元表达式的后缀，如++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TokenOptions = &#123;</span><br><span class="line">  keyword?: <span class="built_in">string</span>,</span><br><span class="line">  beforeExpr?: <span class="built_in">boolean</span>,</span><br><span class="line">  startsExpr?: <span class="built_in">boolean</span>,</span><br><span class="line">  rightAssociative?: <span class="built_in">boolean</span>,</span><br><span class="line">  isLoop?: <span class="built_in">boolean</span>,</span><br><span class="line">  isAssign?: <span class="built_in">boolean</span>,</span><br><span class="line">  prefix?: <span class="built_in">boolean</span>,</span><br><span class="line">  postfix?: <span class="built_in">boolean</span>,</span><br><span class="line">  binop?: ?<span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TokenType &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">  keyword: ?<span class="built_in">string</span>;</span><br><span class="line">  beforeExpr: <span class="built_in">boolean</span>;</span><br><span class="line">  startsExpr: <span class="built_in">boolean</span>;</span><br><span class="line">  rightAssociative: <span class="built_in">boolean</span>;</span><br><span class="line">  isLoop: <span class="built_in">boolean</span>;</span><br><span class="line">  isAssign: <span class="built_in">boolean</span>;</span><br><span class="line">  prefix: <span class="built_in">boolean</span>;</span><br><span class="line">  postfix: <span class="built_in">boolean</span>;</span><br><span class="line">  binop: ?<span class="built_in">number</span>;</span><br><span class="line">  updateContext: ?<span class="function">(<span class="params">context: <span class="built_in">Array</span>&lt;TokContext&gt;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">label: <span class="built_in">string</span>, conf: TokenOptions = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label;</span><br><span class="line">    <span class="keyword">this</span>.keyword = conf.keyword;</span><br><span class="line">    <span class="keyword">this</span>.beforeExpr = !!conf.beforeExpr;</span><br><span class="line">    <span class="keyword">this</span>.startsExpr = !!conf.startsExpr;</span><br><span class="line">    <span class="keyword">this</span>.rightAssociative = !!conf.rightAssociative;</span><br><span class="line">    <span class="keyword">this</span>.isLoop = !!conf.isLoop;</span><br><span class="line">    <span class="keyword">this</span>.isAssign = !!conf.isAssign;</span><br><span class="line">    <span class="keyword">this</span>.prefix = !!conf.prefix;</span><br><span class="line">    <span class="keyword">this</span>.postfix = !!conf.postfix;</span><br><span class="line">    <span class="keyword">this</span>.binop = conf.binop != <span class="literal">null</span> ? conf.binop : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.updateContext = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构相对来讲还不是很复杂，但是这些参数一时之间我们可能也看不出所有的用意，没关系，我们看看几个具体的例子，来分析：</p>
<p>在分析具体的例子前，我们可以先看两个工具方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> keywords = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;string, TokenType&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyword</span>(<span class="params">name: string, options: TokenOptions = &#123;&#125;</span>): <span class="title">TokenType</span> </span>&#123;</span><br><span class="line">  options.keyword = name;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">new</span> TokenType(name, options);</span><br><span class="line">  keywords.set(name, token);</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBinop</span>(<span class="params">name: string, binop: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TokenType(name, &#123; beforeExpr, binop &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个createKeyword就是创建一个keyword类型的TokenType，结合上面的代码，我们能看出来，keyword类型的TokenType一个比较特殊的地方，是它的keyword变量有值，而且值和label相同。</p>
<p>createBinop的作用是创建一个二元表达式类型，其特点就是beforeExpr是true，且binop有具体的值</p>
<p>好了，看完这些，我们就来看看几个具体的例子</p>
<p>首先是基本的变量类型的Type，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">num: <span class="keyword">new</span> TokenType(<span class="string">"num"</span>, &#123; startsExpr &#125;),</span><br><span class="line">bigint: <span class="keyword">new</span> TokenType(<span class="string">"bigint"</span>, &#123; startsExpr &#125;),</span><br></pre></td></tr></table></figure>

<p>然后是符号类型的Type</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bracketL: <span class="keyword">new</span> TokenType(<span class="string">"["</span>, &#123; beforeExpr, startsExpr &#125;),</span><br><span class="line">bracketR: <span class="keyword">new</span> TokenType(<span class="string">"]"</span>),</span><br><span class="line">question: <span class="keyword">new</span> TokenType(<span class="string">"?"</span>, &#123; beforeExpr &#125;),</span><br></pre></td></tr></table></figure>

<p>运算符类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eq: <span class="keyword">new</span> TokenType(<span class="string">"="</span>, &#123; beforeExpr, isAssign &#125;),</span><br><span class="line">incDec: <span class="keyword">new</span> TokenType(<span class="string">"++/--"</span>, &#123; prefix, postfix, startsExpr &#125;),</span><br><span class="line">pipeline: createBinop(<span class="string">"|&gt;"</span>, <span class="number">0</span>),</span><br><span class="line">nullishCoalescing: createBinop(<span class="string">"??"</span>, <span class="number">1</span>),</span><br></pre></td></tr></table></figure>

<p>关键字类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_break: createKeyword(<span class="string">"break"</span>),</span><br><span class="line">_case: createKeyword(<span class="string">"case"</span>, &#123; beforeExpr &#125;),</span><br><span class="line">_default: createKeyword(<span class="string">"default"</span>, &#123; beforeExpr &#125;),</span><br><span class="line">_do: createKeyword(<span class="string">"do"</span>, &#123; isLoop, beforeExpr &#125;),</span><br></pre></td></tr></table></figure>

<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>刚才Type还有一个updateContext没有讲，这个函数与context.js有关，给JSX插件用的。我们一起来看一下</p>
<p>一开始，注释里就说了，context是做什么的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The token context is used to track whether the apostrophe "`"</span></span><br><span class="line"><span class="comment">// starts or ends a string template</span></span><br></pre></td></tr></table></figure>

<p>就是用来分析模板字符串的，它的类型定义更加简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TokContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(token: string, preserveSpace?: boolean) &#123;</span><br><span class="line">    <span class="keyword">this</span>.token = token;</span><br><span class="line">    <span class="keyword">this</span>.preserveSpace = !!preserveSpace;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  token: string;</span><br><span class="line">  preserveSpace: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个types指的是分析模板字符串过程中可以又嵌套的模板字符串，所以有个context的栈，用来检测所有的模板字符串是否闭合的，这个栈中只有两种类型的数据，一种是花括号，一种是反引号</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> types: &#123;</span><br><span class="line">  [key: string]: TokContext,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  brace: <span class="keyword">new</span> TokContext(<span class="string">"&#123;"</span>),</span><br><span class="line">  template: <span class="keyword">new</span> TokContext(<span class="string">"`"</span>, <span class="literal">true</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后剩下的所有代码就是给刚才所有type中会和模板字符串扯上关系的type添加updateContext方法来维护解析过程中的contex栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">backQuote: new TokenType("`", &#123; startsExpr &#125;),</span></span><br><span class="line"><span class="comment">braceL: new TokenType("&#123;", &#123; beforeExpr, startsExpr &#125;),</span></span><br><span class="line"><span class="comment">braceHashL: new TokenType("#&#123;", &#123; beforeExpr, startsExpr &#125;),</span></span><br><span class="line"><span class="comment">dollarBraceL: new TokenType("$&#123;", &#123; beforeExpr, startsExpr &#125;),</span></span><br><span class="line"><span class="comment">braceR: new TokenType("&#125;", &#123; beforeExpr &#125;),</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">tt.braceR.updateContext = <span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">  context.pop();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we don't need to update context for tt.braceBarL because we do not pop context for tt.braceBarR</span></span><br><span class="line"><span class="comment">// ideally only dollarBraceL "$&#123;" needs a non-template context</span></span><br><span class="line"><span class="comment">// in order to indicate that the last "`" in `$&#123;`" starts a new string template</span></span><br><span class="line"><span class="comment">// inside a template element within outer string template.</span></span><br><span class="line"><span class="comment">// but when we popped such context in `&#125;`, we lost track of whether this</span></span><br><span class="line"><span class="comment">// `&#125;` matches a `$&#123;` or other tokens matching `&#125;`, so we have to push</span></span><br><span class="line"><span class="comment">// such context in every token that `&#125;` will match.</span></span><br><span class="line">tt.braceL.updateContext =</span><br><span class="line">  tt.braceHashL.updateContext =</span><br><span class="line">  tt.dollarBraceL.updateContext =</span><br><span class="line">    context =&gt; &#123;</span><br><span class="line">      context.push(types.brace);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">tt.backQuote.updateContext = <span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当解析到反引号的时候，看看当前的栈顶是不是模板类型，如果是，那就说明上一个反引号已经进过栈了，也就是走过一次else逻辑了，那这时候就把上次进栈的template弹出来。</span></span><br><span class="line">  <span class="keyword">if</span> (context[context.length - <span class="number">1</span>] === types.template) &#123;</span><br><span class="line">    context.pop();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context.push(types.template);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>这个文件中定义的是解析过程中的状态，包括当前解析到了那个位置，哪一行，那一列，第几个字符等等。</p>
<p>这个文件所有的内容都是在声明这个state的class，所以接下来所有的代码都是在这个类中的。</p>
<p>首先是初始化函数，这个类没有构造函数，倒是有个初始化函数，需要调用者自己调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">strict: boolean;</span><br><span class="line">curLine: number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// And, if locations are used, the &#123;line, column&#125; object</span></span><br><span class="line"><span class="comment">// corresponding to those offsets</span></span><br><span class="line">startLoc: Position;</span><br><span class="line">endLoc: Position;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current position of the tokenizer in the input.</span></span><br><span class="line">pos: number = <span class="number">0</span>;</span><br><span class="line">lineStart: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">init(options: Options): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.strict =</span><br><span class="line">    options.strictMode === <span class="literal">false</span> ? <span class="literal">false</span> : options.sourceType === <span class="string">"module"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.curLine = options.startLine;</span><br><span class="line">  <span class="keyword">this</span>.startLoc = <span class="keyword">this</span>.endLoc = <span class="keyword">this</span>.curPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个初始化函数做的事很简单，首先是对严格模式的一个判断和保存</p>
<p>另一个就是初始化curLine为传入的开始行，这个curLine会在后面解析过程中不断变化</p>
<p>最后就是初始化startLoc和endLoc，这两个值在后面不会再发生变化了，最起码在state类中没有方法去改变它，在以后继续看的时候如果看到了哪里改变了，我再回来更新。</p>
<p>而这个curPosition函数也很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curPosition(): Position &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Position(<span class="keyword">this</span>.curLine, <span class="keyword">this</span>.pos - <span class="keyword">this</span>.lineStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Position的第一个参数是行数，第二个参数是列数</p>
<p>这个curLine在之前刚被初始化为startLine，而pos和lineStart没有在之前被赋值，所以都是0</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>除了上面两个函数，还有一个clone函数，用来深复制State的，没什么特别逻辑，放在这里，有兴趣的可以看看。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clone(skipArrays?: boolean): State &#123;</span><br><span class="line">   <span class="keyword">const</span> state = <span class="keyword">new</span> State();</span><br><span class="line">   <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> key = keys[i];</span><br><span class="line">     <span class="comment">// $FlowIgnore</span></span><br><span class="line">     <span class="keyword">let</span> val = <span class="keyword">this</span>[key];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!skipArrays &amp;&amp; <span class="built_in">Array</span>.isArray(val)) &#123;</span><br><span class="line">       val = val.slice();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $FlowIgnore</span></span><br><span class="line">     state[key] = val;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> state;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>State中有大量的属性，都是用来保存解析状态，并生成AST的，很多属性直接说，感受不到用处，就补充几个一看就知道做什么的属性吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The current position of the tokenizer in the input.</span></span><br><span class="line"> pos: number = <span class="number">0</span>;</span><br><span class="line"> lineStart: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Properties of the current token:</span></span><br><span class="line"> <span class="comment">// Its type</span></span><br><span class="line"> type: TokenType = tt.eof;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// For tokens that include more information than their type, the value</span></span><br><span class="line"> value: any = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Its start and end offset</span></span><br><span class="line"> start: number = <span class="number">0</span>;</span><br><span class="line"> end: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Position information for the previous token</span></span><br><span class="line"> <span class="comment">// $FlowIgnore this is initialized when generating the second token.</span></span><br><span class="line"> lastTokEndLoc: Position = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// $FlowIgnore this is initialized when generating the second token.</span></span><br><span class="line"> lastTokStartLoc: Position = <span class="literal">null</span>;</span><br><span class="line"> lastTokStart: number = <span class="number">0</span>;</span><br><span class="line"> lastTokEnd: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// The context stack is used to track whether the apostrophe "`" starts</span></span><br><span class="line"> <span class="comment">// or ends a string template</span></span><br><span class="line"> context: <span class="built_in">Array</span>&lt;TokContext&gt; = [ct.brace];</span><br><span class="line"> <span class="comment">// Used to track whether a JSX element is allowed to form</span></span><br><span class="line"> exprAllowed: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Used to signal to callers of `readWord1` whether the word</span></span><br><span class="line"> <span class="comment">// contained any escape sequences. This is needed because words with</span></span><br><span class="line"> <span class="comment">// escape sequences must not be interpreted as keywords.</span></span><br><span class="line"> containsEsc: boolean = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// This property is used to track the following errors</span></span><br><span class="line"> <span class="comment">// - StrictNumericEscape</span></span><br><span class="line"> <span class="comment">// - StrictOctalLiteral</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// in a literal that occurs prior to/immediately after a "use strict" directive.</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// todo(JLHwung): set strictErrors to null and avoid recording string errors</span></span><br><span class="line"> <span class="comment">// after a non-directive is parsed</span></span><br><span class="line"> strictErrors: <span class="built_in">Map</span>&lt;number, ErrorTemplate&gt; = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Tokens length in token store</span></span><br><span class="line"> tokensLength: number = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>最后就是Tokenizer的主逻辑了，接近1600行，我们来慢慢分析。</p>
<p>其实代码虽多，但是核心思路不复杂，首先就是构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isLookahead: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Token store.</span></span><br><span class="line">tokens: <span class="built_in">Array</span>&lt;Token | N.Comment&gt; = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(options: Options, input: string) &#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="keyword">new</span> State();</span><br><span class="line">  <span class="keyword">this</span>.state.init(options);</span><br><span class="line">  <span class="keyword">this</span>.input = input;</span><br><span class="line">  <span class="keyword">this</span>.length = input.length;</span><br><span class="line">  <span class="keyword">this</span>.isLookahead = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是初始化了State，并且调用了init函数。</p>
<p>然后就是几个解析的入口函数，也就是那些被外界调用方法，如next等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pushToken(token: Token | N.Comment) &#123;</span><br><span class="line">    <span class="comment">// Pop out invalid tokens trapped by try-catch parsing.</span></span><br><span class="line">    <span class="comment">// Those parsing branches are mainly created by typescript and flow plugins.</span></span><br><span class="line">    <span class="keyword">this</span>.tokens.length = <span class="keyword">this</span>.state.tokensLength;</span><br><span class="line">    <span class="keyword">this</span>.tokens.push(token);</span><br><span class="line">    ++<span class="keyword">this</span>.state.tokensLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move to the next token</span></span><br><span class="line"></span><br><span class="line">  next(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkKeywordEscapes();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.tokens) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pushToken(<span class="keyword">new</span> Token(<span class="keyword">this</span>.state));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state.lastTokEnd = <span class="keyword">this</span>.state.end;</span><br><span class="line">    <span class="keyword">this</span>.state.lastTokStart = <span class="keyword">this</span>.state.start;</span><br><span class="line">    <span class="keyword">this</span>.state.lastTokEndLoc = <span class="keyword">this</span>.state.endLoc;</span><br><span class="line">    <span class="keyword">this</span>.state.lastTokStartLoc = <span class="keyword">this</span>.state.startLoc;</span><br><span class="line">    <span class="keyword">this</span>.nextToken();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">  eat(type: TokenType): boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.match(type)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.next();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">  match(type: TokenType): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state.type === type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>nextToken我们上篇博客讲了，主要就是两个，一个是分析模板字符串，一个是getTokenFromCode，主要就是这个getTokenFromCode，判断了各种情况，然后调用不同的方法，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Anything else beginning with a digit is an integer, octal</span></span><br><span class="line"><span class="comment">// number, or float. (fall through)</span></span><br><span class="line"><span class="keyword">case</span> charCodes.digit1:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit2:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit3:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit4:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit5:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit6:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit7:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit8:</span><br><span class="line"><span class="keyword">case</span> charCodes.digit9:</span><br><span class="line">  <span class="keyword">this</span>.readNumber(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quotes produce strings.</span></span><br><span class="line"><span class="keyword">case</span> charCodes.quotationMark:</span><br><span class="line"><span class="keyword">case</span> charCodes.apostrophe:</span><br><span class="line">  <span class="keyword">this</span>.readString(code);</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>还有大量其他的函数，如readRegexp读取正则，readEscapedChar等等，大部分代码都是这种，每个内部都像我上个博客讲的读取模板字符串那样，内部是个小的状态机。</p>
]]></content>
      <categories>
        <category>Babel</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2020/03/28/backtracking-algorithm/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>最近在做题的时候遇到了好几次回溯算法，每次都是慢慢试出来的，所以就去找一下有没有什么抽象出来的思路可以参考，于是找了很多文章，这里摘录一片最基础但也是最清楚的文章，原文链接是<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" rel="external nofollow noopener noreferrer" target="_blank">这个</a>。</p>
<p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：</p>
<p>1、路径：也就是已经做出的选择。</p>
<p>2、选择列表：也就是你当前可以做的选择。</p>
<p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
<a id="more"></a>

<p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p>
<p>代码方面，回溯算法的框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。</p>
<p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><p>我们在高中的时候就做过排列组合的数学题，我们也知道 n 个不重复的数，全排列共有 n! 个。</p>
<p>PS：为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字。</p>
<p>那么我们当时是怎么穷举全排列的呢？比方说给三个数 [1,2,3]，你肯定不会无规律地乱穷举，一般是这样：</p>
<p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032281/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215193732_x2lnqw.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032281/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215193732_x2lnqw.png"></p>
<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。</p>
<p>为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032359/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215193902_cao7zo.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032359/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215193902_cao7zo.png"></p>
<p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p>现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p>
<p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032609/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215194319_ri7upg.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032609/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215194319_ri7upg.png"></p>
<p>我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。</p>
<p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p>
<p>void traverse(TreeNode root) {<br>    for (TreeNode child : root.childern)<br>        // 前序遍历需要的操作<br>        traverse(child);<br>        // 后序遍历需要的操作<br>}<br>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点</p>
<p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p>
<p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032818/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215194648_rfi3ci.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608032818/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215194648_rfi3ci.png"></p>
<p>现在，你是否理解了回溯算法的这段核心框架？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<p>我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。</p>
<p>自己实现的JavaScript代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">nums, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generate = <span class="function">(<span class="params">nums, output, n, first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (first === n) &#123;</span><br><span class="line">        output.push([...nums]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">        swap(nums, i, first);</span><br><span class="line">        generate(nums, output, n, first + <span class="number">1</span>);</span><br><span class="line">        swap(nums, i, first);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = [];</span><br><span class="line">    generate(nums, output, nums.length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>本文图片均来自于labuladong公众号</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>线性表基础总结</title>
    <url>/2021/08/25/basis-of-linear-list/</url>
    <content><![CDATA[<p>这两个周重新拿出了大学的数据结构与算法看了看，看完了第二章线性表的部分，又有些新的收获吧，总结一下。</p>
<a id="more"></a>

<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是信息的载体，是描述客观事物属性的数，字符及所有能输入到计算机中并被计算机程序识别和处理的符号的合集。数据是计算机程序加工的原料。</p>
<h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><strong>数据元素</strong>是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个<strong>数据项</strong>组成，<strong>数据项是构成数据元素的不可分割的最小单位</strong>。例如，学生记录就是一个数据元素，它由学号，姓名等数据项组成。</p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。如整型对象就是集合N={0,1,2,…}</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p>
<ul>
<li>原子类型：其值不可再分的数据类型</li>
<li>结构类型：其值可以再分解为若干成分（分量）的数据类型</li>
<li>抽象数据类型：抽象数据组织及与之相关的操作</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是相互之间存在一种或者多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构.</p>
<p><strong>数据结构包括三方面的内容：逻辑结构，存储结构和数据的运算</strong>。</p>
<p>数据的逻辑结构和存储结构是密不可分的两个方面，<strong>一个算法的设计取决于所选的逻辑结构，而算法的实现，依赖所采用的存储结构</strong>。</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储结构无关，是独立于计算机的。</p>
<p>数据的逻辑结构分为线性结构和非线性结构。线性表是典型的线性结构。集合，树，图是典型的非线性结构。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629936472/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210826080632_xmnhbt.png" alt></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>存储结构是指数据结构在计算机中的表示，也成为物理结构。</p>
<p>主要有顺序存储，链式存储，索引存储和散列存储。</p>
<h2 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限序列</strong>。</p>
<p>线性表的特点：</p>
<ul>
<li>表中元素个数有限</li>
<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li>
<li>表中元素都是数据元素，每个元素都是单个元素。</li>
<li>表中元素的数据类型都相同，这意味着每个元素都占有相同大小的存储空间。</li>
<li>表中元素具有抽象性，即讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li>
</ul>
<blockquote>
<p><strong>线性表是一种逻辑结构，表示元素之间的一对一相邻关系。</strong></p>
<p><strong>顺序表和链表表示的是存储结构。</strong></p>
</blockquote>
<h2 id="看到的几个简单但巧妙的算法思想"><a href="#看到的几个简单但巧妙的算法思想" class="headerlink" title="看到的几个简单但巧妙的算法思想"></a>看到的几个简单但巧妙的算法思想</h2><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><p>从顺序表中删除其值在给定值s和t之间（包含s和t，要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。</p>
<p>算法思想：从前向后扫描顺序表L，用k记录下元素值在s到t之间元素的个数（初始时k=0），对于当前扫描的元素，若其值不再s和t之间，则前移k个位置，否则执行k++。由于这样，每个不在s到t之间的元素仅移动一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t</span><span class="params">(SqlList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length === <span class="number">0</span> || s &gt;= t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] &gt;= s &amp;&amp; L.data[i] &lt;= t) &#123;</span><br><span class="line">            k++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L.data[i - k] = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个算法中，i表示当前遍历到的节点，k表示0 - i 之间需要删除的节点的数量，也就意味着0 到 (i - k)之间是需要保留的节点，(i - k) 到 i之间是需要删除的几点。</p>
<p>这个关系，利用数学归纳法，在i等于0时开始，在接下来的遍历到每个节点都保证整个关系，那最后i为L.length时，最终数组的保留节点就应该是0到L.length-k</p>
<p>其实也可以用k表示需要保留的节点数量，那这段代码就变成了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t</span><span class="params">(SqlList &amp;L, ElemType s, ElemType t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length === <span class="number">0</span> || s &gt;= t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] &lt; s || L.data[i] &gt; t) &#123;</span><br><span class="line">            L.data[k++] = L.data[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h3><p>设将n个整数存放到一位数组R中。设计一个在时间和空间上都尽可能高效的算法。将R中保存的序列循环左移p个位置，即将R中的数据由（X0, X1, …, XR）变为(Xp, Xp+1, …. XR, X0, X1, … , Xp - 1)</p>
<p>算法思想：将这个问题视为把数组ab转化为ba，那么就先把a逆置得到a逆b，再将b逆置得到a逆b逆，最后将a逆b逆整个逆置，得到ba。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (to - from + <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = R[from + i];</span><br><span class="line">        R[from + i] = R[to - i];</span><br><span class="line">        R[to - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Converse</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    Reverse(R, <span class="number">0</span>, p - <span class="number">1</span>);</span><br><span class="line">    Reverse(R, p, n - <span class="number">1</span>);</span><br><span class="line">    Reverse(R, <span class="number">0</span>, n - <span class="number">1</span>);h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h3><p>设一个长度为L的升序序列S，处在第[L / 2]的位置的数称为S的中位数。例如升序序列S1（11，13,15，17,19），则其中位数为15。两个序列的中位数是包含他们所有元素的升序序列的中位数。例如S2（2,4,6,8,20），则S1和S2的中位数为11。现有两个等长的升序序列A和B。设计一个时间和空间上都高效的算法，找出A和B的中位数。</p>
<p>算法思想1：我们很容易想到第一种算法，因为A和B都是升序的，所以设置两个指针i，j，初始时指向A和B的第一个元素，然后每次比较A[i]和B[j]，如果A[i]小，则i++，如果B[j]小，则j++，当比较到第A.length次时，此时较小的就是A和B的中位数。这种算法的时间复杂度是O(n)</p>
<p>算法思想2：可以利用二分法提高效率。分别求两个升序序列A和B的中位数，设为a和b，求序列A和B的中位数的过程如下：</p>
<ul>
<li>若a=b，则a或者b即为中位数，返回结果。</li>
<li>如果a&lt;b，则舍弃A中较小的一半，同时舍弃B中较大的一半，要求两次舍弃的长度相等。</li>
<li>如果a&gt;b，则舍弃A中较大的一半，同时舍弃B中较小的一半，要求两次舍弃的长度相等。</li>
</ul>
<p>在保留两个升序序列中，重复上述三个过程，直到两个序列中均只含有一个元素位置，较小者即为所求中位数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">M_Search</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>, d1 = n - <span class="number">1</span>, m1, s2 = <span class="number">0</span>, d2 = n - <span class="number">1</span>, m2;</span><br><span class="line">    <span class="keyword">while</span>(s1 != d1 || s2 != d2) &#123;</span><br><span class="line">        m1 = (s1 + d1) / <span class="number">2</span>;</span><br><span class="line">        m2 = (s2 + d2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[m1] === B[m2]) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[m1]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[m1] &lt; B[m2]) &#123;</span><br><span class="line">            s1 = (s1 + d1) % <span class="number">2</span> === <span class="number">0</span> ? m1 : m1 + <span class="number">1</span>;</span><br><span class="line">            d2 = m2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d1 = m1;</span><br><span class="line">            s2 = (s2 + d2) % <span class="number">2</span> === <span class="number">0</span> ? m2 : m2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A[s1] &lt; B[s2] ? A[s1] : B[s2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>魔鬼的二分查找</title>
    <url>/2020/04/05/binary-search/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：<strong>思路很简单，细节是魔鬼</strong>。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 <code>mid</code> 加一还是减一，while 里到底用 <code>&lt;=</code> 还是 <code>&lt;</code>。</p>
<p>你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。</p>
<a id="more"></a>

<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;<span class="comment">// 可有效防止left + right溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;</strong>？</p>
<p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：<strong>前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</strong></p>
<p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>

<p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>总的来说，如果一开始的right是length - 1，那么你需要让left = right 这种情况也被搜索一遍，如果一开始right是length，left = right这种临界情况其实已经超出了数组的有效范围</strong></p>
<p><strong>2、为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断</strong>？</p>
<p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p>
<p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p>
<p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？<strong>因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除</strong>。</p>
<p><strong>3、此算法有什么缺陷</strong>？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见，<strong>你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p>
<h3 id="寻找左侧边界的二分查找"><a href="#寻找左侧边界的二分查找" class="headerlink" title="寻找左侧边界的二分查找"></a>寻找左侧边界的二分查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 中是 <code>&lt;</code> 而不是 <code>&lt;=</code></strong>?</p>
<p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p>
<p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p>
<p><strong>2、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p>
<p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p>
<p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。</p>
<p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p>
<p>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p>
<p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样</strong>？</p>
<p>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p>
<p><strong>4、为什么该算法能够搜索左侧边界</strong>？</p>
<p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure>

<p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p>
<p><strong>5、为什么返回 <code>left</code> 而不是 <code>right</code></strong>？</p>
<p>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p>
<p><strong>6、能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了</strong>。</p>
<p>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：</p>
<p>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    int left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    <span class="comment">// 收缩右侧边界</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p>
<p><a href="https://github.com/Sun668/fucking-algorithm/blob/master/pictures/二分查找/2.jpg" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://github.com/Sun668/fucking-algorithm/raw/master/pictures/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg" alt="img"></a></p>
<p>因此，最后返回结果的代码应该检查越界情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> left;</span><br></pre></td></tr></table></figure>

<p>至此，整个算法就写完了，完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p>
<h3 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">    int left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界的情况，见下图</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接： <a href="https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/二分查找详解.md" rel="external nofollow noopener noreferrer" target="_blank">二分法详解</a></p>
<h2 id="二分法变种（2021-04-08更新）"><a href="#二分法变种（2021-04-08更新）" class="headerlink" title="二分法变种（2021.04.08更新）"></a>二分法变种（2021.04.08更新）</h2><p>今天的leetcode每日一题是一道二分法的题目，但是不同于上面讲的这些二分法，在这里更新记录一下</p>
<p>这是题目链接：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<p>这里我就直接使用官方的题解来解答，只不过会对这个题解加以更加详细的解释</p>
<p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885648/origin-of-ray/1_nmfrw2.png" alt></p>
<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。</p>
<p>我们考虑数组中的最后一个元素 xx：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于 xx；而在最小值左侧的元素，它们的值一定都严格大于 xx。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p>
<p>在二分查找的每一步中，左边界为low，右边界为high，区间的中点为pivot，最小值就在该区间内。我们将中轴元素nums[pivot] 与右边界元素 nums[high] 进行比较，可能会有以下的三种情况：</p>
<p>第一种情况是nums[pivot]&lt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885675/origin-of-ray/2_anlru2.png" alt></p>
<p>第二种情况是nums[pivot]&gt;nums[high]。如下图所示，这说明 nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617885701/origin-of-ray/3_wizs40.png" alt></p>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与 high 重合；而如果当前的区间长度为 11，这说明我们已经可以结束二分查找了。因此不会存在 nums[pivot]=nums[high] 的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">const</span> pivot = low + <span class="built_in">Math</span>.floor((high - low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">            high = pivot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[low];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><p>看完上面那些解释，大家可能觉得自己明白了，但是还有几个问题我们需要思考一下：</p>
<ul>
<li><p>搜索区间是什么</p>
<blockquote>
<p>根据原理那部分所讲，由于high = nums.length - 1，所以搜索区间是[low, high]</p>
</blockquote>
</li>
<li><p>为什么是low &lt; high 的时候才执行，也就是说为什么low = high的时候不需要判断</p>
<blockquote>
<p>这是因为当low = high的时候，区间长度为1，那最小值就是这个唯一值，所以直接返回就好</p>
</blockquote>
</li>
<li><p>为什么是比较pivot和high而不是low</p>
<blockquote>
<p>左、中、右三个位置的值相比较，有以下几种情况：</p>
<p>左值 &lt; 中值, 中值 &lt; 右值 ：没有旋转，最小值在最左边，可以收缩右边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;     右</span><br><span class="line">&gt;   中</span><br><span class="line">&gt; 左</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>左值 &gt; 中值, 中值 &lt; 右值 ：有旋转，最小值在左半边，可以收缩右边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 左       </span><br><span class="line">&gt;     右</span><br><span class="line">&gt;   中</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>左值 &lt; 中值, 中值 &gt; 右值 ：有旋转，最小值在右半边，可以收缩左边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;   中  </span><br><span class="line">&gt; 左 </span><br><span class="line">&gt;     右</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>左值 &gt; 中值, 中值 &gt; 右值 ：单调递减，不可能出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 左</span><br><span class="line">&gt;  中</span><br><span class="line">&gt;    右</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>我们可以分析一下上面几种情况，比较中值和右值只分两种情况就好。中值大于左值还要再分两种情况</p>
</blockquote>
</li>
<li><p>为什么缩小区间时，high = pivot，而 low = pivot + 1</p>
<blockquote>
<p>因为当<code>nums[pivot] &lt; nums[high]</code>时，这个<code>nums[pivot]</code>还有可能是最小值，所以pivot仍然在搜索区间内。而当<code>nums[pivot] &gt; nums[high]</code>，<code>nums[pivot]</code>不可能是最小值</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Blob 与 大文件分片上传</title>
    <url>/2020/07/24/blob/</url>
    <content><![CDATA[<h2 id="Blob是什么"><a href="#Blob是什么" class="headerlink" title="Blob是什么"></a>Blob是什么</h2><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1595596596/js/image-20200724202124460_csorcu.png" alt="image-20200724202124460"></p>
<p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 <code>size</code> 属性用于表示数据的大小（以字节为单位），<code>type</code> 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 <code>File</code> 接口基于 <code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<a id="more"></a>

<h2 id="Blob-API-简介"><a href="#Blob-API-简介" class="headerlink" title="Blob API 简介"></a>Blob API 简介</h2><p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p>
<blockquote>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p>
<p>常见的 MIME 类型有：超文本标记语言文本 .html text/html、PNG图像 .png image/png、普通文本 .txt text/plain 等。</p>
</blockquote>
<p>相关的参数说明如下：</p>
<ul>
<li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p>
</li>
<li><p>options：一个可选的对象，包含以下两个属性：</p>
</li>
<li><ul>
<li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li>
<li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。它是以下两个值中的一个：<code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>前面我们已经知道 Blob 对象包含两个属性：</p>
<ul>
<li>size（只读）：表示 <code>Blob</code> 对象中所包含数据的大小（以字节为单位）。</li>
<li>type（只读）：一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。</li>
<li>stream()：返回一个能读取 blob 内容的 <code>ReadableStream</code>。</li>
<li>text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code>。</li>
<li>arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code>。</li>
</ul>
<p>这里我们需要注意的是，<strong><code>Blob</code> 对象是不可改变的</strong>。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。</p>
<h2 id="大文件分片上传（Vue）"><a href="#大文件分片上传（Vue）" class="headerlink" title="大文件分片上传（Vue）"></a>大文件分片上传（Vue）</h2><h3 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h3><h4 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h4><p>首先实现上传功能，上传需要做两件事</p>
<ul>
<li>对文件进行切片</li>
<li>将切片传输给服务端</li>
</ul>
<p>这里的File其实继承的就是Blob对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> @change=<span class="string">"handleFileChange"</span> /&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"handleUpload"</span>&gt;上传&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"> const SIZE = 10 * 1024 * 1024; /</span><span class="regexp">/ 切片大小</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data: () =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    container: &#123;</span></span><br><span class="line"><span class="regexp">      file: null</span></span><br><span class="line"><span class="regexp">    &#125;，</span></span><br><span class="line"><span class="regexp">   data: []</span></span><br><span class="line"><span class="regexp">  &#125;),</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    request() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    handleFileChange() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 生成文件切片</span></span><br><span class="line"><span class="regexp">    createFileChunk(file, size = SIZE) &#123;</span></span><br><span class="line"><span class="regexp">     const fileChunkList = [];</span></span><br><span class="line"><span class="regexp">      let cur = 0;</span></span><br><span class="line"><span class="regexp">      while (cur &lt; file.size) &#123;</span></span><br><span class="line"><span class="regexp">        fileChunkList.push(&#123; file: file.slice(cur, cur  size) &#125;);</span></span><br><span class="line"><span class="regexp">        cur = size;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      return fileChunkList;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">   /</span><span class="regexp">/ 上传切片</span></span><br><span class="line"><span class="regexp">    async uploadChunks() &#123;</span></span><br><span class="line"><span class="regexp">      const requestList = this.data</span></span><br><span class="line"><span class="regexp">        .map((&#123; chunk，hash &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          const formData = new FormData();</span></span><br><span class="line"><span class="regexp">          formData.append("chunk", chunk);</span></span><br><span class="line"><span class="regexp">          formData.append("hash", hash);</span></span><br><span class="line"><span class="regexp">          formData.append("filename", this.container.file.name);</span></span><br><span class="line"><span class="regexp">          return &#123; formData &#125;;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        .map(async (&#123; formData &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">          this.request(&#123;</span></span><br><span class="line"><span class="regexp">            url: "http:/</span><span class="regexp">/localhost:3000",</span></span><br><span class="line"><span class="regexp">            data: formData</span></span><br><span class="line"><span class="regexp">          &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      await Promise.all(requestList); /</span><span class="regexp">/ 并发切片</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    async handleUpload() &#123;</span></span><br><span class="line"><span class="regexp">      if (!this.container.file) return;</span></span><br><span class="line"><span class="regexp">      const fileChunkList = this.createFileChunk(this.container.file);</span></span><br><span class="line"><span class="regexp">      this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">        chunk: file,</span></span><br><span class="line"><span class="regexp">        hash: this.container.file.name  "-"  index /</span><span class="regexp">/ 文件名  数组下标</span></span><br><span class="line"><span class="regexp">      &#125;));</span></span><br><span class="line"><span class="regexp">      await this.uploadChunks();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片</p>
<p>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回</p>
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名  下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p>
<p>随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p>
<h4 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h4><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> @change=<span class="string">"handleFileChange"</span> /&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">"handleUpload"</span>&gt;上传&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data: () =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">    container: &#123;</span></span><br><span class="line"><span class="regexp">      file: null</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    data: []</span></span><br><span class="line"><span class="regexp">  &#125;),</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    request() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    handleFileChange() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    createFileChunk() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 上传切片，同时过滤已上传的切片</span></span><br><span class="line"><span class="regexp">    async uploadChunks() &#123;</span></span><br><span class="line"><span class="regexp">      const requestList = this.data</span></span><br><span class="line"><span class="regexp">        .map((&#123; chunk，hash &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          const formData = new FormData();</span></span><br><span class="line"><span class="regexp">          formData.append("chunk", chunk);</span></span><br><span class="line"><span class="regexp">          formData.append("hash", hash);</span></span><br><span class="line"><span class="regexp">          formData.append("filename", this.container.file.name);</span></span><br><span class="line"><span class="regexp">          return &#123; formData &#125;;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        .map(async (&#123; formData &#125;) =&gt;</span></span><br><span class="line"><span class="regexp">          this.request(&#123;</span></span><br><span class="line"><span class="regexp">            url: "http:/</span><span class="regexp">/localhost:3000",</span></span><br><span class="line"><span class="regexp">            data: formData</span></span><br><span class="line"><span class="regexp">          &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      await Promise.all(requestList);</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 合并切片</span></span><br><span class="line"><span class="regexp">     await this.mergeRequest();</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    async mergeRequest() &#123;</span></span><br><span class="line"><span class="regexp">      await this.request(&#123;</span></span><br><span class="line"><span class="regexp">        url: "http:/</span><span class="regexp">/localhost:3000/m</span>erge<span class="string">",</span></span><br><span class="line"><span class="string">        headers: &#123;</span></span><br><span class="line"><span class="string">          "</span>content-type<span class="string">": "</span>application/json<span class="string">"</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: JSON.stringify(&#123;</span></span><br><span class="line"><span class="string">          filename: this.container.file.name</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">    &#125;,    </span></span><br><span class="line"><span class="string">    async handleUpload() &#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h3><p>简单使用 http 模块搭建服务端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h4><p>使用 <code>multiparty</code> 包处理前端传来的 FormData</p>
<p>在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">"fs-extra"</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">"multiparty"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"> <span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">".."</span>, <span class="string">"target"</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line"></span><br><span class="line">  multipart.parse(req, <span class="keyword">async</span> (err, fields, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [chunk] = files.chunk;</span><br><span class="line">    <span class="keyword">const</span> [hash] = fields.hash;</span><br><span class="line">    <span class="keyword">const</span> [filename] = fields.filename;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 切片目录不存在，创建切片目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.mkdirs(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// fs-extra 专用方法，类似 fs.rename 并且跨平台</span></span><br><span class="line">      <span class="comment">// fs-extra 的 rename 方法 windows 平台会有权限问题</span></span><br><span class="line">      <span class="comment">// https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span></span><br><span class="line">      <span class="keyword">await</span> fse.move(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    res.end(<span class="string">"received file chunk"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>

<p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename(由于我用的是 fs-extra，它的 rename 方法 windows 平台权限问题，所以换成了 fse.move) 移动临时文件，即移动文件切片</p>
<p>在接受文件切片时，需要先创建存储切片的文件夹，由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中</p>
<h4 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h4><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">"fs-extra"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">".."</span>, <span class="string">"target"</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> resolvePost = <span class="function"><span class="params">req</span> =&gt;</span></span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> chunk = <span class="string">""</span>;</span><br><span class="line">     req.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">       chunk = data;</span><br><span class="line">     &#125;);</span><br><span class="line">     req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">       resolve(<span class="built_in">JSON</span>.parse(chunk));</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> pipeStream = <span class="function">(<span class="params">path, writeStream</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> readStream = fse.createReadStream(path);</span><br><span class="line">    readStream.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">      fse.unlinkSync(path);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">    readStream.pipe(writeStream);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并切片</span></span><br><span class="line"> <span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, filename, size) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">  <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">  <span class="comment">// 根据切片下标进行排序</span></span><br><span class="line">  <span class="comment">// 否则直接读取目录的获得的顺序可能会错乱</span></span><br><span class="line">  chunkPaths.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.split(<span class="string">"-"</span>)[<span class="number">1</span>] - b.split(<span class="string">"-"</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    chunkPaths.map(<span class="function">(<span class="params">chunkPath, index</span>) =&gt;</span></span><br><span class="line">      pipeStream(</span><br><span class="line">        path.resolve(chunkDir, chunkPath),</span><br><span class="line">        <span class="comment">// 指定位置创建可写流</span></span><br><span class="line">        fse.createWriteStream(filePath, &#123;</span><br><span class="line">          start: index * size,</span><br><span class="line">          end: (index  <span class="number">1</span>) * size</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  fse.rmdirSync(chunkDir); <span class="comment">// 合并后删除保存切片的目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">"request"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (req.url === <span class="string">"/merge"</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req);</span><br><span class="line">     <span class="keyword">const</span> &#123; filename,size &#125; = data;</span><br><span class="line">     <span class="keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="string">`<span class="subst">$&#123;filename&#125;</span>`</span>);</span><br><span class="line">     <span class="keyword">await</span> mergeFileChunk(filePath, filename);</span><br><span class="line">     res.end(</span><br><span class="line">       <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         code: <span class="number">0</span>,</span><br><span class="line">         message: <span class="string">"file merged success"</span></span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"正在监听 3000 端口"</span>));</span><br></pre></td></tr></table></figure>

<p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p>
<p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名  后缀名</strong>组合而成</p>
<p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p>
<p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start/end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> mergeRequest() &#123;</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.request(&#123;</span><br><span class="line">     url: <span class="string">"http://localhost:3000/merge"</span>,</span><br><span class="line">     headers: &#123;</span><br><span class="line">       <span class="string">"content-type"</span>: <span class="string">"application/json"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      size: SIZE,</span><br><span class="line">       filename: <span class="keyword">this</span>.container.file.name</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h2><h3 id="从互联网下载数据"><a href="#从互联网下载数据" class="headerlink" title="从互联网下载数据"></a>从互联网下载数据</h3><p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadBlob = <span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"> xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line"> xhr.responseType = <span class="string">'blob'</span></span><br><span class="line"> xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(xhr.response)</span><br><span class="line"> &#125;</span><br><span class="line"> xhr.send(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 <code>fetch</code> API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 fetch API 获取线上图片并本地显示，具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myImage = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line"><span class="keyword">const</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'flowers.jpg'</span>);</span><br><span class="line"></span><br><span class="line">fetch(myRequest)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;)</span><br><span class="line"> .then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">   myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p>
<h3 id="Blob-用作-URL"><a href="#Blob-用作-URL" class="headerlink" title="Blob 用作 URL"></a>Blob 用作 URL</h3><p>Blob 可以很容易的作为 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code> 或其他标签的 URL，多亏了 <code>type</code> 属性，我们也可以上传/下载 <code>Blob</code> 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。</p>
<p><strong>1.Blob URL/Object URL</strong></p>
<p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>，对应的示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">blob:https:<span class="comment">//example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</span></span><br></pre></td></tr></table></figure>

<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code>。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p>
<p>上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。</p>
<p>但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p>
<p>针对这个问题，我们可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。</p>
<p><strong>2.Blob 文件下载示例</strong></p>
<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Blob 文件下载示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"downloadBtn"</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>js</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> download = <span class="function">(<span class="params">fileName, blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">  link.href = URL.createObjectURL(blob);</span><br><span class="line">  link.download = fileName;</span><br><span class="line">  link.click();</span><br><span class="line">  link.remove();</span><br><span class="line">  URL.revokeObjectURL(link.href);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> downloadBtn = <span class="built_in">document</span>.querySelector(<span class="string">"#downloadBtn"</span>);</span><br><span class="line">downloadBtn.addEventListener(<span class="string">"click"</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileName = <span class="string">"blob.txt"</span>;</span><br><span class="line">  <span class="keyword">const</span> myBlob = <span class="keyword">new</span> Blob([<span class="string">"一文彻底掌握 Blob Web API"</span>], &#123; <span class="attr">type</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  download(fileName, myBlob);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在示例中，我们通过调用 Blob 的构造函数来创建类型为 <strong>“text/plain”</strong> 的 Blob 对象，然后通过动态创建 <code>a</code> 标签来实现文件的下载。</p>
<h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>更多的用法可以参考  <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247484522&idx=1&sn=7028aa65a4dec0f2d0cb847838703bc3&scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">你不知道的Blob</a>。</p>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247484522&idx=1&sn=7028aa65a4dec0f2d0cb847838703bc3&scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">你不知道的Blob</a></p>
<p><a href="https://juejin.im/post/5dff8a26e51d4558105420ed" rel="external nofollow noopener noreferrer" target="_blank">大文件分片上传</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>区块链入门</title>
    <url>/2019/09/21/blockchain/</url>
    <content><![CDATA[<p>区块链（blockchain）是眼下的大热门，新闻媒体大量报道，宣称它将创造未来。</p>
<p>作者在阅读了部分论文，博客以及官方文档之后结合自己的理解整合了这些资料的内容，并对这些内容进行了重新组织。</p>
<a id="more"></a>

<h2 id="区块链的本质"><a href="#区块链的本质" class="headerlink" title="区块链的本质"></a>区块链的本质</h2><p>从本质上讲，区块链是一种特殊的分布式数据库。首先他可以存储信息，任何需要保存的信息都可以在区块链中进行读写。</p>
<p>但是与普通的数据库不同，任何人都可以假设服务器加入区块链的网络，成为一个节点，每个节点都是平等的，也不存在类似于数据库管理员一样的角色。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>
<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者就都必须听命于他们了。</p>
<p>向任意一个节点进行读写数据，所有的节点都会同步，保证区块链的一致性，这也是区块链去中心化之后能够保证其数据可靠性的原因。</p>
<h2 id="区块链中的一些概念"><a href="#区块链中的一些概念" class="headerlink" title="区块链中的一些概念"></a>区块链中的一些概念</h2><p>区块链的基本原理理解起来并不复杂。首先来看三个基本概念：</p>
<ul>
<li>交易（Transaction）：一次对账本的操作，导致账本状态的一次改变，如添加一条转账记录；</li>
<li>区块（Block）：记录一段时间内发生的所有交易和状态结果等，是对当前账本状态的一次共识；</li>
<li>链（Chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录。</li>
</ul>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>区块链由一个个的区块（block）组成。可以把这些区块类比成数据库的记录，每一次对数据的修改，都会创建一个新的区块，因为区块链的设计是增量式的，所以无论是对现有区块中的数据做任何CRUD操作，都是在现有链的基础上增加新的区块。</p>
<p>每个区块分为两个部分：</p>
<ul>
<li>区块头：记录当前区块的特征值</li>
<li>区块体：记录当前区块的实际数据</li>
</ul>
<p>区块头又包含了当前区块的多项特征值：</p>
<ul>
<li>当前区块的生成时间</li>
<li>区块体的哈希</li>
<li>上一个区块的哈希</li>
<li>…</li>
</ul>
<p>哈希其实就是计算机可以对任意内容计算出一个长度相同的特征值，区块链的哈希长度是256位，也就是说，不管什么内容最终计算出来的特征值都是256位，而且可以保证只要原始内容不同，计算出来的哈希值一定不同。</p>
<p>这样就可以保证：</p>
<ul>
<li>每个区块的哈希值一定是不同的，可以通过哈希标识区块</li>
<li>如果区块的内容改变了，他的哈希值一定会改变</li>
</ul>
<p>区块的哈希值都是根据区块头进行计算的，也就是说是把区块头的所有值拼接成一个字符串后对该字符串进行哈希的结果。</p>
<p>结合前面所说，区块头包含了很多内容，其中就有当前区块体的内容以及上个区块的哈希，也就是当前区块体的内容改变了或者上一个区块的内容改变了，就一定会引起当前区块哈希的改变。</p>
<p>这一点对区块链有重大意义。如果有人修改了一个区块，该区块的哈希就变了。为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），该人必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点指的是区块链网络中的计算机，包含手机，矿机和服务器等等。操作一个节点的可以是普通的钱包用户，矿工和多个人协作。例如比特币是属于公有链，当我们用自己已连接到互联网的电脑运行程序时，该电脑就是比特币网络中的一个节点。对于像比特币这样的公有链，理论上来讲，你下载完整的区块链，参与交易和挖矿，才算是节点。</p>
<p>节点，保存着自己的一份或者部分账本，通过算力或者份额投票的方式来解决拜占庭将军问题，通过无信任的方式确保全体节点遵循的账本和自己的账本是一致的。</p>
<h3 id="采矿"><a href="#采矿" class="headerlink" title="采矿"></a>采矿</h3><p>由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p>
<p>所以，区块链的发明者中本聪故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p>
<p>这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效哈希，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p>
<h2 id="区块链的原理"><a href="#区块链的原理" class="headerlink" title="区块链的原理"></a>区块链的原理</h2><p>如果把区块链系统作为一个状态机，则每次交易意味着一次状态改变；生成的区块，就是参与者对其中交易导致状态改变结果的共识。</p>
<p>区块链的目标是实现一个分布的数据记录账本，这个账本只允许添加、不允许删除。账本底层的基本结构是一个线性的链表。链表由一个个“区块”串联组成（如下图所示），后继区块中记录前导区块的哈希（Hash）值。某个区块（以及块里的交易）是否合法，可通过计算哈希值的方式进行快速检验。网络中节点可以提议添加一个新的区块，但必须经过共识机制来对区块达成确认。</p>
<h3 id="通过比特币来了解区块链的工作过程"><a href="#通过比特币来了解区块链的工作过程" class="headerlink" title="通过比特币来了解区块链的工作过程"></a>通过比特币来了解区块链的工作过程</h3><p>具体以比特币网络为例，来看其中如何使用了区块链技术。</p>
<p>首先，用户通过比特币客户端发起一项交易，消息广播到比特币网络中等待确认。网络中的节点会将收到的等待确认的交易请求打包在一起，添加上前一个区块头部的哈希值等信息，组成一个区块结构。然后，试图找到一个 nonce 串（随机串）放到区块里，使得区块结构的哈希结果满足一定条件（比如小于某个值）。这个计算 nonce 串的过程，即俗称的“挖矿”。nonce 串的查找需要花费一定的计算力。</p>
<p>一旦节点找到了满足条件的 nonce 串，这个区块在格式上就“合法”了，成为候选区块。节点将其在网络中广播出去。其它节点收到候选区块后进行验证，发现确实合法，就承认这个区块是一个新的合法区块，并添加到自己维护的本地区块链结构上。当大部分节点都接受了该区块后，意味着区块被网络接受，区块中所包括的交易也就得到确认。</p>
<p>这里比较关键的步骤有两个，一个是完成对一批交易的共识（创建合法区块结构）；一个是新的区块添加到链结构上，被网络认可，确保未来无法被篡改。当然，在实现上还会有很多额外的细节。</p>
<p>比特币的这种基于算力（寻找 nonce 串）的共识机制被称为工作量证明（Proof of Work，PoW）。这是因为要让哈希结果满足一定条件，并无已知的快速启发式算法，只能对 nonce 值进行逐个尝试的蛮力计算。尝试的次数越多（工作量越大），算出来的概率越大。</p>
<p>通过调节对哈希结果的限制条件，比特币网络控制平均约 10 分钟产生一个合法区块。算出区块的节点将得到区块中所有交易的管理费和协议固定发放的奖励费（目前是 12.5 比特币，每四年减半）。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>根据作者现在的理解，所谓的挖矿并不是去抢夺比特币，而是去抢夺比特币这个账本的记账权，如果把比特币整个网络比作一个账本，区块链上的每个区块都是账本中的一页，但是并不是所有的账页都会被这个账本所接受，只有符合其规则的账页才能正确插入到账本中，所谓矿机就是寻找这种符合规则的账页。</p>
<p>只不过目前比特币的激励机制就是每当你成功创建一个新的账页，你可以直接在其中写入向自己的账户转入一定数额的比特币，并结合你目前记录的所有未被记入区块链并且被承认有效的交易记录一起记入到这个区块体中，只要这个账页被成功插入并被大多数节点所接受并作为主分支，那么这些交易记录就是有效的。</p>
<p>但是比特币数量又是有限的，当某一天比特币发完之后，矿机的收入来源就是那些记录在自己这一页上的交易记录的抽成。</p>
<h2 id="区块链的三种场景"><a href="#区块链的三种场景" class="headerlink" title="区块链的三种场景"></a>区块链的三种场景</h2><p>引入智能合约后的区块链，已经超越了单纯的数据记录功能，实际上带有点“智能计算”的意味了；更进一步地，还可以为区块链加入权限管理、高级编程语言支持等，实现更强大的、支持更多商用场景的分布式账本系统。</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">功能</th>
<th align="left">智能合约</th>
<th align="left">一致性</th>
<th align="left">权限</th>
<th align="left">类型</th>
<th align="left">性能</th>
<th align="left">编程语言</th>
<th align="left">代表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数字货币</td>
<td align="left">记账功能</td>
<td align="left">不带有或较弱</td>
<td align="left">PoW</td>
<td align="left">无</td>
<td align="left">公有链</td>
<td align="left">较低</td>
<td align="left">简单脚本</td>
<td align="left">比特币网络</td>
</tr>
<tr>
<td align="left">分布式应用引擎</td>
<td align="left">智能合约</td>
<td align="left">图灵完备</td>
<td align="left">PoW、PoS</td>
<td align="left">无</td>
<td align="left">公有链</td>
<td align="left">受限</td>
<td align="left">特定语言</td>
<td align="left">以太坊网络</td>
</tr>
<tr>
<td align="left">带权限的分布式账本</td>
<td align="left">商业处理</td>
<td align="left">多种语言，图灵完备</td>
<td align="left">包括 CFT、BFT 在内的多种机制，可插拔</td>
<td align="left">支持</td>
<td align="left">联盟链</td>
<td align="left">可扩展</td>
<td align="left">高级编程语言</td>
<td align="left">超级账本</td>
</tr>
</tbody></table>
<p>根据参与者的不同，可以分为公有（Public 或 Permissionless）链、联盟（Consortium 或 Permissioned）链和私有（Private）链。</p>
<p>公有链，顾名思义，任何人都可以参与使用和维护，参与者多为匿名。典型的如比特币和以太坊区块链，信息是完全公开的。</p>
<p>如果进一步引入许可机制，可以实现私有链和联盟链两种类型。</p>
<p>私有链，由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开。一般认为跟传统中心化记账系统的差异不明显。</p>
<p>联盟链则介于两者之间，由若干组织一起合作（如供应链机构或银行联盟等）维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护，典型如超级账本项目。在架构上，现有大部分区块链在实现都至少包括了网络层、共识层、智能合约和应用层等分层结构，联盟链实现往还会引入额外的权限管理机制。</p>
<h2 id="Hyperledger-Fabric"><a href="#Hyperledger-Fabric" class="headerlink" title="Hyperledger Fabric"></a>Hyperledger Fabric</h2><p>Hyperledger Fabric 是由 IBM 公司主导开发的一个面向企业级客户的开源项目。与比特币和以太坊这类公有链不同，Hyperledger Fabric 网络中的节点必须经过授权认证后才能加入，从而避免了 POW 资源开销，大幅提高了交易处理效率，满足企业级应用对处理性能的诉求。同时，为了满足灵活多变的应用场景，Hyperledger Fabric 采用了高度模块化的系统设计理念，将权限认证模块（MSP）、共识服务模块（Ordering Service）、背书模块（Endorsing peers）、区块提交模块（committing peers）等进行分离部署，使开发者可以根据具体的业务场景替换模块，实现了模块的插件式管理（plug-in/plug-out）。所以，Hyperledger Fabric 是一个私有链／联盟链的开发框架，而且系统的运行不需要 token 支持。</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="Channel："><a href="#Channel：" class="headerlink" title="Channel："></a>Channel：</h4><p>是一种数据隔离机制，保证交易信息只有交易参与方可见，每个 channel 是一个独立的区块链，这使得多个用户可以共用同一个区块链系统而不用担心信息泄露问题。Channels 能够让上层不同的用户业务共享同一个区块链系统资源，主要包括网络、计算、存储资源。从本质上来说，channels 是通过不同的区块链账本来为上层业务服务，而且，这些区块链统一部署在 peers 节点上，统一通过 ordering service 进行交易排序和打包区块。Channels 之间通过权限隔离控制，不同 channel 内的成员，无法访问对方的交易信息，只能访问所属 channel 的交易信息。</p>
<h4 id="Chaincode："><a href="#Chaincode：" class="headerlink" title="Chaincode："></a>Chaincode：</h4><p>也叫智能合约，将资产定义和资产处理逻辑封装成接口，当其被用户调用的时候，改变账本的状态。</p>
<h4 id="Ledger："><a href="#Ledger：" class="headerlink" title="Ledger："></a>Ledger：</h4><p>区块链账本，保存交易信息和智能合约代码。</p>
<h4 id="Network："><a href="#Network：" class="headerlink" title="Network："></a>Network：</h4><p>交易处理节点之间的 P2P 网络，用于维持区块链账本的一致性。</p>
<h4 id="Ordering-service："><a href="#Ordering-service：" class="headerlink" title="Ordering service："></a>Ordering service：</h4><p>利用 kafka、SBTF 等共识算法对所有交易信息进行排序并打包成区块，发给 committing peers 节点，写入区块链中。</p>
<h4 id="World-state："><a href="#World-state：" class="headerlink" title="World state："></a>World state：</h4><p>显示当前资产数据的状态，底层通过 LevelDB 和 CouchDB 数据库将区块链中的资产信息组织起来，提供高效的数据访问接口。</p>
<h4 id="Membership-service-provider-（MSP）："><a href="#Membership-service-provider-（MSP）：" class="headerlink" title="Membership service provider （MSP）："></a>Membership service provider （MSP）：</h4><p>管理认证信息，为 client 和 peers 提供授权服务。</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在 Hyperledger 中，由三种类型的角色：</p>
<h4 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h4><p>应用客户端，用于将终端用户的交易请求发送到区块链网络；</p>
<h4 id="Peers："><a href="#Peers：" class="headerlink" title="Peers："></a>Peers：</h4><p>负责维护区块链账本，分为 endoring peers 和 committing peers，其中，endorser 为交易做背书（验证交易并对交易签名），committer 接收打包好的区块，然后写入区块链中。Peers 节点是一个逻辑的概念，endorser 和 committer 可以同时部署在一台物理机上。</p>
<h4 id="Ordering-Service："><a href="#Ordering-Service：" class="headerlink" title="Ordering Service："></a>Ordering Service：</h4><p>接收交易信息，并将其排序后打包成区块，放入区块链，最后将结果返回给 committer peers。</p>
<h3 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h3><p>区块链的账本由 peer 节点维护，并不是由 ordering service 集群维护，所以，只有 peer 节点上可以找到完整的区块链信息，而 order service 集群只负责对交易进行排序，只保留处理过程中的一部分区块链信息。Hyperledger Fabric 系统中的节点是一个逻辑的概念，并不一定是一个台物理设备，但是对于生产环境的设计者来说，peer 节点不能和 order 节点部署在一台机器上，而 enduring peers 和 committing peers 可以部署在同一台机器上，这种设计主要是为了系统架构的解耦，提高扩展性，以及通过主机隔离提高安全性。 Endorsing peer 校验客户端的签名，然后执行智能合约代码模拟交易。交易处理完成后，对交易信息签名，返回给客户端。客户端收到签名后的交易信息后，发给 order 节点排序。Order 节点将交易信息排序打包成区块后，广播发给 committing peers，写入区块链中。（具体交易流程可以参考：<a href="https://www.chainnews.com/articles/074736012702.htm）" rel="external nofollow noopener noreferrer" target="_blank">https://www.chainnews.com/articles/074736012702.htm）</a></p>
<p>参考文章：</p>
<p><a href="https://mp.weixin.qq.com/s/8W_oegxPCMr9zTtpN1h6dA" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/8W_oegxPCMr9zTtpN1h6dA</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a></p>
<p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/02_overview/definition.html" rel="external nofollow noopener noreferrer" target="_blank">https://yeasy.gitbooks.io/blockchain_guide/content/02_overview/definition.html</a></p>
<p><a href="https://www.chainnews.com/articles/074736012702.htm" rel="external nofollow noopener noreferrer" target="_blank">https://www.chainnews.com/articles/074736012702.htm</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器架构</title>
    <url>/2020/12/03/browser-architecture/</url>
    <content><![CDATA[<p>无论你是想要设计高性能 Web 应用，还是要优化现有的 Web 应用，你都需要了解浏览器中的网络流程、页面渲染过程，JavaScript 执行流程，以及 Web 安全理论。</p>
<p>这篇文章简单介绍下浏览器的架构演进。</p>
<a id="more"></a>

<h2 id="什么是浏览器"><a href="#什么是浏览器" class="headerlink" title="什么是浏览器"></a>什么是浏览器</h2><p>提起浏览器，大家都是非常熟悉的，但是浏览器到底是做什么的，大家可能没有仔细思考过。</p>
<p>其实这个问题我们从浏览器的另外一个名字就能知道：<strong>万维网客户端</strong>。</p>
<p>没错，浏览器其实就是一个客户端，帮助我们浏览万维网信息的。</p>
<p>那什么是万维网呢？万维网上的信息又是什么呢？</p>
<p>简单来讲，万维网上的信息就是html文档，万维网的通信就是通过http协议，这两者一个叫做超文本标记语言，一个叫做超文本传输协议。</p>
<p><strong>浏览器最本质的作用就是帮助我们通过http协议去获取html文档并进行展示</strong>。</p>
<h2 id="浏览器的架构"><a href="#浏览器的架构" class="headerlink" title="浏览器的架构"></a>浏览器的架构</h2><h3 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h3><p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1607950533/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201214205124_zhp4vc.png" alt></p>
<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。</p>
<h4 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h4><p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>
<p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</p>
<h4 id="不流畅"><a href="#不流畅" class="headerlink" title="不流畅"></a>不流畅</h4><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。比如，一个这个无限循环的脚本</p>
<p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p>
<h4 id="不安全"><a href="#不安全" class="headerlink" title="不安全"></a>不安全</h4><p>插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>
<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>
<h3 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h3><h4 id="早期多进程浏览器"><a href="#早期多进程浏览器" class="headerlink" title="早期多进程浏览器"></a>早期多进程浏览器</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1607951301/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201214210808_qtiudk.png" alt></p>
<p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）</p>
<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p>
<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p>
<p>对于<strong>内存泄漏的解决方法</strong>那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>
<p>最后我们再来看看上面的<strong>两个安全问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>
<h4 id="目前的多进程浏览器"><a href="#目前的多进程浏览器" class="headerlink" title="目前的多进程浏览器"></a>目前的多进程浏览器</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1607951570/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201214211245_onevmr.png" alt></p>
<p>下面我们来逐个分析下这几个进程的功能。</p>
<ul>
<li><p>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>
</li>
<li><p>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
<h2 id="浏览器导航流程"><a href="#浏览器导航流程" class="headerlink" title="浏览器导航流程"></a>浏览器导航流程</h2><p>“在浏览器里，从输入 URL 到页面展示，这中间发生了什么？ ”这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。</p>
<p>那么今天我们就一起来探索下这个流程</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1607952407/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201214212637_nqv6vr.png" alt></p>
<p>这个过程可以大致描述为如下。</p>
<ul>
<li><p>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</p>
</li>
<li><p>然后，在网络进程中发起真正的 URL 请求。</p>
</li>
<li><p>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</p>
</li>
<li><p>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；</p>
</li>
<li><p>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</p>
</li>
<li><p>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</p>
</li>
<li><p>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</p>
</li>
</ul>
<blockquote>
<p>渲染流程的内容如果大家有兴趣可以看我的<a href="https://sunra.top/2020/11/26/rendering-process/">另一篇关于渲染流程的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/2021/02/28/browser-cache/</url>
    <content><![CDATA[<p>前段时间遇到了关于浏览器缓存的问题，当时没有什么想法，后来回来查了一下发现很多东西都接触过，只是没有系统地整理起来，借着这篇博客整理一下。</p>
<p>主要内容是浏览器的强缓存，协商缓存的机制以及对应的HTTP头。</p>
<p>另外以后可能会整理下浏览器的Cache API相关的内容。</p>
<a id="more"></a>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><p>浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</p>
<ol>
<li>如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</li>
<li>在 <code>chrome</code> 中强缓存（虽然没有发出真实的 <code>http</code> 请求）的请求状态码返回是 <code>200 (from cache)</code>；而协商缓存如果命中走缓存的话，请求的状态码是 <code>304 (not modified)</code>。 不同浏览器的策略不同，在 <code>Fire Fox</code>中，<code>from cache</code> 状态码是 304.</li>
</ol>
<blockquote>
<p>其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。</p>
</blockquote>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>首先我们来总体感知一下它的匹配流程，如下： </p>
<ol>
<li>浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</li>
<li>没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</li>
<li>如果前两步都没有命中，则直接从服务端获取资源。</li>
</ol>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：</p>
<ol>
<li>浏览器会获取该缓存资源的 <code>header</code> 中的信息，根据 <code>response header</code> 中的 <code>expires</code> 和 <code>cache-control</code> 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。</li>
<li>如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 <code>IF-Modified-Since</code> 或者 <code>IF-None-Match</code>, 它们的值分别是第一次请求返回 <code>Last-Modified</code>或者 <code>Etag</code>，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。</li>
</ol>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存是根据返回头中的 <code>Expires</code> 或者 <code>Cache-Control</code> 两个字段来控制的，都是表示资源的缓存有效时间。</p>
<ul>
<li><code>Expires</code> 是 <code>http 1.0</code> 的规范，值是一个<code>GMT</code> 格式的时间点字符串，比如 <code>Expires:Mon,18 Oct 2066 23:59:59 GMT</code> 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 <code>Expires</code> 在实际使用中会带来一些麻烦。</li>
<li><code>Cache-Control</code>这个字段是 <code>http 1.1</code> 的规范，一般常用该字段的 <code>max-age</code> 值来进行判断，它是一个相对时间，比如 .<code>Cache-Control:max-age=3600</code> 代表资源的有效期是 3600 秒。并且返回头中的 <code>Date</code> 表示消息发送的时间，表示当前资源在 <code>Date ~ Date +3600s</code> 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 <code>max-age</code> 之后，在 <code>max-age</code> 时间内重新访问资源却会返回 <code>304 not modified</code> ，这是由于服务器的时间与本地的时间不同造成的。当然 <code>Cache-Control</code> 还有其他几个值可以设置， 不过相对来说都很少用了：<ul>
<li><code>no-cache</code> 不使用本地缓存。需要使用协商缓存。</li>
<li><code>no-store</code>直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 <code>network</code> 中的 <code>disabled cache</code>。</li>
<li><code>public</code> 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。</li>
<li><code>private</code> 只能被终端用户的浏览器缓存。</li>
</ul>
</li>
</ul>
<p>如果 <code>Cache-Control</code>与 <code>Expires</code> 同时存在的话， <code>Cache-Control</code> 的优先级高于 <code>Expires</code> 。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, <code>Last-Modified</code> 或者 <code>Etag</code>，则后续请求则会带上对应的请求字段 <code>If-Modified-Since</code>或者 <code>If-None-Match</code>，若响应头没有 <code>Last-Modified</code> 或者 <code>Etag</code> 字段，则请求头也不会有对应的字段。</p>
<ul>
<li><code>Last-Modified/If-Modified-Since</code> 二者的值都是 GMT 格式的时间字符串， <code>Last-Modified</code> 标记最后文件修改时间， 下一次请求时，请求头中会带上 <code>If-Modified-Since</code> 值就是 <code>Last-Modified</code> 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 <code>304 Not Modified</code> ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 <code>304 Not Modified</code> 的响应时，<code>response header</code> 中不会再添加的 <code>Last-Modified</code> 去试图更新本地缓存的 <code>Last-Modified</code>， 因为既然资源没有变化，那么 <code>Last-Modified</code> 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 <code>Last-Modified</code> 会在 <code>response header</code> 返回，并在下次请求之前更新本地缓存的 <code>Last-Modified</code>，下次请求时，<code>If-Modified-Since</code>会启用更新后的 <code>Last-Modified</code>。</li>
<li><code>Etag/If-None-Match</code>， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 <code>ETag</code>字段返回给浏览器，接收到 <code>If-None-Match</code> 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 <code>Last-Modified</code> 不一样的是，当服务器返回 <code>304 Not Modified</code> 的响应时，由于在服务器上<code>ETag</code> 重新计算过，<code>response header</code>中还会把这个 <code>ETag</code> 返回，即使这个 <code>ETag</code> 跟之前的没有变化。</li>
</ul>
<blockquote>
<p>HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。</p>
</blockquote>
<h3 id="为什么要有-Etag"><a href="#为什么要有-Etag" class="headerlink" title="为什么要有 Etag"></a>为什么要有 Etag</h3><p><code>HTTP1.1</code> 中 <code>Etag</code> 的出现主要是为了解决几个 <code>Last-Modified</code> 比较难解决的问题：</p>
<ul>
<li>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 <code>Etag</code> 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h3><h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ul>
<li><p><code>public</code></p>
<p>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有<code>max-age</code>指令或<code>Expires</code>消息头；2. 该响应对应的请求方法是 <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" rel="external nofollow noopener noreferrer" target="_blank">POST</a> 。）</p>
</li>
<li><p><code>private</code></p>
<p>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</p>
</li>
<li><p><code>no-cache</code></p>
<p>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p>
</li>
<li><p><code>no-store</code></p>
<p>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p>
</li>
</ul>
<h4 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h4><ul>
<li><p><code>max-age=&lt;seconds&gt;</code></p>
<p>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间。</p>
</li>
<li><p><code>s-maxage=&lt;seconds&gt;</code></p>
<p>覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</p>
</li>
<li><p><code>max-stale[=&lt;seconds&gt;]</code></p>
<p>表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。</p>
</li>
<li><p><code>min-fresh=&lt;seconds&gt;</code></p>
<p>表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。</p>
</li>
<li><p><code>stale-while-revalidate=&lt;seconds&gt;</code> </p>
<p>表明客户端愿意接受陈旧的响应，同时在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度。</p>
</li>
<li><p><code>stale-if-error=&lt;seconds&gt;</code> </p>
<p>表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。</p>
</li>
</ul>
<h4 id="重新验证和重新加载"><a href="#重新验证和重新加载" class="headerlink" title="重新验证和重新加载"></a>重新验证和重新加载</h4><ul>
<li><p><code>must-revalidate</code></p>
<p>一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。</p>
</li>
<li><p><code>proxy-revalidate</code></p>
<p>与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</p>
</li>
<li><p><code>immutable</code> </p>
<p>表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头（例如<code>If-None-Match</code>或I<code>f-Modified-Since</code>）来检查更新，即使用户显式地刷新页面。在Firefox中，immutable只能被用在 <code>https://</code> transactions. 有关更多信息，请参阅<a href="http://bitsup.blogspot.de/2016/05/cache-control-immutable.html" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p><code>no-transform</code></p>
<p>不得对资源进行转换或转变。<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等HTTP头不能由代理修改。例如，非透明代理或者如<a href="https://support.google.com/webmasters/answer/6211428?hl=en" rel="external nofollow noopener noreferrer" target="_blank">Google’s Light Mode</a>可能对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。<code>no-transform</code>指令不允许这样做。</p>
</li>
<li><p><code>only-if-cached</code></p>
<p>表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。</p>
</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control &gt; expires &gt; Etag &gt; Last-Modified</span><br></pre></td></tr></table></figure>

<h3 id="三级缓存原理"><a href="#三级缓存原理" class="headerlink" title="三级缓存原理"></a>三级缓存原理</h3><p>最后总结一下浏览器的三级缓存原理：</p>
<ol>
<li>先去内存看，如果有，直接加载</li>
<li>如果内存没有，去硬盘获取，如果有直接加载</li>
<li>如果硬盘也没有，那么就进行网络请求</li>
<li>加载到的资源缓存到硬盘和内存</li>
</ol>
<p>参考文章：<a href="https://segmentfault.com/a/1190000021661656" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000021661656</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>前端性能分析工具</title>
    <url>/2019/08/21/chrome_develop_tools/</url>
    <content><![CDATA[<p>当我们开发网站的时候，可能会有很多种原因造成我们的页面卡顿，那么我们可以利用Google Devtools 去快速定位导致页面卡顿的最主要原因。本篇总结了Chrome官方文档上最主要也是最直接的两个工具。</p>
<a id="more"></a>

<h2 id="利用开发者工具Performance选项卡"><a href="#利用开发者工具Performance选项卡" class="headerlink" title="利用开发者工具Performance选项卡"></a>利用开发者工具Performance选项卡</h2><h3 id="打开开发者工具"><a href="#打开开发者工具" class="headerlink" title="打开开发者工具"></a>打开开发者工具</h3><p>按Command+ Option+ I（Mac）或 Control+ Shift+ I（Windows，Linux）打开DevTools，Windows也可以使用F12。</p>
<h3 id="利用Performance选项卡录制操作"><a href="#利用Performance选项卡录制操作" class="headerlink" title="利用Performance选项卡录制操作"></a>利用Performance选项卡录制操作</h3><ol>
<li><p>选择Performance选项卡</p>
</li>
<li><p>点击左上角的圆点（开始录制按钮）</p>
</li>
<li><p>对页面进行操作</p>
</li>
<li><p>操作完成后点击stop按钮</p>
</li>
</ol>
<h3 id="分析录制结果"><a href="#分析录制结果" class="headerlink" title="分析录制结果"></a>分析录制结果</h3><h4 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612008/Devtools/fps_ju7mvq.png" alt></p>
<p>图中上方红色方框圈出的地方显示的就是录制过程中页面的FPS变化，当FPS显示的是绿色条时，表示页面比较流畅，且绿色条越高，FPS越高，用户体验越好。</p>
<p>但是当FPS出现红色条时表示页面存在较为严重的卡顿，可能会影响用户体验。</p>
<p>当你把鼠标放到FPS上的某一点时就会显示出该点的页面快照。（这里需要在录制时将screenshoot选项勾选）</p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612007/Devtools/CPU_yv1izl.png" alt></p>
<p>在FPS图表下方就是CPU图表，该图表中的颜色与下方的Summary选项卡是一一对应的。</p>
<p>当你的录制结果中CPU图表别大量颜色占满，下方的Summary也大部分是有颜色的时候，就应该分析一下是什么占据了大量的CPU并想办法减少该类操作或者优化该类操作。</p>
<p>比如当rendering占据了很大比例的时候，就应该想办法减少dom元素，因为rendering的过程其实就是把html语句转化为dom树的过程，如果该过程占据了大量的CPU就应该考虑如何优化你的dom结构了。</p>
<h4 id="FPS仪表盘"><a href="#FPS仪表盘" class="headerlink" title="FPS仪表盘"></a>FPS仪表盘</h4><ol>
<li>我们可以在开发者工具中输入快捷键Command+ Shift+ P（Mac）或 Control+ Shift+ P（Windows，Linux）打开命令菜单。</li>
<li>输入Show Render，选择Rendering对应的命令</li>
<li>页面左上角就会出现一个实时的FPS监控器</li>
</ol>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612008/Devtools/fps2_fhp16u.png" alt></p>
<h2 id="利用Audits选项卡分析性能"><a href="#利用Audits选项卡分析性能" class="headerlink" title="利用Audits选项卡分析性能"></a>利用Audits选项卡分析性能</h2><h3 id="运行审核"><a href="#运行审核" class="headerlink" title="运行审核"></a>运行审核</h3><ol>
<li>开启Audits选项卡</li>
<li>点击运行审核，等待10-30秒后会出现审计结果（Tips：这里要注意这个功能需要翻墙，不然会一直卡在LightHouse is warming up，LightHouse是这个选项卡依赖地一个组件）</li>
</ol>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612007/Devtools/Audits_tfnnf2.png" alt></p>
<h3 id="分析运行结果"><a href="#分析运行结果" class="headerlink" title="分析运行结果"></a>分析运行结果</h3><p>运行结果很长，我们从上到下分块进行分析</p>
<h4 id="总览模块"><a href="#总览模块" class="headerlink" title="总览模块"></a>总览模块</h4><p>这一部分综述了这次审核的几个维度的评分</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612007/Devtools/audits1_opabc0.png" alt></p>
<h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><ol>
<li>右上角的数字是该指标的总体评分，评分越高性能越好，当你优化了你的网站时，该评分就会上升</li>
<li>First Contentful Paint：首次将内容绘制到页面的时间，改时间越短越好</li>
<li>Time to Interactice：标记页面准备就绪处理用户交互的时间</li>
<li>我们可以将鼠标停在任意一个指标右侧的标记上去查看详细信息</li>
</ol>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612007/Devtools/audits2_zyuvmj.png" alt></p>
<h4 id="Opportunities"><a href="#Opportunities" class="headerlink" title="Opportunities"></a>Opportunities</h4><p>该部分提供了关于如何改进加载性能的建议</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612008/Devtools/opportunity_xvzdpm.png" alt></p>
<h4 id="Diagnostics"><a href="#Diagnostics" class="headerlink" title="Diagnostics"></a>Diagnostics</h4><p>该部分提供了关于导致页面加载问题的因素，可以将每一项展开来查看详细信息</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612008/Devtools/Diag_hqaivt.png" alt></p>
<h4 id="Passed-audits"><a href="#Passed-audits" class="headerlink" title="Passed audits"></a>Passed audits</h4><p>该部分显示了你的网站那一部分是做正确的</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566612008/Devtools/Passed_ijjuxq.png" alt></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>codereview</title>
    <url>/2019/10/05/codereview/</url>
    <content><![CDATA[<p>就在大家 happy 的这几天期间，Google 公开了两个文档，我感觉作为程序员和工程师非常有必要了解一下。作者在阅读之后截取部分原文并精简了其他一些部分总结下来。</p>
<a id="more"></a>

<h2 id="The-CL-author’s-guide-to-getting-through-code-review"><a href="#The-CL-author’s-guide-to-getting-through-code-review" class="headerlink" title="The CL author’s guide to getting through code review"></a>The CL author’s guide to getting through code review</h2><p>简单来讲就是 CL 作者指南去指导通过代码审查。那么 CL 是什么意思呢？就是 change list ，变更记录和日志的意思。</p>
<p>这个指南可帮助您更快地完成代码审核并获得更高质量的结果。适用于每个 Google 开发人员，阅读这份指南非常有帮助。</p>
<p><a href="https://google.github.io/eng-practices/review/developer/" rel="external nofollow noopener noreferrer" target="_blank">https://google.github.io/eng-practices/review/developer/</a></p>
<h3 id="Writing-good-CL-descriptions"><a href="#Writing-good-CL-descriptions" class="headerlink" title="Writing good CL descriptions"></a>Writing good CL descriptions</h3><h4 id="First-Line"><a href="#First-Line" class="headerlink" title="First Line"></a>First Line</h4><ul>
<li>Short summary of what is being done.</li>
<li>Complete sentence, written as though it was an order.</li>
<li>Follow by empty line.</li>
</ul>
<p>首先，CL的第一行最好是一个做了什么的简短的描述，并且后面跟着一个空行，其次应该将其写成命令式的，当然接下来的部分可以没有必要写成这样。</p>
<h4 id="Body-is-informative"><a href="#Body-is-informative" class="headerlink" title="Body is informative"></a>Body is informative</h4><p>其余的描述应提供信息。它可能包括对要解决的问题的简要说明，以及为什么这是最好的方法。如果该方法有任何缺点，则应予以提及。如果相关，请包括背景信息，例如错误号，基准测试结果以及设计文档的链接.。</p>
<h4 id="Bad-CL-Description"><a href="#Bad-CL-Description" class="headerlink" title="Bad CL Description"></a>Bad CL Description</h4><p>“Fix bug” is an inadequate CL description. What bug? What did you do to fix it? Other similarly bad descriptions include:</p>
<ul>
<li>“Fix build.”</li>
<li>“Add patch.”</li>
<li>“Moving code from A to B.”</li>
<li>“Phase 1.”</li>
<li>“Add convenience functions.”</li>
<li>“kill weird URLs.”</li>
</ul>
<p>Some of those are real CL descriptions. Their authors may believe they are providing useful information, but they are not serving the purpose of a CL description.</p>
<h4 id="Good-CL-Descriptions"><a href="#Good-CL-Descriptions" class="headerlink" title="Good CL Descriptions"></a>Good CL Descriptions</h4><p>Here are some examples of good descriptions.</p>
<h5 id="Functionality-change"><a href="#Functionality-change" class="headerlink" title="Functionality change"></a>Functionality change</h5><blockquote>
<p>rpc: remove size limit on RPC server message freelist.</p>
<p>Servers like FizzBuzz have very large messages and would benefit from reuse. Make the freelist larger, and add a goroutine that frees the freelist entries slowly over time, so that idle servers eventually release all freelist entries.</p>
</blockquote>
<p>The first few words describe what the CL actually does. The rest of the description talks about the problem being solved, why this is a good solution, and a bit more information about the specific implementation.</p>
<p>文档中还有很多好的CL的举例说明，大家可以自己去看一下。同时记住，CL最好是全英的。</p>
<h3 id="Small-CLs"><a href="#Small-CLs" class="headerlink" title="Small CLs"></a>Small CLs</h3><h4 id="Why-write-small-CLs"><a href="#Why-write-small-CLs" class="headerlink" title="Why write small CLs?"></a>Why write small CLs?</h4><ul>
<li><strong>Reviewed more quickly.</strong> It’s easier for a reviewer to find five minutes several times to review small CLs than to set aside a 30 minute block to review one large CL.</li>
<li><strong>Reviewed more thoroughly.</strong> With large changes, reviewers and authors tend to get frustrated by large volumes of detailed commentary shifting back and forth—sometimes to the point where important points get missed or dropped.</li>
<li><strong>Less likely to introduce bugs.</strong> Since you’re making fewer changes, it’s easier for you and your reviewer to reason effectively about the impact of the CL and see if a bug has been introduced.</li>
<li><strong>Less wasted work if they are rejected.</strong> If you write a huge CL and then your reviewer says that the overall direction is wrong, you’ve wasted a lot of work.</li>
<li><strong>Easier to merge.</strong> Working on a large CL takes a long time, so you will have lots of conflicts when you merge, and you will have to merge frequently.</li>
<li><strong>Easier to design well.</strong> It’s a lot easier to polish the design and code health of a small change than it is to refine all the details of a large change.</li>
<li><strong>Less blocking on reviews.</strong> Sending self-contained portions of your overall change allows you to continue coding while you wait for your current CL in review.</li>
<li><strong>Simpler to roll back.</strong> A large CL will more likely touch files that get updated between the initial CL submission and a rollback CL, complicating the rollback (the intermediate CLs will probably need to be rolled back too).</li>
</ul>
<p>简单来讲，就是小步提交可以更容易地知道你每一次提交在做什么，这样一来，当你有什么问题的时候，可以非常快速地定位问题，如果该问题需要回滚时，也不会对现有代码产生什么影响。</p>
<h4 id="What-is-small"><a href="#What-is-small" class="headerlink" title="What is small?"></a>What is small?</h4><p>In general, the right size for a CL is <strong>one self-contained change</strong>. This means that:</p>
<ul>
<li>The CL makes a minimal change that addresses <strong>just one thing</strong>. This is usually just one part of a feature, rather than a whole feature at once. In general it’s better to err on the side of writing CLs that are too small vs. CLs that are too large. Work with your reviewer to find out what an acceptable size is.</li>
<li>Everything the reviewer needs to understand about the CL (except future development) is in the CL, the CL’s description, the existing codebase, or a CL they’ve already reviewed.</li>
<li>The system will continue to work well for its users and for the developers after the CL is checked in.</li>
<li>The CL is not so small that its implications are difficult to understand. If you add a new API, you should include a usage of the API in the same CL so that reviewers can better understand how the API will be used. This also prevents checking in unused APIs.</li>
</ul>
<p>对于每次提交的大小，每次100行左右的是一个比较合理的大小，而1000行就太大了。但这也不是绝对的判断标准，如果100行代码分布在50个文件中，那也算一次很大的修改。</p>
<h4 id="When-are-large-CLs-okay"><a href="#When-are-large-CLs-okay" class="headerlink" title="When are large CLs okay?"></a>When are large CLs okay?</h4><p>There are a few situations in which large changes aren’t as bad:</p>
<ul>
<li>You can usually count deletion of an entire file as being just one line of change, because it doesn’t take the reviewer very long to review.</li>
<li>Sometimes a large CL has been generated by an automatic refactoring tool that you trust completely, and the reviewer’s job is just to sanity check and say that they really do want the change. These CLs can be larger, although some of the caveats from above (such as merging and testing) still apply.</li>
</ul>
<h5 id="Splitting-by-Files"><a href="#Splitting-by-Files" class="headerlink" title="Splitting by Files"></a>Splitting by Files</h5><p>可以将需要不同reviewer的相对独立的更改拆分为不同的CL</p>
<h5 id="Separate-Out-Refactoring"><a href="#Separate-Out-Refactoring" class="headerlink" title="Separate Out Refactoring"></a>Separate Out Refactoring</h5><p>通常最好是在单独的CL中进行重构，而不包含功能更改或错误修复。例如，修改某个类以及调用该类应该放到不同的两个CL中。</p>
<h5 id="Keep-related-test-code-in-the-same-CL"><a href="#Keep-related-test-code-in-the-same-CL" class="headerlink" title="Keep related test code in the same CL"></a>Keep related test code in the same CL</h5><p>尽量不要把测试代码放到不同的CL中，因为测试会保证你的这段代码的正确性，即使测试代码可能会使你的提交变得庞大。</p>
<p>但是，我们可以将独立的测试放到单独的CL中，比如：</p>
<ul>
<li>validating pre-existing, submitted code with new tests.</li>
<li>refactoring the test code (e.g. introduce helper functions).</li>
<li>introducing larger test framework code (e.g. an integration test).</li>
</ul>
<h5 id="Don’t-break-the-build"><a href="#Don’t-break-the-build" class="headerlink" title="Don’t break the build"></a>Don’t break the build</h5><p>如果多个CL会相互依赖，最好是能够保证在每个CL被提交修改之后，系统能够正常运行。</p>
<h5 id="Can’t-Make-it-small-enough"><a href="#Can’t-Make-it-small-enough" class="headerlink" title="Can’t Make it small enough"></a>Can’t Make it small enough</h5><h3 id="How-to-handle-reviewer-comments"><a href="#How-to-handle-reviewer-comments" class="headerlink" title="How to handle reviewer comments"></a>How to handle reviewer comments</h3><p>When you’ve sent a CL out for review, it’s likely that your reviewer will respond with several comments on your CL. Here are some useful things to know about handling reviewer comments.</p>
<h4 id="Don’t-take-it-personally"><a href="#Don’t-take-it-personally" class="headerlink" title="Don’t take it personally"></a>Don’t take it personally</h4><p>The goal of review is to maintain the quality of our codebase and our products. When a reviewer provides a critique of your code, think of it as their attempt to help you, the codebase, and Google, rather than as a personal attack on you or your abilities.</p>
<p>也就是说，尽量不要再代码审查中加入自己的负面情绪，如果有人在你的代码审查过程中加入了负面情绪，首先考虑一下他们真正想说的是什么，然后再想办法和他们私下交流，比如面谈或者邮件。</p>
<h4 id="Fix-the-code"><a href="#Fix-the-code" class="headerlink" title="Fix the code"></a>Fix the code</h4><p>如果审阅者说不明白你的代码，那你应该想办法解释清楚你的代码在做什么。因为你的审阅者看不懂，将来其他的同事也可能看不懂。</p>
<h4 id="Think-for-yourself"><a href="#Think-for-yourself" class="headerlink" title="Think for yourself"></a>Think for yourself</h4><p>因为我们每次提交可能是花费了大量的时间，所以当我们看到审阅者给我们提出意见的时候，我们的第一反应是拒绝。</p>
<p>但是我们最好先考虑一下，审阅者的意见是否是正确的，如果我们没办法回答这个问题，我们就可能需要去找到审阅者让他说清楚自己的观点，然后再去判断。</p>
<h4 id="Resolving-conflicts"><a href="#Resolving-conflicts" class="headerlink" title="Resolving conflicts"></a>Resolving conflicts</h4><p>Your first step in resolving conflicts should always be to try to come to consensus with your reviewer. If you can’t achieve consensus, see <a href="https://google.github.io/eng-practices/review/reviewer/standard.html" rel="external nofollow noopener noreferrer" target="_blank">The Standard of Code Review</a>, which gives principles to follow in such a situation.</p>
<h2 id="How-to-do-a-code-review"><a href="#How-to-do-a-code-review" class="headerlink" title="How to do a code review"></a>How to do a code review</h2><p>这份文档中包含有关进行代码审查的最佳方式的建议。是一个非常完整的文档，分为许多单独的部分。阅读这个文档，对于大家来看，肯定会非常有帮助，绝对让大家受益匪浅的一件事。</p>
<p><a href="https://google.github.io/eng-practices/review/reviewer/" rel="external nofollow noopener noreferrer" target="_blank">https://google.github.io/eng-practices/review/reviewer/</a></p>
<h3 id="The-standard-of-code-review"><a href="#The-standard-of-code-review" class="headerlink" title="The standard of code review"></a>The standard of code review</h3><p>代码审查的主要目的是确保Google代码库的整体代码运行状况随着时间的推移而不断改善。</p>
<p>首先，开发人员必须能够在其任务上取得进展。如果您从未向代码库提交过改进，那么代码库将永远不会得到改进。另外，如果审阅者很难进行任何更改，那么开发人员就没有动力在将来进行改进。</p>
<p>另一方面，审阅者有责任确保每个CL的质量都使得其代码库的整体代码运行状况不会随着时间的流逝而减少。</p>
<p>Thus, we get the following rule as the standard we expect in code reviews:</p>
<p><strong>In general, reviewers should favor approving a CL once it is in a state where it definitely improves the overall code health of the system being worked on, even if the CL isn’t perfect.</strong></p>
<p>That is <em>the</em> senior principle among all of the code review guidelines.</p>
<h4 id="Mentoring"><a href="#Mentoring" class="headerlink" title="Mentoring"></a>Mentoring</h4><p>代码审查具有重要的功能，可以教给开发人员有关语言，框架或通用软件设计原理的新知识。留下有助于开发人员学习新知识的评论总是很好的。共享知识是随着时间的推移改善系统代码运行状况的一部分。</p>
<h4 id="Principles"><a href="#Principles" class="headerlink" title="Principles"></a>Principles</h4><ul>
<li>Technical facts and data overrule opinions and personal preferences.</li>
<li>On matters of style, the <a href="http://google.github.io/styleguide/" rel="external nofollow noopener noreferrer" target="_blank">style guide</a> is the absolute authority. Any purely style point (whitespace, etc.) that is not in the style guide is a matter of personal preference. The style should be consistent with what is there. If there is no previous style, accept the author’s.</li>
<li><strong>Aspects of software design are almost never a pure style issue or just a personal preference.</strong> They are based on underlying principles and should be weighed on those principles, not simply by personal opinion. Sometimes there are a few valid options. If the author can demonstrate (either through data or based on solid engineering principles) that several approaches are equally valid, then the reviewer should accept the preference of the author. Otherwise the choice is dictated by standard principles of software design.</li>
<li>If no other rule applies, then the reviewer may ask the author to be consistent with what is in the current codebase, as long as that doesn’t worsen the overall code health of the system.</li>
</ul>
<h3 id="What-to-look-for-in-a-code-review"><a href="#What-to-look-for-in-a-code-review" class="headerlink" title="What to look for in a code review"></a>What to look for in a code review</h3><h4 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h4><p>审查中最重要的内容是CL的总体设计。CL中各种代码的交互是否有意义？</p>
<h4 id="Functionality"><a href="#Functionality" class="headerlink" title="Functionality"></a>Functionality</h4><p>此CL是否达到开发人员的预期目的？开发人员打算为该代码的用户带来什么好处？</p>
<p>“用户”通常既是最终用户（当他们受到更改影响时）又是开发人员（将来他们将不得不“使用”此代码）。通常，我们希望开发人员能够对CL进行良好的测试，以确保它们在进行代码审查时能够正常工作。</p>
<p>但是，作为审阅者，您仍然应该考虑边缘情况，寻找并发性问题，尝试像用户一样思考，并确保没有仅仅通过阅读代码就能看到的错误。</p>
<p>您可以根据需要验证CL，对于审阅者而言，检查CL的行为最重要的时间是对用户的影响（如UI更改）。</p>
<p>当您仅阅读代码时，很难理解某些更改将如何影响用户。进行此类更改时，如果过于麻烦以致无法在CL中打补丁并自己尝试，则可以让开发人员向您演示该功能。</p>
<p>另外一次在代码审查期间考虑功能特别重要的时候是，CL中是否正在进行某种并行编程，从理论上讲可能会导致死锁或竞争状况。仅通过运行代码很难检测到这类问题，通常需要有人（开发人员和审阅者）仔细考虑它们，以确保不会引入问题。</p>
<h4 id="Complex"><a href="#Complex" class="headerlink" title="Complex"></a>Complex</h4><p>简单来说就是不要过度设计。</p>
<h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p>根据更改要求进行单元测试，集成测试或端到端测试。通常，除非CL处理紧急情况，否则应在与生产代码相同的CL中添加测试。确保CL中的测试正确，合理且有用。测试不会自我测试，我们很少为测试编写测试-人员必须确保测试有效。</p>
<h4 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h4><p>名字要足够长，直到他可以完全表达清楚它是什么或者它想做什么。</p>
<h4 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h4><p>开发人员是否用可理解的英语写下清晰的评论？所有评论实际上都是必要的吗？通常，当注释解释了为什么存在某些代码，而不应该解释某些代码在做什么时，它们很有用。如果代码不够清晰，无法说明自身，则应简化代码。有一些例外情况（例如，正则表达式和复杂算法通常会从注释中解释它们的作用而受益匪浅），但大多数注释是针对代码本身可能无法包含的信息，例如决策背后的原因。</p>
<h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p>确保CL遵循适当的样式指南。如果您想改善样式指南中没有的样式点，请在注释前面加上“ Nit：”，以使开发人员知道这是您认为可以改善代码但不是强制性的选择。</p>
<p>CL的作者不应将主要样式更改与其他更改结合在一起。这使得很难看到CL中的更改，使合并和回滚更加复杂，并导致其他问题。</p>
<h4 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h4><p>如果CL改变了用户构建，测试，与代码交互或释放代码的方式，请检查其是否还更新了相关文档，包括自述文件</p>
<h4 id="Every-Line"><a href="#Every-Line" class="headerlink" title="Every Line"></a>Every Line</h4><p>查看已分配给您检查的每一行代码。有时您可以扫描数据文件，生成的代码或大型数据结构之类的东西，但不扫描人工编写的类，函数或代码块，并认为其中的内容是可以的。显然，某些代码比其他代码更需要仔细检查-这是您必须做出的判断调用-但您至少应确保您了解所有代码在做什么。如果您阅读代码太困难，并且使审查速度变慢，那么您应该让开发人员知道这一点，并等待他们澄清，然后再尝试审查</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>通常，代码查看工具只会向您显示围绕要更改的部分的几行代码。有时，您必须查看整个文件，以确保更改确实有意义。</p>
<h4 id="Good-Things"><a href="#Good-Things" class="headerlink" title="Good Things"></a>Good Things</h4><p>如果您在CL中看到不错的东西，请告诉开发人员，尤其是当他们以出色的方式回答了您的评论之一时。</p>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>In doing a code review, you should make sure that:</p>
<ul>
<li>The code is well-designed.</li>
<li>The functionality is good for the users of the code.</li>
<li>Any UI changes are sensible and look good.</li>
<li>Any parallel programming is done safely.</li>
<li>The code isn’t more complex than it needs to be.</li>
<li>The developer isn’t implementing things they <em>might</em> need in the future but don’t know they need now.</li>
<li>Code has appropriate unit tests.</li>
<li>Tests are well-designed.</li>
<li>The developer used clear names for everything.</li>
<li>Comments are clear and useful, and mostly explain <em>why</em> instead of <em>what</em>.</li>
<li>Code is appropriately documented (generally in g3doc).</li>
<li>The code conforms to our style guides.</li>
</ul>
<h3 id="Navigating-a-CL-in-review"><a href="#Navigating-a-CL-in-review" class="headerlink" title="Navigating a CL in review"></a>Navigating a CL in review</h3><p>Now that you know <a href="https://google.github.io/eng-practices/review/reviewer/looking-for.html" rel="external nofollow noopener noreferrer" target="_blank">what to look for</a>, what’s the most efficient way to manage a review that’s spread across multiple files?</p>
<ol>
<li>Does the change make sense? Does it have a good <a href="https://google.github.io/eng-practices/review/developer/cl-descriptions.html" rel="external nofollow noopener noreferrer" target="_blank">description</a>?</li>
<li>Look at the most important part of the change first. Is it well-designed overall?</li>
<li>Look at the rest of the CL in an appropriate sequence.</li>
</ol>
<h3 id="Speed-of-Code-Reviews"><a href="#Speed-of-Code-Reviews" class="headerlink" title="Speed of Code Reviews"></a>Speed of Code Reviews</h3><h4 id="Why-should-code-reviews-be-fase"><a href="#Why-should-code-reviews-be-fase" class="headerlink" title="Why should code reviews be fase?"></a>Why should code reviews be fase?</h4><p><strong>At Google, we optimize for the speed at which a team of developers can produce a product together</strong>, as opposed to optimizing for the speed at which an individual developer can write code. The speed of individual development is important, it’s just not <em>as</em> important as the velocity of the entire team.</p>
<p>When code reviews are slow, several things happen:</p>
<ul>
<li><strong>The velocity of the team as a whole is decreased.</strong> Yes, the individual, who doesn’t respond quickly to the review, gets other work done. However, new features and bug fixes for the rest of the team are delayed by days, weeks, or months as each CL waits for review and re-review.</li>
<li><strong>Developers start to protest the code review process.</strong> If a reviewer only responds every few days, but requests major changes to the CL each time, that can be frustrating and difficult for developers. Often, this is expressed as complaints about how “strict” the reviewer is being. If the reviewer requests the <em>same</em> substantial changes (changes which really do improve code health) but responds <em>quickly</em> every time the developer makes an update, the complaints tend to disappear. <strong>Most complaints about the code review process are actually resolved by making the process faster.</strong></li>
<li><strong>Code health can be impacted.</strong> When reviews are slow, there is increased pressure to allow developers to submit CLs that are not as good as they could be. Slow reviews also discourage code cleanups, refactorings, and further improvements to existing CLs.</li>
</ul>
<h3 id="How-to-write-code-revieww-comment"><a href="#How-to-write-code-revieww-comment" class="headerlink" title="How to write code revieww comment"></a>How to write code revieww comment</h3><ul>
<li>Be kind.</li>
<li>Explain your reasoning.</li>
<li>Balance giving explicit directions with just pointing out problems and letting the developer decide.</li>
<li>Encourage developers to simplify code or add code comments instead of just explaining the complexity to you.</li>
</ul>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>codesandbox是如何在浏览器中运行npm模块</title>
    <url>/2021/05/14/codesandbox/</url>
    <content><![CDATA[<p>目前，跑在浏览器端的web IDE产品越来越多，按照他们的功能特性来做划分的话，目前的web IDE可以分为两种，一种是将本地IDE的功能基本原封不动的迁移到了web端的IDE，像是目前最流行的前端IDE VS Code，借助于云+容器化的能力，在浏览器端VS Code拥有着跟本地IDE几乎完全一样的功能；还有一种web IDE则更多的聚焦于 <code>页面开发与实时的代码解析、编译、预览</code>的呈现，代码打包构建的实现则并不局限于在服务端（如基于Docker容器等）实现，部分的产品实现了 <code>基于浏览器端的代码编译、打包、构建、运行</code>的功能，而这一切在我们原来的开发体系里是只有基于 <code>本地IDE+Node本地构建、本地服务+浏览器访问预览</code>才有的能力。此类产品的代表是CodeSandbox，codepen，StackBlitz，JSFiddle等。</p>
<p>也就是说前者只是将代码的编辑放在了web段，其实背后借助了云去做代码的存储，项目的编译打包运行等，这种方式下，我们最后得到的和本地开发并无区别，对我们的区别只是不用特地下个编辑器了。</p>
<p>后者则是将一部分的编译打包功能以及最终的运行放在了浏览器，且由于浏览器的限制，其所能支持的应用大小是有限制的（PS：最近遇到一个问题，看错误应该是代码大小超过了500K，留个坑，留待以后解决，嘿嘿）</p>
<a id="more"></a>

<p>能将 <code>类似基于本地webpack打包构建</code>的能力迁移到浏览器端看起来是一件非常不可思议的事情，上面也已经讲到，实现方式往往有两种方式，一种是基于服务端的webpack的打包构建，构建完后将构建出的代码再转交给浏览器端解析执行，相关实践如：<a href="https://juejin.im/entry/5a372e6a6fb9a0450f220711" rel="external nofollow noopener noreferrer" target="_blank">基于webpack打造前端在线编译器</a>，还有一种实现则是由服务端提供依赖包的代码（从npm安装拉取）返回给客户端，打包构建则完全是在浏览器端实现，实现了浏览器端的’webpack’，比如CodeSandbox就是这种模式的实现。今天我们就来一起看下CodeSandbox的作者这篇文章的介绍，这一切究竟是如何实现的。</p>
<blockquote>
<p>这里注意，codesandbox的实现经历了多次迭代，但改变的只是服务端如何提供依赖，从服务端加载依赖以后返回给客户端使用这一点是没有变的。</p>
</blockquote>
<h2 id="内容梳理"><a href="#内容梳理" class="headerlink" title="内容梳理"></a>内容梳理</h2><p>因为下面很多内容是翻译自codesandbox作者原文，有些地方比较难理解，我先梳理一下整个过程</p>
<ul>
<li>第一版，需要事先将依赖下载到本地，在运行时动态递归分析require的依赖，然后将require给stub本地实现下载的依赖，不仅无法支持所有依赖，而且递归分析性能有瓶颈</li>
<li>借助webpack DllPlugin的思想，首先将依赖关系发送给后台，根据依赖关系的hash，查找后台是否有缓存，如果没有，再分析依赖，通过yarn下载，然后打包成一个dll发回给调用者调用。这个版本一个问题是如果没有在依赖关系中明确定义，是无法被打包的，而且缓存是以依赖关系为键的，如果两个不同的依赖关系树中有相同的package，是不会重用的</li>
<li>为了解决上面一版的第一个问题，作者实现了一个版可以自己添加入口的webpack 打包器</li>
<li>为了解决第二个问题，作者结合serverless，并对依赖项进行了拆分，服务器缓存的是一个一个独立的依赖，服务器只是把下载好的依赖返回给前端，真正负责打包的是前端，这样前端就可以实现按需打包，这一点在后端是无法实现的，因为后端并没有实际的代码，所以没有这个“需”。</li>
<li>然后为了实现离线版本，作者又在前端做了一层缓存</li>
<li>至此，实现了我们目前使用的codesandbox</li>
</ul>
<h2 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h2><p>这个版本的codesandbox只是自己实现了一个算法，利用了类似require的加载方式，去一个个加载依赖到本地（这个本地我个人认为应该指的是用户个人的浏览器）。codesandbox的作者个人认为第一版还不能算是npm的完整支持.</p>
<p>也就是说这一版并不是实时根据代码中的依赖去npm仓库加载依赖，而是事先将依赖下载到本地，然后stub代码中的require，所以作者说这一版并不能支持所有的npm依赖。</p>
<p>而且这个版本应该是具体require a的时候才去分析a依赖了什么，然后一层层递归进去，这种递归如果项目依赖复杂，性能上也有很大的瓶颈。</p>
<blockquote>
<p>This version of npm support was very simple. It wasn’t even really npm support, I just installed the dependencies locally and stubbed every dependency call with an already installed dependency. This, of course, is absolutely not scalable to 400,000 packages with different versions.</p>
<p>Even though this version was not very usable, it was encouraging to see that I was able to at least make two dependencies work in a sandbox environment.</p>
</blockquote>
<h2 id="webpack版本"><a href="#webpack版本" class="headerlink" title="webpack版本"></a>webpack版本</h2><p>第一个版本作者认为完整支持npm是不可能的，直到有人真正实现了。</p>
<p>所以作者就在考虑如何也实现一般出来，他一开始设计了一个算法，不过这个算法比较复杂，最终也没有实际使用，就不赘述了，感兴趣的可以去看文末的参考链接。</p>
<p>紧接着，作者参考了webpack的DLLPlugin插件的实现方式。</p>
<p>简单来说，DllPlugin做的事情就是把一个项目打包成一个dll依赖，将项目中的依赖关系包装在dll中，然后对外暴露接口。这是官方文档地址：<a href="https://webpack.docschina.org/plugins/dll-plugin/#root" rel="external nofollow noopener noreferrer" target="_blank">DllPlugin文档</a></p>
<p>webpack的<a href="https://webpack.js.org/plugins/dll-plugin/" rel="external nofollow noopener noreferrer" target="_blank">DLLPlugin</a>可以打包依赖项，并且使用一个manifest清单来标记打出的js包包含哪些依赖项。这份清单看起来是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"dll_bundle"</span>,</span><br><span class="line">  <span class="attr">"content"</span>: &#123;</span><br><span class="line">    <span class="attr">"./node_modules/fbjs/lib/emptyFunction.js"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"./node_modules/fbjs/lib/invariant.js"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"./node_modules/fbjs/lib/warning.js"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"./node_modules/react"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"./node_modules/fbjs/lib/emptyObject.js"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"./node_modules/object-assign/index.js"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"./node_modules/prop-types/checkPropTypes.js"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"./node_modules/prop-types/lib/ReactPropTypesSecret.js"</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">"./node_modules/react/cjs/react.development.js"</span>: <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个路径都映射一个模块id。如果我想引入 <code>React</code>，我只需要调用 <code>dll_bundle(3)</code>，然后我就得到了React！这对需求来说简直就是完美，</p>
<p>于是作者开始行动，基于Webpack DllPlugin的思想，思考出了一个下面的系统：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621126841/origin-of-ray/1574822062018-7c62e623-e99b-43c1-80a4-a0eba2c3dfdb_ikivwp.png" alt></p>
<p>对于打包的每一个请求，我将在 <code>tmp/:hash</code>下面创建一个新的目录，接着运行 <code>yarn add ${dependencyList}</code>，然后让 <code>webpack</code>做打包处理即可。同时作为一种缓存方案，我会将打出的新包保存至gcloud。这看起来比上面的方案图要简单的多，更多的是因为我使用yarn来安装依赖模块并使用 <code>webpack</code>做打包来作为前一个实现版本中的替代方案。</p>
<blockquote>
<p>这里可能有些难以理解，我来说一下我的看法，在上一版本，也就是第一个版本，codesandbox是需要事先把依赖下载到本地，然后在真正运行到require的时候，才会去递归分析依赖，然后将require给stub到本地的已经下载好的依赖中</p>
<p>而这个版本，借助webpack DllPlugin的思想，codesandbox是先分析依赖关系，然后为这个依赖关系创建一个hash值，去缓存中查看是否有相同的hash，如果有的话，直接返回打包好的Dll，如果没有，再根据依赖关系去npm源下载所有的依赖，暂存在<code>tmp/:hash</code>下面，下载完后，然后将所有的依赖打包成一个Dll，缓存并返回给使用者，然后清除刚刚创建的<code>tmp/hash</code>文件夹。</p>
</blockquote>
<p>但是，这套系统仍然有一个非常大的限制，它不支持引入 <code>不在webpack依赖关系图</code>中的文件。这就意味着像是下面的这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'react-icons/lib/fa/fa-beer'</span>)</span><br></pre></td></tr></table></figure>

<p>将不能正常运行，因为从依赖项的入口开始自始至终都不需要它，也就不会被打包进去。（webpack的打包是基于package.json里的依赖模块以及各个依赖模块的依赖项去做打包的，不被包含在这个体系里的文件则不会被打包进去）</p>
<h2 id="带入口的webpack"><a href="#带入口的webpack" class="headerlink" title="带入口的webpack"></a>带入口的webpack</h2><p>为了解决刚才说的那个限制，也就是说不在webpack依赖关系中的文件无法打包进入最后的dll。</p>
<p>手动的增加了入口配置，以确保 <code>webpack</code>也可以将这些文件能够打包进去。在对这个方案做了非常多的调整之后，这个系统已经可以支持任意（？译者注：作者这里加了问号，表示并不太确定支持任意）组合的打包需求。因此你也可以去加载 react-icons，css文件也是可以的。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621468814/origin-of-ray/packager1_qabrps.png" alt></p>
<h2 id="接入Serverless"><a href="#接入Serverless" class="headerlink" title="接入Serverless"></a>接入Serverless</h2><h3 id="什么是serverless"><a href="#什么是serverless" class="headerlink" title="什么是serverless"></a>什么是serverless</h3><p>基于serverless，你可以定义一个函数，该函数会在服务器被请求的时候触发执行：该函数会首先被启动，然后处理请求，并在一段时间后杀掉并释放自己。这也就意味着你会有非常高的可伸缩性：如果你的服务器同时有1000个请求过来，你可以立即启动1000个服务。这也意味着你仅仅需要按照实际运行时间付费即可。</p>
<h3 id="如何结合serverless"><a href="#如何结合serverless" class="headerlink" title="如何结合serverless"></a>如何结合serverless</h3><p>对于我们的服务来说，serverless听起来简直就是完美：服务不是一直都在运行的，而且如果同时有多个请求，我们需要高并发性。于是我开始非常急切的使用一个叫做<a href="https://serverless.com/" rel="external nofollow noopener noreferrer" target="_blank">Serverless</a>的框架。</p>
<p>得益于Serverless，我们的服务迁移非常顺畅，我在两天内就有了一个可以工作的版本。我创建了三个serverless函数：</p>
<ul>
<li>1、一个源数据解析器：此服务用于解析版本和peerDependencies，并请求打包函数；</li>
<li>2、一个打包器：此服务用于实际的依赖项的安装及打包工作；</li>
<li>3、一个丑化器（压缩&amp;混淆）：负责异步丑化打包生成的包。</li>
</ul>
<p>几天后我还是发现了一个限制：一个lambda函数最大只能拥有500M的磁盘空间，这就意味着一些组合的依赖项无法进行安装（译者注：后端在做打包构建的时候需要将所有的依赖项的代码加载到内存中来进行）。这真的是一个毁灭性的限制，我不得不将服务切回原来的实现。</p>
<p>几个月过去后，我发布了一个新的CodeSandbox的构建器（<a href="https://hackernoon.com/how-i-created-a-parallel-offline-extensible-browser-based-bundler-886db508cc31" rel="external nofollow noopener noreferrer" target="_blank">I released a new bundler for CodeSandbox</a>）。这个构建器非常强大，可以很容易的让我们来支持更多的像是Preact或者Vue的框架。通过支持这些框架，我们的服务收到了一些非常有意思的请求。比如：如果你想在Preact中使用React，你需要将 <code>require(&#39;react&#39;)</code>重命名为： <code>require(&#39;preact-compat&#39;)</code>。对Vue来说，你可能会引入 <code>@/components/App.vue</code>作为你沙箱里的文件。我们服务端的打包器（packager）不会处理这类的事情，但是我们浏览器端的构建器（bundler）会。</p>
<p>就在那时，<strong>我开始想我们也许可以让浏览器端构建器做实际的打包</strong>。如果服务端只是将相关文件发送到浏览器（而不做服务端打包构建的事情），然后我们用浏览器端构建器对依赖模块进行实际的打包，这样处理应该会更快，因为我们没有处理整个的大包，只是部分包。</p>
<p>服务端基于webpack DLLPLugin的打包构建会从依赖入口开始递归遍历所有依赖然后进行打包构建，而浏览器的打包构建只是 <code>按需</code>打包构建。所以会更快的原因有二，一是浏览器端打包构建就不需要服务端再做打包构建了，服务端只是纯粹的依赖项的递归获取，然后发送给浏览器端，这样就节省了服务端打包构建的时间，也节省了服务器开销；二是浏览器端的打包构建是按需构建而非全量构建。</p>
<p>这个方案有一个非常大的优势：<strong>我们可以实现对依赖项单独的安装及缓存</strong>（还记得webpack版本那里所讲吗，从那个版本开始，我们缓存的不是一个个的依赖，而是一个个依赖关系组合中所有的依赖），然后我们在端上实现对依赖项的合并（merge）就好了。这就意味着，如果在现有所有依赖项的基础上再请求一个新的依赖项，则只需要为新的依赖项收集文件即可！这将很好地解决AWS Lambda500M内存限制的局限，因为我们在服务端只是会安装一个依赖模块而已。我们也可以在打包器中舍弃 <code>webpack</code>，因为现在打包器只全权负责找出被依赖的相关的那些文件并把它们发送给浏览器端。</p>
<h2 id="加入浏览器缓存"><a href="#加入浏览器缓存" class="headerlink" title="加入浏览器缓存"></a>加入浏览器缓存</h2><p>作者说不采取从unpkg.com上直接动态请求文件的方案，是因为想支持离线方案，即即使你没有网络你也可以实现浏览器端的编译打包构建预览，前提是你已经在浏览器端做了相关文件的本地缓存。基于作者实现的服务端单个依赖打包的方案是将整个依赖模块的所有文件全部缓存在了本地浏览器，而基于动态的从unpkg.com上请求文件是单个的请求某个依赖模块里的单个文件，很容易出现某个依赖文件不存在的情况。</p>
<p>也就是说，每次去请求单独的依赖时，去后台获取依赖之前会先看一下本地是不是有缓存。</p>
<h2 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h2><p><strong>CodeSandbox 打包和运行并不依赖于服务器, 只是如果你所需的依赖在客户端没有缓存，需要去服务器请求</strong></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621128800/origin-of-ray/codesandbox-arch_b64xm7.png" alt></p>
<ul>
<li><strong>Editor</strong>: 编辑器。主要用于修改文件，CodeSandbox这里集成了 <code>VsCode</code>, 文件变动后会通知 <code>Sandbox</code> 进行转译。</li>
<li><strong>Sandbox</strong>: 代码运行器。<strong>Sandbox 在一个单独的 iframe 中运行, 负责代码的转译(Transpiler)和运行(Evalation)</strong>. 如最上面的图，左边是Editor，右边是Sandbox</li>
<li><strong>Packager</strong> 包管理器。类似于yarn和npm，负责拉取和缓存 npm 依赖</li>
</ul>
<p>CodeSandbox 的作者 <a href="https://twitter.com/CompuIves" rel="external nofollow noopener noreferrer" target="_blank">Ives van Hoorne</a> 也尝试过将 <code>Webpack</code> 移植到浏览器上运行，因为现在几乎所有的 CLI 都是使用 Webpack 进行构建的，如果能将 Webpack 移植到浏览器上, 可以利用 Webpack 强大的生态系统和转译机制(loader/plugin)，低成本兼容各种 CLI.</p>
<p>然而 Webpack 太重了😱，压缩过后的大小就得 3.5MB，这还算勉强可以接受吧；更大的问题是要在浏览器端模拟 Node 运行环境，这个成本太高了，得不偿失。</p>
<p>所以 CodeSandbox 决定自己造个打包器，这个打包器更轻量，并且针对 CodeSandbox 平台进行优化. 比如 CodeSandbox 只关心开发环境的代码构建, 目标就是能跑起来就行了, 跟 Webpack 相比裁剪掉了以下特性:</p>
<ul>
<li>生产模式. CodeSandbox 只考虑 development 模式，不需要考虑 production一些特性，比如<ul>
<li>代码压缩，优化</li>
<li>Tree-shaking</li>
<li>性能优化</li>
<li>代码分割</li>
</ul>
</li>
<li>文件输出. 不需要打包成chunk</li>
<li>服务器通信. Sandbox直接原地转译和运行, 而Webpack 需要和开发服务器建立一个长连接用于接收指令，例如 HMR.</li>
<li>静态文件处理(如图片). 这些图片需要上传到 CodeSandbox 的服务器</li>
<li>插件机制等等.</li>
</ul>
<p>所以可以认为<strong>CodeSandbox是一个简化版的Webpack, 且针对浏览器环境进行了优化，比如使用worker来进行并行转译</strong></p>
<h3 id="项目构建过程"><a href="#项目构建过程" class="headerlink" title="项目构建过程"></a>项目构建过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packager -&gt; transpilation -&gt; evaluation</span><br></pre></td></tr></table></figure>

<p>Sandbox 构建分为三个阶段:</p>
<ul>
<li><strong>Packager</strong> 包加载阶段，下载和处理所有npm模块依赖</li>
<li><strong>Transpilation</strong> 转译阶段，转译所有变动的代码, 构建模块依赖图</li>
<li><strong>Evaluation</strong> 执行阶段，使用 <code>eval</code> 运行模块代码进行预览</li>
</ul>
<h4 id="Packer"><a href="#Packer" class="headerlink" title="Packer"></a>Packer</h4><p>由于 CodeSandbox 已经包揽了代码构建的部分，所以我们并不需要<code>devDependencies</code>, 也就是说 <strong>在CodeSandbox 中我们只需要安装所有实际代码运行需要的依赖，这可以减少成百上千的依赖下载. 所以暂且不用担心浏览器会扛不住</strong>.</p>
<p>而在Packer下载依赖之前其实先经过了Transpilation转移阶段去按需分析依赖，然后再拿分析产物去Packer</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621469497/origin-of-ray/packager2_pk7goe.png" alt></p>
<h4 id="Transpilation"><a href="#Transpilation" class="headerlink" title="Transpilation"></a>Transpilation</h4><p> 这个阶段<strong>从应用的入口文件开始, 对源代码进行转译, 解析AST，找出下级依赖模块，然后递归转译，最终形成一个’依赖图’</strong>:</p>
<p>CodeSandbox 的整个转译器是在一个单独的 iframe 中运行的：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621469683/origin-of-ray/editor-vs-compiler_m9eo6p.png" alt="img"></p>
<p>Editor 负责变更源代码，源代码变更会通过 postmessage 传递给 Compiler，这里面会携带 <code>Module+template</code></p>
<ul>
<li><strong>Module</strong> 中包含所有源代码内容和模块路径，其中还包含 package.json, Compiler 会根据 package.json 来读取 npm 依赖;</li>
<li><strong>template</strong> 表示 Compiler 的 Preset，例如<code>create-react-app</code>、<code>vue-cli</code>, 定义了一些 loader 规则，用来转译不同类型的文件, 另外preset也决定了应用的模板和入口文件。 通过上文我们知道, 这些 template 目前的预定义的.</li>
</ul>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621469733/origin-of-ray/compiler_cgbsyb.png" alt></p>
<p>大局上基本上可以划分为以下四个阶段:</p>
<ul>
<li><strong>配置阶段</strong>：配置阶段会创建 Preset 对象，确定入口文件等等. CodeSandbox 目前只支持限定的几种应用模板，例如 vue-cli、create-react-app。不同模板之间目录结构的约定是不一样的，例如入口文件和 html 模板文件。另外文件处理的规则也不一样，比如 vue-cli 需要处理<code>.vue</code>文件。</li>
<li><strong>依赖下载阶段</strong>： 即 Packager 阶段，下载项目的所有依赖，生成 Manifest 对象</li>
<li><strong>变动计算阶段</strong>：根据 Editor 传递过来的源代码，计算新增、更新、移除的模块。</li>
<li><strong>转译阶段</strong>：真正开始转译了，首先重新转译上个阶段计算出来的需要更新的模块。接着从入口文件作为出发点，转译和构建新的依赖图。这里不会重复转译没有变化的模块以及其子模块</li>
</ul>
<h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p>虽然称为打包器(bundler), 但是 CodeSandbox 并不会进行打包，也就是说他不会像 Webpack 一样，将所有的模块都打包合并成 chunks 文件.</p>
<p><code>Transpilation</code>从<code>入口文件</code>开始转译, 再分析文件的模块导入规则，递归转译依赖的模块. 到<code>Evaluation</code>阶段，CodeSandbox 已经构建出了一个完整的<strong>依赖图</strong>. 现在要把应用跑起来了</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621470036/origin-of-ray/evaluation_gseiqz.png" alt></p>
<p>参考链接：</p>
<p><a href="https://www.yuque.com/wangxiangzhong/aob8up/uf99c5?language=en-us" rel="external nofollow noopener noreferrer" target="_blank">https://www.yuque.com/wangxiangzhong/aob8up/uf99c5?language=en-us</a></p>
<p><a href="https://hackernoon.com/how-we-make-npm-packages-work-in-the-browser-announcing-the-new-packager-6ce16aa4cee6" rel="external nofollow noopener noreferrer" target="_blank">codesandbox作者解读</a></p>
<p><a href="https://segmentfault.com/a/1190000019679430" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000019679430</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>ESModule和CommonJS的比较以及注意事项</title>
    <url>/2021/04/09/compare-esmodule-and-commonjs/</url>
    <content><![CDATA[<p>在 ES6 中，我们知道 import、export 取代了 require、module.exports 用来引入和导出模块，但是如果不了解 ES6 模块特性的话，代码可能就会运行出一些匪夷所思的结果，下面我将通过这篇文章为你揭开 ES6 模块机制特点。</p>
<p>关于二者的使用方式我就不具体介绍了，有兴趣的可以看一下我以前的博客：<a href="https://sunra.top/2020/01/17/js-modules2/">JavaScript Module使用语法</a></p>
<p>本文主要针对以下几个问题：</p>
<ul>
<li>这二者输出的是拷贝还是引用，拷贝的话是深拷贝还是浅拷贝？</li>
<li>二者的加载运行时机有什么不同？</li>
<li>它们是如何解决循环依赖以及重复加载问题的？</li>
<li>二者的运行环境有什么不同，它们什么情况下可以混合使用，为什么可以？</li>
</ul>
<a id="more"></a>

<h2 id="拷贝-or-引用"><a href="#拷贝-or-引用" class="headerlink" title="拷贝 or 引用"></a>拷贝 or 引用</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>我们看一下下面这段代码及其运行结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  foo = <span class="number">2</span>;</span><br><span class="line">  bar.a = <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: foo,</span><br><span class="line">  bar</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.foo);</span><br><span class="line"><span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b.foo);</span><br><span class="line">  <span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node a.js 结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这段代码在a引入b之后，在b的内部修改了foo和bar，然后再次打印了foo和bar，可以看到，foo的值没有改变，而bar改变了。</p>
<p>这说明了什么？module.exports.foo已经与内部的foo不是一个变量了，而module.exports.bar与内部的bar还是一个变量。</p>
<p>但是这能说明CommonJS是拷贝还是引用吗？</p>
<blockquote>
<p>这里做一个简单说明，module.exports在初始时就是exports，就是说，有一个exports变量，然后我们把module.exports赋值为这个exports，所以exports.a 与 module.exports.a赋值是完全相同的效果。</p>
<p>区别在于我们require的是module.exports，而不是exports，如果我们直接修改了module.exports的引用，那我们在exports上挂载的属性是完全无用的。</p>
<p>举个例子：</p>
<p>exports.a = 1;</p>
<p>exports.b = 2;</p>
<p>module.exports = { c: 3 };</p>
<p>如果只有前两行，我们require的时候会得到 { a: 1, b: 2 }，但是第三行直接覆写了module.exports，这个时候我们require的话，得到的就是{ c: 3 }</p>
</blockquote>
<p>我再举一个例子，大家思考一下它的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports.foo = <span class="number">2</span>;  <span class="comment">// 不同之处</span></span><br><span class="line">  bar.a = <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: foo,</span><br><span class="line">  bar</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.foo);</span><br><span class="line"><span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b.foo);</span><br><span class="line">  <span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node a.js 结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="comment">// 这里就是2了，为什么？</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从上面这个例子我们可以看出，<strong>require的结果其实就是module.exports的引用</strong>。</p>
<ul>
<li>为什么第一个例子中foo没有改而第二个改变了，因为在生成module.exports的时候，foo是基本类型，被深复制给了module.exports.foo，我们require进来的是module.exports.foo而不是内部的b内部的foo。</li>
<li>为什么bar一直都是改了，因为在生成module.exports的时候，bar是个对象，module.exports.bar中保存的是bar的地址，而不是深复制，所以我们require进来的module.exports.bar就是内部的bar，它们两个指向同一个内存地址</li>
</ul>
<blockquote>
<p>你也可以这么理解：</p>
<p>我们在构造module.exports的时候其实是一层浅拷贝，把值浅拷贝给了module.exports中的属性。</p>
<p>但是我们require的时候引入的是module.exports的引用。</p>
</blockquote>
<h3 id="ESModule"><a href="#ESModule" class="headerlink" title="ESModule"></a>ESModule</h3><blockquote>
<p>ESModule是ES6引入的，所以没有babel，node是没法识别的，我们就用浏览器来执行。</p>
<p>但如果你直接用html引入js的方式，有两点需要注意：</p>
<ol>
<li>script的type需要是module</li>
<li>你需要其一个服务器，可以用anywhere这个npm package，因为浏览器对于file协议认为是跨域的</li>
</ol>
</blockquote>
<p>老规矩，看代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  foo = <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./b.js'</span>).then(<span class="function">(<span class="params">&#123; foo &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从这个结果来看，<strong>ES6 模块是动态关联模块中的值，也就是说看起来是引用</strong></p>
<blockquote>
<p>之所以说是看起来，是因为我还没有去看过具体实现，只是从表象上来看，是引用</p>
</blockquote>
<h2 id="二者的加载运行时机有什么不同？"><a href="#二者的加载运行时机有什么不同？" class="headerlink" title="二者的加载运行时机有什么不同？"></a>二者的加载运行时机有什么不同？</h2><p>ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载，也就是说</p>
<p>对于CommonJS只有在require的时候，才会去引入。</p>
<p>ES6 模块编译时执行会导致有以下两个特点：</p>
<ol>
<li>import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。</li>
<li>export 命令会有变量声明提前的效果。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js'</span>)</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 先执行'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="comment">// b.js 先执行</span></span><br><span class="line"><span class="comment">// a.js</span></span><br></pre></td></tr></table></figure>

<h2 id="重复加载问题"><a href="#重复加载问题" class="headerlink" title="重复加载问题"></a>重复加载问题</h2><h3 id="CommonJS-1"><a href="#CommonJS-1" class="headerlink" title="CommonJS"></a>CommonJS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports.foo = <span class="number">2</span>;</span><br><span class="line">  bar.a = <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: foo,</span><br><span class="line">  bar</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.foo);</span><br><span class="line"><span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b.foo);</span><br><span class="line">  <span class="built_in">console</span>.log(b.bar.a);</span><br><span class="line"></span><br><span class="line">  b.foo = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">'./b'</span>).foo);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node a.js</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>这个例子说明，每个module只会加载一次，每次require返回的都是同一个引用。</p>
<h3 id="ESModule-1"><a href="#ESModule-1" class="headerlink" title="ESModule"></a>ESModule</h3><p>这个很好理解，无论是 ES6 模块，当你重复引入某个相同的模块时，模块只会执行一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'只会执行一次'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 只会执行一次</span></span><br></pre></td></tr></table></figure>

<h2 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h2><p>解决了重复引用到问题，那么循环依赖的问题就可以解释了</p>
<h3 id="CommonJS-2"><a href="#CommonJS-2" class="headerlink" title="CommonJS"></a>CommonJS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, b.done ='</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, a.done ='</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in b, a.done = false</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// in a, b.done = true</span></span><br><span class="line"><span class="comment">// a done</span></span><br></pre></td></tr></table></figure>

<p>结合之前讲的特性很好理解，当你从 b 中想引入 a 模块的时候，因为 node 之前已经加载过 a 模块了，所以它不会再去重复执行 a 模块，而是直接去生成当前 a 模块吐出的 module.exports 对象，因为 a 模块引入 b 模块先于给 done 重新赋值，所以当前 a 模块中输出的 module.exports 中 done 的值仍为 false。而当 a 模块中输出 b 模块的 done 值的时候 b 模块已经执行完毕，所以 b 模块中的 done 值为 true。</p>
<p>从上面的执行过程中，我们可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。虽然这种模块加载机制可以避免出现循环依赖时报错的情况，但稍不注意就很可能使得代码并不是像我们想象的那样去执行。因此在写代码时还是需要仔细的规划，以保证循环模块的依赖能正确工作。</p>
<h3 id="ESModule-2"><a href="#ESModule-2" class="headerlink" title="ESModule"></a>ESModule</h3><p>跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>)</span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, foo:'</span>, foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, bar:'</span>, bar);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'in a, setTimeout bar:'</span>, bar);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in a, bar: undefined</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// in b, foo: foo</span></span><br><span class="line"><span class="comment">// a done</span></span><br><span class="line"><span class="comment">// in a, setTimeout bar: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import()"></a><strong>动态 import()</strong></h3><p>ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(some condition) &#123;</span><br><span class="line">  <span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> (str + <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入 import() 应运而生。</p>
<p>import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。</p>
<ul>
<li>require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话 require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。</li>
<li>而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()</li>
</ul>
<p>我们先来看下它的用法：</p>
<ol>
<li>动态的 import() 提供一个基于 Promise 的 API</li>
<li>动态的import() 可以在脚本的任何地方使用</li>
<li>import() 接受字符串文字，你可以根据你的需要构造说明符</li>
</ol>
<p>举个简单的使用例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'./b'</span>;</span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./b'</span>).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span>(str).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。</p>
<h2 id="二者什么情况下可以混用"><a href="#二者什么情况下可以混用" class="headerlink" title="二者什么情况下可以混用"></a>二者什么情况下可以混用</h2><h3 id="Node-js-的区分"><a href="#Node-js-的区分" class="headerlink" title="Node.js 的区分"></a>Node.js 的区分</h3><p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>
<p>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="string">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment"># 解释成 ES6 模块</span></span><br><span class="line">&gt; $ node my-app.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</p>
<p>总结为一句话：<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</p>
<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function">(<span class="params"><span class="keyword">async</span> (</span>) =&gt;</span> &#123;</span><br><span class="line">&gt; <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./my-app.mjs'</span>);</span><br><span class="line">&gt; &#125;)();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码可以在 CommonJS 模块中运行。</p>
<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">// 正确</span></span><br><span class="line">&gt; <span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">'commonjs-package'</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 报错</span></span><br><span class="line">&gt; <span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">'commonjs-package'</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p>
<p>加载单一的输出项，可以写成下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">'commonjs-package'</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> &#123; method &#125; = packageMain;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="同时支持两种格式的模块"><a href="#同时支持两种格式的模块" class="headerlink" title="同时支持两种格式的模块"></a>同时支持两种格式的模块</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>
<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>
<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">'../index.js'</span>;</span><br><span class="line">&gt; <span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.foo; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>
<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>{ type: &quot;module&quot; }</code>。</p>
<p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="string">"exports"</span>：&#123; </span><br><span class="line">&gt;  <span class="string">"require"</span>: <span class="string">"./index.js"</span>，</span><br><span class="line">&gt;  <span class="string">"import"</span>: <span class="string">"./esm/wrapper.js"</span> </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>
<h3 id="webpack-babel编译"><a href="#webpack-babel编译" class="headerlink" title="webpack + babel编译"></a>webpack + babel编译</h3><p>webpack本身就可以支持用自身的方式去<code>__webpack_exports__</code>，<code>__webpack_require__</code>去替代CommonJS，ESModule等。</p>
<p>而Babel则是将ES6的import，export转化为CommonJS，也就是说转化后的代码是没有import和export这种写法的。</p>
<p>具体的源码我们另开一篇博客分析，目前的内容已经很多了。</p>
]]></content>
  </entry>
  <entry>
    <title>几种基础数据结构的比较</title>
    <url>/2020/10/16/comparison-of-data-structures/</url>
    <content><![CDATA[<p><strong>对于计算机而言，它只知道利用内存地址去访问内存中的变量，我们人为分出了两种存储形式，一种是连续存储（也就是数组），一种是链式存储（链表），至于其他的数据结构其实都是对这两种存储形式的利用。任何一种数据结构都可以用两种存储形式去实现，只有合适不合适的问题，没有能不能的问题，因为最终都是利用内存地址去访问内存。</strong>队列，栈我们平时都用数组实现，但是用链表也可以，比如树我们大部分情况下用链表实现，但是其实像完全二叉树用数组去实现也完全没问题。</p>
<p>这篇博客主要是<strong>通过一些例子去分析这些情况下我们需要什么数据结构的什么特性，为了更好地满足这些特性，我们需要用数组还是链表去实现。</strong>对于所有的内容都不会去细讲，更不会涉及具体实现，因为都很基础，但真要展开讲也会变成长篇大论，我们更主要的是从一个更高的层面看他们的一些特性。</p>
<a id="more"></a>

<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>我个人认为，数据结构可以分两部分说。</p>
<p>一种是数据的存储结构，也就是顺序存储还是链式存储。</p>
<p>一种是数据的逻辑结构，及一组相同类型的数据之间的特殊关系以及为了维持这种关系定义的一系列特殊的增删查改操作。</p>
<h2 id="如何选择设计一个数据结构"><a href="#如何选择设计一个数据结构" class="headerlink" title="如何选择设计一个数据结构"></a>如何选择设计一个数据结构</h2><p>不同的数据结构适用于不同的场景，数组的连续性可以让我们高效地随机访问，但是插入和删除就比较费时，扩容也比较麻烦，而链表虽然不能高效地随机访问，但是插入和删除很简单，也没有扩容这一说。我们设计数据结构的时候就是反复利用这两点来做文章。</p>
<p>比如拉链式的散列表利用哈希函数快速获得数组下标，然后利用链表实现快速插入和删除。</p>
<p>比如利用堆（一种完全二叉树）来实现将链表搜索的O(n)简化为O(logn)等。</p>
<p>我们平时选择一个数据结构的思考过程应该是这样的：</p>
<ul>
<li>我们这个场景需要<strong>选择什么样的算法</strong>，如逆波兰就是需要先进后出</li>
</ul>
<ul>
<li>这个<strong>算法需要什么特性的数据结构</strong>，如果只需要入栈出栈，那就选择栈。</li>
</ul>
<ul>
<li>再根据我们具体的需求，是否需要频繁扩容缩容，是否对访问时间有高要求等等<strong>选择数据结构合适的存储方式</strong>。</li>
</ul>
<p>其实这个过程与数据结构产生的过程是相反的。</p>
<p><strong>无论是数组还是链表，对于计算机而言都是利用内存地址去访问内存中的数据</strong>，只不过数组的内存地址是连续的，所以我们可以通过首地址加偏移量的形式直接计算出要访问的数据的内存地址，而链表的内存地址是不连续，需要链表中的每一个节点记录下一个节点内存地址，而不是通过偏移量计算得出的。</p>
<p>所以说<strong>数组还是链表其实是我们人为对计算机存储空间的一种利用形式的不同</strong>。</p>
<p>而<strong>不同的数据结构可以说是我们赋予这些相同类型数据之间的一些特殊关系，这些关系能够帮助我们算法更高效地执行，所以需要特殊的插入删除方式去维持这种关系</strong>。如只能FIFO的数组我们叫队列，必须左子节点小于父节点，右子节点大于父节点的我们叫二叉搜索树。</p>
<h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>数组和链表既是计算机内存中存储数据的两种方式，也是最基本的数据结构，用来进行最基本的数据存储。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特性就是先进先出（FIFO），它的操作就是入队和出队，入队就是在队尾添加一项，出队就是从队首弹出一项。</p>
<p>比如我们JavaScript中的EventLoop，或者Vue中的nextTick都是这种形式。</p>
<p>每次事件触发后都将回调函数放入到一个队列中，然后不断循环从头遍历队列，依次从头部取出回调函数来执行。</p>
<p>当我们需要运用到<strong>先进先出的特性时，我们就可以使用队列这种数据结构</strong>。</p>
<p>而队列的实现，使用数组和链表都没有问题，正常情况下，它的插入和删除都只需要O(1)。</p>
<p>但是如果<strong>利用数组来实现，由于数组的连续内存的特性</strong>，导致我们必须事先指定好这个数组的大小，然后去申请一块连续的内存，所以如果一旦队列的长度需要超过一开始的队列长度，那就<strong>存在一个扩容问题</strong>，我们需要申请一块更大的内存，然后把数据拷贝过去，再回头把这块内存释放掉，这个时候插入的时间复杂度就会变成O(n)。</p>
<p>而如果使用<strong>链表则不会存在扩容问题</strong>，因为它的内存是不连续的，我们可以在入队时单独为入队的数据申请内存。但是由于它的内存是不连续的，所以<strong>我们没有办法通过首地址加偏移量的方式计算出每个节点的地址，就需要额外的空间去记录每个节点的地址</strong>，也就是我们每个节点都要记录下一个节点的地址。</p>
<p>所以说具体是使用数组还是链表具体还要看需求，如果队列长度固定或者不怎么变化，用数组比较好，因为连续的内存空间对于缓存比较友好，但如果队列长度会不断变化，需要存储的数据也比指针所需的空间大得多，其实链表更好一点。</p>
<p>关于队列的其他内容可以去看我的另一篇<a href="https://sunra.top/2020/10/02/queue/">关于队列的文章</a></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的特点是先进后出，它的操作就是入栈和出栈，入栈也可以叫做压栈，就是从栈顶压入一项，出栈就是从栈顶弹出一项，也就是入栈和出栈是从同一头。</p>
<p>比如leetcode上面的这道<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" rel="external nofollow noopener noreferrer" target="_blank">逆波兰表达式求值</a>，它的解题思路就是非常经典的栈的应用。</p>
<p>同样的，栈的实现也是既可以用数组实现，也可以用链表实现。</p>
<p>关于栈就不多做分析了，其实和队列是大同小异的。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>我们上面也说过，链式的问题就在于对于随机访问的时间复杂度是O(n)。</p>
<p>即便是链表中的数据已经是从小到大排好序的，也没法像数组那样利用二分法在O(logn)的时间夫复杂度找到需要的数据。</p>
<p>针对这种问题，计算机领域经典的空间换时间就来了，我们可以每隔k个节点向上抽出第一个节点组成一个新的链表，抽出的节点中保存一个新的指针指向原节点。</p>
<p>这样我们层层抽取，直到某一层只剩一个节点。</p>
<p>这个时候我们再去查找某个数据，就可以先从最上层比较，如果大于当前节点值，就把指针下移一层，再向后比较，找到最后一个小于它的节点，再下沉，一直到最后一层。</p>
<p>这样一来查找的时间复杂度就会下降为以k为底n的对数。</p>
<p>我们常说的redis数据库其使用的就是跳表。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>关于散列表的介绍，可以先去看一下我的这篇<a href="https://sunra.top/2020/10/12/hash-table/">关于散列表的文章</a></p>
<p>看完以后，我们可以大概总结下，散列表完全可以只是一个数组，它利用的最重要的特性就是数组可以根据下标进行O(1)时间复杂度的随机访问，通过散列函数计算出数据应该存储的下标位置，但是由于鸽笼原理（n + 1只鸽子放在n个笼子里，必定有个笼子不止一个鸽子），就算你的散列函数设计的再好，散列冲突是必然存在的。</p>
<p>那我们就要想办法解决散列冲突，一种就是开放寻址法，通过其他方法在散列表中找到另一个空位，另一个就是利用链表的特性，使用拉链法，散列表中的每一项其实都是一个链表的头节点，每次插入数据其实都是在链表中插入。</p>
<p>拉链法就很好地结合了数组和链表的特性，首先利用散列函数计算出数据应该存在的散列表下标，利用数组随机访问的优势快速找到应该存在的链表，然后在链表中找到或者插入。只要我们散列函数设计得好，这个拉链平均长度就不会太长，时间复杂度还可以认为是O(1)。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>到目前位置，我们可能觉得散列表已经能够很好的支持我们的需求了，为啥还需要出现树呢？</p>
<p>这里我们就要讲一下几点散列表的局限性了：</p>
<ul>
<li>散列中的数据是无序的，也就是说如果要查找某个特定的值，散列可以很好的运作，但是如果我们要找某个范围的所有数据，散列表就没法工作了</li>
<li>散列函数很难设计，所以导致散列表的性能很不稳定，而且如果涉及到扩容缩容之类的，更加麻烦。</li>
<li>为了尽量避免散列冲突，装载因子不能太大，所以会有部分空间浪费。</li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>对于刚才讲的第一点局限性，我们可以使用二叉搜索树(BST)来实现</p>
<p>二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？这些都依赖于二叉查找树的特殊结构。二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p>除了插入、删除、查找操作之外，二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。这些操作我就不一一展示了。我会将相应的代码放到 GitHub 上，你可以自己先实现一下，然后再去上面看。二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>上面讲的二叉搜索树看起来也很好，但是还是有问题。假设我们又1-9九个树，很有可能通过一系列的插入删除操作，变成了从根节点一路左子节点到0，那这个时候二叉搜索树就变成了个链表，效率就会急剧退化成O(n)。</p>
<p>所以我们就需要尽量保证左右子树的高度差别不要太大，这就引出了平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p>
<p>如果我们的BST还是一个平衡二叉树，那就可以很好解决上面这个问题。</p>
<p>当然我们实践中可能用到的更多是<strong>红黑树</strong>，一种近似平衡的二叉树。</p>
<h3 id="堆（完全二叉树）"><a href="#堆（完全二叉树）" class="headerlink" title="堆（完全二叉树）"></a>堆（完全二叉树）</h3><p>堆是一种特殊的树。我们现在就来看看，什么样的树才是堆。</p>
<p>我罗列了两点要求，只要满足这两点，它就是一个堆。</p>
<ul>
<li><p>堆是一个完全二叉树；</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>
</li>
</ul>
<p>第一点，堆必须是一个完全二叉树。还记得我们之前讲的完全二叉树的定义吗？完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p>
<p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p>
<p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。</p>
<p>对于堆的应用，非常常见的就是TopK的关键词推荐。</p>
<p>对于这个需求，我们可以维护一个节点数为K的小顶堆，然后依次遍历关键词出现的次数，如果次数小于根节点，则继续，如果大于则进行入堆操作。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>既然又出现了一个新的数据结构，那就必然是有的问题上面的数据结构没法很好地支持。</p>
<p>作为除了树以外的另一种非线性数据结构，图能够表达的关系是交叉的，节点之间的关系不一定是父子关系。</p>
<p>比如我们的社交网络，每个人都是一个节点，两两之间如果存在关系，就连接起来，这种关系是树无法表达的。</p>
<p>当然，图的存储也可以用数组或者链表，数组的话我们可以用邻接矩阵，链表我们可以用邻接表</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Cookie与同站</title>
    <url>/2020/12/18/cookie-and-samesite/</url>
    <content><![CDATA[<p>最近在重新看cookie的配置的时候，发现了它的一个新的配置，叫做sameSite。</p>
<p>这个sameSite的中文翻译就是同站。</p>
<p>我们今天就来看一下这个同站是什么，它和同源有什么区别，为什么cookie明明都有domain和path来规定作用域了还需要sameSite这个属性。</p>
<a id="more"></a>

<h2 id="同源和同站"><a href="#同源和同站" class="headerlink" title="同源和同站"></a>同源和同站</h2><ul>
<li>同源：协议（scheme）+ 主机名（hostname）+ 端口号（port） 完全一致。</li>
<li>同站：<code>eTLD+1</code> 完全一致。</li>
</ul>
<p><code>TLD</code> 表示顶级域名，例如 <code>.com</code>、<code>.org</code>、<code>.cn</code> 等等，不过顶级域名并不是一成不变的，会随着时间推移增加，</p>
<p><code>TLD+1</code> 表示顶级域名和它前面二级域名的组合，例如网址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.example.com:443/foo</span><br></pre></td></tr></table></figure>

<p>那么：</p>
<ul>
<li><code>TLD</code> 是 <code>.com</code></li>
<li><code>TLD+1</code> 是 <code>example.com</code></li>
</ul>
<p>但是，这种表示方式是有缺陷的，例如对于下面的网址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.example.com.cn</span><br></pre></td></tr></table></figure>

<p>如果按照上面的规则，它的 <code>TLD+1</code> 就是 <code>com.cn</code>，并不能表示这个站点，真正能表示这个站点的应该是 <code>example.com.cn</code> 才对，所以衍生出 <code>eTLD</code> 的概念，即<strong>有效顶级域名</strong>：</p>
<ul>
<li><code>eTLD</code>：<code>com.cn</code></li>
<li><code>eTLD+1</code>：<code>example.com.cn</code></li>
</ul>
<blockquote>
<p>注意，同源与跨域同级的概念</p>
<p>同站与跨站是相同的概念，比如著名的XSS和CSRF，都是跨站攻击</p>
</blockquote>
<h2 id="Cookie的作用域"><a href="#Cookie的作用域" class="headerlink" title="Cookie的作用域"></a>Cookie的作用域</h2><p><strong>Cookie有两个很重要的属性:Domain和Path，用来指示此Cookie的作用域：</strong></p>
<p>　 Domain 告诉浏览器当前要添加的 Cookie 的域名归属，如果没有明确指明，则默认为当前域名，比如通过访问 <a href="http://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com</a> 添加的 Cookie 的域名默认就是<a href="http://www.baidu.com，通过访问[www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com，通过访问[www.baidu.com</a> 所生成的 Cookie 的域名就是<a href="http://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com</a></p>
<p>　　Path 告诉浏览器当前要添加的Cookie的路径归属，如果没有明确指明则默认为当前路径，比如通过访问 <a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/java/hotspot.html" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com/java/hotspot.html</a> 添加的 Cookie 的默认路径就是/java/,通过 <a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/java/hotspot.html" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com/java/hotspot.html</a> 生成的 Cookie 的路径也是 /java/</p>
<p><strong>浏览器提交的Cookie需要满足以下两点：</strong></p>
<ul>
<li><p>当前域名或者父域名下的Cookie；</p>
</li>
<li><p>当前路径或父路径下的Cookie</p>
</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>搞明白了同站和Cookie的作用域是什么，我们再来看看CSRF的攻击方式。</p>
<p>Cookie是我们用来应对HTTP无状态的一种解决方案，通过将一些用户信息存储在浏览器，然后在接下来的请求中自动携带cookie来达到让HTTP请求携带状态的目的。</p>
<p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。</p>
<p>举例来说，用户登陆了银行网站<code>your-bank.com</code>，银行服务器发来了一个 Cookie。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie:id=afasdfafa;</span><br></pre></td></tr></table></figure>

<p>用户后来又访问了恶意网站<code>evil.com</code>，上面有一个表单。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"your-bank.com/transfer"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用户一旦被诱骗发送这个表单，<strong>由于请求的目标是银行，所以就会自动携带上cookie中在银行的domain和path下的内容</strong>，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，表单一般都带有一个随机 token，告诉服务器这是真实请求。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"your-bank.com/transfer"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"token"</span> <span class="attr">value</span>=<span class="string">"dad3weg34"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种第三方网站引导发出的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。</p>
<p>比如，Facebook 在第三方网站插入一张看不见的图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"facebook.com"</span> <span class="attr">style</span>=<span class="string">"visibility:hidden;"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p>
<h2 id="SameSite属性"><a href="#SameSite属性" class="headerlink" title="SameSite属性"></a>SameSite属性</h2><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止 CSRF 攻击和用户追踪。</p>
<p>但是既然cookie已经有了domain和path，为什么还需要一个sameSite呢？</p>
<p><strong>其实是因为sameSite限制的并不是cookie的作用域，作用域限制的是当我一个请求想要携带cookie时，它能获取到什么cookie，这个叫作用域，而sameSite限制的是如果从我的页面发出去一个请求，我是否允许它携带cookie</strong></p>
<p>举个例子，我自己的博客页面有一条指向淘宝的链接，无论这条链接是我自己贴的，还是被XSS注入的，反正有这么条连接，如果我在我的博客点击了这条链接，由于我的博客和淘宝是不同站的，所以sameSite的限制根本就不会允许这个请求携带cookie，如果没有sameSite的限制，才会进一步去根据作用域看看有什么允许的cookie。</p>
<p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。</p>
<p>它可以设置三个值。</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，<strong>只有当前网页的 URL 与请求目标一致，才会带上 Cookie</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Strict;</span><br></pre></td></tr></table></figure>

<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Lax;</span><br></pre></td></tr></table></figure>

<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>
<table>
<thead>
<tr>
<th align="left">请求类型</th>
<th align="center">示例</th>
<th align="right">正常情况</th>
<th align="left">Lax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">链接</td>
<td align="center"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">预加载</td>
<td align="center"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">GET 表单</td>
<td align="center"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">发送 Cookie</td>
</tr>
<tr>
<td align="left">POST 表单</td>
<td align="center"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">iframe</td>
<td align="center"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">AJAX</td>
<td align="center"><code>$.get(&quot;...&quot;)</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
<tr>
<td align="left">Image</td>
<td align="center"><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td align="left">不发送</td>
</tr>
</tbody></table>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None</span><br></pre></td></tr></table></figure>

<p>下面的设置有效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://juejin.cn/post/6877496781505200142" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.cn/post/6877496781505200142</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>CSS主流布局总结与比较(四)圣杯布局</title>
    <url>/2021/04/26/css-layout-grail/</url>
    <content><![CDATA[<p>前面的博客总结了水平垂直居中和两列布局。</p>
<p>这次我们就继续看一下圣杯布局，也就是三行三列布局。</p>
<a id="more"></a>

<p>首先看一下圣杯布局的效果图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619407434/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210426111418_oly7qh.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619407434/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210426111418_oly7qh.png"></p>
<p>这个布局其实分为两部分，首先是个简单的三行布局，头部，中间和底部。</p>
<p>其次中间部分是个三列布局，而这个三列布局就是圣杯布局的核心。</p>
<p>我们来看一下如何实现这个三列布局。</p>
<h2 id="如何实现三列布局"><a href="#如何实现三列布局" class="headerlink" title="如何实现三列布局"></a>如何实现三列布局</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>看过我前面关于两列布局的博客，大家应该对这个三列布局有点感觉的。</p>
<p>我们先根据两列布局中float + margin的方式改造成三列布局，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #left, #right, #center &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #left &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #center &#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">            margin: 0 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #right &#123;</span><br><span class="line">            background-color: grey;</span><br><span class="line">            float: right;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>大家可以自己试一下这段代码，发现会有点问题，就是right到了下一行。</p>
<p>这是为什么呢？因为float元素不能超过前一个非float元素。</p>
<p>解决方案也很简单，把center移动到最后。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>上面的方案是center放在最后，虽然可以实现效果，但是我们的主要内容一般是放在center中的，所以对于SEO不是很友好，我们可以想办法把center放在最前面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            /* 这个是为了防止高度坍塌，因为子元素全都是浮动的，脱离了文档流 */</span><br><span class="line">            height: 300px;</span><br><span class="line">            /* margin-left值与left宽度同，margin-right值与right宽度同 */</span><br><span class="line">            margin-left: 300px;</span><br><span class="line">            margin-right: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #left, #right, #center &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        #left &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #center &#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">            /* 自动扩充到与parent相同的宽度 */</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        #right &#123;</span><br><span class="line">            background-color: grey;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的实现其实无法达成效果，因为三者都是浮动的，而center把整个parent占满了，所以left和right会被挤到下一行。</p>
<p>那我们就需要向左移动left，而因为三者是浮动的，所以向左移动可以把left提到上一行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            /* 这个是为了防止高度坍塌，因为子元素全都是浮动的，脱离了文档流 */</span><br><span class="line">            height: 300px;</span><br><span class="line">            /* margin-left值与left宽度同，margin-right值与right宽度同 */</span><br><span class="line">            margin-left: 300px;</span><br><span class="line">            margin-right: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #left, #right, #center &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        #left &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            width: 300px;</span><br><span class="line">            /* 向左移动父级元素的宽度 */</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            /* 再向左移动自身的宽度，二者结合再加上三个子元素都是浮动的，就可以把left放到正确位置 */</span><br><span class="line">            position: relative;</span><br><span class="line">            left: -300px;</span><br><span class="line">        &#125;</span><br><span class="line">        #center &#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">            /* 自动扩充到与parent相同的宽度 */</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        #right &#123;</span><br><span class="line">            background-color: grey;</span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS主流布局总结与比较(一)水平居中对齐</title>
    <url>/2021/04/19/css-layout-horizontal-center/</url>
    <content><![CDATA[<p>作为一个前端开发，常年关注的重点都在JS上，对于CSS没有形成一个系统的知识脉络，趁这个机会总结一下几种主流布局中水平居中对齐的不同实现方案以及方案之间的比较。</p>
<a id="more"></a>

<h2 id="父text-align-子inline-block"><a href="#父text-align-子inline-block" class="headerlink" title="父text-align + 子inline-block"></a>父text-align + 子inline-block</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #child &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h4><p><code>text-align</code> CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。<code>text-align</code> 并不控制块元素自己的对齐，只控制它的行内内容的对齐。具体的取值范围可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align" rel="external nofollow noopener noreferrer" target="_blank">MDN</a></p>
<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><strong><code>display</code></strong> 属性可以设置元素的内部和外部显示类型 <em>display types*。元素的外部显示类型 *outer display types</em> 将决定该元素在<a href="https://wiki.developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout" rel="external nofollow noopener noreferrer" target="_blank">流式布局</a>中的表现（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout" rel="external nofollow noopener noreferrer" target="_blank">块级或内联元素</a>）；元素的内部显示类型 <em>inner display types</em> 可以控制其子元素的布局（例如：<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout" rel="external nofollow noopener noreferrer" target="_blank">flow layout</a>，<a href="https://wiki.developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" rel="external nofollow noopener noreferrer" target="_blank">grid</a> 或 <a href="https://wiki.developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout" rel="external nofollow noopener noreferrer" target="_blank">flex</a>）。</p>
<p><code>display</code> 属性使用关键字取值来指定，关键字取值被分为六类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display:  [ &lt;display-outside&gt; | &lt;display-inside&gt; ] | &lt;display-listitem&gt; | &lt;display-internal&gt; | &lt;display-box&gt; | &lt;display-legacy&gt; ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体不展开介绍，有兴趣也可以去MDN一个个翻看</p>
<p>简单介绍其中三类：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display-outside" rel="external nofollow noopener noreferrer" target="_blank"><code>display-outside</code></a></p>
<p>这些关键字指定了元素的外部显示类型，实际上就是其在流式布局中的角色（即在流式布局中的表现）。</p>
<p>这个就是我们常见的并且是这次使用的inline，block之类的</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display-inside" rel="external nofollow noopener noreferrer" target="_blank"><code>display-inside</code> (en-US)</a></p>
<p>这些关键字指定了元素的内部显示类型，它们定义了该元素内部内容的布局方式（假定该元素为非替换元素 non-replaced element）。</p>
<p>常见的有flow，flex，table，grid等</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display-legacy" rel="external nofollow noopener noreferrer" target="_blank"><code>display-legacy</code></a></p>
<p>CSS 2 对于 <strong><code>display</code></strong> 属性使用单关键字语法，对于相同布局模式的 block 级和 inline 级变体需要使用单独的关键字。常见的就是inline-block，inline-flex</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以综上，为什么这个方案可以生效，首先就是child的display的值为inline-block，是display-outside类型，定义的是它的外部显示类型，也就是针对parent的类型为行内块级元素，这里最主要的是行内，块级元素只是为了让width和height生效，然后parent的text-align的作用就是定义内部元素的对齐方式。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>浏览器兼容好，ie6也可以支持，因为text-align和inline-block都是CSS2的内容</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>text-align具有继承性，也就是子级元素的文本也是居中的，如果你不想子级元素的文本居中，你需要在子集元素中重新设置text-align属性</li>
</ul>
<h2 id="子table-子margin"><a href="#子table-子margin" class="headerlink" title="子table + 子margin"></a>子table + 子margin</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #child &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            display: table; // 或者block</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="display-1"><a href="#display-1" class="headerlink" title="display"></a>display</h4><p>这里用到的还是上面讲的display，类型是<code>display-inside</code>的table</p>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><code>margin</code> 属性接受 1~4 个值。每个值可以是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" rel="external nofollow noopener noreferrer" target="_blank">``</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage" rel="external nofollow noopener noreferrer" target="_blank">``</a>，或 <code>auto</code>。取值为负时元素会比原来更接近临近元素。</p>
<ul>
<li>当只指定<strong>一个</strong>值时，该值会统一应用到<strong>全部四个边</strong>的外边距上。</li>
<li>指定<strong>两个</strong>值时，第一个值会应用于<strong>上边和下边</strong>的外边距，第二个值应用于<strong>左边和右边</strong>。</li>
<li>指定<strong>三个</strong>值时，第一个值应用于<strong>上边</strong>，第二个值应用于<strong>右边和左边</strong>，第三个则应用于<strong>下边</strong>的外边距。</li>
<li>指定<strong>四个</strong>值时，依次（顺时针方向）作为<strong>上边</strong>，<strong>右边</strong>，<strong>下边</strong>，和<strong>左边</strong>的外边距。</li>
</ul>
<p>可取值：</p>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" rel="external nofollow noopener noreferrer" target="_blank"><code>length</code></a></strong></p>
<p>以固定值为外边距。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage" rel="external nofollow noopener noreferrer" target="_blank"><code>percentage</code></a></p>
<p>相对于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block" rel="external nofollow noopener noreferrer" target="_blank">包含块</a>的<em>宽度</em>，以百分比值为外边距。</p>
<p>auto</p>
<p>让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>只需要对子级元素进行设置</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>如果子级元素脱离文档流，导致margin属性无效</p>
<blockquote>
<p>脱离文档流的方式</p>
<ul>
<li>浮动</li>
<li>绝对定位</li>
<li>固定定位</li>
</ul>
</blockquote>
<h2 id="子position-absolute-子transform"><a href="#子position-absolute-子transform" class="headerlink" title="子position:absolute + 子transform"></a>子position:absolute + 子transform</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            /* 只要不是默认的static就可以 */</span><br><span class="line">            position:relative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #child &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position:absolute;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translateX(-50%);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>CSS <strong><code>position</code></strong>属性用于指定一个元素在文档中的定位方式。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top" rel="external nofollow noopener noreferrer" target="_blank"><code>top</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right" rel="external nofollow noopener noreferrer" target="_blank"><code>right</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom" rel="external nofollow noopener noreferrer" target="_blank"><code>bottom</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left" rel="external nofollow noopener noreferrer" target="_blank"><code>left</code></a> 属性则决定了该元素的最终位置。</p>
<ul>
<li><strong>定位元素（positioned element）</strong>是其<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value" rel="external nofollow noopener noreferrer" target="_blank">计算后</a>位置属性为 <code>relative</code>, <code>absolute</code>, <code>fixed</code>或 <code>sticky</code> 的一个元素（换句话说，除<code>static</code>以外的任何东西）。</li>
<li><strong>相对定位元素（**</strong>relatively positioned element<strong>**）</strong>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value" rel="external nofollow noopener noreferrer" target="_blank">计算后</a>位置属性为 <code>relative</code>的元素。</li>
<li><strong>绝对定位元素（absolutely positioned element）</strong>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value" rel="external nofollow noopener noreferrer" target="_blank">计算后</a>位置属性为 <code>absolute</code> 或 <code>fixed</code> 的元素。</li>
<li><strong>粘性定位元素**</strong>（<strong><strong>stickily positioned element</strong></strong>）**是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value" rel="external nofollow noopener noreferrer" target="_blank">计算后</a>位置属性为 <code>sticky</code> 的元素。</li>
</ul>
<p>大多数情况下，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height" rel="external nofollow noopener noreferrer" target="_blank"><code>height</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width" rel="external nofollow noopener noreferrer" target="_blank"><code>width</code></a> 被设定为auto的绝对定位元素，按其内容大小调整尺寸。但是，被绝对定位的元素可以通过指定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top" rel="external nofollow noopener noreferrer" target="_blank"><code>top</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom" rel="external nofollow noopener noreferrer" target="_blank"><code>bottom</code></a> ，保留<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height" rel="external nofollow noopener noreferrer" target="_blank"><code>height</code></a>未指定（即<code>auto</code>），来填充可用的垂直空间。它们同样可以通过指定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left" rel="external nofollow noopener noreferrer" target="_blank"><code>left</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right" rel="external nofollow noopener noreferrer" target="_blank"><code>right</code></a>并将<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width" rel="external nofollow noopener noreferrer" target="_blank"><code>width</code></a> 指定为<code>auto</code>来填充可用的水平空间。</p>
<p>除了刚刚描述的情况（绝对定位元素填充可用空间）：</p>
<ul>
<li>如果 <code>top</code> 和 <code>bottom</code> 都被指定（严格来说，这里指定的值不能为 <code>auto</code> ），<code>top</code> 优先。</li>
<li>如果指定了 <code>left</code> 和 <code>right</code> ，当 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction" rel="external nofollow noopener noreferrer" target="_blank"><code>direction</code></a>设置为 <code>ltr</code>（水平书写的中文、英语）时 <code>left</code> 优先， 当<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction" rel="external nofollow noopener noreferrer" target="_blank"><code>direction</code></a>设置为 <code>rtl</code>（阿拉伯语、希伯来语、波斯语由右向左书写）时 <code>right</code> 优先。</li>
</ul>
<blockquote>
<p>相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。</p>
<p>绝对定位元素相对于<em>最近的非 <code>static</code> 祖先元素</em>定位。当这样的祖先元素不存在时，则</p>
</blockquote>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>CSS<strong><code>transform</code></strong>属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的，具体可以看一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" rel="external nofollow noopener noreferrer" target="_blank">MDN</a></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>父级元素是否脱离文档流，不影响子级元素居中</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>transform是CSS3新特性，需要考虑兼容性</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS主流布局总结与比较(三)两列布局</title>
    <url>/2021/04/25/css-layout-two-column/</url>
    <content><![CDATA[<p>这次我们继续总结CSS主流布局中的两列布局的方式和原理。</p>
<p>首先讲一下什么是两列布局。</p>
<p>两列布局一般情况下时指定宽与自适应布局，两列中的左列是确定宽度，右列是自动填满剩余所有空间的一种布局效果。</p>
<a id="more"></a>

<h2 id="float-margin"><a href="#float-margin" class="headerlink" title="float + margin"></a>float + margin</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .left, .right &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            margin-left: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左：定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右，自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#absolute_positioning" rel="external nofollow noopener noreferrer" target="_blank">绝对定位</a>相反）。</p>
<blockquote>
<p><strong>浮动元素</strong>是 <code>float</code> 的计算值非 <code>none</code> 的元素。</p>
<p>由于float意味着使用块布局，它在某些情况下修改<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" rel="external nofollow noopener noreferrer" target="_blank"><code>display</code></a> 值的计算值：</p>
<p>具体会修改成什么可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/CSS/float</a></p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实现方式简单</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>自适应地margin值必须与定宽元素的宽度相同。</p>
<p>定宽元素的浮动与自适应元素的不浮动在老版本浏览器中会出现显示问题。</p>
<p>当浮动元素中的子元素利用clear清除浮动时，会出现显示问题。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .left, .right &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            float: left;</span><br><span class="line">            /* 这个是为了提高left的层级，不然rigth-fix会覆盖在left上方 */</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .right-fix &#123;</span><br><span class="line">            float:right;</span><br><span class="line">            width: 100%;</span><br><span class="line">            margin-left: -300px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左：定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-fix"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右，自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改进后的版本可以解决第二和第三个缺点</p>
<h2 id="float-overflow"><a href="#float-overflow" class="headerlink" title="float + overflow"></a>float + overflow</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .left, .right &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            /* 为了开启BFC模式 */</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左：定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右，自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>CSS属性 <strong>overflow</strong> 定义当一个元素的内容太大而无法适应 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" rel="external nofollow noopener noreferrer" target="_blank">块级格式化上下文</a> 时候该做什么。它是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-x" rel="external nofollow noopener noreferrer" target="_blank"><code>overflow-x</code></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y" rel="external nofollow noopener noreferrer" target="_blank"><code>overflow-y</code></a>的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties" rel="external nofollow noopener noreferrer" target="_blank">简写属性 </a>。</p>
<p>这个选项包含剪切，显示滚动条，或者显示 从容器溢出到周围区域的内容。</p>
<p>指定除<code>visible</code>(默认值)以外的值将创建一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" rel="external nofollow noopener noreferrer" target="_blank">块级格式化上下文</a>. 这在技术层面上是必须的——如果一个浮动元素和滚动条相交，它会在每个滚动步骤后强行重新包装内容，从而导致慢滚动体验。</p>
<p>为使 <code>overflow</code>有效果，块级容器必须有一个指定的高度（<code>height</code>或者<code>max-height</code>）或者将<code>white-space</code>设置为<code>nowrap</code>。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>第一种方案中的所有问题都没有</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>overflow属性不仅开启了BFC模式，但也同时设置了内容溢出的情况</p>
<h2 id="display：table"><a href="#display：table" class="headerlink" title="display：table"></a>display：table</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .parent &#123;</span><br><span class="line">            display: table;</span><br><span class="line">            table-layout: fixed;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        .left, .right &#123;</span><br><span class="line">            display: table-cell;</span><br><span class="line">            height: 300px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左：定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右，自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="display：table-1"><a href="#display：table-1" class="headerlink" title="display：table"></a>display：table</h4><p>These elements behave like HTML <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table" rel="external nofollow noopener noreferrer" target="_blank"><code>table</code></a> elements. It defines a block-level box.</p>
<h4 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h4><p><strong>table-layout</strong> CSS属性定义了用于布局表格<em>单元格</em>，<em>行</em>和<em>列</em>的算法。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/width" rel="external nofollow noopener noreferrer" target="_blank"><code>auto</code> (en-US)</a></li>
</ul>
<p>大多数浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。</p>
<ul>
<li>fixed</li>
</ul>
<p>表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。</p>
<p>使用 “fixed” 布局方式时，整个表格可以在其首行被下载后就被解析和渲染。这样对于 “automatic” 自动布局方式来说可以加速渲染，但是其后的单元格内容并不会自适应当前列宽。任何一个包含溢出内容的单元格可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" rel="external nofollow noopener noreferrer" target="_blank"><code>overflow</code></a> 属性控制是否允许内容溢出。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>兼容性好</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>会受到table的制约</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS主流布局总结与比较(二)垂直居中对齐</title>
    <url>/2021/04/21/css-layout-vertical-center/</url>
    <content><![CDATA[<p>总结一下几种主流布局中垂直居中对齐的不同实现方案以及方案之间的比较。</p>
<a id="more"></a>

<h2 id="父-display-table-cell-父-vertical-align-middle"><a href="#父-display-table-cell-父-vertical-align-middle" class="headerlink" title="父 display:table-cell + 父 vertical-align:middle"></a>父 display:table-cell + 父 vertical-align:middle</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 600px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            display: table-cell;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #child &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h4><p><a href="https://developer.mozilla.org/en-US/docs/CSS" rel="external nofollow noopener noreferrer" target="_blank">CSS</a> 的属性 <strong><code>vertical-align</code></strong> 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</p>
<p>注意 <code>vertical-align</code> 只对行内元素、表格单元格元素生效：不能用它垂直对齐<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements" rel="external nofollow noopener noreferrer" target="_blank">块级元素</a>。</p>
<p>具体vertical-align的取值可以去看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" rel="external nofollow noopener noreferrer" target="_blank">MDN</a>，这里只提一点，就是对于行内元素和表格单元，它的取值范围不完全相同，就算相同的值也会有不同的意义。</p>
<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>这个属性在上一篇博客中介绍过了，这一次我们用的是它的table-cell值</p>
<p>该值会让当前元素表现得像一个td一样。而td的内容可以是水平居中，也可以是垂直居中。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性好</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>vertical-align具有继承性</p>
<h2 id="子posititon-absolute-子transform"><a href="#子posititon-absolute-子transform" class="headerlink" title="子posititon:absolute + 子transform"></a>子posititon:absolute + 子transform</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #parent &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 600px;</span><br><span class="line">            background-color: aliceblue;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #child &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            position: absolute;</span><br><span class="line">            transform: translateY(-50%);</span><br><span class="line">            top: 50%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理，优点，缺点"><a href="#原理，优点，缺点" class="headerlink" title="原理，优点，缺点"></a>原理，优点，缺点</h3><p>这个原理可以去看我的<a href="https://sunra.top/2021/04/19/css-layout-horizontal-center/">上一篇博客</a>中讲水平居中的方案二相同。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2020/05/08/curry/</url>
    <content><![CDATA[<p>最近遇到了一个奇怪的题目，实现以下效果：</p>
<p>sum(2, 3).result = 5;</p>
<p>sum(2, 3)(4, 5).result = 14;</p>
<p>sum(1, 2)(3).result = 6;</p>
<p>这个题目看起来很奇怪，其实就是个函数柯里化加上个脑筋急转弯，这里记录一下这个题目的思路，如果不懂柯里化，看完对柯里化的介绍之后可以先自己想一下怎么实现这个效果，反正作者想了半个小时才缓过神来原来竟然如此简单，归根结底还是理论充足，但是见识少了。</p>
<a id="more"></a>

<h2 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h2><p>柯里化, 即 Currying 的音译。 Currying 是编译原理层面实现多参函数的一个技术，Currying ——只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。。</p>
<p>在说JavaScript 中的柯里化前，可以聊一下原始的 Currying 是什么，又从何而来。</p>
<p>在编码过程中，身为码农的我们本质上所进行的工作就是——将复杂问题分解为多个可编程的小问题。</p>
<p>Currying 为实现多参函数提供了一个递归降解的实现思路——把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数，在某些编程语言中（如 Haskell），是通过 Currying 技术支持多参函数这一语言特性的。</p>
<p>对于Javascript语言来说，我们通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。</p>
<p>在数学和计算机科学中的柯里化函数，一次只能传递一个参数；</p>
<p>而我们Javascript实际应用中的柯里化函数，可以传递一个或多个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c,d,e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a,b,c,d,e)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成的柯里化函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _fn = curry(fn);</span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);     <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h2 id="柯里化的用途"><a href="#柯里化的用途" class="headerlink" title="柯里化的用途"></a>柯里化的用途</h2><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。</p>
<p>它的用途也可以叫做参数复用，也就是说你前面传入的参数会对后面生成的函数产生影响。</p>
<p>比如，如果我们不使用柯里化去封装校验函数，它是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkByRegExp</span>(<span class="params">regExp,string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> regExp.test(string);  </span><br><span class="line">&#125;</span><br><span class="line">checkByRegExp(<span class="regexp">/^1\d&#123;10&#125;$/</span>, <span class="string">'18642838455'</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkByRegExp(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>这个函数每次传入的数都不会对后面产生影响。</p>
<p>但是如果使用柯里化的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行柯里化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _check = curry(checkByRegExp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成工具函数，验证电话号码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> checkCellPhone = _check(<span class="regexp">/^1\d&#123;10&#125;$/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成工具函数，验证邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">'18642838455'</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">'13109840560'</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">'13204061212'</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">'test@163.com'</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">'test@qq.com'</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">'test@gmail.com'</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>你前面传入的正则表达式会对接下来的计算结果产生影响。</p>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>延迟执行也是 Currying 的一个重要使用场景，Currying延迟求值的特性需要用到 JavaScript 中的作用域——说得更通俗一些，我们需要使用作用域来保存上一次传进来的参数。同样 bind 和箭头函数也能实现同样的功能。</p>
<p>在前端开发中，一个常见的场景就是为标签绑定 onClick 事件，同时考虑为绑定的方法传递参数。</p>
<h2 id="柯里化工具函数"><a href="#柯里化工具函数" class="headerlink" title="柯里化工具函数"></a>柯里化工具函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将函数柯里化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数，默认为原函数的形参个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn,len = fn.length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _curry.call(<span class="keyword">this</span>,fn,len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中转函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>args  已接收的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_curry</span>(<span class="params">fn,len,...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _args = [...args,...params];</span><br><span class="line">        <span class="keyword">if</span>(_args.length &gt;= len)&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,_args);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _curry.call(<span class="keyword">this</span>,fn,len,..._args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).forEach(<span class="function">(<span class="params">cur</span>) =&gt;</span> &#123;</span><br><span class="line">        result += cur;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tempresult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).forEach(<span class="function">(<span class="params">cur</span>) =&gt;</span> &#123;</span><br><span class="line">        result += cur;</span><br><span class="line">      &#125;);</span><br><span class="line">      tempresult.result = result;</span><br><span class="line">      <span class="keyword">return</span> tempresult;</span><br><span class="line">    &#125;</span><br><span class="line">    tempresult.result = result;</span><br><span class="line">    <span class="keyword">return</span> tempresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，这个脑筋急转弯就是函数也是个对象，直接就塞一个result上去就好。</p>
<h2 id="Thunk函数（2020-06-03更新）"><a href="#Thunk函数（2020-06-03更新）" class="headerlink" title="Thunk函数（2020.06.03更新）"></a>Thunk函数（2020.06.03更新）</h2><p>最近在看Generator函数的时候发现了有一种函数叫做Thunk函数，它和柯里化函数长得很像，在这里记录一下，主要内容来自于<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" rel="external nofollow noopener noreferrer" target="_blank">阮一峰老师的博客</a>，稍加修改和注释。</p>
<h3 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h3><p>Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。<strong>一个争论的焦点是<a href="https://zh.wikipedia.org/wiki/求值策略" rel="external nofollow noopener noreferrer" target="_blank">“求值策略”</a>，即函数的参数到底应该何时求值。</strong></p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> m * <span class="number">2</span>;     </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f(x + <span class="number">5</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码先定义函数 f，然后向它传入表达式 x + 5 。请问，这个表达式应该何时求值？</p>
<p>一种意见是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" rel="external nofollow noopener noreferrer" target="_blank">“传值调用”</a>（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函数 f 。C语言就采用这种策略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; f(x + <span class="number">5</span>)</span><br><span class="line">&gt; <span class="comment">// 传值调用时，等同于</span></span><br><span class="line">&gt; f(<span class="number">6</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一种意见是<a href="https://zh.wikipedia.org/wiki/求值策略#.E4.BC.A0.E5.90.8D.E8.B0.83.E7.94.A8_.28Call_by_name.29" rel="external nofollow noopener noreferrer" target="_blank">“传名调用”</a>（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; f(x + <span class="number">5</span>)</span><br><span class="line">&gt; <span class="comment">// 传名调用时，等同于</span></span><br><span class="line">&gt; (x + <span class="number">5</span>) * <span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>传值调用和传名调用，哪一种比较好？回答是各有利弊。</strong>传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> b;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，函数 f 的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。</p>
<p>因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p>
<h3 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h3><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> m * <span class="number">2</span>;     </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f(x + <span class="number">5</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 等同于</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。</p>
<p><strong>这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</strong></p>
<h3 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h3><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。<strong>在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</strong></p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">&gt; fs.readFile(fileName, callback);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line">&gt; <span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">&gt; readFileThunk(callback);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> fs.readFile(fileName, callback); </span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p>
<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">&gt;       args.push(callback);</span><br><span class="line">&gt;       <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用上面的转换器，生成 fs.readFile 的 Thunk 函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">&gt; readFileThunk(fileA)(callback);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h3><p>生产环境的转换器，建议使用 <a href="https://github.com/tj/node-thunkify" rel="external nofollow noopener noreferrer" target="_blank">Thunkify 模块</a>。</p>
<p>首先是安装。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ npm install thunkify</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用方式如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line">&gt; read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Thunkify 的<a href="https://github.com/tj/node-thunkify/blob/master/index.js" rel="external nofollow noopener noreferrer" target="_blank">源码</a>与上一节那个简单的转换器非常像。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">&gt;     <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">&gt;       args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">&gt;       <span class="keyword">var</span> called;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">&gt;         called = <span class="literal">true</span>;</span><br><span class="line">&gt;         done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&gt;       &#125;);</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;         fn.apply(ctx, args);</span><br><span class="line">&gt;       &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">&gt;         done(err);</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它的源码主要多了一个检查机制，<a href="http://segmentfault.com/q/1010000000524121" rel="external nofollow noopener noreferrer" target="_blank">变量 called</a> 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, callback</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> sum = a + b;</span><br><span class="line">&gt;   callback(sum);</span><br><span class="line">&gt;   callback(sum);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> ft = thunkify(f);</span><br><span class="line">&gt; ft(<span class="number">1</span>, <span class="number">2</span>)(<span class="built_in">console</span>.log); </span><br><span class="line">&gt; <span class="comment">// 3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，由于 thunkify 只允许回调函数执行一次，所以只输出一行结果。</p>
<h3 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h3><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p>
<p>以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> readFile = thunkify(fs.readFile);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">&gt;   <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p>
<p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> g = gen();</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> r1 = g.next();</span><br><span class="line">&gt; r1.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&gt;   <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">&gt;   r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&gt;     g.next(data);</span><br><span class="line">&gt;   &#125;);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。</p>
<p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。</p>
<h3 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h3><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> gen = fn();</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">&gt;     <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">&gt;     result.value(next);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   next();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; run(gen);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p>
<p>有了这个执行器，执行 Generator 函数方便多了。不管有多少个异步操作，直接传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'fileA'</span>);</span><br><span class="line">&gt;   <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'fileB'</span>);</span><br><span class="line">&gt;   <span class="comment">// ...</span></span><br><span class="line">&gt;   <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; run(gen);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="使用柯里化函数封装重复逻辑（2020-10-10更新）"><a href="#使用柯里化函数封装重复逻辑（2020-10-10更新）" class="headerlink" title="使用柯里化函数封装重复逻辑（2020.10.10更新）"></a>使用柯里化函数封装重复逻辑（2020.10.10更新）</h2><p>最近看了一些vue的源码，它其中对于平台的判断逻辑会封装在柯里化函数之中，通过传入平台配置，返回一个新的函数，这样每次调用返回的函数就可以了，就可以省略每次对于平台的判断。</p>
<p>吸收了这个思想，加上最近的工作中需要封装一些工具类，用于封装针对特定的数据集的CRUD，比如user和userProfile。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createRepositoryUtilForModelProfile = <span class="function">(<span class="params">mainModel, profileModel, foreignKey</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">selectSearchModels</span>(<span class="params">where</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> conditions = _.keys(where);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; conditions.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mainModelKeys.indexOf(conditions[i]) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          searchModel: mainModel.name,</span><br><span class="line">          supplementModel: profileModel.name</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      searchModel: profileModel.name,</span><br><span class="line">      supplementModel: mainModel.name</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mainModelKeys = _.keys(mainModel.properties);</span><br><span class="line">  <span class="keyword">const</span> profileModelKeys = _.keys(profileModel.properties);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> createUtil = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">data, operator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> savedMain = <span class="keyword">await</span> create(&#123;</span><br><span class="line">      model: mainModel.name,</span><br><span class="line">      data: _.pick(data, mainModelKeys),</span><br><span class="line">      operator &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> profile = <span class="keyword">await</span> create(&#123;</span><br><span class="line">      model: profileModel.name,</span><br><span class="line">      data: _.pick(data, profileModelKeys),</span><br><span class="line">      operator</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _.merge(savedMain, profile);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> findUtil = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">where, pageNumber, pageSize, fields</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; searchModel, supplementModel &#125; = selectSearchModels(where);</span><br><span class="line">    <span class="keyword">let</span> skip = _.toNumber(pageNumber - <span class="number">1</span>) * _.toNumber(pageSize);</span><br><span class="line">    <span class="keyword">let</span> mainList = <span class="keyword">await</span> find(&#123;</span><br><span class="line">      model: searchModel,</span><br><span class="line">      where,</span><br><span class="line">      skip: skip &gt;= <span class="number">0</span> ? skip : <span class="number">0</span>,</span><br><span class="line">      limit: _.toNumber(pageSize),</span><br><span class="line">      fields</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mainList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> supplement = <span class="keyword">await</span> findOne(&#123;</span><br><span class="line">        model: supplementModel,</span><br><span class="line">        where: &#123; [<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>]: mainList[i][<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>] &#125;,</span><br><span class="line">        fields &#125;);</span><br><span class="line">      _.merge(mainList[i], supplement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mainList;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> findOneUtil = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">where, fields</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; searchModel, supplementModel &#125; = selectSearchModels(where);</span><br><span class="line">    <span class="keyword">let</span> main = <span class="keyword">await</span> findOne(&#123; <span class="attr">model</span>: searchModel, where, fields &#125;);</span><br><span class="line">    <span class="keyword">if</span> (main) &#123;</span><br><span class="line">      <span class="keyword">let</span> supplement = <span class="keyword">await</span> findOne(&#123;</span><br><span class="line">        model: supplementModel,</span><br><span class="line">        where: &#123; [<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>]: main[<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>] &#125;,</span><br><span class="line">        fields &#125;);</span><br><span class="line">      <span class="keyword">return</span> _.merge(main, supplement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> main;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> updateAllUtil = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> updated = <span class="keyword">await</span> updateAll(&#123;</span><br><span class="line">      model: mainModel.name,</span><br><span class="line">      where: &#123; [<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>]: data[<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>] &#125;,</span><br><span class="line">      data: _.pick(data, mainModelKeys)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> profile = <span class="keyword">await</span> updateAll(&#123;</span><br><span class="line">      model: profileModel.name,</span><br><span class="line">      where: &#123; [<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>]: data[<span class="string">`<span class="subst">$&#123;foreignKey&#125;</span>`</span>] &#125;,</span><br><span class="line">      data: _.pick(data, profileModelKeys)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(updated, profile);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    findUtil,</span><br><span class="line">    findOneUtil,</span><br><span class="line">    createUtil,</span><br><span class="line">    updateAllUtil</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://juejin.im/post/5af13664f265da0ba266efcf#heading-1" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af13664f265da0ba266efcf#heading-1</a></p>
<p><a href="https://juejin.im/post/5d2299faf265da1bb67a3b65" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5d2299faf265da1bb67a3b65</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>OAuth的发展与设计</title>
    <url>/2020/04/11/design-of-OAuth/</url>
    <content><![CDATA[<p>OAuth的中文名称是开放式授权协议，这个名字大家仔细品，它是一个授权协议，<strong>任何实现这个协议的网站都可以在用户同意的条件下给某些在自己这里注册的应用授予对应用户在本网站某些资源的权限</strong>，而这个权限一般用token来表示。</p>
<a id="more"></a>

<h2 id="实际应用的举例"><a href="#实际应用的举例" class="headerlink" title="实际应用的举例"></a>实际应用的举例</h2><p>大家去leetcode登陆的时候，会弹出如下页面</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586583310/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411133437_kt05s5.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586583310/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411133437_kt05s5.png"></p>
<p>在这里我们有两个选项，一个是直接注册一个账号，另一个就是选择第三方登陆，比如QQ登陆，这个第三方登陆中就使用了OAuth。</p>
<p>对于这第二种方式，这里要强调几点：</p>
<ul>
<li><strong>你的账号的数量根本没有减少，你还是同时拥有了leetcode以及qq两个账号</strong>，只不过qq提供了OAuth协议，你授权leetcode去获取你在qq的信息，leetcode利用这信息去创建了你在leetcode的账号，你在leetcode的账号也根本不会存储在qq，这就有点类似于实际生活中你在有关机构注册账户时都需要拿着身份证去，这个机构用你的身份证去公安局系统查找你的信息，然后用这些信息创建你在本机构的账户。你给这些机构身份证就类似于一个授权它去公安局操作你的信息的过程。</li>
<li>OAuth协议只是一个授权协议，而上述的过程叫做<strong>第三方授权登录，登陆这个动作不是OAuth协议中规定的，也就是说仅凭OAuth无法完成授权登录这一套动作</strong>，OAuth也不仅仅是用来做第三方登录的。虽然我们大部分时间用第三方授权登陆讲OAuth，但是要打破这局限思维。</li>
</ul>
<h2 id="登陆方式的发展过程"><a href="#登陆方式的发展过程" class="headerlink" title="登陆方式的发展过程"></a>登陆方式的发展过程</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586584078/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411134737_w5ftzj.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586584078/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411134737_w5ftzj.png"></p>
<h3 id="用户名密码"><a href="#用户名密码" class="headerlink" title="用户名密码"></a>用户名密码</h3><p>在一开始我们是服务端渲染以及静态页面的时候，我们仅仅通过用户名和密码进行身份验证，这也是所有身份验证的基础，以后的各种认证方式，大部分还是要基于这种方法的。</p>
<p>这种方法在一开始很管用，网站先给你一个登陆页面，你登录成功就给从服务器返回另外一个页面，你拿到了这个页面就表明你已经登陆过了，而且你的身份信息已经在返回之前写入了页面中，只是你看不到。</p>
<p>但是这样做<strong>最大的问题就是一旦你将这个页面关掉，你下一次再打开你就要重新登陆</strong>，这样就会有很差的用户体验。于是我们就开始想办法能不能将用户的登录态保存下来呢？于是就产生了第二种方式，Session和Cookie。</p>
<h3 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h3><p>在这种方式中，用户在第一次登陆成功之后就会把用户的信息保存在session中存储在服务器中，然后生成一个sessionId标志该session并将其通过set-cookie头部返回给前端。这样一来，由于浏览器的实现决定，每次发起的同源请求都会自动带上该源之下的cookie，也就带上了sessionId，这样一来每次服务器只需要检查cookie中的sessionId，验证其有效性就可以找到用户信息。</p>
<p>但是这样又有了一个问题，浏览器是很不可靠的，基本上浏览器知道很有可能全世界都知道了，这里推荐仔细看一下同源策略，这东西没有想象中那么严格，最近我对它又多了几点认知：</p>
<ul>
<li>同源策略一般只限制XMLHttpRequest之类的请求，比如Ajax。对于地址栏直接发出的请求是不加限制的，置于对这个请求重定向的请求是否限制还在探索中。</li>
<li>跨域写操作，如表单提交，重定向等一般是不限制的</li>
<li>跨域资源嵌入一般是不限制的。</li>
<li>跨域的读操作一般是不被允许的，但是可以通过上一条进行打破，比如利用script标签跨域加载脚本</li>
<li>不同域的脚本无法操作dom。</li>
</ul>
<p>通过上述这些认知，我们可以发现一个比较关键的事情，<strong>浏览器的同源策略对于src中的直接发起的请求不怎么限制，而且只要是你请求的链接同个域名下的cookie都会被自动带上</strong>。</p>
<p>这里有个经典的例子，就是如果你去银行网站登录了之后，将sessionid存储在cookie中，在cookie过期之前，你打开了个攻击者的网站，里面有一个img标签，它的src属性是bank.com/tran/1000，也就是转账1000元的意思，由于它是src，所以浏览器会自动发起这个请求，虽然肯定是不会有图片返回，但是请求已经发出了，而且会自动带上未过期的该银行的cookie，因为浏览器看到你请求的地址是该银行，就自动帮你带上了。</p>
<p>上面这个例子就是比较简单的CSRF攻击。</p>
<p>上面这个例子的主要目的就是为了说明<strong>cookie是不安全的，即使有同源策略</strong>。</p>
<p>而且随着分布式系统的发展，如果通过这种方式来存储身份，你势必就要在每个服务器上维护一份身份的副本，而且要保证其一致性。</p>
<p>基于以上两点原因，我们又在想了，<strong>有没有什么办法可以既能将身份信息丢回给前端，这样每次前端带着身份信息过来，我验证一下是不是我授予他的就好，又能让这种方式比较安全</strong>呢？于是，我们就搞出了一个Token。这也是token的两个特点吧，一个是存储在前端，另一个就是服务器生成的，它一般不存储在cookie中。</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>刚才我们说了Token是服务器生成的我们身份的证明，存储在前端，那我们又怎么保证其安全呢？一种比较古老的做法是如果你的页面是服务端渲染，那就在返回之前在每个需要提交请求的地方插入你的token，这样这个token就可以不存储在cookie中了，而跨域的脚本又无法操作dom也就无法获取你的token。</p>
<p>但是这样一来貌似又回到了一开始，页面一关闭，token就没了，而且这样消耗比较大。</p>
<p>另一种方法就是把这个token可以放在http头部中，也就是x-csrf头部。</p>
<p>还有许多token的使用方式，不是这次的重点，就不详细解释了。</p>
<h3 id="SSO-和-OAuth"><a href="#SSO-和-OAuth" class="headerlink" title="SSO 和 OAuth"></a>SSO 和 OAuth</h3><p>当我们身份认证的所有问题都得到比较好的解决之后，又出现了一个新的问题，那就是随着应用的增多，我们需要记住越来越多的账号，我们需要一个方法来帮我们记住所有账号或者只记一个账号，第二种方式就是SSO，它有多种实现基础，其中一种就是今天的主题OAuth。</p>
<p>在聊这个主题之前我们先定义几个关键字：</p>
<p>User：用户</p>
<p>User Agent：用户代理，如浏览器</p>
<p>Consumer：信息消费者，如Leetcode</p>
<p>Service Provider：分为两个，分别是身份认证提供者（Identity Provider， IDP）,如QQ，以及资源提供者（Resource Provider），不过这二者一般是相同的。</p>
<p>所以：</p>
<ul>
<li>SSO的出现并不是为了解决一些登录上的安全或者流程问题，它是为了帮我们少记一些账号，OAuth只是它一种实现方式的基础。</li>
<li>OAuth只负责user授权consumer去SP操纵一些属于user的资源，只不过在SSO中是用于在SP获取用户信息之后在consumer创建一个账号，这样下次只要user在SP通过了身份验证就等于在consumer通过了身份验证。</li>
<li>User在consumer的身份和权限与OAuth没有关系，这是它们二者之间的事情，与OAuth无关，与SSO也无关，他们之间的认证又会退回前三种方式。SP不会关心也不会存储User在consumer的身份或者权限。</li>
<li>单凭OAuth，是无法完成授权登录整个流程的。</li>
</ul>
<h2 id="实际看一下SSO过程中关于OAuth的请求"><a href="#实际看一下SSO过程中关于OAuth的请求" class="headerlink" title="实际看一下SSO过程中关于OAuth的请求"></a>实际看一下SSO过程中关于OAuth的请求</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586587044/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411143642_a7kkr8.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1586587044/Cloud/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200411143642_a7kkr8.png"></p>
<p>这张图是我截取的用qq去登陆leetcode中前端所涉及的请求，它大致分为以下几步：</p>
<ul>
<li>去qq认证服务器拉取授权页面，参数中带有一些leetcode服务器生成的一些用于接下来授权请求的参数，只有带上这些参数，才可能通过qq认证服务器的验证并返回授权页面，同时授权页面接下来的请求需要用到这些参数</li>
<li>选择授权之后会发送第二个请求，请求中包括一些OAuth协议中定义的参数以及qq自身需要的参数。</li>
<li>第二个请求到达qq之后通过验证，返回一个302，location就是第二个请求参数中的redirect_uri，然后在参数中拼接qq为其生成的code和state。</li>
<li>浏览器收到302返回后，重新拿出location去发送请求，所以这个location一般是自身后台。</li>
<li>自身后台收到请求后，拿出code去qq换取token</li>
</ul>
<p><strong>OAuth协议就干了这些事情，那现在我们在leetcode有账号了吗？没有</strong>，接下来leetcode拿token去qq换回身份信息后才会进行leetcode账号的创建</p>
<h2 id="以授权码模式说明一下OAuth2-0设计中的一些细节"><a href="#以授权码模式说明一下OAuth2-0设计中的一些细节" class="headerlink" title="以授权码模式说明一下OAuth2.0设计中的一些细节"></a>以授权码模式说明一下OAuth2.0设计中的一些细节</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608117974/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216192144_wzrlgz.png" alt></p>
<p>这里的A请求就是刚才的第一个请求，B就是第二个授权请求，C是B的返回，状态码是302，location就是redirect_uri?code=XXX&amp;state=XXX，浏览器收到后重新请求C的location，请求就到了leetcode后台，后台拿到code之后结合一些参数去qq换回了token。</p>
<p>这里大家可能会有很多疑问：</p>
<h3 id="这些参数都表示什么："><a href="#这些参数都表示什么：" class="headerlink" title="这些参数都表示什么："></a>这些参数都表示什么：</h3><p>redirect_uri：consumer在SP申请第三方授权登陆服务时填写的域名，一般是自身服务器的域名。</p>
<p>client_id：consumer在SP申请第三方授权登陆服务后，SP生成的该consumer的唯一id。</p>
<p>client_secret：consumer在SP申请第三方授权登陆服务后，SP生成的该consumer的唯一凭证，只有id与secret同时给出才能证明你是consumer</p>
<p>scope：你要申请的权限，一般都是由SP规定的。</p>
<p>state：一个随机字符串，consumer自身生成</p>
<p>code：用户授权后，SP返回给浏览器的code，consumer可以用这个code换token</p>
<p>access_token：最终目的。</p>
<h3 id="为什么一开始就要发送个redirect-uri给IDP？"><a href="#为什么一开始就要发送个redirect-uri给IDP？" class="headerlink" title="为什么一开始就要发送个redirect_uri给IDP？"></a>为什么一开始就要发送个redirect_uri给IDP？</h3><p>第一次是为了IDP设置返回地302中的Location，可以不验证是不是consumer设置好的，第二次就是验证这个redirect_uri是不是你当初在IDP这里设置的，与第一次过来的是否一样，这一步必须要验证，因为这一步是最关键的，这一步才会返回token。</p>
<h3 id="为什么要绕这么一大圈，为什么要多一步code换access-token？"><a href="#为什么要绕这么一大圈，为什么要多一步code换access-token？" class="headerlink" title="为什么要绕这么一大圈，为什么要多一步code换access_token？"></a>为什么要绕这么一大圈，为什么要多一步code换access_token？</h3><p>说到底还是信不过浏览器同志，让他当个工具人，让它帮自己地后台去第三方申请一个授权码，然后把这个授权码给自己的后台，再然后自己的后台用这个code去第三方申请token，完事还不告诉浏览器这个token是什么，自己留下了，也就是说浏览器同志从头到尾都没见过token。</p>
<h3 id="Secret有什么用？"><a href="#Secret有什么用？" class="headerlink" title="Secret有什么用？"></a>Secret有什么用？</h3><p>原因是IDP不信任何人，就信自己给出去的secret。因为redirect_uri是域名，最终到哪里还是要靠IP地址，如果域名是对的，但是域名被攻击者指向了自己的IP，攻击者就会收到token。怎么修改这个DNS指向就涉及DNS污染了，因为DNS会层层缓存，但是又有时间，如果你一直广播告诉路由器或者主机我是leetcode，我是leetcode，时间长了你在这一片局域网中就被认为是leetcode了。但是如果有了secret，就算你带着code过来了IDP，没有我给你的secret，IDP也不会给出token。所以client_id表明自己是谁，只有给了client_secret，IDP才会相信你说的话，并给你token，所以这个secret非常重要，我们的后台又不会相信浏览器同志了，所以我们的浏览器同志从头到尾也没摸过secret。</p>
<h3 id="State又有什么用呢？"><a href="#State又有什么用呢？" class="headerlink" title="State又有什么用呢？"></a>State又有什么用呢？</h3><p>类似于防御CSRF，保证请求设备的一致性，不过不像CSRF是伪造受害者的请求，而是让受害者登录自己的账号，如果受害者在里面存个比特币账号岂不美哉？具体实现就是攻击者登录之后，正常申请，但是到了IDP返回302以后把请求拦下，不让浏览器发送请求给自己的后台，然后把这个带code的请求链接给受害人，受害人点进去之后就可以拿到access_token成功登录，如果不注意这个账号是不是自己的就上传敏感信息，就很happy。如果有了state，不同的设备我后台都生成一个随机的字符串给前端，攻击者就算把请求发给受害者，他也不知道受害者设备中的state，后台一看你的state和刚开始说好的不一样，就会直接把这个请求丢掉，当然硬要说攻击者把你的state从庞大的互联网的某个请求中给偷到了，那也是绝了，这就属于定点爆破了，就是要搞你，那这个人多半已经混在你的身边了。</p>
<h3 id="为什么最后会返回两个token？"><a href="#为什么最后会返回两个token？" class="headerlink" title="为什么最后会返回两个token？"></a>为什么最后会返回两个token？</h3><p>因为一个代表你是谁，一个代表你能做什么，你能做的事情随时可以被管理员改变，但是你是谁是固定的，而且一般access_token过期时间都比较短，如果我用着用着就过期了，总不能让用户重新登陆吧，那岂不是回到了起点？</p>
<h2 id="OAuth2-0中的其他模式"><a href="#OAuth2-0中的其他模式" class="headerlink" title="OAuth2.0中的其他模式"></a>OAuth2.0中的其他模式</h2><h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608118806/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216193951_hiq7je.png" alt=" "></p>
<p>这种方式与授权码模式不同，它适用于没有服务端的情况，比如手机应用，前端直接就从SP拿到了token，但是要注意，这个token并不是像授权码模式中的code一样，拼在“？”后面，而是“#”后面，所以可以有效降低泄密的危险。</p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<h2 id="OAuth1-0"><a href="#OAuth1-0" class="headerlink" title="OAuth1.0"></a>OAuth1.0</h2><p>在简单介绍一下1.0以及它为什么发展出了2.0</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608119884/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216195014_gz6sjt.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608119884/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201216195014_gz6sjt.png"></p>
<p>最大的不同就是多了AB两步，也就是1.0会先去SP申请一个未认证状态的request_token（可以类比为2.0的code），接下来的目的是为了把这个request_token变为认证状态，然后就可以拿这个request_token去换access_token了。</p>
<p>多了这一步就会出现问题，比如<a href="https://sunra.top/2019/11/09/sessionFixation/">会话固定</a></p>
<p>还有就是对于手机或者客户端应用来说，重定向这一步是无法实现的，只能丢出一个连接来，让用户自己打开浏览器粘贴进去进行接下来的步骤。这样就会给攻击者很大的机会。</p>
<p>由此可以看出，1.0版本安全有很大的问题，而且对于非web应用来说体验比较差，所以就推出了2.0,。</p>
<p>比如2.0的简化模式就是为了适配客户端应用的，有兴趣的可以自己去了解一下。</p>
<h3 id="1-0a"><a href="#1-0a" class="headerlink" title="1.0a"></a>1.0a</h3><p>为了修复1.0中的安全问题，又提出了1.0a，他主要做了如下改变：</p>
<ul>
<li><p>Consumer申请Request Token时，必须传递<strong>oauth</strong>_callback，而Consumer申请Access Token时，不需要传递<strong>oauth</strong>_callback。通过前置<strong>oauth</strong>_callback的传递时机，让<strong>oauth</strong>_callback参与签名，从而避免攻击者假冒<strong>oauth</strong>_callback。</p>
</li>
<li><p>Service Provider获得User授权后重定向User到Consumer时，返回<strong>oauth</strong>_verifier，它会被用在Consumer申请Access Token的过程中。攻击者无法猜测它的值。</p>
</li>
</ul>
<p>参考资料：</p>
<p>[<a href="https://sunra.top/2019/11/16/OAuth%20and%20OIDC/]">https://sunra.top/2019/11/16/OAuth%20and%20OIDC/]</a>(<a href="https://sunra.top/2019/11/16/OAuth">https://sunra.top/2019/11/16/OAuth</a> and OIDC/) ：OAuth，OIDC简介</p>
<p><a href="https://sunra.top/2020/03/27/routing-protocol/">https://sunra.top/2020/03/27/routing-protocol/</a>  ：路由协议</p>
<p><a href="https://sunra.top/2019/09/15/ARP/">https://sunra.top/2019/09/15/ARP/</a> ：ARP原理与防御</p>
<p><a href="https://www.jianshu.com/p/0db71eb445c8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0db71eb445c8</a> ：OAuth认证流程举例</p>
<p><a href="https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.chrisyue.com/security-issue-about-oauth-2-0-you-should-know.html</a> ：OAuth2.0中的安全考虑</p>
<p><a href="https://www.cnblogs.com/linianhui/p/openid-connect-core.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/linianhui/p/openid-connect-core.html</a> ：OIDC文档</p>
<p><a href="https://www.zhihu.com/question/19851243" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/19851243</a> ：OAuth1.0与2.0区别</p>
<p><a href="https://docs.azure.cn/zh-cn/active-directory/azuread-dev/v1-protocols-openid-connect-code" rel="external nofollow noopener noreferrer" target="_blank">https://docs.azure.cn/zh-cn/active-directory/azuread-dev/v1-protocols-openid-connect-code</a> ：OIDC + AAD</p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S2215098617316750" rel="external nofollow noopener noreferrer" target="_blank">https://www.sciencedirect.com/science/article/pii/S2215098617316750</a> ：云服务中面临的安全问题</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a> ：同源策略</p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2020/05/03/divide-conquer-algorithm/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>  在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<a id="more"></a>

<p>  任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p>
<h2 id="基本思想及策略"><a href="#基本思想及策略" class="headerlink" title="基本思想及策略"></a>基本思想及策略</h2><p>  分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>  分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>  如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h2 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a><strong>分治法适用的情况</strong></h2><p>   分治法所能解决的问题一般具有以下几个特征：</p>
<p>  1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>  3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p><strong>第二条特征是应用分治法的前提</strong>它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p><strong>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征</strong>，如果<strong>具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。</p>
<p><strong>第四条特征涉及到分治法的效率</strong>，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但<strong>一般用动态规划法较好</strong>。</p>
<p>分治和动态规划有共通也有不同，我i们来看如下两个定义。</p>
<blockquote>
<p>最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子机构。</p>
</blockquote>
<blockquote>
<p>重叠子问题：用来求解原问题的递归算法反复地解同样的子问题，而不是总是在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。</p>
</blockquote>
<p>当子问题相互独立时，能且只能使用分治。存在重叠子问题时，动态规划是更好的算法。 In a word, 分治法 —— 各子问题独立；动态规划 —— 各子问题重叠。</p>
<blockquote>
<p>算法导论： 动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠的。</p>
</blockquote>
<h2 id="分治法的基本步骤"><a href="#分治法的基本步骤" class="headerlink" title="分治法的基本步骤"></a><strong>分治法的基本步骤</strong></h2><p>分治法在每一层递归上都有三个步骤：</p>
<p>   step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p>   step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>   step3 合并：将各个子问题的解合并为原问题的解。</p>
<p>它的一般的算法设计模式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Divide-and-Conquer(P)</span><br><span class="line"></span><br><span class="line">　　1. if |P|≤n0</span><br><span class="line"></span><br><span class="line">　　2. then return(ADHOC(P))</span><br><span class="line"></span><br><span class="line">　　3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk</span><br><span class="line"></span><br><span class="line">　　4. for i←1 to k</span><br><span class="line"></span><br><span class="line">　　5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</span><br><span class="line"></span><br><span class="line">　　6. T ← MERGE(y1,y2,…,yk) △ 合并子问题</span><br><span class="line"></span><br><span class="line">　　7. return(T)</span><br><span class="line"></span><br><span class="line">　　其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//首先来看函数主体，实现了分割的部分</span><br><span class="line">void mergesort(int a[],int n,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left+1&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(left+right)/2;</span><br><span class="line">        mergesort(a,n,left,mid);</span><br><span class="line">        mergesort(a,n,mid,right);</span><br><span class="line">        merge(a,n,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面来写自己的merge函数！</span><br><span class="line">//L,R是辅助数组！</span><br><span class="line">void merge(int a[],int n,int left,int mid,int right)</span><br><span class="line">&#123;</span><br><span class="line">    int n1=mid-left,n2=right-mid;</span><br><span class="line">    for(int i=0;i&lt;n1;i++)</span><br><span class="line">        L[i]=a[left+i];//储存左数列</span><br><span class="line">    for(int i=0;i&lt;n2;i++)</span><br><span class="line">        R[i]=a[mid+i];//储存右数列</span><br><span class="line">    L[n1]=R[n2]=INF;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for(int k=left;k&lt;right;k++)//合并</span><br><span class="line">    &#123;</span><br><span class="line">        if(L[i]&lt;=R[j])</span><br><span class="line">            a[k]=L[i++];</span><br><span class="line">        else</span><br><span class="line">            a[k]=R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分治法举例"><a href="#分治法举例" class="headerlink" title="分治法举例"></a>分治法举例</h2><p>题目与答案链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p>对于一个区间 [l, r][l,r]，我们可以维护四个量：</p>
<p>lSum 表示 [l, r][l,r] 内以 ll 为左端点的最大子段和<br>rSum 表示 [l, r][l,r] 内以 rr 为右端点的最大子段和<br>mSum 表示 [l, r][l,r] 内的最大子段和<br>iSum 表示 [l, r][l,r] 的区间和<br>以下简称 [l, m][l,m] 为 [l, r][l,r] 的「左子区间」，[m + 1, r][m+1,r] 为 [l, r][l,r] 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 [l, r][l,r] 的信息）？对于长度为 11 的区间 [i, i][i,i]，四个量的值都和 a_ia<br>i</p>
<p>  相等。对于长度大于 11 的区间：</p>
<p>首先最好维护的是 iSum，区间 [l, r][l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。<br>对于 [l, r][l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。<br>对于 [l, r][l,r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。<br>当计算好上面的三个量之后，就很好计算 [l, r][l,r] 的 mSum 了。我们可以考虑 [l, r][l,r] 的 mSum 对应的区间是否跨越 mm——它可能不跨越 mm，也就是说 [l, r][l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 mm，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。<br>这样问题就得到了解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">status</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (lSum, rSum, mSum, iSum) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lSum = lSum;</span><br><span class="line">        <span class="keyword">this</span>.rSum = rSum;</span><br><span class="line">        <span class="keyword">this</span>.mSum = mSum;</span><br><span class="line">        <span class="keyword">this</span>.iSum = iSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pushUp = <span class="function">(<span class="params">l, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iSum = l.iSum + r.iSum;</span><br><span class="line">    <span class="keyword">const</span> lSum = <span class="built_in">Math</span>.max(l.iSum + r.lSum, l.lSum);</span><br><span class="line">    <span class="keyword">const</span> rSum = <span class="built_in">Math</span>.max(r.iSum + l.rSum, r.rSum);</span><br><span class="line">    <span class="keyword">const</span> mSum = <span class="built_in">Math</span>.max(l.mSum, r.mSum, l.rSum + r.lSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> status(lSum, rSum, mSum, iSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = (nums, l, r) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (l === r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> status(nums[l], nums[l], nums[l], nums[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="built_in">Math</span>.floor((l + r) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> lsub = <span class="keyword">get</span>(nums, l, m);</span><br><span class="line">    const rsub = <span class="keyword">get</span>(nums, m + 1, r);</span><br><span class="line">    return pushUp(lsub, rsub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var maxSubArray = function(nums) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(nums, 0, nums.length - 1).mSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动规解法"><a href="#动规解法" class="headerlink" title="动规解法"></a>动规解法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">Math</span>.max(pre + nums[i], nums[i]);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(pre, max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/45986027" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/45986027</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 入门笔记</title>
    <url>/2020/05/30/docker-note/</url>
    <content><![CDATA[<p>最近要使用到Docker，就在晚上找了几篇入门级别的博客，边总结，边实践。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>
<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>
<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<p><strong>（1）资源占用多</strong></p>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<p><strong>（2）冗余步骤多</strong></p>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<p><strong>（3）启动慢</strong></p>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<h3 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes" rel="external nofollow noopener noreferrer" target="_blank">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<p><strong>（1）启动快</strong></p>
<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<p><strong>（2）资源占用少</strong></p>
<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<p><strong>（3）体积小</strong></p>
<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<h3 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h3><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h3><p>Docker 的主要用途，目前有三大类。</p>
<p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>
<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h3 id="image-文件"><a href="#image-文件" class="headerlink" title="image 文件"></a>image 文件</h3><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">&gt; $ docker image ls</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 删除 image 文件</span></span><br><span class="line">&gt; $ docker image rm [imageName]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>
<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>
<h3 id="实例：hello-world"><a href="#实例：hello-world" class="headerlink" title="实例：hello world"></a>实例：hello world</h3><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/" rel="external nofollow noopener noreferrer" target="_blank">hello world”</a>，感受一下 Docker。</p>
<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p>
<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker image pull library/hello-world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>
<p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/" rel="external nofollow noopener noreferrer" target="_blank"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker image pull hello-world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>抓取成功以后，就可以在本机看到这个 image 文件了。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker image ls</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在，运行这个 image 文件。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker container run hello-world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>
<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>
<p>如果运行成功，你会在屏幕上读到下面的输出。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker container run hello-world</span><br><span class="line">&gt; </span><br><span class="line">&gt; Hello from Docker!</span><br><span class="line">&gt; This message shows that your installation appears to be working correctly.</span><br><span class="line">&gt; </span><br><span class="line">&gt; ... ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p>
<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker container run -it ubuntu bash</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/" rel="external nofollow noopener noreferrer" target="_blank"><code>docker container kill</code></a> 命令手动终止。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker container <span class="built_in">kill</span> [containID]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h3><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">&gt; $ docker container ls</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">&gt; $ docker container ls --all</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>
<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/" rel="external nofollow noopener noreferrer" target="_blank"><code>docker container rm</code></a>命令删除。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; $ docker container rm [containerID]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>
<h3 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h3><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>
<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="搭建web服务"><a href="#搭建web服务" class="headerlink" title="搭建web服务"></a>搭建web服务</h3><p>首先，我们需要拉取 centos 镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 80 --name web -i -t centos /bin/bash</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>紧接着，我们安装 nginx 服务器，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>安装完 Nginx 源后，就可以正式安装 Nginx 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此，我们再输入 <code>whereis nginx</code> 命令就可以看到安装的路径了。最后，我们还需要将 Nginx 跑起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在，我们执行 <code>ctrl + P +  Q</code> 切换到后台。然后，通过 <code>docker ps -a</code> 来查看随机分配的端口。</p>
<p>那么通过浏览器访问 <code>http://127.0.0.1:随机端口号</code> 即可。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>Docker 构建镜像有两种方式，一种方式是使用 <code>docker commit</code> 命令，另外一种方式使用 <code>docker build</code> 命令和 <code>Dockerfile</code> 文件。其中，不推荐使用 <code>docker commit</code> 命令进行构建，因为它没有使得整个流程标准化，因此，在企业的中更加推荐使用 <code>docker build</code> 命令和 <code>Dockerfile</code> 文件来构建我们的镜像。我们使用<code>Dockerfile</code> 文件可以让构建镜像更具备可重复性，同时保证启动脚本和运行程序的标准化。</p>
<h3 id="构建第一个-Dockerfile-文件"><a href="#构建第一个-Dockerfile-文件" class="headerlink" title="构建第一个 Dockerfile 文件"></a>构建第一个 Dockerfile 文件</h3><p>现在，我们继续实战。这里，我们把一开始搭建的 Web 服务器构建一个镜像。首先，我们需要创建一个空的 Dokcerfile 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir dockerfile_test</span><br><span class="line">cd dockerfile_test/</span><br><span class="line">touch Dockerfile</span><br><span class="line">nano Dockerfile</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>紧接着，我们需要编写一个 Dockerfile 文件，代码清单如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER LiangGzone &quot;lianggzone@163.com&quot;</span><br><span class="line">RUN rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line">RUN yum install -y nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最后，我们通过 <code>docker build</code> 命令进行构建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t=&quot;lianggzone/nginx_demo:v1&quot; .</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>docker images</code> 看下我们的新镜像。</p>
<p>现在，让我们来理解一下这个全过程吧。首先， <code>FROM centos:7</code> 是 Dockerfile 必须要的第一步，它会从一个已经存在的镜像运行一个容器，换句话说，Docker 需要依赖于一个基础镜像进行构建。这里，我们指定 centos 作为基础镜像，它的版本是 7 (CentOS 7)。然后，我们通过 <code>MAINTAINER LiangGzone &quot;lianggzone@163.com&quot;</code> 指定该镜像的作者是 LiangGzone，邮箱是 <a href="mailto:lianggzone@163.com" rel="external nofollow noopener noreferrer" target="_blank">lianggzone@163.com</a>。这有助于告诉使用者它的作者和联系方式。接着，我们执行两个 RUN 指令进行 Nginx 的下载安装，最后通过 <code>EXPOSE 80</code> 暴露 Dokcer 容器的 80 端口。注意的是，Docker 的执行顺序是从上而下执行的，所以我们要明确整个流程的执行顺序。除此之外，Docker 在执行每个指令之后都会创建一个新的镜像层并且进行提交。</p>
<p>我们使用 <code>docker build</code> 命令进行构建，指定 <code>- t</code> 告诉 Docker 镜像的名称和版本。注意的是，如果没有指定任何标签，Docker 将会自动为镜像设置一个 lastest 标签。还有一点，我们最后还有一个 <code>.</code> 是为了让 Docker 到当前本地目录去寻找 Dockerfile 文件。注意的是，Docker 会在每一步构建都会将结果提交为镜像，然后将之前的镜像层看作缓存，因此我们重新构建类似的镜像层时会直接复用之前的镜像。如果我们需要跳过，可以使用 <code>--no-cache</code> 选项告诉 Docker 不进行缓存。</p>
<h3 id="指令辨别一：RUN、CMD、ENTRYPOINT"><a href="#指令辨别一：RUN、CMD、ENTRYPOINT" class="headerlink" title="指令辨别一：RUN、CMD、ENTRYPOINT"></a>指令辨别一：RUN、CMD、ENTRYPOINT</h3><p><code>RUN</code> 、 <code>CMD</code> 、 <code>ENTRYPOINT</code> 三个指令的用途非常相识，不同在于，<code>RUN</code> 指令是在容器被构建时运行的命令，而<code>CMD</code> 、 <code>ENTRYPOINT</code> 是启动容器时执行 shell 命令，而 <code>RUN</code> 会被 <code>docker run</code> 命令覆盖，但是 <code>ENTRYPOINT</code> 不会被覆盖。事实上，<code>docker run</code> 命令指定的任何参数都会被当作参数再次传递给 <code>ENTRYPOINT</code> 指令。<code>CMD</code> 、 <code>ENTRYPOINT</code> 两个指令之间也可以一起使用。例如，我们 可以使用 <code>ENTRYPOINT</code> 的 exec 形式设置固定的默认命令和参数，然后使用任一形式的 <code>CMD</code> 来设置可能更改的其他默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="指令辨别二：ADD、COPY"><a href="#指令辨别二：ADD、COPY" class="headerlink" title="指令辨别二：ADD、COPY"></a>指令辨别二：ADD、COPY</h3><p><code>ADD</code> 、 <code>COPY</code> 指令用法一样，唯一不同的是 <code>ADD</code> 支持将归档文件（tar, gzip, bzip2, etc）做提取和解压操作。注意的是，<code>COPY</code> 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p>
<h3 id="更多docker命令"><a href="#更多docker命令" class="headerlink" title="更多docker命令"></a>更多docker命令</h3><p><a href="https://docs.docker.com/engine/reference/commandline/docker/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<p>参考链接：</p>
<p><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5cacbfd7e51d456e8833390c</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2020/04/06/double-pointer/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<a id="more"></a>

<p>快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。</p>
<p><strong>1、判定链表中是否含有环</strong></p>
<p>这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。</p>
<p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。</p>
<p>如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != null)</span><br><span class="line">        head = head.next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。</p>
<p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、已知链表中含有环，返回这个环的起始位置</strong></p>
<p>这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p>
<p>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。</p>
<p>设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。</p>
<p>所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。</p>
<p><strong>3、寻找链表的中点</strong></p>
<p>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// slow 就在中间位置</span></span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>

<p>当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：</p>
<p>寻找链表中点的一个重要作用是对链表进行归并排序。</p>
<p>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p>
<p>但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。</p>
<p><strong>4、寻找链表的倒数第 k 个元素</strong></p>
<p>我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode slow, fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line"><span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) </span><br><span class="line">    fast = fast.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fast != null) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>

<h3 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h3><p>左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。</p>
<p><strong>1、二分查找</strong></p>
<p>前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、两数之和</strong></p>
<p>直接看一道 LeetCode 题目吧：<a href="https://leetcode-cn.com/problems/two-sum/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/two-sum/</a></p>
<p>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、反转数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// swap(nums[left], nums[right])</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        left++; right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、滑动窗口算法</strong></p>
<p>这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>三数之和：</p>
<p><a href="https://leetcode-cn.com/problems/3sum/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/3sum/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a - b &#125;)</span><br><span class="line">  <span class="comment">// 先排序，才能左右夹逼</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 如果当前数大于 0，不用循环，因为 k 是最小数，最小数已经大于 0，三数之和不可能等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] === nums[k - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="comment">// 夹逼条件，如果两个边界都挨着了就不用循环了</span></span><br><span class="line">      <span class="keyword">let</span> sum = nums[k] + nums[i] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 满足条件 push 到返回数组</span></span><br><span class="line">        res.push([nums[k], nums[i], nums[j]])</span><br><span class="line">        <span class="keyword">while</span> (nums[i] === nums[++i]) &#123; &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] === nums[--j]) &#123; &#125;</span><br><span class="line">        <span class="comment">// 去重，相当于下面四句，去重后还要指向不重复的那一个</span></span><br><span class="line">        <span class="comment">// while (nums[i] === nums[i + 1]) &#123; i++ &#125;</span></span><br><span class="line">        <span class="comment">// while (nums[j] === nums[j - 1]) &#123; j-- &#125;</span></span><br><span class="line">        <span class="comment">// i++</span></span><br><span class="line">        <span class="comment">// j--</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于 0 说明左边界的数小了，往右移动，因为整个数是排序好的</span></span><br><span class="line">        <span class="comment">// k &gt; i + j，i 右移动，可以让 i + j 更大一点</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        i++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 左夹</span></span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原理部分原文链接：<a href="[https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7.md](https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/双指针技巧.md)">双指针技巧</a> </p>
<p>感谢 labuladong 大神的一系列博客，真的给了我很多的启发。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/03/28/dynamic-programming/</url>
    <content><![CDATA[<p>最近在做题的时候遇到了递归，隐约感觉与动规有点相似，但自已又说不清楚，于是找了很多文章，这里摘录一片最基础但也是最清楚的文章，原文链接是<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/" rel="external nofollow noopener noreferrer" target="_blank">这个</a>。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。</p>
<p>既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p>
<p>动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p>
<p>首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<a id="more"></a>

<p>而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p>
<p>明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。</p>
<p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
<p>请读者不要嫌弃这个例子简单，只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。想要困难的例子，历史文章里有的是。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>1、暴力递归</p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。</p>
<p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215195409_kdnd5s.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033289/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215195409_kdnd5s.png"></p>
<p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。</p>
<p>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：重叠子问题。下面，我们想办法解决这个问题。</p>
<p>2、带备忘录的递归解法</p>
<p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化最简情况</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + </span><br><span class="line">                helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033688/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200116_wqfxvd.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608033688/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215200116_wqfxvd.png"></p>
<p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<p>递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p>
<p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p>3、dp 数组的迭代解法</p>
<p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361138/Algorithm/1b4485704cf963fd49d597040ffbb3b5d4d2ca923752c8c78d00042df66343a9_zzg5tk.jpg" alt></p>
<p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p>f(n) = 1, n = 1, 2</p>
<p>f(n) = f(n -1) + f(n -2), n &gt;2</p>
<p>为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在演示算法设计螺旋上升的过程。下面，看第二个例子，凑零钱问题。</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>先看下题目：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p>
<p>你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p>
<p>1、暴力递归</p>
<p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p>
<p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的。</p>
<p>那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？</p>
<p>先确定「状态」，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。</p>
<p>然后确定 dp 函数的定义：当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。</p>
<p>然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = min(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># 我们要求的问题是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>最后明确 base case，显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p>
<p>dp(n) = 0, n = 0</p>
<p>dp(n) = -1, n &lt; 0</p>
<p>dp(n) = min{dp(n - coin) + 1 | coin ∈ coins}, n &gt; 0    </p>
<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 amount = 11, coins = {1,2,5} 时画出递归树看看：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361160/Algorithm/7db5a80dbffaf2337c0e0323437442d007987bce16b7fa86affbc5ca0e1132d0_vctecf.jpg" alt></p>
<p>时间复杂度分析：子问题总数 x 每个子问题的时间。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<p>2、带备忘录的递归</p>
<p>只需要稍加修改，就可以通过备忘录消除子问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins: List[int], amount: int)</span>:</span></span><br><span class="line">    <span class="comment"># 备忘录</span></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="comment"># 查备忘录，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            res = float(<span class="string">'INF'</span>)</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                subproblem = dp(n - coin)</span><br><span class="line">                <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">                res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记入备忘录</span></span><br><span class="line">            memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>

<p>不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<p>3、dp 数组的迭代解法</p>
<p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的：</p>
<p>dp[i] = x 表示，当目标金额为 i 时，至少需要 x 枚硬币。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 内层 for 在求所有子问题 + 1 的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585361182/Algorithm/b4e6cf1bb8e2284bfc01dfef6c1a60c19f9c78238061b65370ccc01822161e83_qgnjw5.jpg" alt></p>
<p>PS：为啥 dp 数组初始化为 amount + 1 呢，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p>
<p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p>
<p>如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。</p>
<p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
<p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Electron 多进程方案</title>
    <url>/2021/01/01/electron-multi-process/</url>
    <content><![CDATA[<p>这周大部分时间都是在开发一个基于Electron的客户端。</p>
<p>Electron内置一个chrome内核，所以可以让我们像开发一个网站一样开发客户端。</p>
<p>在开发过程中，遇到了一个问题，就是我们的项目需要从本地加载AI的模型并进行计算。</p>
<p>看过我介绍<a href="https://sunra.top/2020/12/03/browser-architecture/">浏览器结构那篇文章</a>的应该知道，在当前chrome结构下，网络进程与渲染进程是完全分开的，所以加载模型并不会pend住渲染进程，所以就没有在意。</p>
<p>但是事实证明我的页面还是会存在卡顿。</p>
<p>于是我就用开发者工具的Performance面板录制了一下，结果发现是模型加载完后的识别函数，它是一个Promise，属于微任务，实际上是个协程，而且是个CPU密集型的协程。</p>
<a id="more"></a>

<p>于是这里我就产生了第一个问题：</p>
<h2 id="协程会pend住进程吗？"><a href="#协程会pend住进程吗？" class="headerlink" title="协程会pend住进程吗？"></a>协程会pend住进程吗？</h2><p>要解决这问题，首先得明白协程是什么。</p>
<h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p>进程是系统资源分配的最小单位, 系统由一个个进程(程序)组成 一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。</p>
<ul>
<li>文本区域存储处理器执行的代码</li>
<li>数据区域存储变量和进程执行期间使用的动态分配的内存；</li>
<li>堆栈区域存储着活动过程调用的指令和本地变量。</li>
</ul>
<p>因此进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。 进程有三个状态:</p>
<ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
</ol>
<p>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</p>
<blockquote>
<p>通信问题:   由于进程间是隔离的,各自拥有自己的内存内存资源, <em>因此相对于线程比较安全</em>, 所以不同进程之间的数据只能通过 <em>IPC(Inter-Process Communication)</em> 进行通信共享.</p>
</blockquote>
<h3 id="线程又是什么"><a href="#线程又是什么" class="headerlink" title="线程又是什么"></a>线程又是什么</h3><ul>
<li>线程属于进程</li>
<li>线程共享进程的内存地址空间</li>
<li>线程几乎不占有系统资源 通信问题:  进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。</li>
</ul>
<p>同时多线程是不安全的,当一个线程崩溃了,会导致整个进程也崩溃了,即其他线程也挂了, 但多进程而不会,一个进程挂了,另一个进程依然照样运行。</p>
<ul>
<li><strong><em>进程是系统分配资源的最小单位</em></strong></li>
<li><strong><em>线程是CPU调度的最小单位</em></strong></li>
<li><em>由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心</em></li>
</ul>
<h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程的概念是相对多进程或者多线程来说的，他是一种协作式的用户态线程</p>
<ol>
<li>与之相对的，线程和进程是以抢占式执行的，意思就是系统帮我们自动快速切换线程和进程来让我们感觉同步运行的感觉，这个切换动作由系统自动完成</li>
<li>协作式执行说的就是，想要切换线程，你必须要用户手动来切换 协程为什么那么快原因就是因为，无需系统自动切换（系统自动切换会浪费很多的资源），而<strong>协程是我们用户手动切换</strong>，而且是在同一个栈上执行，速度就会非常快而且省资源。</li>
</ol>
<p>但是，协程有他自己的问题：<strong>协程只能有一个进程，一个线程在跑，一旦发生IO阻塞，这个程序就会卡住</strong>。</p>
<p>所以我们要使用协程之前，必须要保证我们所有的IO都必须是非阻塞的。也就是需要异步。</p>
<p>意思是多个线程互相协作，完成异步任务。</p>
<h3 id="CPU的多核多线程指的是什么"><a href="#CPU的多核多线程指的是什么" class="headerlink" title="CPU的多核多线程指的是什么"></a>CPU的多核多线程指的是什么</h3><p>计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)，由于超线程技术，实际上可以并行的线程数量通常是物理核数的两倍，这也是操作系统看到的核数。我们只care可以并行的线程数量，所以之后所说的核数是操作系统看到的核数，所指的核也是超线程技术之后的那个核（不是物理核）。</p>
<p>如果计算机有多个cpu核，且计算机中的总的线程数量小于核数，那线程就可以并行运行在不同的核中，如果是单核多线程，那多线程之间就不是并行，而是并发，即为了均衡负载，cpu调度器会不断的在单核上切换不同的线程执行，但是我们说过，一个核只能运行一个线程，所以并发虽然让我们看起来不同线程之间的任务是并行执行的，但是实际上却由于增加了线程切换的开销使得代价更大了。如果是多核多线程，且线程数量大于核数，其中有些线程就会不断切换，并发执行，但实际上最大的并行数量还是当前这个进程中的核的数量，所以盲目增加线程数不仅不会让你的程序更快，反而会给你的程序增加额外的开销。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>从这个角度理解，<strong>协程其实就是把线程的切换权利交给了代码，也就是用户</strong>。</p>
<p>而同一个进程同时只能有一个线程执行，所以说JavaScript的单线程就会pend住渲染进程，所以协程其实也会pend住进程。</p>
<h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>既然我有一个需要定时执行的CPU密集型的协程可能会pend住我当前的JavaScript线程进而peng住渲染进程，那我想办法单独开一个进程来执行这个任务不就好了？</p>
<p>那Electron如何搞多进程呢？</p>
<p>你去翻阅官方文档，并不会找到专门的多进程解决方案，只有多线程的方案，叫做<strong>Web Worker</strong>，这个东西我也是第一次看到，有兴趣的可以自己查一下资料，用起来并不难，也不是Electron的接口，而是JavaScript提供的。</p>
<p>但是这并不能解决我们的问题，因为它是另开一个线程，如果我们的CPU是单核单线程的，并没有什么用，我们需要的是另开一个进程。</p>
<p>虽然我们很少有电脑是单核单线程了，但是Web Worker的使用是需要把参数深复制过去，而这个检测工具的入参需要video的视频流，是没法深复制的，会抛出异常，所以并不合适。</p>
<p>那我们的问题怎么解决呢？</p>
<p>其实Electron自身就是个多进程的架构，<strong>就像Chrome会为每个不同站的网页单独一个渲染进程一样，Electron也能做到，我们只需要new 一个新的BrowserWindow就可以了，然后让我们的检测任务在单独的渲染进程中工作，将结果通过Electron提供的IPC通信接口发送给主渲染进程就好</strong>。</p>
<p>参考链接：</p>
<p><a href="https://juejin.cn/post/6844903607892967432" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.cn/post/6844903607892967432</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Element UI 笔记</title>
    <url>/2020/07/18/elelment-ui-note/</url>
    <content><![CDATA[<p>记录一下在使用elementUI时遇到的坑。</p>
<p>elementUI有的事件命名容易让人产生疑惑，如handleSizeChange，handleCLose等。</p>
<a id="more"></a>

<h2 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-pagination</span><br><span class="line">      @size-change=<span class="string">"handleSizeChange"</span></span><br><span class="line">      @current-change=<span class="string">"handleCurrentChange"</span></span><br><span class="line">      :current-page.sync=<span class="string">"currentPage1"</span></span><br><span class="line">      :page-size=<span class="string">"100"</span></span><br><span class="line">      layout=<span class="string">"total, prev, pager, next"</span></span><br><span class="line">      :total=<span class="string">"1000"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/el-pagination&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个组件中的handleSizeChange听起来是pageSize改变时触发的，感觉上触发时pageSize已经改了，实际上你需要在函数里面再重新赋值才有用。</p>
<h2 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-dialog</span><br><span class="line">  title=<span class="string">"Tips"</span></span><br><span class="line">  :visible.sync=<span class="string">"dialogVisible"</span></span><br><span class="line">  width=<span class="string">"30%"</span></span><br><span class="line">  @close=<span class="string">"handleClose"</span>&gt;</span><br><span class="line">  &lt;span&gt;This is a message&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span slot="footer" class="dialog-footer"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;el-button @click="dialogVisible = false"&gt;Cancel&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;el-button type=<span class="string">"primary"</span> @click=<span class="string">"dialogVisible = false"</span>&gt;Confirm&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/el-dialog&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码dialog的显示与隐藏由“dialogVisible” 决定，这个时候你直接点关闭按钮是无效的，我们必须在handleClose中把“dialogVisible”置为false才有效。</p>
<h2 id="DatePicker"><a href="#DatePicker" class="headerlink" title="DatePicker"></a>DatePicker</h2><p>element-ui的时间选择器返回的时间如果直接拼到url里面，会转成GMT+8时间，也就是本地时间，而不是UTC时间。</p>
<p>所以如果要使用UTC时间就要先转换一下。</p>
<p>如果你是用moment转换的，要注意一点，moment的utc函数转换出来的时间是没有毫秒数的。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Element UI Table 树形组件懒加载问题修复</title>
    <url>/2020/11/04/element-ui-table-lazy-loading/</url>
    <content><![CDATA[<p>上周在使用一个elementUI的table是，发现每次点击table的checkbox的时候，页面都会卡顿接近两秒钟，于是就用vue的devtools去记录了下每次的操作时间消耗在哪里，发现主要是因为elementUI的table虽然提供了树形数据和懒加载的功能，虽然子级节点没有展开，但是已经渲染出来了。</p>
<p>所以elementUI的table提供了懒加载的功能，但是这个懒加载的功能是有问题的，因为懒加载函数只会调用一次，以后无论如何变化数据，子节点都不会发生改变。</p>
<p>经过对vue和elementUI的源码分析，找到原因后适当fix了一下，在这里记录一下。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:data</span>=<span class="string">"parentResourceList"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">border</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"list-resource-table-wrapper"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:height</span>=<span class="string">"tableHeight"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">row-key</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">lazy</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:load</span>=<span class="string">"lazyLoadChildren"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:tree-props</span>=<span class="string">"&#123;children: 'children', hasChildren: 'hasChildren'&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">stripe</span></span></span><br><span class="line"><span class="tag">          @<span class="attr">selection-change</span>=<span class="string">"onSelectionChange"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:default-sort</span>=<span class="string">"&#123; prop: 'assetId' &#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-loading</span>=<span class="string">"loading"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">ref</span>=<span class="string">"listResourceTableRef"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> loadResources() &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> resourceGateway.getAssets();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isSuccessResponse(response)) &#123;</span><br><span class="line">          <span class="keyword">let</span> rows = response.data;</span><br><span class="line">          <span class="keyword">let</span> newResource = &#123;&#125;;</span><br><span class="line">          <span class="keyword">this</span>.childrenResourceMap = &#123;&#125;;</span><br><span class="line">          rows.forEach(<span class="function">(<span class="params">row</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (newResource[row.assetId]) &#123;</span><br><span class="line">              newResource[row.assetId].hasChildren = <span class="literal">true</span>;</span><br><span class="line">              (<span class="keyword">this</span>.childrenResourceMap[row.assetId] || (<span class="keyword">this</span>.childrenResourceMap[row.assetId] = [])).push(row);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              newResource[row.assetId] = row;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">let</span> result = [];</span><br><span class="line">          _.keys(newResource).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> resource = newResource[key];</span><br><span class="line">            result.push(resource);</span><br><span class="line">            <span class="keyword">this</span>.refreshLazyRows(resource);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">this</span>.parentResourceList = result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$_error(<span class="keyword">this</span>.$t(<span class="string">'message.loadResourceFail'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$_error(<span class="keyword">this</span>.$t(<span class="string">'message.loadResourceFail'</span>));</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    lazyLoadChildren(tree, treeNode, resolve) &#123;</span><br><span class="line">      resolve(<span class="keyword">this</span>.childrenResourceMap[tree.assetId]);</span><br><span class="line">    &#125;,</span><br><span class="line">    refreshLazyRows(resource) &#123;</span><br><span class="line">      <span class="keyword">let</span> lazyTreeNodeMap = <span class="keyword">this</span>.$refs.listResourceTableRef.store.states.lazyTreeNodeMap;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.childrenResourceMap[resource.assetId]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.childrenResourceMap[resource.assetId].some(<span class="function">(<span class="params">childResource</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (_.get(lazyTreeNodeMap, childResource.id)) &#123;</span><br><span class="line">            _.set(lazyTreeNodeMap, childResource.id, []);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_.get(lazyTreeNodeMap, resource.id)) &#123;</span><br><span class="line">        _.set(lazyTreeNodeMap, resource.id, <span class="keyword">this</span>.childrenResourceMap[resource.assetId]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>refreshLazyRows()函数的主要作用就是更新<code>this.$refs.listResourceTableRef.store.states.lazyTreeNodeMap</code>，这个值才是子级节点监听的对象</p>
<p>至于为什么先要把已有的映射删除，是因为如果不删除旧有的，就直接添加新的映射，同时我们又新增了一个节点当作父级节点，就会导致节点层层嵌套，并且会引起elementUI报key重复的错误。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>ES6 Class 源码分析</title>
    <url>/2021/03/28/es6-class-source-code/</url>
    <content><![CDATA[<p>上一篇关于React的博客中留了一个关于Es6 class的坑，关于class与function之间的关系，我们这篇博客来讨论一下。</p>
<p>我们带着两个问题来看这篇博客：</p>
<ul>
<li>class是如何用function实现的</li>
<li>new class和new function有什么区别</li>
</ul>
<a id="more"></a>

<h2 id="class如何用function实现"><a href="#class如何用function实现" class="headerlink" title="class如何用function实现"></a>class如何用function实现</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>我们都知道，class其实是function的一个语法糖，是基于原型链的的，所以想要看懂这篇博客，建议大家先去看看我的前面一篇讲原型链的博客：<a href="https://kingworker.cn/javascript%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6%ef%bc%88%e4%ba%94%ef%bc%89%e7%94%a8%e5%85%ac%e5%bc%8f%e8%ae%b2%e6%b8%85%e6%a5%9a%e5%8e%9f%e5%9e%8b%e9%93%be/" rel="external nofollow noopener noreferrer" target="_blank">用公式讲清楚原型链</a></p>
<h3 id="利用babel将class转化为es5代码"><a href="#利用babel将class转化为es5代码" class="headerlink" title="利用babel将class转化为es5代码"></a>利用babel将class转化为es5代码</h3><p>我们可以写一段class的代码，然后利用<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAEAKCmAnCB7AdgbwFDV8dEALogK7CEqIAUaYAtvADTRgDm8AlNrj4QBYBLCADpaDaAF5oY-Dh7R-Q4W3iSW7ObgC-WTdCJhCA4AoCeAB1VSA5ACN4AtK2u7cEMKYBy9VVS57EeEISRDQFQREZPR05AyMTR2IUP24efDRUEHhhEBRWKgAiAo5orBjQSBgAWXgw-AAPQlqAExgEZHRUvAJiMgpqGWYVf3l5CBJLahLR8KV2NGakNWs6MCyXeR0tIA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=true&targets=&version=7.13.13&externalPlugins=" rel="external nofollow noopener noreferrer" target="_blank">babel在线工具</a>将其转化为es5的代码，然后一步步分析。</p>
<p>首先我们先写一段，class的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">     <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> type = <span class="string">'being'</span></span><br><span class="line"></span><br><span class="line">  sayName ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> intro()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Men</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'male'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化后的函数太长了，我就不完整贴在这里了，想看完整版的可以去上面的连接自己看，我们现在开始一步步分析这个转化后的函数。</p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><h4 id="inherits"><a href="#inherits" class="headerlink" title="_inherits"></a>_inherits</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123; value: subClass, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个函数的名字是用来做继承用的，也就是extends的时候会调用这个函数。</p>
<p>这个函数首先上来是判断父类是否符合条件，如果不符合，直接抛出异常。</p>
<p>紧接着是调用Object.create方法，这个方法的作用是：</p>
<p><strong><code>Object.create()</code></strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>
<p>也就是说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123; value: subClass, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码就完成了基于原型链的继承，这段代码的结果就是，通过superClass.prototype创建了一个新的对象，新对象的<code>__proto__</code>指向superClass.prototype，然后将这个对象赋值给subClass.prototype。</p>
<p>也就是说，subClass.prototype.<code>__proto__</code> = superClass.prototype</p>
<p>这样一来，subClass的原型链上就有了superclass的原型。</p>
<p>然后就是最后一步的<code>_setPrototypeOf</code>，我们继续看看这个函数是做什么的</p>
<h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="_setPrototypeOf"></a>_setPrototypeOf</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  _setPrototypeOf =</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">      o.__proto__ = p;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用也是构造原型链，其核心目的就是这句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.__proto__ = p</span><br></pre></td></tr></table></figure>

<p>结合上一个辅助函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_setPrototypeOf(subClass, superClass)</span><br></pre></td></tr></table></figure>

<p>那结果就是subClass.<code>__proto__</code> = superClass</p>
<h4 id="isNativeReflectConstruct"><a href="#isNativeReflectConstruct" class="headerlink" title="_isNativeReflectConstruct"></a>_isNativeReflectConstruct</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_isNativeReflectConstruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"undefined"</span> || !<span class="built_in">Reflect</span>.construct) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Reflect</span>.construct.sham) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Proxy</span> === <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Boolean</span>.prototype.valueOf.call(</span><br><span class="line">      <span class="built_in">Reflect</span>.construct(<span class="built_in">Boolean</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要看懂这段代码，就要明白Reflect是什么，Reflect.construct是什么</p>
<p>首先Reflect其实也是ES6的新语法，具体可以做什么可以去看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="external nofollow noopener noreferrer" target="_blank">MDN</a>，不是我们目前的重点，我们暂时只关注其中一点：</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct" rel="external nofollow noopener noreferrer" target="_blank"><code>Reflect.construct(target, argumentsList[, newTarget\])</code></a></p>
<p>对构造函数进行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" rel="external nofollow noopener noreferrer" target="_blank"><code>new</code> </a>操作，相当于执行 <code>new target(...args)</code>。</p>
</blockquote>
<p>那这个函数的作用就比较明显了，就是看看当前的执行环境下能不能用Reflect.construct去创建新的对象。</p>
<h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="_getPrototypeOf"></a>_getPrototypeOf</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">    ? <span class="built_in">Object</span>.getPrototypeOf</span><br><span class="line">    : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就是获取传入参数的原型链上的下一个原型，也可以理解为它直接继承的对象。</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="_typeof"></a>_typeof</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="string">"@babel/helpers - typeof"</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">    _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">        obj.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">        obj !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">        ? <span class="string">"symbol"</span></span><br><span class="line">        : <span class="keyword">typeof</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _typeof(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先通过if-else创建了函数变量<code>_typeof</code>，由于是es5代码，所以没有const和let，而这种直接变量赋值的方式其实与var相同，所以会存在<a href="https://kingworker.cn/javascript%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6%ef%bc%88%e4%b8%80%ef%bc%89%e5%8f%98%e9%87%8f%e6%8f%90%e5%8d%87/" rel="external nofollow noopener noreferrer" target="_blank">变量提升</a></p>
<p>结果就是在函数作用域中声明了一个函数，赋值给<code>_typeof</code>，然后调用这个函数返回结果。</p>
<p>置于为什么会有这个判断，我应该又要在这里留一个坑了，我们暂时不管它，就当它是为了浏览器的兼容性好了。</p>
<h4 id="possibleConstructorReturn"><a href="#possibleConstructorReturn" class="headerlink" title="_possibleConstructorReturn"></a>_possibleConstructorReturn</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(</span><br><span class="line">      <span class="string">"this hasn't been initialised - super() hasn't been called"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先要知道<code>void 0 === undefined</code> 是 true.</p>
<p>再回来看这段代码，就是说如果call是对象或者函数，直接返回call。</p>
<p>如果不是，那就看看self是不是undefined，是的话就抛出异常，不是则返回self</p>
<h4 id="createSuper"><a href="#createSuper" class="headerlink" title="_createSuper"></a>_createSuper</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createSuper</span>(<span class="params">Derived</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hasNativeReflectConstruct = _isNativeReflectConstruct();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_createSuperInternal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Super = _getPrototypeOf(Derived),</span><br><span class="line">      result;</span><br><span class="line">    <span class="keyword">if</span> (hasNativeReflectConstruct) &#123;</span><br><span class="line">      <span class="keyword">var</span> NewTarget = _getPrototypeOf(<span class="keyword">this</span>).constructor;</span><br><span class="line">      result = <span class="built_in">Reflect</span>.construct(Super, <span class="built_in">arguments</span>, NewTarget);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = Super.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, result);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，看了上面那么多辅助函数，最终都是在这里使用的。</p>
<p>我们好好梳理一下这个函数是做什么的：</p>
<ul>
<li>首先判断当前执行环境能不能调用Reflect.construct，如果可以hasNativeReflectConstruct就是true。</li>
<li>然后这个函数执行的结果，其实返回了另外一个函数_createSuperInternal，这个函数中用到了外层的参数，所以这是个闭包。</li>
<li>那我们看一下，这个闭包中做了什么：<ul>
<li>获取Derived的原型作为Super</li>
<li>如果当前环境可以调用Reflect.construct（hasNativeReflectConstruct是true）</li>
<li>var NewTarget = _getPrototypeOf(this).constructor;获取当前函数执行者的原型链上的上一级的构造函数，并赋值给NewTarget。</li>
<li>result = Reflect.construct(Super, arguments, NewTarget);调用 new Super，参数是arguments，创建的对象的构造函数是NewTarget</li>
<li>如果hasNativeReflectConstruct是false，直接在this上调用apply，这种继承方式其实就是<strong>借用构造函数继承</strong>这种继承方式，还有许多其他的继承方式，有兴趣可以去看我的另外一篇博客：<a href="https://kingworker.cn/javascript-%e7%bb%a7%e6%89%bf/" rel="external nofollow noopener noreferrer" target="_blank">https://kingworker.cn/javascript-%e7%bb%a7%e6%89%bf/</a></li>
<li>最终调用_possibleConstructorReturn(this, result)，结果就是，如果result如果是对象或者函数，则返回result，否则如果this不是undefined，则返回this，都不符合则抛出错误。</li>
</ul>
</li>
</ul>
<h4 id="classCallCheck"><a href="#classCallCheck" class="headerlink" title="_classCallCheck"></a>_classCallCheck</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数很简单，就是用来检测不能像普通函数那样调用class，比如class Persion你不能直接Persion()</p>
<h4 id="defineProperties"><a href="#defineProperties" class="headerlink" title="_defineProperties"></a>_defineProperties</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">    descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">    descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      writable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数一起的作用其实就是在target上不断定义新的属性</p>
<h4 id="createClass"><a href="#createClass" class="headerlink" title="_createClass"></a>_createClass</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">  <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的<code>_defineProperties</code>函数，这个函数三个参数，第一个参数是构造函数，第二个参数是所有普通属性的数组，第三个是所有静态属性的数组，所以这个函数的作用其实就是：</p>
<ul>
<li><p>将class中的普通属性定义在构造函数的原型上，这样当我们new一个实例的时候，就可以在实例的原型链上找到这些普通的属性</p>
<blockquote>
<p>看过我前面关于原型链博客的应该对我的公式有印象：</p>
<p>a = new A() =&gt; a.<code>__proto__</code> = A.prototype </p>
</blockquote>
</li>
<li><p>将class中的静态属性定义在构造函数上，这样我们就可以直接在构造函数上点出静态方法。</p>
</li>
</ul>
<h3 id="动态的生成代码"><a href="#动态的生成代码" class="headerlink" title="动态的生成代码"></a>动态的生成代码</h3><p>好了，有了上面的这些辅助函数，我就可以看看我们一开始定义的class是怎么利用这些辅助函数来实现的了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="comment">/*#__PURE__*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(</span><br><span class="line">    Person,</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        key: <span class="string">"sayName"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        key: <span class="string">"intro"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">_defineProperty(Person, <span class="string">"type"</span>, <span class="string">"being"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Men = <span class="comment">/*#__PURE__*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_Person</span>) </span>&#123;</span><br><span class="line">  _inherits(Men, _Person);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _super = _createSuper(Men);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Men</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Men);</span><br><span class="line"></span><br><span class="line">    _this = _super.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    _this.gender = <span class="string">"male"</span>;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Men;</span><br><span class="line">&#125;)(Person);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先Persion定义为一个立即执行函数的返回结果，这个返回结果还是一个函数，所以我们可以得知，最后Persion其实还是一个函数，我们仍然称这个函数为Constructor Persion。</p>
</li>
<li><p>这个Constructor Persion函数做了什么？</p>
<ul>
<li>首先，调用<code>_classCallCheck(this, Person);</code>，这个是我们刚才分析的辅助函数，保证我们的这个Constructor Persion函数不是直接调用的，而是放在new后面当做构造函数。</li>
<li>然后在实例上添加两个属性，name和age</li>
</ul>
</li>
<li><p>调用_createClass，我们刚才分析过了， 这个函数三个参数分别是构造函数，普通属性的数组，静态属性的数组，所以这一步之后，Persion.prototype上有了一个新的属性，叫做sayName，Persion上有了一个新的静态属性，叫做intro。</p>
</li>
<li><p>最后返回Constructor Persion</p>
</li>
<li><p>因为type是Class Persion的静态属性，所以，在Constructor Persion上定义type，这样就可以直接在构造函数上找到。</p>
</li>
<li><p>Men同样也定义为一个立即执行函数的返回结果，这个返回结果也是一个函数。我们称这个函数为Constructor Men。</p>
</li>
<li><p>首先调用<code>_inherits(Men, _Person)</code>，通过刚才我们分析的<code>_inherits</code>作用可知，其作用就是</p>
<blockquote>
<p>subClass.prototype.<code>__proto__</code> = superClass.prototype</p>
<p>subClass.<code>__proto__</code> = superClass</p>
<p>放在这里，也就是说</p>
<p>Men.prototype.<code>__proto__</code> = _Person.prototype</p>
<p>Men.<code>__proto__</code> = _Person</p>
</blockquote>
<p>这样就完成了原型链的继承</p>
<p>这里要注意的一点是，<strong>这个Men是下面声明的function Men，而不是外层的Men，因为函数声明会提升</strong></p>
</li>
<li><p><code>var _super = _createSuper(Men)</code></p>
<p>我们刚才分析过这个<code>_createSuper</code>函数，它会返回另外一个函数，这个函数的作用是获取<code>Men.__proto__</code>作为Super，然后以函数调用者为上下文去调用Super，而上面的<code>_inherits(Men, _Person)</code>已经使得Men.<code>__proto__</code> = _Person。</p>
<p>所以这一步的结果是返回了一个函数，会在以调用者为上下文去调用Persion函数</p>
</li>
<li><p>其次定义Constructor Men（虽然代码顺序不是这样的，但是函数声明会变量提升），那这个Constructor Men做了什么呢？</p>
<ul>
<li>同样检查下是不是直接调用的Men。</li>
<li>调用_super，也就是Men的一个实例上调用Persion，这就是典型的借用构造函数继承。</li>
<li>在Men实例上挂载gender属性。</li>
</ul>
</li>
<li><p>返回Constructor Men</p>
</li>
</ul>
<p>我们最后来分析下结果：</p>
<ul>
<li>首先我们得到了两个函数Persion和Men，这两个函数都只能通过new去调用，否则会抛出异常。</li>
<li>其次这两个构造函数本身上都定义了声明的静态属性，构造函数的原型上定义了普通属性。</li>
<li>Men.prototype.<code>__proto__</code> = _Person.prototype</li>
<li>Men.<code>__proto__</code> = _Person</li>
<li>Men的构造函数中会通过在Men实例上调用Persion构造函数的方法去进行继承。</li>
</ul>
<h2 id="new-function和new-class"><a href="#new-function和new-class" class="headerlink" title="new function和new class"></a>new function和new class</h2><p>看到这里并且看明白的小伙伴应该明白了，并没有什么区别，只是多了一些内置的检查，帮你做了原型链的继承而已。</p>
<p>class本质返回的还是一个函数。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Proxy 与 Vue</title>
    <url>/2020/07/08/es6-proxy/</url>
    <content><![CDATA[<p>尤雨溪发表了名为 <code>Vue3.0 Updates</code> 的主题演讲，对 <code>Vue3.0</code> 的更新计划、方向进行了详细阐述（感兴趣的小伙伴可以看看完整的 <strong><a href="https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p" rel="external nofollow noopener noreferrer" target="_blank">PPT</a></strong>），表示已经放弃使用了 <code>Object.defineProperty</code>，而选择了使用更快的原生 <strong><code>Proxy</code></strong> !!</p>
<p>这将会消除了之前 <code>Vue2.x</code> 中基于 <code>Object.defineProperty</code> 的实现所存在的很多限制：无法监听 <strong>属性的添加和删除</strong>、<strong>数组索引和长度的变更</strong>，并可以支持 <code>Map</code>、<code>Set</code>、<code>WeakMap</code> 和 <code>WeakSet</code>！</p>
<a id="more"></a>

<h2 id="Proxy介绍"><a href="#Proxy介绍" class="headerlink" title="Proxy介绍"></a>Proxy介绍</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, propKey, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (target, propKey, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure>

<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">"Hello, foo"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcStack = [];</span><br><span class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">    <span class="keyword">get</span> : function (pipeObject, fnName) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fn(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">      <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"><span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line"><span class="comment">// Error: Invalid attempt to get private "_prop" property</span></span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to set private "_prop" property</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<h4 id="has"><a href="#has" class="headerlink" title="has"></a>has</h4><p><code>has</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has</code>拦截会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<h2 id="Vue中对Proxy的使用"><a href="#Vue中对Proxy的使用" class="headerlink" title="Vue中对Proxy的使用"></a>Vue中对Proxy的使用</h2><h3 id="vue2-x-是怎么实现数据的响应的呢"><a href="#vue2-x-是怎么实现数据的响应的呢" class="headerlink" title="vue2.x 是怎么实现数据的响应的呢?"></a>vue2.x 是怎么实现数据的响应的呢?</h3><p>递归遍历data中的数据，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="external nofollow noopener noreferrer" target="_blank">Object.defineProperty()</a>劫持 getter和setter，在getter中做数据依赖收集处理，在setter中 监听数据的变化，并通知订阅当前数据的地方。 <a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js#L156-L193" rel="external nofollow noopener noreferrer" target="_blank">部分源码 src/core/observer/index.js#L156-L193</a>, 版本为 2.6.11 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line"> <span class="comment">// 对 data中的数据进行深度遍历，给对象的每个属性添加响应式</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">         <span class="comment">// 进行依赖收集</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。</span></span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的值需要重新进行observe，保证数据响应式</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">// 将数据变化通知所有的观察者</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>这么做有什么问题呢？</p>
<ul>
<li>检测不到对象属性的添加和删除：当你在对象上新加了一个属性<code>newProperty</code>，当前新加的这个属性并没有加入vue检测数据更新的机制(因为是在初始化之后添加的)。<code>vue.$set</code>是能让vue知道你添加了属性, 它会给你做处理，<code>$set</code>内部也是通过调用<code>Object.defineProperty()</code>去处理的</li>
<li>无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。</li>
<li>当data中数据比较多且层级很深的时候，会有性能问题，因为要遍历data中所有的数据并给其设置成响应式的。</li>
</ul>
<h3 id="vue3-0-使用了Proxy"><a href="#vue3-0-使用了Proxy" class="headerlink" title="vue3.0 使用了Proxy"></a>vue3.0 使用了Proxy</h3><p>vue3.0还未正式发布，不过<a href="https://github.com/vuejs/vue-next" rel="external nofollow noopener noreferrer" target="_blank">vue-next</a> 的相关代码已经开源出来了，目前处于Alpha版本。</p>
<p>为什么使用 Proxy 可以解决上面的问题呢？主要是因为Proxy是拦截对象，对<code>对象</code>进行一个”拦截”，外界对该对象的访问，都必须先通过这层拦截。无论访问对象的什么属性，之前定义的还是新增的，它都会走到拦截中，</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>下面分别用<code>Object.defineProperty()</code>和 <code>Proxy</code>实现一个简单的数据响应</p>
<p>使用<code>Object.defineProperty()</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">        <span class="comment">// 遍历参数data的属性,给添加到this上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(data)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> data[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                data[key] = <span class="keyword">new</span> Observer(data[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">get</span>() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'你访问了'</span> + key);</span><br><span class="line">                    <span class="keyword">return</span> data[key]; <span class="comment">// 中括号法可以用变量作为属性名,而点方法不可以;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'你设置了'</span> + key);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'新的'</span> + key + <span class="string">'='</span> + newVal);</span><br><span class="line">                    <span class="keyword">if</span>(newVal === data[key]) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    data[key] = newVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: <span class="number">1</span>,</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Observer(obj);</span><br><span class="line">app.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(app.age);</span><br><span class="line">app.newPropKey = <span class="string">'新属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(app.newPropKey);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改 obj原有的属性 age的输出</span></span><br><span class="line">你设置了age</span><br><span class="line">新的age=<span class="number">20</span></span><br><span class="line">你访问了age</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="comment">// 设置新属性的输出</span></span><br><span class="line">新属性</span><br></pre></td></tr></table></figure>

<p>可以看到，给对象新增一个属性，内部并没有监听到，新增的属性需要手动再次使用<code>Object.defineProperty()</code>进行监听。 这就是为什么 <code>vue 2.x</code>中 检测不到对象属性的添加和删除的原因，内部提供的<code>$set</code>就是通过调用<code>Object.defineProperty()</code>去处理的。</p>
<p>下面我们使用  <code>Proxy</code> 替代 <code>Object.defineProperty()</code>实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: <span class="number">1</span>,</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你访问了'</span> + propKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, propKey, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你设置了'</span> + propKey);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'新的'</span> + propKey + <span class="string">'='</span> + value);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.age = <span class="string">'20'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age);</span><br><span class="line">p.newPropKey = <span class="string">'新属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.newPropKey);</span><br><span class="line">p.a.d = <span class="string">'这是obj中a的属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.a.d);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到下面输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改原对象的age属性</span></span><br><span class="line">你设置了age</span><br><span class="line">新的age=<span class="number">20</span></span><br><span class="line">你访问了age</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新的属性</span></span><br><span class="line">你设置了newPropKey</span><br><span class="line">新的newPropKey=新属性</span><br><span class="line">你访问了newPropKey</span><br><span class="line">新属性</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给obj的a属性(是个对象)设置属性d</span></span><br><span class="line">你访问了a</span><br><span class="line">你访问了a</span><br><span class="line">这是obj中a的属性</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://es6.ruanyifeng.com/#docs/proxy" rel="external nofollow noopener noreferrer" target="_blank">https://es6.ruanyifeng.com/#docs/proxy</a></p>
<p><a href="https://juejin.im/post/5e69ee2be51d4527196d6a24" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5e69ee2be51d4527196d6a24</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>ES6 Symbol</title>
    <url>/2020/08/14/es6-symbol/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p>
<p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<a id="more"></a>

<h2 id="特性及应用"><a href="#特性及应用" class="headerlink" title="特性及应用"></a>特性及应用</h2><h3 id="独一无二"><a href="#独一无二" class="headerlink" title="独一无二"></a>独一无二</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure>

<p>但是，Symbol 值可以显式转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure>

<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h4 id="应用-作为对象属性标识符"><a href="#应用-作为对象属性标识符" class="headerlink" title="应用 - 作为对象属性标识符"></a>应用 - 作为对象属性标识符</h4><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<h4 id="应用-定义常量"><a href="#应用-定义常量" class="headerlink" title="应用 - 定义常量"></a>应用 - 定义常量</h4><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure>

<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="keyword">return</span> COLOR_RED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>
<h3 id="无法被遍历"><a href="#无法被遍历" class="headerlink" title="无法被遍历"></a>无法被遍历</h3><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p>
<p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p>
<p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">obj[foo] = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p>
<p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>

<h4 id="应用-定义内部使用的方法"><a href="#应用-定义内部使用的方法" class="headerlink" title="应用 - 定义内部使用的方法"></a>应用 - 定义内部使用的方法</h4><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">    <span class="keyword">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h2 id="创建相同的Symbol"><a href="#创建相同的Symbol" class="headerlink" title="创建相同的Symbol"></a>创建相同的Symbol</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>
<p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo();</span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值。</p>
<p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h2 id="内置Symbol"><a href="#内置Symbol" class="headerlink" title="内置Symbol"></a>内置Symbol</h2><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> Even = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> Even <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.isConcatSpreadable] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
<p>参考资料：</p>
<p><a href="https://es6.ruanyifeng.com/#docs/symbol" rel="external nofollow noopener noreferrer" target="_blank">https://es6.ruanyifeng.com/#docs/symbol</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Chrome与Node事件循环机制</title>
    <url>/2021/02/20/event-loop-between-chrome-and-node/</url>
    <content><![CDATA[<p>用了这么久的JavaScript，才发现自己对JavaScript的事件循环机制一直有些误解。</p>
<p>第一，事件循环机制不是V8实现的，V8引擎只是负责JavaScript代码的编译，内存分配等。</p>
<p>第二，Chrome的事件循环机制是通过Web API实现的，Node则是libuv。</p>
<p>第三，Node11之前，Node的事件循环的原理与Chrome是不同的。</p>
<a id="more"></a>

<p>针对这几个误区，我又重新学习了一遍JavaScript的事件循环。</p>
<p>Javascript是一个单线程、非阻塞、异步、解释性脚本语言。js的并发模型基于事件循环，Event Loop是由js宿主环境，如浏览器实现的。v8是Chrome里的javascript运行环境，在V8的源码中并不存在setTimeout/DOM/HTTP请求等 ，这些异步请求在浏览器中由webAPI处理，它是由C++实现的浏览器创建的线程。</p>
<h2 id="Chrome浏览器与Node11"><a href="#Chrome浏览器与Node11" class="headerlink" title="Chrome浏览器与Node11+"></a>Chrome浏览器与Node11+</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>以下是浏览器中事件循环机制的流程图，只要执行栈中没有代码在执行，微任务会在回调后立即执行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13734601-6a8e67d55c966687.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt></p>
<h3 id="Node11"><a href="#Node11" class="headerlink" title="Node11+"></a>Node11+</h3><p>这部分的内容可以看我的另一篇博客：<a href="https://sunra.top/2020/05/30/nodejs-io-and-event/">https://sunra.top/2020/05/30/nodejs-io-and-event/</a></p>
<h2 id="Node10-（以Node8为例）"><a href="#Node10-（以Node8为例）" class="headerlink" title="Node10-（以Node8为例）"></a>Node10-（以Node8为例）</h2><h3 id="1-Node简介"><a href="#1-Node简介" class="headerlink" title="1.Node简介"></a>1.Node简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683d81674f076eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Node.js的运行机制如下:</p>
<ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>
<h3 id="2-六个阶段"><a href="#2-六个阶段" class="headerlink" title="2.六个阶段"></a>2.六个阶段</h3><p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841bd9860c1ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>从上图中，大致看出node中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>
<ul>
<li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>idle, prepare 阶段：仅node内部使用</li>
<li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li>
<li>check 阶段：执行 setImmediate() 的回调</li>
<li>close callbacks 阶段：执行 socket 的 close 事件回调</li>
</ul>
<p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p>
<p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p>
<h4 id="1-timer"><a href="#1-timer" class="headerlink" title="(1) timer"></a>(1) timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p>
<h4 id="2-poll"><a href="#2-poll" class="headerlink" title="(2) poll"></a>(2) poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p>
<p>1.回到 timer 阶段执行回调</p>
<p>2.执行 I/O 回调</p>
<p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>
</ul>
</li>
</ul>
<p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p>
<h4 id="3-check阶段"><a href="#3-check阶段" class="headerlink" title="(3) check阶段"></a>(3) check阶段</h4><p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"><span class="comment">//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li>
<li>然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li>
</ul>
<h3 id="3-Micro-Task-与-Macro-Task"><a href="#3-Micro-Task-与-Macro-Task" class="headerlink" title="3.Micro-Task 与 Macro-Task"></a>3.Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<ul>
<li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li>
<li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li>
</ul>
<h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4.注意点"></a>4.注意点</h3><h4 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="(1) setTimeout 和 setImmediate"></a>(1) setTimeout 和 setImmediate</h4><p>二者非常相似，区别主要在于调用时机不同。</p>
<ul>
<li>setImmediate 设计在poll阶段完成时执行，即check阶段；</li>
<li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li>
<li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li>
<li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li>
</ul>
<p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<h4 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="(2) process.nextTick"></a>(2) process.nextTick</h4><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-与浏览器比较"><a href="#5-与浏览器比较" class="headerlink" title="5.与浏览器比较"></a>5.与浏览器比较</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>
<p>Node端运行结果分两种情况：</p>
<ul>
<li>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul>
<li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li>
</ul>
</li>
</ul>
<p>参考链接：</p>
<p><a href="https://www.jianshu.com/p/054cb77adadd" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/054cb77adadd</a></p>
<p><a href="https://juejin.cn/post/6844903761949753352" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.cn/post/6844903761949753352</a></p>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" rel="external nofollow noopener noreferrer" target="_blank">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Extjs3 Ext.extend 使用填坑</title>
    <url>/2019/08/17/ext/</url>
    <content><![CDATA[<h2 id="Ext-extend"><a href="#Ext-extend" class="headerlink" title="Ext.extend"></a>Ext.extend</h2><p>在使用Extjs时，我们经常会用到他的自定义组件功能来创建我们需要的组件，但是使用Ext.extend时有一个需要注意的点，那就是如果你的自定义组件有一些固定的items，那么这些items不能够直接丢到配置项中，而是需要在initComponent函数中声明。</p>
<a id="more"></a>

<p>下面是通用的模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent = Ext.extend(Ext.Panel, &#123;</span><br><span class="line">    initComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Ext.apply(<span class="keyword">this</span>, &#123;</span><br><span class="line">            _name: <span class="string">'MyComponent'</span> <span class="comment">// 非必须，调试时用 console.log 等可显示对象名。</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.items = [&#123;</span><br><span class="line">            <span class="comment">// 如有固定的 items，须在此设定</span></span><br><span class="line">        &#125;];</span><br><span class="line">        MyComponent.superclass.initComponent.call(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其实不仅仅是是items，如果想要为子组件添加新的事件监听器也需要在initComponents中声明</p>
<h2 id="Ext-Ajax-request"><a href="#Ext-Ajax-request" class="headerlink" title="Ext.Ajax.request"></a>Ext.Ajax.request</h2><p>在使用 Ext.Ajax 发送POST请求时，可能会遇到跨域的问题，即使是后台设置了允许跨域，比如下面这种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Ext.Ajax.request(&#123;</span><br><span class="line">              method: <span class="string">'POST'</span>,</span><br><span class="line">              url: <span class="string">'http://localhost:3000/'</span>,</span><br><span class="line">              jsonData: school,</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span>(<span class="params">response, opts</span>) </span>&#123;</span><br><span class="line">                Ext.Msg.alert(<span class="string">'Status'</span>, <span class="string">'保存成功'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              failure: <span class="function"><span class="keyword">function</span>(<span class="params">response, opts</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">'server-side failure with status code '</span> + response.status);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<p>但是如果修改数据传输方式为params就不会出现跨域问题，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Ext.Ajax.request(&#123;</span><br><span class="line">              method: <span class="string">'POST'</span>,</span><br><span class="line">              url: <span class="string">'http://localhost:3000/'</span>,</span><br><span class="line">              params: &#123;</span><br><span class="line">                data: <span class="built_in">JSON</span>.stringify(school)</span><br><span class="line">              &#125;,</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span>(<span class="params">response, opts</span>) </span>&#123;</span><br><span class="line">                Ext.Msg.alert(<span class="string">'Status'</span>, <span class="string">'保存成功'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              failure: <span class="function"><span class="keyword">function</span>(<span class="params">response, opts</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">'server-side failure with status code '</span> + response.status);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="TreeLoader"><a href="#TreeLoader" class="headerlink" title="TreeLoader"></a>TreeLoader</h2><p>当我们使用AsyncTreeNode以及TreeLoader时，即使数据TreeLoader将数据完全加载了进来也不会渲染到root节点中去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loader = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">  loader = <span class="keyword">new</span> Ext.tree.TreeLoader(&#123;</span><br><span class="line">    requestMethod: <span class="string">'GET'</span>,</span><br><span class="line">    dataUrl: <span class="string">'http://localhost:3000/'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  root = <span class="keyword">new</span> Ext.tree.AsyncTreeNode(&#123;<span class="attr">text</span>: <span class="string">'school'</span>&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tree = <span class="keyword">new</span> Ext.tree.TreePanel(&#123;</span><br><span class="line">    id: <span class="string">'school'</span>,</span><br><span class="line">    collapsible: <span class="literal">true</span>,</span><br><span class="line">    enableDD: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">500</span>,</span><br><span class="line">    width: <span class="number">1000</span>,</span><br><span class="line">    loader: loader,</span><br><span class="line">    root: root,</span><br><span class="line">    autoScroll: <span class="literal">true</span>,</span><br><span class="line">    split: <span class="literal">true</span>,</span><br><span class="line">    contextMenu: menu,</span><br><span class="line">    listeners: &#123;</span><br><span class="line">      contextmenu: <span class="function"><span class="keyword">function</span>(<span class="params"> node, e </span>) </span>&#123;</span><br><span class="line">        node.select();</span><br><span class="line">        <span class="keyword">let</span> c = node.getOwnerTree().contextMenu;</span><br><span class="line">        c.contextNode = node;</span><br><span class="line">        c.showAt(e.getXY());</span><br><span class="line">      &#125;,</span><br><span class="line">      nodedrop: <span class="function"><span class="keyword">function</span> (<span class="params"> e </span>) </span>&#123;</span><br><span class="line">        Ext.Msg.alert(<span class="string">'Status'</span>, <span class="string">`drag <span class="subst">$&#123;e.dropNode.text&#125;</span> to <span class="subst">$&#123;e.target.text&#125;</span> with <span class="subst">$&#123;e.point&#125;</span>`</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      click: <span class="function"><span class="keyword">function</span> (<span class="params"> node, e </span>) </span>&#123;</span><br><span class="line">        currentNode = node</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// tree.expandAll();</span></span><br><span class="line">  loader.on(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">vm, node, response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>下面是我页面刷新时的请求，可以看到数据已经被完全加载进来了</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566184874/2019-08-19_10_50_16-JabberWindow.DesktopShare.BorderWindow_i3ghuf.png" alt></p>
<p>但是在tree初始化的时候监听的load事件打印出的节点中却只render可第一层节点</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566184874/2019-08-19_10_55_15-Window_fa0dov.png" alt></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>云原生应用程序的15个要点</title>
    <url>/2020/04/05/fifteen-factor-for-cloud-service/</url>
    <content><![CDATA[<p>阅读笔记，<a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/?download=true" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p>
<a id="more"></a>

<h2 id="One-Codebase-One-Application"><a href="#One-Codebase-One-Application" class="headerlink" title="One Codebase, One Application"></a>One Codebase, One Application</h2><p>云原生应用程序必须始终由在版本控制系统中跟踪的单个代码库组成。代码库是共享公共根的源代码存储库或一组存储库。</p>
<p>应用程序的单个代码库用于生成任何数量的不可变发行版<a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch01.html#idm139821584969376" rel="external nofollow noopener noreferrer" target="_blank">1</a>，这些发行版旨在用于不同的环境。遵循这一特定纪律，团队必须分析其应用程序的接缝，并潜在地确定应拆分为微服务的整体。<a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch01.html#idm139821584968992" rel="external nofollow noopener noreferrer" target="_blank">2</a>如果您有多个代码库，则您有一个需要分解的系统，而不是单个应用程序。</p>
<p>当一个代码库用于生成多个应用程序时，可以打破此规则。例如，单个代码库在单个包装器模块中具有多个启动脚本甚至多个执行点。</p>
<p>单个代码库中的多个应用程序通常表明多个团队正在维护一个代码库，这可能由于多种原因而变得难看。</p>
<p>换句话说，<em>一个代码库，一个应用程序</em>并不意味着不允许您在多个应用程序之间共享代码。它只是意味着共享代码是另一个代码库。</p>
<p>这也不意味着所有共享代码都必须是微服务。相反，您应该评估共享代码是否应被视为单独发布的产品。</p>
<h2 id="API-First"><a href="#API-First" class="headerlink" title="API First"></a>API First</h2><p>假设您已经完全接受了本书中讨论的所有其他因素。您正在构建本机云应用程序，将代码签入到存储库后，将自动运行测试，并且可以在几分钟之内在实验室环境中运行候选发布版本。</p>
<p>现在，您组织中的另一个团队开始构建与您的代码进行交互的服务。然后，另一个团队看到了，他们加入了团队并带来了他们的服务。很快，您将有多个团队共同构建具有水平依赖项的服务，这些服务均位于不同的发布节奏上。</p>
<p>如果没有纪律约束会发生集成失败的噩梦。为避免这些集成失败，并正式将您的API识别为开发过程的一流工件，<em>API首先</em>使团队能够与彼此的公共合同进行合作，而不会干扰内部开发过程。</p>
<p>“ <em>移动优先”</em>的概念越来越受关注。它指的是从项目一开始就所做的所有事情都围绕着这样的想法，即所构建的是移动设备要消费的产品。同样，<em>API首先</em>意味着您要构建的是供客户端应用程序和服务使用的API。</p>
<p>通过首先设计您的API，您可以很轻松地与您的利益相关者（您的内部团队，客户或组织中可能要使用您的API的其他团队）进行讨论，直到您将自己编码成无法返回的地步。然后，通过这种协作，您可以构建用户案例，模拟API并生成可用于进一步社交化所构建服务的意图和功能的文档。</p>
<p>所有这些都可以完成，以审查（和测试！）您的方向和计划，而无需在支持给定API的管道上投入过多的资金。</p>
<p>此模式是<em>合同优先</em>开发模式的扩展，在此模式中，开发人员专注于首先构建其应用程序的边缘或<em>接缝</em>。通过CI服务器对集成点进行持续测试，两个团队可以使用自己的服务，并且仍保持合理的保证，即所有组件都可以正常工作。</p>
<p><em>API首先</em>将组织从瀑布，精心设计的系统中解放出来，该系统遵循预先计划的编排模式，并允许产品演化为有机的，自组织的生态系统，可以增长以应对新的和不可预见的需求。</p>
<h2 id="Dependency-Management"><a href="#Dependency-Management" class="headerlink" title="Dependency Management"></a>Dependency Management</h2><p>云是经典企业模型的成熟，因此，我们的应用程序需要<em>成长</em>才能利用云。应用程序不能假定服务器或应用程序容器将拥有所需的一切。相反，应用程序需要随身携带依赖项。</p>
<p>大多数当代编程语言都有一些用于管理应用程序依赖项的工具。<code>Maven</code>和<code>Gradle</code>是两个在Java世界上最流行的工具。无论使用哪种工具，这些实用程序都提供一组通用功能：它们允许开发人员声明依赖关系，并让该工具负责确保满足这些依赖关系。</p>
<p>这些工具中的许多工具还具有隔离依赖项的能力。这是通过分析已声明的依赖项并将这些依赖项捆绑（也称为<em>vendoring</em>）到应用程序构件本身下方或内部的某个子结构中来完成的。</p>
<p>不能正确隔离依赖项会导致无法解决的问题。在一些最常见的依赖关系有关的问题，你可以有一个开发者版本X上工作的的工作站上一些依赖库，但版本<em>X + 1</em>该库已安装在生产的中心位置。这可能导致从运行时故障一直到阴险且难以诊断的细微故障的所有原因。如果不加以处理，这些类型的故障可能会导致整个服务器瘫痪，或者由于无法诊断的数据损坏而使公司损失数百万美元。</p>
<p>正确地管理应用程序的依赖关系是关于可重复部署的概念。不应认为部署应用程序的运行时不是自动化的。在理想的情况下，应用程序的容器被捆绑（或被引导，如某些框架所称）在应用程序的发布构件中，或者更好的是，应用程序根本没有容器。</p>
<h2 id="Design-Build-Release-Run"><a href="#Design-Build-Release-Run" class="headerlink" title="Design, Build, Release, Run"></a>Design, Build, Release, Run</h2><p><em>构建，发布，运行</em>要求严格区分开发的构建和运行阶段。这是极好的建议，如果不遵守该准则，可能会给您带来将来的困难。除了三要素的<em>构建，发布，运行</em>三重奏外，离散的<em>设计</em>步骤也至关重要。</p>
<p>从设计到代码再到运行的过程是一个反复的过程，可以在您的团队可以处理的很小或更长的时间内发生。如果团队拥有成熟的CI / CD流程，则从设计到投入<em>生产</em>可能需要几分钟的时间。</p>
<p>在构建过程中将使用单个代码库来生成已编译的工件。然后，该工件与应用程序<em>外部的</em>配置信息合并，以生成<em>不可变的</em>发行版。然后将不可变版本发布到云环境（开发，QA，生产等）并运行。本章的重点是，以下每个部署阶段都是隔离的，并且分别发生。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>在瀑布式应用程序开发的世界中，在编写一行代码之前，我们花费大量的时间来设计应用程序。这种类型的软件开发生命周期不能很好地适应需要经常发布的现代应用程序的需求。</p>
<p>但是，这并不意味着我们根本不设计。取而代之的是，这意味着我们设计了要发布的小功能，并且我们有一个高级设计用于通知我们所做的每件事。但是我们也知道设计会发生变化，少量的设计是<em>每个迭代的</em>一部分，而不是完全预先完成。</p>
<p>应用程序开发人员最能理解应用程序的依赖关系，并且在设计阶段就进行了声明，以声明依赖关系以及将这些依赖关系出售或捆绑到应用程序的方式。换句话说，开发人员决定应用程序将使用哪些库，以及最终如何将这些库捆绑成一个不可变的发行版。</p>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>在构建阶段，将代码存储库转换为版本化的二进制工件。在此阶段，将在设计阶段声明的依赖项提取并捆绑到构建工件中（通常简称为“构建”）。在Java世界中，构建可能是WAR <a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch04.html#idm139821584893536" rel="external nofollow noopener noreferrer" target="_blank">1</a>或JAR文件，或者可能是ZIP文件或其他语言和框架的二进制可执行文件。</p>
<p>理想情况下，构建是由Continuous Integration服务器创建的，并且构建和部署之间存在1：许多关系。一个单一的构建应该能够发布或部署到任意数量的环境中，并且每个未修改的构建都应该能够按预期工作。该工件的不变性以及对其他因素的遵守（尤其是<em>环境平价</em>）使您有信心，如果您的应用程序可以在质量检查中运行，那么它将在生产环境中运行。</p>
<p><strong>如果您发现自己对“在我的机器上工作”的问题进行故障排除，则很明显地表明，此过程的四个阶段可能没有应有的分开。</strong></p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>在云原生世界中，发布通常是通过推送到您的云环境来完成的。构建阶段的输出与特定于环境和特定于应用程序的配置信息结合在一起，以产生另一个不变的工件，即<em>发行版</em>。</p>
<p>版本必须是唯一的，并且理想情况下，每个版本都应使用某种唯一的ID（例如时间戳或自动递增编号）进行标记。</p>
<p>假设您的CI系统刚刚构建了您的应用程序并标记了该工件<code>build-1234</code>。然后，CI系统可以将该应用程序发布到开发，登台和生产环境中。该方案取决于您，但是每个发行版都应该是唯一的，因为每个发行版都将原始版本与<em>特定</em>于<em>环境的</em>配置设置结合在一起。</p>
<p>如果出现问题，您希望能够审核已发布到给定环境的内容，并在必要时回滚到先前的版本。这是使发布保持不变和唯一标识的另一个关键原因。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行阶段通常也由云提供商完成（尽管开发人员需要能够在本地运行应用程序）。提供商之间的详细信息有所不同，但是通常的模式是将您的应用程序放置在某种容器（Docker，Garden，Warden等）中，然后启动一个过程来启动您的应用程序。</p>
<p>值得注意的是，要确保开发人员可以在自己的工作站上本地运行应用程序，同时仍然允许其通过CD管道将其部署到多个云中，通常是很难解决的问题。但是，这值得解决，因为开发人员在处理原生云应用程序时需要不受阻碍。</p>
<p>当应用程序运行时，云运行时将负责保持其运行状态，监视其运行状况并聚合其日志，以及大量其他管理任务，例如动态扩展和容错。</p>
<h2 id="Configuration-Credentials-and-Code"><a href="#Configuration-Credentials-and-Code" class="headerlink" title="Configuration, Credentials, and Code"></a>Configuration, Credentials, and Code</h2><h3 id="构型化学"><a href="#构型化学" class="headerlink" title="构型化学"></a>构型化学</h3><p>将配置，凭证和代码视为<em>易挥发的物质</em>，这些<em>物质</em>在结合时会爆炸。</p>
<p>这听起来可能有点苛刻，但是如果不遵循此规则，可能会导致您无比沮丧，这只会使您的应用程序更接近生产环境。</p>
<p>为了使配置与代码和凭据分开，我们需要对配置进行非常清晰的定义。配置是指可以随部署而变化的任何值（例如，开发人员工作站，QA和生产）。这可能包括：</p>
<ul>
<li>URL和其他有关后备服务的信息，例如Web服务和SMTP服务器</li>
<li>查找和连接数据库所需的信息</li>
<li>第三方服务（例如Amazon AWS）或API（例如Google Maps，Twitter和Facebook）的凭据</li>
<li>通常可能捆绑在属性文件或配置XML或YML中的信息</li>
</ul>
<p>配置并<em>没有</em>包括它是应用程序本身的一部分的内部信息。同样，如果该值在所有部署中都保持不变（这是您不可变的构建构件的一部分），则它不是配置。</p>
<p>凭证是极其敏感的信息，在代码库中绝对没有事务。通常，开发人员会从已编译的源代码中提取凭证，并将其放入属性文件或XML配置中，但这实际上并没有解决问题。包括XML和属性文件在内的捆绑资源仍然是代码库的一部分。这意味着捆绑在您的应用程序附带的资源文件中的凭据仍然违反此规则。</p>
<h3 id="像开源一样对待您的应用"><a href="#像开源一样对待您的应用" class="headerlink" title="像开源一样对待您的应用"></a>像开源一样对待您的应用</h3><p>查看您是否已适当地外部化了凭据和配置，以想象将应用程序源代码推送到GitHub的后果。</p>
<p>如果公众可以访问您的代码，您是否公开了有关应用程序所依赖的资源或服务的敏感信息？人们是否可以看到内部URL，支持服务的凭证或其他与不在目标环境中工作的人敏感或无关的信息？</p>
<p>如果您可以在不暴露敏感信息或特定于环境的信息的情况下开源代码库，那么您可能已经很好地隔离了代码，配置和凭据。</p>
<p>显而易见，我们不想公开凭据，但是对外部配置的需求通常并不那么明显。外部配置支持我们通过CD管道将不可变版本<em>自动</em>部署到多个环境的能力，并有助于我们保持开发/生产环境的均等性。</p>
<h3 id="外化配置"><a href="#外化配置" class="headerlink" title="外化配置"></a>外化配置</h3><p>说您的应用程序的配置应该<em>外部化</em>是一回事，但是实际要做的却是另一回事。如果使用的是Java应用程序，则可能会将发布工件与属性文件捆绑在一起。其他类型的应用程序和语言倾向于使用YAML文件，而.NET应用程序传统上是从基于XML的<em>web.config</em>和<em>machine.config</em>文件中获取配置的。</p>
<p>您应该将<em>所有</em>这些都视为云的<em>反模式</em>。所有这些情况都使您无法在环境之间更改配置，同时仍保持不变的发行工件。</p>
<p>外部化配置的暴力方法是摆脱所有配置文件，然后遍历代码库并对其进行修改，以期望所有这些值都由环境变量提供。环境变量被认为是外部化配置的最佳实践，尤其是在Cloud Foundry或Heroku等云平台上。</p>
<p>根据您的云提供商，您可能可以使用其工具来管理<em>后备服务</em>或<em>绑定服务</em>，以安全的方式向应用程序公开包含服务凭证和URL的结构化环境变量。</p>
<p>强烈建议您将配置外部化的另一个方法是实际使用旨在公开配置的服务器产品。这样的开源服务器之一就是Spring Cloud Configuration Server，但是有无数其他可用的产品。购买配置服务器产品时应注意的一件事是支持版本控制。如果要对配置进行外部化，则应该能够保护数据更改并获得由谁进行更改以及何时进行更改的历史记录。正是这一要求使得位于版本控制存储库（如<em>git）</em>顶部的配置服务器具有吸引力。</p>
<h2 id="Logs"><a href="#Logs" class="headerlink" title="Logs"></a>Logs</h2><p>日志应视为<em>事件流</em>，也就是说，日志是按时间顺序从应用程序发出的事件序列。以云原生方式处理日志的关键在于，真正的云原生应用程序永远不会将自己的输出流路由或存储。</p>
<p>云应用程序不能对其运行所在的文件系统做出任何假设，除非它是短暂的。原生云应用程序将其所有日志条目写入<code>stdout</code>和<code>stderr</code>。这可能会吓到很多人，担心这意味着失去控制。</p>
<p><strong>您应该将日志的聚合，处理和存储视为一项非功能性要求，该要求不是由您的应用程序满足，而是由您的云提供商或与平台合作运行的其他工具套件满足</strong>。</p>
<p>当您的应用程序与日志存储，处理和分析的知识脱钩时，您的代码将变得更加简单，并且您可以依靠行业标准的工具和堆栈来处理日志。此外，如果您需要更改存储和处理日志的方式，则无需修改应用程序即可<em>。</em></p>
<p>您的应用程序不应控制其日志的最终命运的众多原因之一是由于可伸缩性。当您在固定数量的服务器上具有固定数量的实例时，将日志存储在磁盘上似乎很有意义。但是，当您的应用程序可以从1个正在运行的实例动态变为100个，并且您不知道这些实例<em>在哪里</em>运行时，您需要您的云提供商来代表您汇总这些日志。</p>
<p>简化应用程序的日志发出过程可以使您减少代码库，并更加关注应用程序的核心业务价值。</p>
<h2 id="Disposability"><a href="#Disposability" class="headerlink" title="Disposability"></a>Disposability</h2><p>在云实例上，应用程序的生命与支持它的基础架构一样短暂。云原生应用程序的流程是一次性的，这意味着它们可以快速启动或停止。<strong>如果应用程序无法快速启动和正常关闭，则无法快速扩展，部署，释放或恢复</strong>。我们需要构建不仅意识到这一点的应用程序，而且还必须<em>拥抱</em>它以充分利用该平台。</p>
<p><strong>如果您正在启动一个应用程序，并且要花几分钟才能进入稳定状态，那么在当今的高流量世界中，这可能意味着在启动应用程序时拒绝了成百上千个请求</strong>。更重要的是，视应用程序部署所在的平台而定，如此缓慢的启动时间实际上可能会触发警报或警告，因为应用程序无法通过其运行状况检查。极慢的启动时间甚至可能阻止您的应用完全在云中启动。</p>
<p>如果您的应用程序正在承受越来越大的负载，并且您需要快速启动更多实例来处理该负载，则启动过程中的任何延迟都可能会阻碍其处理该负载的能力。如果该应用程序无法快速正常关闭，也可能会阻止失败后再次将其重新启动的功能。无法足够快地关闭系统还可能带来无法处理资源的风险，这可能会破坏数据。</p>
<p>编写许多应用程序时，它们会在启动过程中执行许多长时间运行的活动，例如获取数据以填充缓存或准备其他运行时依赖项。为了真正地接受云原生架构，需要单独处理这种活动。例如，<strong>您可以将缓存外部化为<em>支持服务，</em>以便您的应用程序可以快速执行上下操作，而无需执行前载操作</strong>。</p>
<h2 id="Backing-Services（支持服务）"><a href="#Backing-Services（支持服务）" class="headerlink" title="Backing Services（支持服务）"></a>Backing Services（支持服务）</h2><p>一个<em>支撑服务</em>是您的应用程序依赖于它的功能性的任何服务。这是一个相当广泛的定义，其广泛的范围是有意的。一些最常见的支持服务类型包括数据存储，消息传递系统，缓存系统以及许多其他类型的服务，包括执行业务功能或安全性的服务。</p>
<p>在构建旨在在必须将文件系统视为短暂的云环境中运行的应用程序时，您还需要将文件存储或磁盘视为后备服务。您不应该像使用常规企业应用程序那样读取或写入磁盘上的文件。相反，文件存储应该是作为资源绑定到您的应用程序的支持服务。</p>
<p>一个应用程序，一组支持服务以及这些服务的资源绑定（连接线）。绑定资源实际上只是将您的应用程序连接到支持服务的一种方式。数据库的资源绑定可能包括用户名，密码和允许您的应用程序使用该资源的URL。</p>
<p>我们应该具有外部化的配置（与凭据和代码分开），并且我们的发行产品必须是不可变的。将这些其他规则应用于应用程序使用后台服务的方式，我们最终得到一些用于资源绑定的规则：</p>
<ul>
<li>应用程序应<em>声明</em>其对给定支持服务的需求，但应允许云环境执行实际的资源绑定。</li>
<li>应用程序与其支持服务的绑定应通过外部配置完成。</li>
<li>应该可以随意从应用程序附加和分离支持服务，<em>而无需重新部署应用程序</em>。</li>
</ul>
<p>例如，假设您有一个需要与Oracle数据库进行通信的应用程序。你编写你的应用程序，使得其特定的Oracle数据库的依赖<em>声明</em>（这对声明的方式通常是针对某一种语言或工具集）<em>。</em>应用程序的源代码假定资源绑定的配置发生在应用程序外部。</p>
<p>这意味着您的应用程序中<em>绝不</em>会存在将应用程序紧密耦合到特定支持服务的代码行。同样，您可能还具有用于发送电子邮件的支持服务，因此您知道将通过SMTP与之通信。但是，邮件服务器的确切实现对您的应用程序没有影响，您的应用程序也不应依赖于存在于特定位置或具有特定凭据的SMTP服务器。</p>
<h2 id="Environment-Parity"><a href="#Environment-Parity" class="headerlink" title="Environment Parity"></a>Environment Parity</h2><p>尽管一些组织已经做出了更大的发展，但我们中的许多人可能都在这样的环境中工作：共享开发环境与QA相比具有不同的伸缩性和可靠性配置文件，而QA与生产环境也有所不同。dev和QA中使用的数据库驱动程序与生产版本不同。安全规则，防火墙和其他环境配置设置也有所不同。有些人能够部署到某些环境，而其他人则没有。最后，最糟糕的是，人们害怕部署，他们几乎没有信心，如果该产品在一种环境中工作，它将在另一种环境中工作。</p>
<p>在讨论<em>设计，构建，发布，运行</em>周期时，我提出了“在我的机器上运行”方案是云原生反模式的概念。对于我们在损失数小时或数天的消防和故障排除之前就已经听到的其他短语，也是如此：“它在质量保证中起作用”和“在产品中起作用”。</p>
<p>对<em>环境均等</em>性应用严格和纪律的目的是使您的团队和整个组织有信心该应用程序<em>可以在任何地方使用</em>。<a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch09.html#idm139821584754432" rel="external nofollow noopener noreferrer" target="_blank">1个</a></p>
<p>虽然在环境之间造成差距的机会几乎是无限的，但最常见的罪魁祸首通常是：</p>
<ul>
<li>时间</li>
<li>人</li>
<li>资源</li>
</ul>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>在许多组织中，从开发人员检入代码到生产完成为止，可能要花费数周或数月的时间。在这样的组织中，您经常会听到诸如“第三季度版本”或“ 20xx年12月版本”之类的短语。这样的短语对于任何关注的人都是一个警告信号。</p>
<p>当出现这样的时间间隔时，人们通常会忘记发布中进行了哪些更改（即使有足够的发布说明），更重要的是，开发人员已经忘记了代码的外观。</p>
<p>采用现代方法，组织应努力减少从签入到生产的时间间隔，从数周或数月缩短到<em>数分钟或数小时</em>。正确的CD流水线的结尾应该是在不同环境中执行自动测试，直到将更改自动推向<em>生产</em>环境为止。借助支持零停机时间部署的云，这种模式可以成为常态。</p>
<h3 id="人"><a href="#人" class="headerlink" title="人"></a>人</h3><p><em>人类</em>绝对不应该部署应用程序，至少不应该将其部署到除自己的工作站或实验室以外的任何环境中。如果存在正确的构建管道，则将根据CI工具和目标云实例内的安全限制，将应用程序自动部署到所有适用的环境，并可以将其手动部署到其他环境。</p>
<p>实际上，即使您的目标是公共云提供商，也仍然可以使用CloudBees或Wercker等云托管CD工具来自动化您的测试和部署。</p>
<p>尽管总是有例外，但我认为，如果您无法通过按一下按钮或自动响应某些事件来进行部署，那么您做错了。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>我们使用和提供<em>支持服务</em>的方式通常是一种这样的折衷方案。我们的应用程序可能需要一个数据库，并且我们知道在生产中我们会将其连接到Oracle或Postgres服务器，但是将其设置为可在本地用于开发非常麻烦，因此我们将妥协和使用内存数据库是<em>的那种</em>像目标数据库。</p>
<p>每次我们做出这些折衷之一时，我们就会扩大开发和生产环境之间的差距。差距越大，我们对应用程序工作方式的可预测性就越差。随着可预测性的下降，可靠性也会下降。如果可靠性下降，我们将失去从代码检入到生产部署的<em>连续</em>流程。它使我们所做的一切都变得脆弱。最糟糕的是，我们通常不知道增加dev / prod差距的后果，直到为时已晚。</p>
<p>在构建本地云应用程序时评估开发生命周期中的每个步骤时，都需要标记和质疑增加部署环境之间功能差距的每项决定，并且您需要抵制通过允许您的环境来减轻此问题的冲动即使当时差异似乎微不足道，也可以保持差异。</p>
<h2 id="Administrative-Processes"><a href="#Administrative-Processes" class="headerlink" title="Administrative Processes"></a>Administrative Processes</h2><p>在某些情况下，使用管理流程实际上不是一个<em>好</em>主意，您应该始终在问自己：管理流程是否是您想要的，或者不同的设计或体系结构是否更适合您的需求。可能应重构为其他内容的管理过程的示例包括：</p>
<ul>
<li>数据库迁移</li>
<li>交互式编程控制台（REPL）</li>
<li>运行定时脚本，例如每晚批处理作业或每小时导入</li>
<li>运行一次仅执行一次自定义代码的一次性工作</li>
</ul>
<p>首先，让我们看一下计时器的问题（通常由Autosys或Cron等应用程序管理）。一种想法可能是只内部化计时器，让您的应用程序每<em>n</em>小时唤醒一次以执行其批处理操作。从表面上看，这似乎是一个很好的解决方案，但是当一个可用性区域中运行有20个应用程序实例，而另一区域中运行了另外15个实例时，会发生什么呢？如果他们都在计时器上执行相同的批处理操作，那么此时您基本上是在引起混乱，并且损坏或重复的数据将只是此模式引起的许多可怕事件之一。</p>
<p>交互式外壳由于多种原因也存在问题，但是最大的原因是，即使有可能到达该外壳，您也只能与单个实例的临时内存进行交互。如果应用程序是作为<em>无状态进程</em>正确构建的，那么我认为对于进程内省公开REPL几乎没有任何价值。<a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch10.html#idm139821584721360" rel="external nofollow noopener noreferrer" target="_blank">2</a></p>
<p>接下来，让我们看一下触发定时或批处理管理过程的机制。这通常是由于某些外部计时器刺激（例如<code>cron</code>或）执行shell脚本而发生的<code>Autosys</code>。在云中，您不能指望能够调用这些命令，因此您需要找到其他方法来触发应用程序中的临时活动。</p>
<p>有多种解决方案，但是我发现最吸引人的一种解决方案是，公开一个RESTful终结点，可用于调用即席功能，特别是在将应用程序的其余部分迁移为云原生时，这一点尤其明显。</p>
<p>这仍然允许随意调用定时功能，但是将此操作的刺激因素移到了应用程序<em>之外</em>。此外，此方法还解决了动态缩放实例上内部计时器<em>最多</em>只能执行<em>一次的</em>问题。批处理操作由一个应用程序实例处理一次，然后可以与其他<em>支持服务</em>进行交互以完成任务。保护批处理端点也应该相当简单，以便只能由授权人员操作。更为有用的是，您的批处理操作现在可以灵活地扩展并利用所有其他云优势。</p>
<p>如果仍然觉得需要利用管理流程，则应确保以与云提供商所提供的功能一致的方式使用管理流程。换句话说，不要使用您喜欢的编程语言来产生新的流程来运行您的工作；使用旨在以云原生方式运行一次性任务的工具。</p>
<h2 id="Port-Binding"><a href="#Port-Binding" class="headerlink" title="Port Binding"></a>Port Binding</h2><h3 id="避开容器确定的端口"><a href="#避开容器确定的端口" class="headerlink" title="避开容器确定的端口"></a>避开容器确定的端口</h3><p>Web应用程序（尤其是已经在企业内部运行的Web应用程序）通常在某种服务器容器中执行。Java世界充满了Tomcat，JBoss，Liberty和WebSphere等容器。其他Web应用程序可能在其他容器中运行，例如Microsoft Internet信息服务器（IIS）。</p>
<p>在非云环境中，Web应用程序已部署到这些容器中，然后容器负责在应用程序启动时为其分配端口。</p>
<p>在管理自己的Web服务器的企业中，一种极为常见的模式是将多个应用程序托管在同一容器中，通过端口号（或URL层次结构）分隔应用程序，然后使用DNS在该服务器周围提供用户友好的外观。例如，你可能有一个叫（虚拟或物理）主机<code>appserver</code>，以及已分配的端口8080通过8090，而不是让用户记住端口号，使用DNS主机名关联像一些应用程序的<code>app1</code>使用<code>appserver:8080</code>，<code>app2</code>用<code>appserver:8081</code>，等等。</p>
<h3 id="避免微管理端口分配"><a href="#避免微管理端口分配" class="headerlink" title="避免微管理端口分配"></a>避免微管理端口分配</h3><p>这里采用平台即服务，使开发人员和开发人员都不必再执行这种微管理。您的云提供商应该为您管理端口分配，因为它还可能管理路由，扩展，高可用性和容错能力，所有这些都需要云提供商管理网络的某些方面，包括将主机名路由到端口和将外部端口号映射到容器内部端口。</p>
<p>最初的12个用于<em>端口绑定的*因素之所以使用“ *导出</em> ”一词，是因为假定云本机应用程序是<em>独立的</em>，并且从未注入到任何类型的外部应用程序服务器或容器中。</p>
<p>实用性和现有企业应用程序的性质可能使以这种方式构建应用程序变得困难或不可能。结果，限制性的准则稍微少了一点，即<em>应用程序和应用程序服务器之间必须始终保持1：1的关联</em>。换句话说，您的云提供商可能支持Web应用程序容器，但极不可能支持在同一容器中托管多个应用程序，因为这几乎不可能实现持久性，可伸缩性和弹性。</p>
<p>对于现代应用程序，端口绑定对开发人员的影响非常简单：您的应用程序可以<code>http://localhost:12001</code>在开发人员的工作站上运行，而在质量检查中，它可以运行在<code>http://192.168.1.10:2000</code>，在生产环境中运行<code>http://app.company.com</code>。考虑到导出端口绑定而开发的应用程序支持此特定于环境的端口绑定，而无需更改任何代码。</p>
<h3 id="应用程序是支持服务"><a href="#应用程序是支持服务" class="headerlink" title="应用程序是支持服务"></a>应用程序是支持服务</h3><p>最后，为允许外部化的运行时端口绑定而开发的应用程序可以充当另一个应用程序的支持服务。这种灵活性以及在云上运行的所有其他好处非常强大。</p>
<h2 id="无状态过程"><a href="#无状态过程" class="headerlink" title="无状态过程"></a>无状态过程</h2><h3 id="无状态的实用定义"><a href="#无状态的实用定义" class="headerlink" title="无状态的实用定义"></a>无状态的实用定义</h3><p>我经常提出的一个问题是由于对无状态概念的困惑。人们想知道如何建立一个无状态的流程。毕竟，每个应用程序都需要<em>某种</em>状态，对吗？即使是最简单的应用程序，也会留下一些数据浮动，那么您如何才能拥有一个真正的无状态进程？</p>
<p>无状态应用程序在处理请求之前不会对内存的内容做任何假设，在处理该请求之后也不会对内存的内容做任何假设。在处理请求或处理事务的过程中，应用程序可以创建和使用瞬态，但是到客户端收到响应时，数据应该全部消失。</p>
<p>简单地说，<em>所有持久状态必须在应用程序的外部，由*</em>后备服务提供***。</p>
<p>例如，公开用于用户管理的功能的微服务必须是无状态的，因此所有用户的列表都在支持服务（例如Oracle或MongoDB数据库）中维护。由于明显的原因，数据库无状态是没有意义的。</p>
<h3 id="无共享模式"><a href="#无共享模式" class="headerlink" title="无共享模式"></a>无共享模式</h3><p>进程通常通过共享公共资源相互通信。即使不考虑迁移到云计算，采用无<em>共享</em>模式也会有很多好处。</p>
<p>首先，过程之间共享的任何东西都是使所有这些过程更加脆弱的责任。在许多高可用性模式中，流程将通过多种技术共享数据，以选择集群领导者，确定流程是主要流程还是备份流程，等等。</p>
<p>在云中运行时，需要避免所有这些选项。您的流程可能会在没有任何警告的情况下立即消失，<em>这是一件好事</em>。过程来来去去，在水平和垂直方向上缩放，并且高度一次性。这意味着进程之间共享的任何内容也可能消失，从而可能导致级联故障。</p>
<p>不用说，但是<em>文件系统不是后备服务</em>。这意味着您不能将文件视为应用程序共享数据的一种方式。云中的磁盘是临时磁盘，在某些情况下甚至是只读磁盘。</p>
<p>如果进程需要共享数据，例如形成Web场的一组进程的会话状态，则应将该会话状态外部化，并通过真正的支持服务使其可用。</p>
<h3 id="资料快取"><a href="#资料快取" class="headerlink" title="资料快取"></a>资料快取</h3><p>特别是在基于容器的长期运行的Web应用程序中，一种常见的模式是在流程启动期间缓存常用数据。本书已经提到，进程需要快速启动和停止，而花很长时间填充内存中的高速缓存违反了这一原则。</p>
<p>更糟糕的是，存储您的应用程序认为始终可用的内存中缓存可能会使您的应用程序肿，从而使您的每个实例（应该可以弹性伸缩）占用的内存远远超过了所需的内存。</p>
<p>有数十种第三方缓存产品，包括Gemfire和Redis，它们都旨在充当应用程序的后备服务缓存。它们可用于会话状态，但也可用于缓存启动过程中可能需要的数据，并避免进程之间紧密耦合的数据共享。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><em>并发性</em>，建议我们<em>使用流程模型扩展</em>本地云应用程序。有时，如果应用程序达到其容量极限，解决方案就是增加其大小。如果应用程序每分钟只能处理一定数量的请求，那么首选解决方案是简单地使应用程序<em>更大</em>。</p>
<p>在单个整体应用程序中添加CPU，RAM和其他资源（虚拟或物理）称为<em>垂直扩展</em>，这种类型的行为在当今的文明社会中通常不受欢迎。</p>
<p>一个更现代的方法，一个理想的那种弹性可扩展性的云支持，是扩大<em>了</em>，或者<em>水平</em>。您可以创建多个进程，而不是将一个大进程变得更大，然后在这些进程之间分配应用程序的负载。</p>
<p>大多数云提供商已经完善了此功能，甚至可以配置规则，这些规则将根据系统中可用的负载或其他运行时遥测来动态扩展应用程序实例的数量。</p>
<p>如果您要构建一次性的，无状态的，无共享的流程，那么您将可以充分利用水平扩展并运行应用程序的多个并发实例</p>
<h2 id="遥测"><a href="#遥测" class="headerlink" title="遥测"></a>遥测</h2><p>在监视应用程序时，通常有几种不同类别的数据：</p>
<ul>
<li>应用程序性能监控（APM）</li>
<li>特定领域遥测</li>
<li>运行状况和系统日志</li>
</ul>
<p>第一个是APM，由一系列事件组成，云外部的工具可以使用这些事件来监视应用程序的运行状况。这是您要负责的事情，因为性能的定义和水印特定于您的应用程序和标准。用于提供APM仪表板的数据通常是相当通用的，并且可以来自跨多个业务线的多个应用程序。</p>
<p>第二，特定领域的遥测也由您决定。这是指对您的业务有意义的事件和数据流，可用于自己的分析和报告。这类事件流通常被馈送到“大数据”系统中，以进行仓储，分析和预测。</p>
<p>APM和特定领域遥测之间的区别可能不会立即显现。可以这样考虑：APM可以为您提供应用程序每秒处理的HTTP请求的平均数量，而特定领域的遥测可以告诉您最近20分钟内卖给iPad使用者的小部件数量。</p>
<p>最后，运行状况和系统日志应由您的云提供商提供。它们组成了一系列事件，例如应用程序启动，关闭，扩展，Web请求跟踪以及定期运行状况检查的结果。</p>
<p>云计算让很多简单的事情，但监测和遥测仍然是困难的，甚至可能<em>更加</em>困难比传统的企业应用程序的监控。当您盯着包含常规运行状况检查，请求审核，业务级别事件以及跟踪数据和性能指标的流中的流水线时，这是令人难以置信的数据量。</p>
<p>在计划监视策略时，您需要考虑要汇总的信息量，输入的速度以及要存储的信息量。如果您的应用程序从1个实例动态扩展到100个实例，这也可能导致日志流量增加一百倍。</p>
<p>审计和监视云应用程序通常被忽略，但可能是为生产部署进行计划和正确执行的一些最重要的事情。如果您不会盲目地将卫星发射到轨道上而无法对其进行监视，那么您就不应对云应用程序执行同样的操作。</p>
<h2 id="身份验证和授权"><a href="#身份验证和授权" class="headerlink" title="身份验证和授权"></a>身份验证和授权</h2><p>安全性是任何应用程序和云环境的重要组成部分。<em>安全绝不是事后的想法</em>。</p>
<p>很多时候，我们非常关注于实现应用程序的功能需求，以至于忽略了交付任何应用程序的最重要方面之一，无论该应用程序是面向企业，移动设备还是面向应用程序。云。</p>
<p>云原生应用程序是<em>安全的</em>应用程序。您的代码（无论是编译的还是原始的）都跨多个数据中心传输，在多个容器中执行，并被无数的客户端（某些合法，最有害的客户端）访问。</p>
<p>即使在应用程序中实现安全性的唯一原因是，您可以对哪个用户进行了哪些数据更改进行审核跟踪，仅此一项就足以证明为保护应用程序端点安全所需的时间和精力相对较少。</p>
<p>在理想情况下，所有云原生应用程序都将使用RBAC（基于角色的访问控制）保护其所有端点。每个对应用程序资源的请求都应该知道<em>谁</em>在发出请求，以及该使用者所属的角色。这些角色指示主叫客户端是否具有足够的权限来允许应用程序满足请求。</p>
<p>借助OAuth2，OpenID Connect，各种SSO服务器和标准之类的工具，以及几乎无限提供的特定于语言的身份验证和授权库，从一开始就应将安全性纳入应用程序的开发中，而不应一并添加应用程序在生产中运行后的螺栓固定项目。</p>
<h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><h3 id="什么是云原生？"><a href="#什么是云原生？" class="headerlink" title="什么是云原生？"></a>什么是云原生？</h3><p>诸如“ SOA”，“云原生”和“微服务”之类的流行语和短语都开始出现，因为我们需要一种更快，更有效的方式来传达我们对某个主题的想法。这对于促进有关复杂主题的有意义的对话至关重要，我们最终建立了<em>共享的上下文</em>或<em>通用的语言</em>。</p>
<p>这些流行语的问题在于它们依赖多方之间的共同或共同理解。类似的经典游戏<a href="https://en.wikipedia.org/wiki/Chinese_whispers" rel="external nofollow noopener noreferrer" target="_blank">电话</a><a href="https://learning.oreilly.com/library/view/beyond-the-twelve-factor/9781492042631/ch16.html#idm139821584628208" rel="external nofollow noopener noreferrer" target="_blank">1</a>上了空前的规模，这个所谓的共享迅速了解恶化到相互混淆。</p>
<p>我们通过SOA（面向服务的体系结构）看到了这一点，并通过云原生的概念再次看到了这一点。似乎每次共享此概念时，含义都会改变，直到我们对云原生的看法和IT专业人员一样多。</p>
<p>要了解“云原生”，我们必须首先了解“云”。许多人认为“云”是公开不受限制地公开访问互联网的代名词。尽管有一些这样的云产品，但还远远没有一个完整的定义。</p>
<p>在本书的上下文中，云指的是<em>平台即服务</em>。PaaS提供程序公开了一个平台，该平台向应用程序开发人员隐藏基础结构详细信息，该平台位于基础结构即服务（IaaS）之上。PaaS提供程序的示例包括Google App Engine，Redhat Open Shift，Pivotal Cloud Foundry，Heroku，AppHarbor和Amazon AWS。</p>
<p>关键要点是，云不一定是公共的同义词，企业正在自己的IaaS或第三方IaaS提供商（例如VMware或Citrix）的数据中心中建立自己的私有云。</p>
<p>对“ cloud native”一词中的“ native”一词表示怀疑。<strong>这造成了一种错误的印象，即只有在云内部原生开发的全新的绿色应用程序才可以被视为云原生。这是完全不正确的</strong>。</p>
<blockquote>
<p><em>云原生应用程序是一种已设计和实现为在“平台即服务”安装上运行并包含水平弹性缩放的应用程序。</em></p>
</blockquote>
<h3 id="为什么要使用Cloud-Native？"><a href="#为什么要使用Cloud-Native？" class="headerlink" title="为什么要使用Cloud Native？"></a>为什么要使用Cloud Native？</h3><p>不久以前，将应用程序部署在物理服务器上就被认为是构建应用程序的规范—从空调房中的大型塔楼到实际数据中心中安装的超薄<em>1U</em>设备，<em>一应俱全</em>。</p>
<p>裸机部署充满了问题和风险：我们无法动态扩展应用程序，部署过程很困难，硬件的更改可能会导致应用程序故障，而硬件故障通常会导致大量数据丢失和大量停机。</p>
<p>这引发了虚拟化革命。每个人都同意不再使用裸机，因此<em>管理程序</em>诞生了。业界决定在硬件之上放置一个抽象层，以便我们可以简化部署，横向扩展应用程序，并希望避免大量的停机时间和对硬件故障的敏感性。</p>
<p>在当今始终连接在一起的智能设备甚至是更智能的软件世界中，您必须漫长而艰难地寻找一家没有某种软件开发流程作为其基石的公司。即使是传统的制造行业，即公司制造坚硬的<em>物理产品</em>，如果没有软件，制造也不会发生。没有软件，就无法组织人们高效，大规模地构建事物，没有软件，您当然无法参与全球市场。</p>
<p>无论您身处哪个行业，如果没有迅速交付<em>不会失败的</em>软件的能力，就无法在当今的市场中竞争。它需要能够动态扩展以处理以前闻所未闻的数据量。如果您无法处理<em>大数据</em>，那么您的竞争对手就会。如果您无法生产能够处理大量负载，保持响应能力并与市场一样快的变化的软件，那么您的竞争对手将找到一种方法来做到这一点。</p>
<p>这将我们带到了<em>云原生</em>的本质。过去，公司可以通过在DevOps任务上花费过多的时间和资源，在构建和维护脆弱的基础架构上，以及担心仅每个蓝月亮才发生一次的生产部署带来的后果而摆脱分散注意力的日子。</p>
<p>这是云计算的时代，我们需要以一种包含这种方式的方式来构建应用程序。我们需要构建应用程序，以便我们可以将大部分时间用于刺猬（一件大事）上，并让某人或其他人来照顾狐狸的许多小事情。超快速上市时间已不再是一个好时机；有必要避免被我们的竞争者甩在后面。我们希望能够将资源投入我们的业务领域，并让其他专家处理他们比我们做得更好的事情。</p>
<p>通过采用<em>云原生架构</em>，并假设<em>一切都是服务，</em>并且将它们部署在云环境中，就可以构建我们的应用程序，我们可以获得所有这些好处以及更多。问题不是<em>为什么云原生？</em>您必须问自己的问题是，为什么<em>不</em>拥抱云原生？</p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2021/01/27/file-upload-vulnerablity/</url>
    <content><![CDATA[<h2 id="文件上传漏洞及其危害"><a href="#文件上传漏洞及其危害" class="headerlink" title="文件上传漏洞及其危害"></a>文件上传漏洞及其危害</h2><p>文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。</p>
<p>由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件。</p>
<a id="more"></a>

<p>打个比方来说，如果你使用 windows 服务器并且以 asp 作为服务器端的动态网站环境，那么在你的网站的上传功能处，就一定不能让用户上传 asp 类型的文件，否则他上传一个 webshell，你服务器上的文件就可以被他任意更改了。因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。</p>
<p>比如，我们向后台传输了一个php文件，该文件的内容很简单，就一行代码，通过eval函数执行请求参数中hacker字段的值。</p>
<p>如果我们将这个文件上传到服务器，并假设存储到了<code>http://localhost/images/shell.php</code></p>
<p>那么这个时候我们去利用命令行执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d "hacker=echo get_current_user();" http://localhost/images/shell.php</span><br></pre></td></tr></table></figure>

<p>这个时候就会回显会服务器当前的用户。</p>
<p>当然我们也可以利用其它php自带的系统函数去推测出整个后台服务器的信息。</p>
<h2 id="文件上传漏洞初阶：后缀域名绕过"><a href="#文件上传漏洞初阶：后缀域名绕过" class="headerlink" title="文件上传漏洞初阶：后缀域名绕过"></a>文件上传漏洞初阶：后缀域名绕过</h2><h3 id="后缀名检测"><a href="#后缀名检测" class="headerlink" title="后缀名检测"></a>后缀名检测</h3><p>我们开头所讲的这个例子之所以能够执行成功，很重要的一部分原因是因为文件的后缀名是php，所以服务器在解析整个文件的时候会使用php的解析器去执行代码。</p>
<p>如果这个文件只是一个普通的txt文件，即使其中有恶意代码，我们的服务器也只是把它当做一段普通的字符串而已。</p>
<p>所以基于这个前提，如果我们能够对上传文件的后缀名进行一个检测，对于类似php这样的文件后缀名进行拦截，就可以避免这样的漏洞。</p>
<h3 id="如何绕过检测"><a href="#如何绕过检测" class="headerlink" title="如何绕过检测"></a>如何绕过检测</h3><p>以php为例，如果我们的后缀名检测只检测<code>*.php</code>，那如果我上传的是php3类型的文件，其实就可以上传成功，但是像Apache2这样的代理，会将以php，php3，php4，php5为后缀的所有文件当做php文件解析。</p>
<h2 id="文件上传漏洞中阶"><a href="#文件上传漏洞中阶" class="headerlink" title="文件上传漏洞中阶"></a>文件上传漏洞中阶</h2><h3 id="服务器关联漏洞"><a href="#服务器关联漏洞" class="headerlink" title="服务器关联漏洞"></a>服务器关联漏洞</h3><h4 id="IIS5-x-6-0-解析漏洞"><a href="#IIS5-x-6-0-解析漏洞" class="headerlink" title="IIS5.x / 6.0 解析漏洞"></a>IIS5.x / 6.0 解析漏洞</h4><ul>
<li>当创建以.asp结尾的文件目录时，在此目录下的任何文件都会被解析成asp文件。</li>
<li>服务器默认不解析“；”以后的内容</li>
</ul>
<p>基于两点，我们可以有两种利用形式</p>
<ul>
<li><a href="http://www.xxx.com/xx.asp/xx.jpg" rel="external nofollow noopener noreferrer" target="_blank">www.xxx.com/xx.asp/xx.jpg</a> 会被解析成asp文件</li>
<li><a href="http://www.xxx.com/xx.asp;.jpg" rel="external nofollow noopener noreferrer" target="_blank">www.xxx.com/xx.asp;.jpg</a> 会被解析成asp文件</li>
</ul>
<h4 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h4><p>在低版本的Nginx中存在一个由PHP-CGI导致的文件解析漏洞。</p>
<p>PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.in配置文件中，默认是开启的。</p>
<p>当URL中有不存在的文件时，PHP就会默认向前解析。</p>
<p>基于这一点，我们可以：</p>
<ul>
<li>访问：<a href="http://www.xx.com/phpinfo.jpg/1.php" rel="external nofollow noopener noreferrer" target="_blank">www.xx.com/phpinfo.jpg/1.php</a> (其实这个1.php不存在)</li>
<li>会解析phpinfo.jpg文件，但是会使用php解析器来解析。</li>
</ul>
<h4 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h4><p>Apache在1.x和2.x版本中存在解析漏洞</p>
<p>Apache会从右向左判断后缀，并且会跳过无法识别的后缀，直到找到第一个可以识别的后缀，然后根据改后缀来解析。</p>
<p>基于这一点，我们可以：</p>
<ul>
<li>上传shell.php.test</li>
<li>访问shell.php.test,服务器会解析shell.php.test文件，但是按照php文件格式进行解析。</li>
</ul>
<h3 id="前端认证绕过"><a href="#前端认证绕过" class="headerlink" title="前端认证绕过"></a>前端认证绕过</h3><p>很多网站都只是在前端利用JavaScript来做校验。</p>
<p>利用该漏洞：</p>
<ul>
<li>通过抓包的方式，修改内容。</li>
<li>通过Chrome禁止或者删除JavaScript代码</li>
</ul>
<h3 id="htaccess绕过"><a href="#htaccess绕过" class="headerlink" title=".htaccess绕过"></a>.htaccess绕过</h3><p>.htaccess文件（分布式配置文件）提供了一种方式，使得配置文件可以随文件夹不同而不同，其所放置的文件夹与子文件夹都会受到影响，其语法与Apache主配置文件相同。</p>
<p>如果服务器启用了htaccess，我们可以去上传htaccess文件，从而修改该文件夹的服务器配置</p>
<ul>
<li>上传一个.htaccess文件，文件内容设置为<code>[AddType application/x-httpd-php .test]</code></li>
<li>上传一句话木马文件，文件名设置为shell.test。</li>
<li>访问shell.test，其实就会当做php文件来执行。</li>
</ul>
<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>针对黑名单的检测，我们可以改变后缀名的大小写来绕过。</p>
<p>比如我们想上传一个php文件，我们可以上传一个pHp。</p>
<p>但问题是，为什么这样是可以运行的：</p>
<ul>
<li>php真的等同于pHp？</li>
<li>如果不同，那为什么pHp可以执行。</li>
</ul>
<p>对于Windows系统，它其实对于后缀名是大小写不敏感的。</p>
<p>但是对与Linux系统，他是对于大小写是敏感的，但是由于这一点，可能会导致用户使用起来不方便，所以有的开发者会手动修改自己app的配置，让它是大小写不敏感的。</p>
<h2 id="文件上传漏洞高阶"><a href="#文件上传漏洞高阶" class="headerlink" title="文件上传漏洞高阶"></a>文件上传漏洞高阶</h2><h3 id="Windows文件流特性绕过"><a href="#Windows文件流特性绕过" class="headerlink" title="Windows文件流特性绕过"></a>Windows文件流特性绕过</h3><p>Windows的文件流系统是NTFS的，NTFS文件系统实现了多文件流特性。</p>
<p>NTFS环境下一个文件默认使用的是未命名的文件流，但同时我们也可以创建其他命名的文件流，Windows资源管理器默认情况下并不会显示文件的命名文件流，这些命名的文件流功能上和磨人的为命名文件流是相同的。</p>
<p>我们可以在Windows平台上尝试以下三个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 111 &gt; test.txt:1.txt  // 向test.txt的命名文件流1.txt中写入数据111</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 222 &gt; test.txt // 向test.txt中写入数据222</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo test &gt; test.txt::$data // 向test.txt的默认文件流中写入数据test</span><br></pre></td></tr></table></figure>

<p>通过第一个命令，我们会创建一个test.txt文件，但是我们打开该文件会发现什么内容都没有，而此时我们通过<code>notepad test.txt:1.txt</code>打开该文件流，又可以看见<code>111</code></p>
<p>而第二个和第三个命令是相同的效果，会在文件中写入内容。</p>
<p>基于以上的特性，我们可以这样理解，NTFS文件流允许我们让一个文件拥有多个文件流，平时我们的图形化界面使用的都是默认的未命名文件流，但是其他的文件流一旦通过命令行创建，其实是真实存在并且附着在文件上的，而且这种附着可以无视后缀名，也就是说你完全可以把一个php附着在txt文件上，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 恶意代码 &gt; test.txt:shell.php</span><br></pre></td></tr></table></figure>

<p>这段代码可以将恶意代码附着在一个普通的txt文件上，从而帮助我们绕过类型检测。</p>
<h3 id="文件头部检查绕过"><a href="#文件头部检查绕过" class="headerlink" title="文件头部检查绕过"></a>文件头部检查绕过</h3><p>不同类型的文件其实都有自己标志性的文件头。</p>
<p>有的服务器可能会对这些文件头进行校验。</p>
<p>为了绕过这个漏洞，我们可以尝试将代码直接拼接到允许的文件类型后面，然后用解析器去执行它，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat shell.php &gt; test.jpg</span><br></pre></td></tr></table></figure>

<p>这样我们就将一段php代码拼接在test.jpg之后。</p>
<p>这个时候我们再用php解析器去执行，是可以成功执行最后的代码的。</p>
<blockquote>
<p>这里有一点要注意，图片中可能会存在一些解析器无法执行的字符编码，所以我们可以把这些无法解析的内容直接删除，因为我们需要的只是jpg文件的头部。</p>
</blockquote>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>四种基本算法思想</title>
    <url>/2020/10/26/four-algorithm-thought/</url>
    <content><![CDATA[<p>数据结构与算法是一个非常大的范围，各种不同的问题需要不同的算法，这些算法或复杂或简单。这篇博客简单通过经典的背包问题介绍四种非常基本且常用的算法思想，分别是贪心，分治，回溯，动规。</p>
<p>这四种是算法思想，不是具体的算法，主要是理解其思路，而不是具体的实现。</p>
<p>这篇文章主要是帮我我把以前略显零散的知识点重新总结一下，所以很多具体内容在以前的其他博客中。</p>
<a id="more"></a>

<p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>总量（kg）</th>
<th>总价值（元）</th>
</tr>
</thead>
<tbody><tr>
<td>黄豆</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>绿豆</td>
<td>30</td>
<td>90</td>
</tr>
<tr>
<td>红豆</td>
<td>60</td>
<td>120</td>
</tr>
<tr>
<td>黑豆</td>
<td>20</td>
<td>80</td>
</tr>
<tr>
<td>青豆</td>
<td>50</td>
<td>75</td>
</tr>
</tbody></table>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>实际上，这个问题很简单，我估计你一下子就能想出来，没错，我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p>
<p>这个问题的解决思路显而易见，它本质上借助的就是贪心算法。结合这个例子，我总结一下贪心算法解决问题的步骤，我们一起来看看。</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们<strong>定义了限制值和期望值</strong>，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p>
<p>类比到刚刚的例子，限制值就是重量不能超过 100kg，期望值就是物品的总价值。这组数据就是 5 种豆子。我们从中选出一部分，满足重量不超过 100kg，并且总价值最大。</p>
<p>第二步，我们尝试看下这个问题是否可以用贪心算法解决：<strong>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</strong>。</p>
<p>类比到刚刚的例子，我们每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。</p>
<p>第三步，我们<strong>举几个例子看下贪心算法产生的结果是否是最优的</strong>。大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>贪心算法工作的前提是前一步的选择不会影响下一步的选择，比如刚才这个问题，如果我加了限制，选了黄豆就不能选绿豆，这个题目用贪心算法就没法解决了。</p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>我们稍微改造下刚才的背包问题，变成0-1背包问题：</p>
<p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
<p>实际上，背包问题我们在贪心算法那一节，已经讲过一个了，不过那里讲的物品是可以分割的，我可以装某个物品的一部分到背包里面。今天讲的这个背包问题，物品是不可分割的，要么装要么不装，所以叫 0-1 背包问题。显然，这个问题已经无法通过贪心算法来解决了。我们现在来看看，用回溯算法如何来解决。</p>
<p><strong>回溯是一种思想，往往与递归这种编程技巧配合使用。</strong></p>
<p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。</p>
<p><strong>为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段</strong>。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>
<p>具体解释可以看这篇博客：<a href="https://sunra.top/2020/03/28/backtracking-algorithm/">https://sunra.top/2020/03/28/backtracking-algorithm/</a></p>
<p><strong>其实片面点讲，回溯就是在深度优先遍历的过程中记录下来你走过了哪些节点，而到达叶子节点的条件是满足是没有其他路可以选了，就开始回溯</strong>。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划如果从递归的角度讲，其实也不是一个非常难懂的思想，上面讲的<strong>回溯说的是在遍历过程中记录下走过的路径，那么动态规划就是一个带备忘录的递归过程，换种说法，如果递归过程中有重复子问题，就用动态规划，没有那就回溯。</strong></p>
<p>比如我在递归过程中选择前四种豆子的最优解是选择前三种和选择前两种最优解的一个函数，即dp(4) = f(dp(3), dp(2))，一旦我计算出dp(4)，我先找个地方把它存下来，等我计算dp(5)的时候需要用到dp(4)，我就不需要继续递归了。</p>
<p><strong>而把这个递归过程转化为递推公式，就是动态规划了。</strong></p>
<p>具体可以参考这里：<a href="https://sunra.top/2020/03/28/dynamic-programming/">https://sunra.top/2020/03/28/dynamic-programming/</a></p>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p>这个定义看起来有点类似递归的定义。关于分治和递归的区别，我们在排序（下）的时候讲过，分治算法是一种处理问题的思想，递归是一种编程技巧。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ul>
<li><p>分解：将原问题分解成一系列子问题；</p>
</li>
<li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p>
</li>
<li><p>合并：将子问题的结果合并成原问题。</p>
</li>
</ul>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li><p>原问题与分解成的小问题具有相同的模式；</p>
</li>
<li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别。</p>
</li>
<li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</p>
</li>
<li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</p>
</li>
</ul>
<p><a href="https://sunra.top/2020/10/02/sort-algorithm/">归并排序</a>就是一个非常典型的分治思想</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>G6 使用入门与总结</title>
    <url>/2021/06/09/g6/</url>
    <content><![CDATA[<p>这周的工作中，有一个需求需要我去在前端生成一个决策树，于是去考察了很多开源的方案，下面这是我一开始调研的图表，大家可以看一下，根据自己的选择去挑自己合适的，最终我选的是G6。</p>
<p>其实<a href="https://g6.antv.vision/zh/docs/manual/introduction" rel="external nofollow noopener noreferrer" target="_blank">G6的文档</a>已经算是非常不错的了，那我写这篇博客的目的主要有两点：</p>
<ul>
<li>根据自己的使用体验，重新组织成我习惯记忆的方式，方便以后自己查看。</li>
<li>总结一下使用过程中踩的几个小坑。</li>
</ul>
<blockquote>
<p>这里吐槽一句，G6对于TypeScript实在是太不友好了，所有的属性都是可选的，有时候写下来一堆问号</p>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th>组件库</th>
<th>上手难度</th>
<th>性能</th>
<th>自由度/已有方案成熟型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>G6</td>
<td>文档较为详细：<a href="https://g6.antv.vision/zh/docs/manual/tutorial/preface" rel="external nofollow noopener noreferrer" target="_blank">前言</a></td>
<td>节点数少，但是单个节点比较复杂时候比较实用</td>
<td>自由度较高，支持自定义节点</td>
<td>主要是做图分析</td>
</tr>
<tr>
<td>X6</td>
<td>文档较为详细 <a href="https://x6.antv.vision/zh/docs/tutorial/getting-started" rel="external nofollow noopener noreferrer" target="_blank">快速上手</a></td>
<td>节点多，但是单个简单，且更多的是拖拽等操作时比较实用</td>
<td></td>
<td>主要做的是图编辑</td>
</tr>
<tr>
<td>ggEditor</td>
<td>几乎没有文档，也不更新文档了 <a href="https://github.com/alibaba/GGEditor" rel="external nofollow noopener noreferrer" target="_blank">alibaba/GGEditor</a></td>
<td></td>
<td></td>
<td>蚂蚁金服团队基于G6+React封装的，与React兼容较好，但是早已不更新，使用的是3.5版本的G6</td>
</tr>
<tr>
<td>Graphin</td>
<td><a href="https://graphin.antv.vision/graphin/quick-start/overview/" rel="external nofollow noopener noreferrer" target="_blank">功能概览</a></td>
<td></td>
<td>自由度较低，只支持圆形节点，无法定制且已有方案不符合要求 主要做图分析，而不是图编辑</td>
<td>蚂蚁金服团队基于G6+React封装的，与React兼容较好</td>
</tr>
<tr>
<td>jointjs</td>
<td></td>
<td></td>
<td></td>
<td>收费，且license为MPL-2.0</td>
</tr>
<tr>
<td>jsPlumb</td>
<td></td>
<td>基于Jquery和canvas，大批量操作可能有问题</td>
<td></td>
<td>使用上与React有些不搭配</td>
</tr>
<tr>
<td>d3</td>
<td>文档比较清晰，但是较为偏底层，所以要实现需求难度较大</td>
<td></td>
<td>自由度较高，但是感觉还比较原始，不如X6成熟</td>
<td>如果把G6和X6比做arco，这个更像是react</td>
</tr>
<tr>
<td>spritejs</td>
<td>文档比较清晰，但是较为偏底层，所以要实现需求难度较大</td>
<td></td>
<td>同上</td>
<td>同上</td>
</tr>
</tbody></table>
<h2 id="如何在React中使用G6"><a href="#如何在React中使用G6" class="headerlink" title="如何在React中使用G6"></a>如何在React中使用G6</h2><p>一开始我还在GGEditor和G6之间徘徊，因为我的前端项目是基于React的，使用GGEditor可能会方便一点，但是我在G6的官网找到了官方推荐的React中的使用示例，这才决定使用G6，这是官方势力的链接：<a href="https://g6.antv.vision/zh/docs/manual/advanced/g6InReact" rel="external nofollow noopener noreferrer" target="_blank">https://g6.antv.vision/zh/docs/manual/advanced/g6InReact</a></p>
<h2 id="G6核心概念"><a href="#G6核心概念" class="headerlink" title="G6核心概念"></a>G6核心概念</h2><p>这里借用一下官方网站的图片</p>
<p><img src="https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*I0RoTKgsvSEAAAAAAAAAAAAAARQnAQ" alt></p>
<p>我来帮大家理一下，这几个核心概念之间的关系：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1623800978/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210616074924_wrkvj4.png" alt></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>在G6中，主体（objects）与关系（relationships）的组成。它甚至不局限于视觉，主体与关系的数据也可以称为图。在 G6 中，Graph 对象是图的载体，它包含了图上的所有元素（节点、边等），同时挂载了图的相关操作（如交互监听、元素操作、渲染等）。Graph 对象的生命周期为：初始化 —&gt; 加载数据 —&gt; 渲染 —&gt; 更新 —&gt; 销毁。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><p>图形：又叫做Shape，Shape 指 G6 中的图形、形状，它可以是圆形、矩形、路径等。它一般与 G6 中的节点、边、Combo 相关。<strong>G6 中的每一种节点/边/ Combo 由一个或多个 Shape 组成。节点、边、Combo、标签文本的配置都会被体现到对应的图形上。</strong></p>
<p>既然每种节点都可以由多个图形组成，那么同一个节点中的所有图形就可以组成一个组,，也就是<strong>图形分组</strong>，而每个组都有一个<strong>关键图形</strong>（keyShape），像内置的rect节点的关键图形就是个rect图形。</p>
<p>不过到目前为止，我所接触的分组概念一般是在自定义节点的时候才会用到，等会解释自定义节点的时候会说。</p>
<p>每个图形都有自己的属性，不同的图形有公共的属性，但也有各自独特的属性，公共的属性，比如图的填充色，边框色，边框宽度，阴影颜色，阴影位置等。</p>
<p>单独的属性，如矩形会有宽度和高度，圆会有半径等等。</p>
<p>图形分组 group 类似于SVG 中的 g 是用来组合图形对象的容器。在 group 上添加变换（例如剪裁、旋转、放缩、平移等）会应用到其所有的子元素上。在 group 上添加属性（例如颜色、位置等）会被其所有的子元素继承。此外， group 可以多层嵌套使用，因此可以用来定义复杂的对象。</p>
<p><strong>图形变换</strong>则是指的旋转缩放等</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局则是G6自带的一些帮助你安排自动节点位置的布局方式，由于我这次是要生成一个决策树，每个节点的位置需要我自己控制，所以就没有仔细去看，有需要的可以去官网查阅</p>
<h3 id="交互与事件"><a href="#交互与事件" class="headerlink" title="交互与事件"></a>交互与事件</h3><p>事件可以分为以下四个层次：</p>
<ul>
<li>画布、图形层次的事件，<code>mousedown</code>，<code>mouseup</code>，<code>click</code>，<code>mouseenter</code>，<code>mouseleave</code> 等；</li>
<li>节点/边 上的事件，<code>node:mousedown</code>，<code>edge:click</code> 等，以 <code>type:eventName</code> 为事件名称；</li>
<li>时机事件：<ul>
<li>节点/边增删改时的事件, 例如：<code>beforeadditem</code>，<code>afteradditem</code> 等；</li>
<li>节点/边状态改变时的事件：<code>beforerefreshitem</code> 与 <code>afterrefreshitem</code>；</li>
<li>布局时机：<code>beforelayout</code> 与 <code>afterlayout</code>。</li>
</ul>
</li>
</ul>
<p>如果要了解 G6 支持的所有事件，请参考 <a href="https://g6.antv.vision/zh/docs/api/Event" rel="external nofollow noopener noreferrer" target="_blank">Event API</a>。</p>
<p>在事件之上，G6定义了Behavior，其实就是事件及其处理函数的集合，我们从如何自定义一个事件就可以看出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">G6.registerBehavior(<span class="string">'activate-node'</span>, &#123;</span><br><span class="line">  getDefaultCfg() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      multiple: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvents() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="string">'node:click'</span>: <span class="string">'onNodeClick'</span>,</span><br><span class="line">      <span class="string">'canvas:click'</span>: <span class="string">'onCanvasClick'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  onNodeClick(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> graph = <span class="keyword">this</span>.graph;</span><br><span class="line">    <span class="keyword">const</span> item = e.item;</span><br><span class="line">    <span class="keyword">if</span> (item.hasState(<span class="string">'active'</span>)) &#123;</span><br><span class="line">      graph.setItemState(item, <span class="string">'active'</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this 上即可取到配置，如果不允许多个 'active'，先取消其他节点的 'active' 状态</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.multiple) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeNodesState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 置点击的节点状态 'active' 为 true</span></span><br><span class="line">    graph.setItemState(item, <span class="string">'active'</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onCanvasClick(e) &#123;</span><br><span class="line">    <span class="comment">// shouldUpdate 可以由用户复写，返回 true 时取消所有节点的 'active' 状态，即将 'active' 状态置为 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shouldUpdate(e)) &#123;</span><br><span class="line">      removeNodesState();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeNodesState() &#123;</span><br><span class="line">    graph.findAllByState(<span class="string">'node'</span>, <span class="string">'active'</span>).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        graph.setItemState(node, <span class="string">'active'</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然，G6也有很多内置的事件，比如拖拽节点，拖拽或者缩放画布。</p>
<p>在事件之上，定义了交互模式Mode，每个交互模式就是几个Behavior的集合，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> G6.Graph(&#123;</span><br><span class="line">  container: <span class="string">'mountNode'</span>,</span><br><span class="line">  width: <span class="number">500</span>,</span><br><span class="line">  height: <span class="number">500</span>,</span><br><span class="line">  modes: &#123;</span><br><span class="line">    <span class="comment">// 支持的 behavior</span></span><br><span class="line">    <span class="keyword">default</span>: [<span class="string">'drag-canvas'</span>, <span class="string">'zoom-canvas'</span>],</span><br><span class="line">    edit: [<span class="string">'click-select'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上是模式定义的一个例子。在图上定义了两个模式，分别是 <code>default</code>，<code>edit</code>。其中 <code>default</code> 包含两个  <a href="https://g6.antv.vision/zh/docs/manual/middle/states/defaultBehavior" rel="external nofollow noopener noreferrer" target="_blank">Behavior</a>：<code>&#39;drag-canvas&#39;</code> 和 ‘<code>zoom-canvas&#39;</code>，都使用行为的默认参数。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>G6 中的 <strong>state</strong>，指的是节点或边的状态，包括<strong>交互状态</strong>和<strong>业务状态</strong>两种。</p>
<p>在 G6 中，配置交互状态和业务状态的方式是相同的。对于部分只使用 G6 来完成某个需求的开发，而不想深入理解 G6 的用户，其实不用区分交互状态和业务状态的区别，使用相同的方式定义状态，完全没有理解成本。</p>
<h4 id="交互状态"><a href="#交互状态" class="headerlink" title="交互状态"></a>交互状态</h4><p>交互状态是与具体的交互动作密切相关的，如用户使用鼠标选中某个节点则该节点被选中，hover 到某条边则该边被高亮等。</p>
<p>G6 中默认处理的是交互状态。</p>
<h4 id="业务状态"><a href="#业务状态" class="headerlink" title="业务状态"></a>业务状态</h4><p>指根据用户业务需求自定义的状态。业务状态是与交互动作无关的，与具体业务逻辑强相关的，也可理解为是强数据驱动的。如某个任务的执行状态、某条申请的审批状态等，不同的数据值代表不同的业务状态。业务状态与用户交互动作无关，但在 G6 中的处理方式同交互状态一致。</p>
<blockquote>
<p>不论是节点还是边，它们的属性分为两种：</p>
<ul>
<li><strong>样式属性 <code>style</code></strong>：对应 Canvas 中的各种样式，在元素<a href="https://g6.antv.vision/zh/docs/manual/middle/states/state" rel="external nofollow noopener noreferrer" target="_blank">状态 State</a> 发生变化时，可以被改变；<a href="https://g6.antv.vision/zh/docs/manual/middle/states/state#%E9%85%8D%E7%BD%AE-state-%E6%A0%B7%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">配置state样式</a></li>
<li><strong>其他属性</strong>：例如图形类型（ <code>type</code>）、id（<code>id</code> ）一类在元素<a href="https://g6.antv.vision/zh/docs/manual/middle/states/state" rel="external nofollow noopener noreferrer" target="_blank">状态 State</a> 发生变化时不能被改变的属性。</li>
</ul>
</blockquote>
<h3 id="图元素"><a href="#图元素" class="headerlink" title="图元素"></a>图元素</h3><p>这次主要用到的就是自定义节点和边，主要就是踩坑，都在下面的总结里了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>图形属性与节点属性不同，虽然有很多相同配置</li>
<li>自定义dom节点，只能在render是svg模式下生效</li>
<li>自定义dom节点上的时间，不会被图监听到，而是被自身截获。</li>
<li>自定义节点时，在图形分组上第一次调用addShape返回的就是关键shape，同时越往后的shape越靠上，也就是会覆盖在之前的shape上面。</li>
</ul>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>散列表的设计和应用</title>
    <url>/2020/10/12/hash-table/</url>
    <content><![CDATA[<h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”</p>
<p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p>为什么这么说呢？其实所谓的散列表的存储是从要存储的数据中抽取出某些数据，根据某个具体的规则计算出一个数组的下标，然后将这个数据存储到对应下标的位置，抽取出来的数据叫做<strong>键（key），或者叫关键字</strong>，这个规则就叫做<strong>散列函数</strong>，计算得到的数组下标就是<strong>散列值</strong>，或者叫Hash值。</p>
<p>我们具体举个例子，我们要把一个名叫<strong>abcd.txt</strong>的文档存储在散列表中，我们就以文件名作为key，设计一个散列函数，这个散列函数入参就是文件名，经过一系列的计算，得到数组的下标是3，那么就把这个文档的内容存储在数组下标为3的地方，下次我想看一下是否存储过abcd.txt的文档，可以再次执行散列函数，得到下标3，然后去查询下标为3的地方是否有数据。</p>
<a id="more"></a>

<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>从上面的例子我们可以看到，散列函数在散列表中起着非常关键的作用。现在我们就来学习下散列函数。</p>
<p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<p>那么应该如何设计一个散列函数呢？</p>
<ul>
<li><p>散列函数计算得到的散列值是一个非负整数；</p>
</li>
<li><p>如果 key1 = key2，那 hash(key1) == hash(key2)；</p>
</li>
<li><p>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</p>
</li>
</ul>
<p>第一点很好理解，因为我们的散列表是一个数组，数组的下标是非负整数。</p>
<p>第二点也比较好理解，我同一个内容得到的hash值应该是一样的，这样才能保证我下次要查找的时候能够准确地找到。</p>
<p>第三点其实很难做到，我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。举个简单的例子，如果散列表的长度为1万，就算你的散列函数再怎么设计，第10001条数据进来也必定会和某一条记录得到的数组下标相同。这种情况就是装载因子到达1的情况，这种情况是必定冲突的。</p>
<blockquote>
<p>散列表的装载因子=填入表中的元素个数/散列表的长度</p>
</blockquote>
<p>当key1 ≠ key2，那 hash(key1) = hash(key2)，这种情况叫做<strong>散列冲突</strong>。</p>
<h3 id="散列冲突的解决方法"><a href="#散列冲突的解决方法" class="headerlink" title="散列冲突的解决方法"></a>散列冲突的解决方法</h3><p>既然我们说了，我们几乎没法避免散列冲突，我们就要想个代价比较低的方式去解决散列冲突。</p>
<p>我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul>
<li>插入过程：</li>
</ul>
<p>那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，线性探测（Linear Probing）。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<ul>
<li>查找过程：</li>
</ul>
<p>在散列表中<strong>查找元素的过程</strong>有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<ul>
<li>删除过程：</li>
</ul>
<p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>
<h5 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h5><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。装载因子的计算公式是：散列表的装载因子=填入表中的元素个数/散列表的长度装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。</p>
<p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。</p>
<p>当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p>
<p>那查找或删除操作的时间复杂度是多少呢？实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。解答开篇。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>既然散列表其实就是数组，那么我们为什么要搞得这么复杂呢？</p>
<p>我个人认为最主要的一点是能够在O（1）的时间复杂度内判断要找的值是否在散列表中，如果在则返回。</p>
<h2 id="如何设计一个好的散列表"><a href="#如何设计一个好的散列表" class="headerlink" title="如何设计一个好的散列表"></a>如何设计一个好的散列表</h2><p>散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。</p>
<p>如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p>
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<p>通过上面我们对散列表的描述，我们应该能够理解设计一个好的散列表最主要的三点：</p>
<ul>
<li>设计一个高效且分布均匀的散列函数</li>
<li>高效地对散列表进行扩容</li>
<li>选择正确的散列冲突解决方案</li>
</ul>
<h3 id="设计一个散列函数"><a href="#设计一个散列函数" class="headerlink" title="设计一个散列函数"></a>设计一个散列函数</h3><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。其次，散列函数生成的值要尽可能<strong>随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<h3 id="高效扩容"><a href="#高效扩容" class="headerlink" title="高效扩容"></a>高效扩容</h3><p>当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重</p>
<p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。</p>
<p>因为散列表的大小变了，数据的存储位置也变了，所以<strong>我们需要通过散列函数重新计算每个数据的存储位置</strong>。</p>
<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)</p>
<p>大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p>
<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，<strong>我们只申请新空间，但并不将老的数据搬移到新散列表中</strong>。</p>
<p><strong>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表</strong>。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><h4 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。</p>
<p>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>
<p>所以<strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法</strong>。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因</p>
<h4 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h4><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p>
<p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
<p>如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p>
<p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<h2 id="为什么散列表经常与链表一起使用"><a href="#为什么散列表经常与链表一起使用" class="headerlink" title="为什么散列表经常与链表一起使用"></a>为什么散列表经常与链表一起使用</h2><p>数组占据随机访问的优势，却有需要连续内存的缺点。</p>
<p>链表具有可不连续存储的优势，但访问查找是线性的。</p>
<p>散列表和链表的混合使用，是为了结合数组和链表的优势，规避它们的不足。</p>
<p>通过散列加链表，可以实现不连续存储但是能够随机访问，比如我们需要访问一个元素，可以计算出它的hash值然后直接去散列表中查找，同时由于散列表中的每一项都是个链表，又可以实现数据的不连续存储。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2020/11/11/heap-and-dijkstra/</url>
    <content><![CDATA[<p>上周的博客中我们讨论并实现了图的拓扑排序，这周我们继续学习图的另外一种基础的算法，最短路径算法Dijkstra算法，以及如何将其改造成我们平时导航或者游戏中经常使用中用到的寻路算法。</p>
<a id="more"></a>

<h2 id="优先级队列（堆）"><a href="#优先级队列（堆）" class="headerlink" title="优先级队列（堆）"></a>优先级队列（堆）</h2><p>由于Dijkstra算法中需要用到优先级队列，所以我们先模仿实现一个，采用堆的形式.</p>
<p>首先解释下堆是什么：</p>
<ul>
<li><p>堆是一个完全二叉树；</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>
</li>
</ul>
<h3 id="如何实现一个堆"><a href="#如何实现一个堆" class="headerlink" title="如何实现一个堆"></a>如何实现一个堆</h3><p>要实现一个堆，我们先要知道，堆都支持哪些操作以及如何存储一个堆。</p>
<p>我们都知道，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点，<strong>这一点也是我们要用堆来实现优先级队列的一点原因</strong>。</p>
<h4 id="如何插入元素"><a href="#如何插入元素" class="headerlink" title="如何插入元素"></a>如何插入元素</h4><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。</p>
<p>如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做堆化（heapify）。</p>
<p>堆化实际上有两种，从下往上和从上往下。这里我先讲从下往上的堆化方法。</p>
<p>我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = capacity;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="keyword">new</span> <span class="built_in">Array</span>(capacity);</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(i, j) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">this</span>.a[i];</span><br><span class="line">        <span class="keyword">this</span>.a[i] = <span class="keyword">this</span>.a[j];</span><br><span class="line">        <span class="keyword">this</span>.a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= <span class="keyword">this</span>.n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.a[<span class="keyword">this</span>.count] = data;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">Math</span>.floor(i / <span class="number">2</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.a[i] &lt; <span class="keyword">this</span>.a[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(i, <span class="built_in">Math</span>.floor(i / <span class="number">2</span>));</span><br><span class="line">            i = <span class="built_in">Math</span>.floor(i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h4><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。假设我们构造的是大顶堆，堆顶元素就是最大的元素。</p>
<p>当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>但是上述方法容易破坏掉堆的结构</p>
<p>实际上，我们稍微改变一下思路，就可以解决这个问题。你看我画的下面这幅图。我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = capacity;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="keyword">new</span> <span class="built_in">Array</span>(capacity);</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(i, j) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">this</span>.a[i];</span><br><span class="line">        <span class="keyword">this</span>.a[i] = <span class="keyword">this</span>.a[j];</span><br><span class="line">        <span class="keyword">this</span>.a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt;= <span class="keyword">this</span>.n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.a[<span class="keyword">this</span>.count] = data;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">Math</span>.floor(i / <span class="number">2</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.a[i] &lt; <span class="keyword">this</span>.a[<span class="built_in">Math</span>.floor(i / <span class="number">2</span>)]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(i, <span class="built_in">Math</span>.floor(i / <span class="number">2</span>));</span><br><span class="line">            i = <span class="built_in">Math</span>.floor(i / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update(data) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.a[i].key === data.key) &#123;</span><br><span class="line">                <span class="keyword">this</span>.a[i] = data;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.count === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.a[<span class="number">0</span>] = <span class="keyword">this</span>.a[<span class="keyword">this</span>.count];</span><br><span class="line">        <span class="keyword">this</span>.count--;</span><br><span class="line">        <span class="keyword">this</span>.heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heapify() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> maxPos = i;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= <span class="keyword">this</span>.count &amp;&amp; <span class="keyword">this</span>.a[i] &gt; <span class="keyword">this</span>.a[i * <span class="number">2</span>]) &#123;</span><br><span class="line">                maxPos = i * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= <span class="keyword">this</span>.count &amp;&amp; <span class="keyword">this</span>.a[i] &gt; <span class="keyword">this</span>.a[i * <span class="number">2</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxPos === i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.swap(i, maxPos);</span><br><span class="line">            i = maxPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>首先来一张算法的步骤图</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1605138918/Algorithm/e20907173c458fac741e556c947bb9a9_hpgxz9.jpg" alt></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> <span class="built_in">Array</span>(v).fill([]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(s, t, w) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[s].push(<span class="keyword">new</span> Edge(s, t, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra(s, t) &#123;</span><br><span class="line">        <span class="keyword">let</span> predecessor = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v);</span><br><span class="line">        <span class="keyword">let</span> vertexes = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; i++) &#123;</span><br><span class="line">            vertexes[i] = <span class="keyword">new</span> Vertex(i, <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> queue = <span class="keyword">new</span> Heap(<span class="keyword">this</span>.v);</span><br><span class="line">        <span class="keyword">let</span> inqueue = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v).fill(<span class="literal">false</span>);</span><br><span class="line">        vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">        queue.add(vertexes[s]);</span><br><span class="line">        inqueue[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> minVertex = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (minVertex.id === t) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.adj[minVertex.id].length; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> edge = <span class="keyword">this</span>.adj[minVertex.id][i];</span><br><span class="line">                <span class="keyword">const</span> nexeVertex = vertexes[edge.tid];</span><br><span class="line">                <span class="keyword">if</span> (minVertex.dist + edge.w &lt; nexeVertex.dist) &#123;</span><br><span class="line">                    nexeVertex.dist = minVertex.dist + edge.w;</span><br><span class="line">                    predecessor[nexeVertex.id] = minVertex.id;</span><br><span class="line">                    <span class="keyword">if</span> (inqueue[nexeVertex.id]) &#123;</span><br><span class="line">                        queue.update(nexeVertex);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        queue.add(nexeVertex);</span><br><span class="line">                        inqueue[nexeVertex.id] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(s);</span><br><span class="line">        print(s, t, predecessor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(s, t, predecessor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === t) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(s, predecessor[t], predecessor);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`-&gt;<span class="subst">$&#123;t&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(sid, tid, weight) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">        <span class="keyword">this</span>.w = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id, dist) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.dist = dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dijkstra算法的思路有点像BFS，从起始顶点开始遍历它所能到的所有顶点，然后依次更新到这些顶点的最短路径，更新完之后加入到优先级队列中，接下来从优先级队列中拿出当前dist最小的顶点，然后计算出它所能到的所有顶点，依次更新，然后不断重复上述过程。</p>
<p>但其实也不是完全的BFS，因为<strong>优先级队列与普通队列不同，它会在每次插入数据时调整数据的位置，保证头部的数据是队列中的最小值，并不是先进先出。</strong></p>
<h2 id="A-算法（简化Dijkstra算法）"><a href="#A-算法（简化Dijkstra算法）" class="headerlink" title="A*算法（简化Dijkstra算法）"></a>A*算法（简化Dijkstra算法）</h2><p>魔兽世界、仙剑奇侠传这类 MMRPG 游戏，不知道你有没有玩过？在这些游戏中，有一个非常重要的功能，那就是人物角色自动寻路。当人物处于游戏地图中的某个位置的时候，我们用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去。玩过这么多游戏，不知你是否思考过，这个功能是怎么实现的呢？</p>
<p>算法解析实际上，这是一个非常典型的搜索问题。人物的起点就是他当下所在的位置，终点就是鼠标点击的位置。我们需要在地图中，找一条从起点到终点的路径。这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法。所谓“聪明”，笼统地解释就是，走的路不能太绕。<strong>理论上讲，最短路径显然是最聪明的走法，是这个问题的最优解。</strong></p>
<p><strong>不过，如果图非常大，那 Dijkstra 最短路径算法的执行耗时会很多</strong>。在真实的软件开发中，我们面对的是超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的。</p>
<p>实际上，像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，我们都不需要非得求最优解（也就是最短路径）。在权衡路线规划质量和执行效率的情况下，我们只需要寻求一个次优解就足够了。那如何快速找出一条接近于最短路线的次优路线呢？</p>
<p>这个快速的路径规划算法，就是我们今天要学习的 A* 算法。实际上，A* 算法是对 Dijkstra 算法的优化和改造。</p>
<p><strong>Dijkstra 算法有点儿类似 BFS 算法，它每次找到跟起点最近的顶点</strong>，往外扩展。<strong>这种往外扩展的思路，其实有些盲目</strong>。为什么这么说呢？我举一个例子来给你解释一下。下面这个图对应一个真实的地图，每个顶点在地图中的位置，我们用一个二维坐标（x，y）来表示，其中，x 表示横坐标，y 表示纵坐标。</p>
<p><img src="https://static001.geekbang.org/resource/image/11/dd/11840cc13071fe2da67675338e46cadd.jpg" alt></p>
<p>在 Dijkstra 算法的实现思路中，我们用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展，从图中举的例子可以看出，尽管我们找的是从 s 到 t 的路线，但是最先被搜索到的顶点依次是 1，2，3。通过肉眼来观察，这个搜索方向跟我们期望的路线方向（s 到 t 是从西向东）是反着的，路线搜索的方向明显“跑偏”了。</p>
<p>之所以会“跑偏”，那是因为我们是按照顶点与起点的路径长度的大小，来安排出队列顺序的。与起点越近的顶点，就会越早出队列。我们并没有考虑到这个顶点到终点的距离，所以，在地图中，尽管 1，2，3 三个顶点离起始顶点最近，但离终点却越来越远。</p>
<p>如果我们综合更多的因素，把这个顶点到终点可能还要走多远，也考虑进去，综合来判断哪个顶点该先出队列，那是不是就可以避免“跑偏”呢？当我们遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，我们记作 g(i)（i 表示顶点编号）。但是，从这个顶点到终点的路径长度，我们是未知的。虽然确切的值无法提前知道，但是我们可以用其他估计值来代替。</p>
<p>这里我们可以通过这个顶点跟终点之间的直线距离，也就是欧几里得距离，来近似地估计这个顶点跟终点的路径长度（注意：路径长度跟直线距离是两个概念）。我们把这个距离记作 h(i)（i 表示这个顶点的编号），专业的叫法是启发函数（heuristic function）。因为欧几里得距离的计算公式，会涉及比较耗时的开根号计算，所以，我们一般通过另外一个更加简单的距离计算公式，那就是曼哈顿距离（Manhattan distance）。曼哈顿距离是两点之间横纵坐标的距离之和。计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效。</p>
<p>原来只是单纯地通过顶点与起点之间的路径长度 g(i)，来判断谁先出队列，现在有了顶点到终点的路径长度估计值，我们通过两者之和 f(i)=g(i)+h(i)，来判断哪个顶点该最先出队列。综合两部分，我们就能有效避免刚刚讲的“跑偏”。这里 f(i) 的专业叫法是估价函数（evaluation function）。从刚刚的描述，我们可以发现，A* 算法就是对 Dijkstra 算法的简单改造。实际上，代码实现方面，我们也只需要稍微改动几行代码，就能把 Dijkstra 算法的代码实现，改成 A* 算法的代码实现。</p>
<p>在 A* 算法的代码实现中，顶点 Vertex 类的定义，跟 Dijkstra 算法中的定义，稍微有点儿区别，多了 x，y 坐标，以及刚刚提到的 f(i) 值。</p>
<p>A* 算法的代码实现的主要逻辑是下面这段代码。它跟 Dijkstra 算法的代码实现，主要有 3 点区别：</p>
<ul>
<li>优先级队列构建的方式不同。A* 算法是根据 f 值（也就是刚刚讲到的 f(i)=g(i)+h(i)）来构建优先级队列，而 Dijkstra 算法是根据 dist 值（也就是刚刚讲到的 g(i)）来构建优先级队列；</li>
<li>A* 算法在更新顶点 dist 值的时候，会同步更新 f 值；循环结束的条件也不一样。</li>
<li>Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。</li>
</ul>
<p>注：</p>
<p>本文中的所有图均来自于极客时间《数据结构与算法之美》一课</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>http协议头部部分参数解析与应用</title>
    <url>/2020/01/25/http-headers-part-params/</url>
    <content><![CDATA[<p>这个周工作中遇到了几个问题，都是关于http协议的头部报错的，大致可以分为三类，Referrer Policy, 断点续传，范围请求的。这里搜索和整理了一点内容还有应用。</p>
<a id="more"></a>

<h2 id="Referrer-Policy"><a href="#Referrer-Policy" class="headerlink" title="Referrer Policy"></a>Referrer Policy</h2><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>首先要搞明白Referer是什么。</p>
<p>简单来说，当你发起一个http请求，请求头中的<code>referrer</code>字段就说明了你是从哪个页面发起该请求的。详细的解释可以看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2019/06/http-referer.html" rel="external nofollow noopener noreferrer" target="_blank">Http Referer 教程</a></p>
<h3 id="Referer-Policy"><a href="#Referer-Policy" class="headerlink" title="Referer Policy"></a>Referer Policy</h3><p><code>Referrer-Policy</code>的作用就是为了控制请求头中<code>referrer</code>的内容，目前是一个候选标准，不过已经有部分浏览器支持该标准。</p>
<p>目前<code>Referrer-Policy</code>只包含以下几种值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ReferrerPolicy &#123;</span><br><span class="line">&quot;&quot;,</span><br><span class="line">&quot;no-referrer&quot;,</span><br><span class="line">&quot;no-referrer-when-downgrade&quot;,</span><br><span class="line">&quot;same-origin&quot;,</span><br><span class="line">&quot;origin&quot;,</span><br><span class="line">&quot;strict-origin&quot;,</span><br><span class="line">&quot;origin-when-cross-origin&quot;,</span><br><span class="line">&quot;strict-origin-when-cross-origin&quot;,</span><br><span class="line">&quot;unsafe-url&quot;</span><br><span class="line">&#125;;复制代码</span><br></pre></td></tr></table></figure>

<h4 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h4><p>若设为空串则默认按照浏览器的机制设置<code>referrer</code>的内容，默认情况下是和<code>no-referrer-when-downgrade</code>设置得一样。</p>
<h4 id="no-referrer"><a href="#no-referrer" class="headerlink" title="no-referrer"></a>no-referrer</h4><p>不显示<code>referrer</code>的任何信息在请求头中。</p>
<h4 id="no-referrer-when-downgrade"><a href="#no-referrer-when-downgrade" class="headerlink" title="no-referrer-when-downgrade"></a>no-referrer-when-downgrade</h4><p>这是默认值。当从https网站跳转到http网站或者请求其资源时（安全降级HTTPS→HTTP），不显示<code>referrer</code>的信息，其他情况（安全同级HTTPS→HTTPS，或者HTTP→HTTP）则在<code>referrer</code>中显示完整的源网站的URL信息。</p>
<h4 id="same-origin"><a href="#same-origin" class="headerlink" title="same-origin"></a>same-origin</h4><p>表示浏览器只会显示<code>referrer</code>信息给同源网站，并且是完整的URL信息。所谓同源网站，是协议、域名、端口都相同的网站。</p>
<h3 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h3><p>表示浏览器在<code>referrer</code>字段中只显示源网站的源地址（即协议、域名、端口），而不包括完整的路径。</p>
<h4 id="strict-origin"><a href="#strict-origin" class="headerlink" title="strict-origin"></a>strict-origin</h4><p>该策略更为安全些，和<code>origin</code>策略相似，只是不允许<code>referrer</code>信息显示在从https网站到http网站的请求中（安全降级）。</p>
<h4 id="origin-when-cross-origin"><a href="#origin-when-cross-origin" class="headerlink" title="origin-when-cross-origin"></a>origin-when-cross-origin</h4><p>当发请求给同源网站时，浏览器会在<code>referrer</code>中显示完整的URL信息，发个非同源网站时，则只显示源地址（协议、域名、端口）</p>
<h4 id="strict-origin-when-cross-origin"><a href="#strict-origin-when-cross-origin" class="headerlink" title="strict-origin-when-cross-origin"></a>strict-origin-when-cross-origin</h4><p>和<code>origin-when-cross-origin</code>相似，只是不允许<code>referrer</code>信息显示在从https网站到http网站的请求中（安全降级）。</p>
<h4 id="unsaft-url"><a href="#unsaft-url" class="headerlink" title="unsaft-url"></a>unsaft-url</h4><p>浏览器总是会将完整的URL信息显示在<code>referrer</code>字段中，无论请求发给任何网站</p>
<h3 id="Referrer-Policy更改方法"><a href="#Referrer-Policy更改方法" class="headerlink" title="Referrer-Policy更改方法"></a>Referrer-Policy更改方法</h3><p>可以有以下5种方法：</p>
<p><strong>1.</strong> 通过<code>Referrer-Policy</code> HTTP <code>header</code>设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Referrer-Policy: origin复制代码</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> 通过``元素改变<code>Referrer Policy</code>，直接修改名为<code>referrer</code>的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;&gt;复制代码</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> 给 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a" rel="external nofollow noopener noreferrer" target="_blank">``</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area" rel="external nofollow noopener noreferrer" target="_blank">``</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="external nofollow noopener noreferrer" target="_blank"><code>![img]()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" rel="external nofollow noopener noreferrer" target="_blank">``</a>, 或者<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="external nofollow noopener noreferrer" target="_blank">``</a>元素设置<code>referrerpolicy</code>属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com&quot; referrerpolicy=&quot;origin&quot;&gt;复制代码</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> 如需设置不显示<code>referrer</code>信息时，也可以给 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a" rel="external nofollow noopener noreferrer" target="_blank">``</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area" rel="external nofollow noopener noreferrer" target="_blank">``</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" rel="external nofollow noopener noreferrer" target="_blank">``</a>元素设置<code>rel</code>的链接关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com&quot; rel=&quot;noreferrer&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>范围请求主要是针对较大的文件的请求或者上传，可以仅操作它的某一段。</p>
<p>一个比较常见的场景，就是断点续传/下载，在网络情况不好的时候，可以在断开连接以后，仅继续获取部分内容。例如在网上下载软件，已经下载了 95% 了，此时网络断了，如果不支持范围请求，那就只有被迫重头开始下载。但是如果有范围请求的加持，就只需要下载最后 5% 的资源，避免重新下载。</p>
<p>另一个场景就是多线程下载，对大型文件，开启多个线程，每个线程下载其中的某一段，最后下载完成之后，在本地拼接成一个完整的文件，可以更有效的利用资源。</p>
<p>这算是两个比较常见的场景，接下来我们来看看范围请求的 HTTP 协议支持的技术细节。</p>
<h2 id="HTTP-的范围请求"><a href="#HTTP-的范围请求" class="headerlink" title="HTTP 的范围请求"></a>HTTP 的范围请求</h2><h3 id="是否支持范围请求"><a href="#是否支持范围请求" class="headerlink" title="是否支持范围请求"></a>是否支持范围请求</h3><p>HTTP 本身是一种无状态的“松散”协议，而在经历了很多版本的迭代之后，只在 HTTP/1.1（RFC2616） 之上，才支持范围请求。所以如果客户端或者服务端两端的某一端低于 HTTP/1.1，我们就不应该使用范围请求的功能。</p>
<p>而在 HTTP/1.1 中，很明确的声明了一个响应头部 <code>Access-Ranges</code> 来标记是否支持范围请求，它只有一个可选参数 <code>bytes</code>。</p>
<p>例如这里给了一个 MP4 的响应头，可以看到它是有 <code>Accept-Ranges:bytes</code> 来标记的，有此标记标识当前资源支持范围请求。</p>
<h3 id="使用范围请求"><a href="#使用范围请求" class="headerlink" title="使用范围请求"></a>使用范围请求</h3><p>如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。</p>
<p>所有的文件最终都是存储在磁盘或者内存中的字节，对于待操作的文件可以将其以字节为单位分割。这样只需要 HTTP 支持请求该文件从 n 到 n+x 这个范围内的资源，就可以实现范围请求了。</p>
<p>HTTP/1.1 中定义了一个 Ranges 的请求头，来指定请求实体的范围。它的范围取值是在 <code>0 - Content-Length</code> 之间，使用 <code>-</code> 分割。。</p>
<p>例如已经下载了 1000 bytes 的资源内容，想接着继续下载之后的资源内容，只要在 HTTP 请求头部，增加 <code>Ranges:bytes=1000-</code> 就可以了。</p>
<p>Range 还有几种不同的方式来限定范围，可以根据需要灵活定制：</p>
<p><em>1.</em> 500-1000：指定开始和结束的范围，一般用于多线程下载。</p>
<p><em>2.</em> 500- ：指定开始区间，一直传递到结束。这个就比较适用于断点续传、或者在线播放等等。</p>
<p><em>3.</em> -500：无开始区间，只意思是需要最后 500 bytes 的内容实体。</p>
<p><em>4.</em> 100-300,1000-3000：指定多个范围，这种方式使用的场景很少，了解一下就好了。</p>
<p>HTTP 协议是一种双边协商的协议，既然请求头部已经确定是使用 Ranges 了，还有响应头部中，也需要使用 <code>Content-Ragne</code> 这个响应头来标记响应的实体内容范围。</p>
<p><code>Content-Range</code> 的格式也很清晰，首先标记它的单位是 bytes 然后标记当前传递的内容实体范围和总长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Range: bytes 100-999/1000</span><br></pre></td></tr></table></figure>

<p>在这个例子中，会传递 100 ~ 999 范围的内容实体，而该资源文件的总大小是 1000 bytes。并且此时的 HTTP  响应状态码为 <code>206 Partial Content</code> 。</p>
<h3 id="资源变化"><a href="#资源变化" class="headerlink" title="资源变化"></a>资源变化</h3><p>当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会遇见它又重头开始下载的情况。</p>
<p>这看似是 HTTP 的范围请求失效了，但是实际上并不一定如此，很可能是因为请求的资源，在请求的这个过程中，发生了改变。</p>
<p>假如你下载的过程中，下载的源资源文件发生了变化，但是 URL 没有改变，此时文件长度可能已经变化了（这是非常容易发现的），极端情况下就算没有长度没有变化，你再继续下载，很可能最终下载完成之后，无法将下载的内容拼接成我们需要的文件。</p>
<p>如果我们需要从服务器上下载某个资源，一定要预防此资源可能发生的变动。在之前讲 <a href="http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&mid=2247485517&idx=1&sn=3edffef8db15d92c26072d85df1cc5a8&chksm=9785116ca0f2987a4ccf77339800873d092c1bded522d50fcf03aec98a9f51b23355e28aa3b7#rd" rel="external nofollow noopener noreferrer" target="_blank">HTTP 缓存</a>的时候讲到，在 HTTP 协议中，可以通过 ETag 或者 Last-Modified 来标识当前资源是否变化。</p>
<ul>
<li>ETag：当前文件的一个验证令牌指纹，用于标识文件的唯一性。</li>
<li>Last-Modified：标记当前文件最后被修改的时间。</li>
</ul>
<p>在 HTTP 的范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在 <code>If-Range</code> 这个请求报文头中即可。<code>If-Range</code> 使用 <code>ETag</code> 或者 <code>Last-Modified</code> 两个参数任意一个，原样填入即可。</p>
<p>参考文献：</p>
<p><a href="https://juejin.im/post/5cd81b59518825686a06fd05" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5cd81b59518825686a06fd05</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy</a></p>
<p><a href="https://juejin.im/post/5b555f055188251af25700aa" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5b555f055188251af25700aa</a></p>
<p><a href="https://www.jianshu.com/p/934d3e8d371e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/934d3e8d371e</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>http-proxy-middleware</title>
    <url>/2019/09/07/http_proxy_middleware/</url>
    <content><![CDATA[<p>前端与后台进行通信时，遇到了跨域问题时，我们可以通过设置nginx代理来修改请求的源来解决跨域问题。但是，其实我们也可以通过nodejs的http-proxy-middleware来自己设置一个代理。</p>
<a id="more"></a>

<h3 id="启动代理"><a href="#启动代理" class="headerlink" title="启动代理"></a>启动代理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, proxy(&#123;<span class="attr">target</span>: <span class="string">'http://localhost:3001/'</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="启动后台服务"><a href="#启动后台服务" class="headerlink" title="启动后台服务"></a>启动后台服务</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入express</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建express服务器</span></span><br><span class="line"><span class="keyword">var</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 访问服务器(get或者post)</span></span><br><span class="line"><span class="comment">//参数一: 请求根路径</span></span><br><span class="line"><span class="comment">//3.1 get请求</span></span><br><span class="line">server.get(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(request)</span></span><br><span class="line">    response.send(<span class="string">'get请求成功'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 post请求</span></span><br><span class="line">server.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.send(<span class="string">'post请求成功'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 绑定端口</span></span><br><span class="line">server.listen(<span class="number">3001</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'启动3001'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="利用PostMan模拟请求"><a href="#利用PostMan模拟请求" class="headerlink" title="利用PostMan模拟请求"></a>利用PostMan模拟请求</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1567840454/js/360%E6%88%AA%E5%9B%BE17290503508975_rgztoo.png" alt></p>
<h3 id="http-proxy-middleware高级属性"><a href="#http-proxy-middleware高级属性" class="headerlink" title="http-proxy-middleware高级属性"></a>http-proxy-middleware高级属性</h3><p>其他高级的用法可以参考这片博客：</p>
<p><a href="https://juejin.im/post/5bd13c5ce51d457a203cebf4" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5bd13c5ce51d457a203cebf4</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS协议简介</title>
    <url>/2020/04/19/https/</url>
    <content><![CDATA[<p>HTTPS协议是HTTP + SSL/TLS组合而成的，而HTTP是用来从万维网服务器获取信息的协议，所以我们就从万维网开始讲起。</p>
<h2 id="万维网与HTTP"><a href="#万维网与HTTP" class="headerlink" title="万维网与HTTP"></a>万维网与HTTP</h2><p>万维网（WWW）并非某种特殊的计算机网络。万维网是一个大规模的，联机式的信息储藏所，英文简称web。万维网用链接的方式可以非常方便地从互联网上的一个站点访问另一个站点。</p>
<p>每一个万维网站点都存放了许多文档。在这些文档中有一些地方的文字是用特殊方式显示的，当我们鼠标移动到这些地方的时候，鼠标的箭头就变成了一只手的形状，这就表明这里有一个链接。如果我们点击这些链接，我们就可以从这个文档链接到可能相隔很远的另一个文档。</p>
<p>正是由于互联网的出现，使得互联网从少数计算机专家使用变成了普通百姓也能使用。</p>
<blockquote>
<p>我们平时从浏览器打开网页就是从万维网服务器获取信息，使用的是HTTP协议。但是我们去玩LOL的时候，客户端与服务器之间的交流就可以不是HTTP协议了。</p>
</blockquote>
<p>万维网是一个分布式的超媒体，他是超文本系统的扩展、所谓的超文本就是指包含连接向其他文档的链接的文本。一个超文本由多个信息源链接而成，而这些信息分布在世界各地。</p>
<p><strong>万维网的客户端程序就是浏览器</strong>，万维网文档存储的主机就是万维网服务器，运行万维网服务器程序。<strong>客户程序向服务器程序发送请求，服务器程序就向客户端程序发送客户所需的万维网文档</strong>。在浏览器中显示的万维网文档就称为页面。</p>
<a id="more"></a>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>从上面的描述可以看出，万维网必须解决几个问题：</p>
<ul>
<li>怎样标志分布在整个网络上的万维网网络。</li>
<li>用什么样的协议来实现万维网上的各种链接。</li>
<li>怎样使不同作者创作的不同风格的万维网文档，都能在互联网的各种主机上都能够显示出来，并是用户清楚地知道在什么地方存在链接。</li>
<li>怎样使用户能够很方便地找到所需要的信息。</li>
</ul>
<p>要解决第一个问题，万维网使用<strong>统一资源定位符URL（Uniform Resource Locator）</strong>,来标志万维网上的各种文档，并使每个文档在整个互联网范围内具有唯一的标识符URL。</p>
<p>为了解决第二个问题，就要是<strong>万维网的客户程序与万维网服务器之间的交互遵守严格的协议，就是超文本传输协议HTTP（HyperText Transfer Protocol）</strong>，它是一个应用层协议，使用TCP进行可靠传输。</p>
<p>为了解决第三个问题，万维网使用<strong>超文本标记语言HTML（HyperText Markup Language）</strong>。</p>
<p>解决最后一个问题的办法就是<strong>搜索引擎</strong>。</p>
<h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><p>URL相当于是一个文件在网络范围内的扩展，是与互联网相连的机器上任何可访问的对象的一个指针（不止用于HTTP）。由于访问不同对象用的协议不同，所以还需要指出读取某个对象所需要的协议。</p>
<p><strong>URL一般形式由四个部分组成：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong></p>
<p><strong>现在有的浏览器为了用户方便，在输入URL时，可以吧最前面的HTTP://甚至是www给省略掉</strong>。</p>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p>HTTP是<strong>面向事务</strong>的应用层协议，它是万维网上能够可靠交付文件的重要基础。</p>
<p>每个万维网服务器都有一个服务器进程，它不断监听TCP的80端口，以便发现是否有浏览器向它发出连接建立请求。一旦监听到连接建立请求并建立TCP连接之后，浏览器就像万维网服务器发送某个页面的请求，服务器就返回所请求的页面作为响应。</p>
<p>HTTP规定在HTTP客户和HTTP服务器之间的每次交互，都由一个ASCII码串构成的请求和一个类似的通用互联网扩充，即“类MIME（MIME-like）”响应组成。</p>
<p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输，HTTP不必考虑数据在运输过程中被丢弃后又怎样重传。</p>
<p>用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接，这需要三次握手，当建立TCP连接的三次握手前两次完成后，浏览器就可以把HTTP请求报文作为第三个报文的数据发送过去。服务器收到请求后，就把请求的文档作为响应报文返回给客户。</p>
<p>上述过程就是HTTP1.0，它请求一个文档的时间是该文档的传输时间加上两倍的RTT，一个RTT用于连接TCP连接，另一个RTT用于请求和接收文档。</p>
<p>但是1.0主要的缺点是每请求一个文档，都要有两倍的RTT开销。若一个主页上有很多链接的对象需要一次连接，每一次下载都要有2RTT。另一种开销就是浏览器和服务器每一次建立新的TCP链接都要分配缓存和变量，特别是服务器要服务与大量的浏览器，所以这种<strong>非持续连接</strong>会使万维网服务器负担很重</p>
<p>HTTP/1.1协议采取了持续连接，它在服务器返回响应后仍在一段时间内保持这条连接，使同一个客户和服务器可以继续在这条连接上发送后续的HTTP请求和响应。1.1有两种工作方式，一种是非流水线，一种是流水线。第一种方式需要等前一个请求的响应到达之后才可以发送下一个请求，而流水线方式不用。</p>
<h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><p>代理服务器是一种网络实体，又称为<strong>万维网高速缓存（Web Cache）</strong>，可以将最近的一些请求和响应暂存在缓存中。</p>
<h4 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h4><p>HTTP有两类报文：</p>
<ul>
<li>请求报文</li>
<li>响应报文</li>
</ul>
<p><img src="HTTPS://res.cloudinary.com/dvtfhjxi4/image/upload/v1587259061/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200419091617_aku8ru.png" alt="HTTPS://res.cloudinary.com/dvtfhjxi4/image/upload/v1587259061/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200419091617_aku8ru.png"></p>
<p>HTTP的请求和响应报文都是由三个部分组成：</p>
<ul>
<li>开始行：用于区别请求报文还是响应报文，请求报文中叫做请求行，响应报文中叫做状态行</li>
<li>首部行：用来说明浏览器，服务器或报文主体的一些信息，可以有好几行，也可以一行不用</li>
<li>实体主体：在请求报文中一般不用，想用报文中也可能没有这个字段。</li>
</ul>
<p>这里只是简单介绍一下HTTP，实际中的HTTP非常复杂，各种头部的使用种类繁多。</p>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>在理解这段内容之前，需要了解一下<a href="HTTPS://sunra.top/2019/10/19/Asymmetric_Encryption/">非对称加密，数字签名和证书</a></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<blockquote>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</blockquote>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<blockquote>
<p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p>
<p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p>
<p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p>
</blockquote>
<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<p><strong>（1）如何保证公钥不被篡改？</strong></p>
<blockquote>
<p>解决方法：将公钥放在<a href="HTTP://en.wikipedia.org/wiki/Digital_certificate" rel="external nofollow noopener noreferrer" target="_blank">数字证书</a>中。只要证书是可信的，公钥就是可信的。</p>
</blockquote>
<p><strong>（2）公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<blockquote>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</blockquote>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<blockquote>
<p>（1） 客户端向服务器端索要并验证公钥。</p>
<p>（2） 双方协商生成”对话密钥”。</p>
<p>（3） 双方采用”对话密钥”进行加密通信。</p>
</blockquote>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p>
<p><strong>4.1 客户端发出请求（ClientHello）</strong></p>
<p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息。</p>
<blockquote>
<p>（1） 支持的协议版本，比如TLS 1.0版。</p>
<p>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。</p>
<p>（3） 支持的加密方法，比如RSA公钥加密。</p>
<p>（4） 支持的压缩方法。</p>
</blockquote>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个<a href="HTTP://tools.ietf.org/html/rfc4366" rel="external nofollow noopener noreferrer" target="_blank">Server Name Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p>
<p><strong>4.2 服务器回应（SeverHello）</strong></p>
<p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<blockquote>
<p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p>
<p>（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。</p>
<p>（3） 确认使用的加密方法，比如RSA公钥加密。</p>
<p>（4） 服务器证书。</p>
</blockquote>
<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<p><strong>4.3 客户端回应</strong></p>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<blockquote>
<p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</p>
<p>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
</blockquote>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，<a href="HTTP://blog.csdn.net/dog250/article/details/5717162" rel="external nofollow noopener noreferrer" target="_blank">dog250</a>解释得很好：</p>
<blockquote>
<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<p><strong>4.4 服务器的最后回应</strong></p>
<p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<blockquote>
<p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p>
<p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
</blockquote>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<p>参考文章：</p>
<p><a href="HTTPS://www.ruanyifeng.com/blog/2014/02/SSL_TLS.html" rel="external nofollow noopener noreferrer" target="_blank">HTTPS://www.ruanyifeng.com/blog/2014/02/SSL_TLS.html</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>微服务中的调用协议的发展</title>
    <url>/2021/04/14/invoking-protocols-in-microservices/</url>
    <content><![CDATA[<p>微服务现在大行其道，不同服务之间的调用方式也经过一系列的发展，这次我们就一起看看他们的发展过程，一起看不仅有利于统一理解，也有助于我们看清变化的原因。</p>
<p>我们就拿最简单的场景，客户端调用一个加法函数，将两个整数加起来，返回它们的和。如果放在本地调用，那是简单的不能再简单了，只要稍微学过一种编程语言，三下五除二就搞定了。</p>
<p>但是一旦变成了远程调用，门槛一下子就上去了。首先你要会 Socket 编程，至少先要把咱们这门网络协议课学一下，然后再看 N 本砖头厚的 Socket 程序设计的书，学会咱们学过的几种 Socket 程序设计的模型。这就使得本来大学毕业就能干的一项工作，变成了一件五年工作经验都不一定干好的工作，而且，搞定了 Socket 程序设计，才是万里长征的第一步。后面还有很多问题呢！</p>
<a id="more"></a>

<h2 id="远程调用需要解决的五个问题"><a href="#远程调用需要解决的五个问题" class="headerlink" title="远程调用需要解决的五个问题"></a>远程调用需要解决的五个问题</h2><h3 id="问题一：如何规定远程调用的语法？"><a href="#问题一：如何规定远程调用的语法？" class="headerlink" title="问题一：如何规定远程调用的语法？"></a>问题一：如何规定远程调用的语法？</h3><p>客户端如何告诉服务端，我是一个加法，而另一个是乘法。我是用字符串“add”传给你，还是传给你一个整数，比如 1 表示加法，2 表示乘法？服务端该如何告诉客户端，我的这个加法，目前只能加整数，不能加小数，不能加字符串；而另一个加法“add1”，它能实现小数和整数的混合加法。那返回值是什么？正确的时候返回什么，错误的时候又返回什么？</p>
<h3 id="问题二：如果传递参数？"><a href="#问题二：如果传递参数？" class="headerlink" title="问题二：如果传递参数？"></a>问题二：如果传递参数？</h3><p>我是先传两个整数，后传一个操作符“add”，还是先传操作符，再传两个整数？是不是像咱们数据结构里一样，如果都是 UDP，想要实现一个逆波兰表达式，放在一个报文里面还好，如果是 TCP，是一个流，在这个流里面，如何将两次调用进行分界？什么时候是头，什么时候是尾？把这次的参数和上次的参数混了起来，TCP 一端发送出去的数据，另外一端不一定能一下子全部读取出来。所以，怎么才算读完呢？</p>
<h3 id="问题三：如何表示数据？"><a href="#问题三：如何表示数据？" class="headerlink" title="问题三：如何表示数据？"></a>问题三：如何表示数据？</h3><p>在这个简单的例子中，传递的就是一个固定长度的 int 值，这种情况还好，如果是变长的类型，是一个结构体，甚至是一个类，应该怎么办呢？如果是 int，不同的平台上长度也不同，该怎么办呢？</p>
<h3 id="问题四：如何知道一个服务端都实现了哪些远程调用？"><a href="#问题四：如何知道一个服务端都实现了哪些远程调用？" class="headerlink" title="问题四：如何知道一个服务端都实现了哪些远程调用？"></a>问题四：如何知道一个服务端都实现了哪些远程调用？</h3><p>从哪个端口可以访问这个远程调用？假设服务端实现了多个远程调用，每个可能实现在不同的进程中，监听的端口也不一样，而且由于服务端都是自己实现的，不可能使用一个大家都公认的端口，而且有可能多个进程部署在一台机器上，大家需要抢占端口，为了防止冲突，往往使用随机端口，那客户端如何找到这些监听的端口呢？</p>
<h3 id="问题五：发生了错误、重传、丢包、性能等问题怎么办？"><a href="#问题五：发生了错误、重传、丢包、性能等问题怎么办？" class="headerlink" title="问题五：发生了错误、重传、丢包、性能等问题怎么办？"></a>问题五：发生了错误、重传、丢包、性能等问题怎么办？</h3><p>本地调用没有这个问题，但是一旦到网络上，这些问题都需要处理，因为网络是不可靠的，虽然在同一个连接中，我们还可通过 TCP 协议保证丢包、重传的问题，但是如果服务器崩溃了又重启，当前连接断开了，TCP 就保证不了了，需要应用自己进行重新调用，重新传输会不会同样的操作做两遍，远程调用性能会不会受影响呢？</p>
<h2 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h2><h3 id="协议约定问题"><a href="#协议约定问题" class="headerlink" title="协议约定问题"></a>协议约定问题</h3><p>一个大牛 Bruce Jay Nelson 写了一篇论文Implementing Remote Procedure Calls，定义了 RPC 的调用标准。后面所有 RPC 框架，都是按照这个标准模式来的。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1618400952/origin-of-ray/8534c52daf3682cd1cfe5a3375ec9525_ptfocq.jpg" alt></p>
<p>当客户端的应用想发起一个远程调用时，它实际是通过本地调用本地调用方的 Stub。它负责将调用的接口、方法和参数，通过约定的协议规范进行编码，并通过本地的 RPCRuntime 进行传输，将调用网络包发送到服务器。</p>
<p>服务器端的 RPCRuntime 收到请求后，交给提供方 Stub 进行解码，然后调用服务端的方法，服务端执行方法，返回结果，提供方 Stub 将返回结果编码后，发送给客户端，客户端的 RPCRuntime 收到结果，发给调用方 Stub 解码得到结果，返回给客户端。</p>
<p>这里面分了三个层次，对于用户层和服务端，都像是本地调用一样，专注于业务逻辑的处理就可以了。对于 Stub 层，处理双方约定好的语法、语义、封装、解封装。对于 RPCRuntime，主要处理高性能的传输，以及网络的错误和异常。</p>
<p>在 RPC 的调用过程中，所有的数据类型都要封装成类似的格式。而且 RPC 的调用和结果返回，也有严格的格式。</p>
<ul>
<li><p>XID 唯一标识一对请求和回复。请求为 0，回复为 1。</p>
</li>
<li><p>RPC 有版本号，两端要匹配 RPC 协议的版本号。如果不匹配，就会返回 Deny，原因就是 RPC_MISMATCH。</p>
</li>
<li><p>程序有编号。如果服务端找不到这个程序，就会返回 PROG_UNAVAIL。</p>
</li>
<li><p>程序有版本号。如果程序的版本号不匹配，就会返回 PROG_MISMATCH。</p>
</li>
<li><p>一个程序可以有多个方法，方法也有编号，如果找不到方法，就会返回 PROC_UNAVAIL。</p>
</li>
<li><p>调用需要认证鉴权，如果不通过，则 Deny。</p>
</li>
<li><p>最后是参数列表，如果参数无法解析，则返回 GABAGE_ARGS。</p>
</li>
</ul>
<p>在客户端，会调用 clnt_create 创建一个连接，然后调用 add_1，这是一个 Stub 函数，感觉是在调用本地一样。其实是这个函数发起了一个 RPC 调用，通过调用 clnt_call 来调用 ONC RPC 的类库，来真正发送请求。调用的过程非常复杂，一会儿我详细说这个。</p>
<p>当然服务端也有一个 Stub 程序，监听客户端的请求，当调用到达的时候，判断如果是 add，则调用真正的服务端逻辑，也即将两个数加起来。</p>
<p>服务端将结果返回服务端的 Stub，这个 Stub 程序发送结果给客户端，客户端的 Stub 程序正在等待结果，当结果到达客户端 Stub，就将结果返回给客户端的应用程序，从而完成整个调用过程。</p>
<p>有了这个 RPC 的框架，前面五个问题中的前三个“如何规定远程调用的语法？”“如何传递参数？”以及“如何表示数据？”基本解决了，这三个问题我们统称为<strong>协议约定问题</strong>。</p>
<h3 id="传输问题"><a href="#传输问题" class="headerlink" title="传输问题"></a>传输问题</h3><p>但是错误、重传、丢包、性能等问题还没有解决，这些问题我们统称为传输问题。这个就不用 Stub 操心了，而是由 ONC RPC 的类库来实现。这是大牛们实现的，我们只要调用就可以了。</p>
<h3 id="服务发现问题"><a href="#服务发现问题" class="headerlink" title="服务发现问题"></a>服务发现问题</h3><p>传输问题解决了，我们还遗留一个问题，就是问题四“如何找到 RPC 服务端的那个随机端口”。这个问题我们称为服务发现问题。在 ONC RPC 中，服务发现是通过 portmapper 实现的。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1618402636/origin-of-ray/2aff190d1f878749d2a5bd73228ca37c_fneugl.jpg" alt></p>
<p>portmapper 会启动在一个众所周知的端口上，RPC 程序由于是用户自己写的，会监听在一个随机端口上，但是 RPC 程序启动的时候，会向 portmapper 注册。客户端要访问 RPC 服务端这个程序的时候，首先查询 portmapper，获取 RPC 服务端程序的随机端口，然后向这个随机端口建立连接，开始 RPC 调用。从图中可以看出，mount 命令的 RPC 调用，就是这样实现的。</p>
]]></content>
  </entry>
  <entry>
    <title>IP地址与子网划分，以及与内网的区别</title>
    <url>/2020/03/21/ip_address/</url>
    <content><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="两级IP"><a href="#两级IP" class="headerlink" title="两级IP"></a>两级IP</h3><p>最开始的IP地址是由两个部分组成，即网络号和主机号，不同的网络号指定了该ip所属的网段，，它标志着主机或者路由器所连接到的网络，每个网络号在整个互联网中是唯一的。主机号则标志着该主机或路由器，每个主机号在所属的网络号中是唯一的。所以每个IP在互联网中都是唯一的。</p>
<p>这种IP地址叫做两级IP：</p>
<p>IP地址 = { &lt;网络号&gt;, &lt;主机号&gt; }</p>
<a id="more"></a>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1584758269/computer_network/581342-20170503163928117-1456880074_sbfcsp.png" alt="IP地址分类"></p>
<p>通过上图我们可以看出：</p>
<ul>
<li>A，B，C类地址的网络号分别为1，2，3个<strong>字节</strong>长，而网络号字段前面分别有1-3<strong>位</strong>的类别字段，其数值分别是0，10，110。</li>
<li>A，B，C类地址的主机号字段分别是3个，2个，1个字节长。</li>
<li>D类地址用于多播</li>
<li>E类地址保留。</li>
<li>A，B，C类的可以分配的地址是由网络号和主机号共同规定，大致上（全0和全1地址保留）依次是后者的两倍（差一位），但是一个A类地址中可以分配的地址数是B类地址的256倍，因为主机号的位数查了8位。</li>
</ul>
<p>当一个单位申请到一个IP地址时，实际上时申请到了具有相同网络号的一块地址，其中各主机号由该单位自己分配，只要不重复就好。</p>
<h3 id="两级IP的一些特点"><a href="#两级IP的一些特点" class="headerlink" title="两级IP的一些特点"></a>两级IP的一些特点</h3><ul>
<li>IP地址是一种分等级的地址结构，<strong>分为两级有两个好处</strong>，第一，IP地址管理机构在分配IP地址的时候只负责分配网络地址，剩下的主机号由由得到该网络号的单位自己分配。第二，<strong>路由器仅根据目的主机所连接的网络号来转发分组</strong>，这样就会大大减少路由器中需要保存的转发表的大小，以及查找路由所需要的时间。</li>
<li>IP地址实际上标志的是一台主机或者路由器的一个<strong>接口</strong>（与平时我们所说的端口不同），当一台主机接到两个网络上时，他就必须同时拥有两个IP地址，而且因为是两个网络，这两个IP地址的网络号必须不同，这种主机成为<strong>多归属主机</strong>。</li>
<li>按照互联网的观点，一个网络指的是具有相同网络号的主机的集合，<strong>用转发器或者网桥（工作在链路层）连接起来的若干个局域网任然属于同一个网络</strong>，因为这些局域网拥有相同的网络号，<strong>具有不同网络号的局域网必须用路由器相连</strong>。</li>
<li>所有的IP地址都是平等的。</li>
<li>同一个<strong>局域网内部的主机或者路由器的网络号必须相同</strong>。</li>
<li><strong>路由器总是具有两个或者以上的IP地址，且每个地址的网络号互不相同</strong>。</li>
<li>当两个路由器直接相连时，在连线两端的连个接口也可以不分配IP地址，这种叫做无编号网络。</li>
</ul>
<h3 id="IP地址与MAC地址"><a href="#IP地址与MAC地址" class="headerlink" title="IP地址与MAC地址"></a>IP地址与MAC地址</h3><p>MAC地址是链路层和物理层使用的，是基于物理现实的地址，是在设备出场时就已经固定好并且永远不会改变的，而IP地址则是逻辑上的地址，是当一个设备接入某个网络时动态分配的，在不同的网络中同一个设备的IP地址是不同的。</p>
<p>IP地址是放在IP数据报的首部，包括源地址和目的地址，在将IP数据包交给链路层时，网络层会利用<strong>ARP协议</strong>去查找目的地址的下一跳路由的MAC地址， 然后将其封装到MAC帧中交给链路层，链路层在根据MAC地址去转发MAC帧，在整个<strong>路由转发过程中，IP地址是始终不变的，但是MAC地址会不断通过去查找当前路由中目的IP的下一跳MAC地址去替换</strong>。</p>
<h2 id="三级IP地址与子网划分"><a href="#三级IP地址与子网划分" class="headerlink" title="三级IP地址与子网划分"></a>三级IP地址与子网划分</h2><p>刚才说了二级的IP地址，那么为什么还需要三级的IP地址呢？</p>
<ul>
<li><strong>IP地址空间的利用率有时候非常低</strong>，一个A类的地址，主机号有24位，可以分配的主机数多达1000万台，但是实际上很少有哪个单位会很好的去利用。</li>
<li><strong>两级IP地址不够灵活（注意，这里是不够灵活，而不是不够用，子网划分并不能解决IP地址不够）</strong>。有的时候，某个单位需要在一个新的地点开通一个新的网络，而在申请到一个新的网络号之前是不可能的。</li>
</ul>
<p>为了解决上述问题，在1985年，IP地址中有增加了一个<strong>子网号字段</strong>。使得二级IP地址变为三级。</p>
<p>划分子网的基本思路如下：</p>
<ul>
<li>一个拥有许多物理网络的单位，可以将所属的物理网络划分为多个子网，本单位以外的网络看不见整个网络是由多个子网构成的，因为这个单位的对外的网络号仍然是相同的，是同一个网络。</li>
<li>划分子网的方式是<strong>从主机号借用若干位作为子网号</strong>，同时主机号也减少了相应位数，于是二级IP地址在单位内部也从二级IP地址变成了三级IP地址。</li>
<li>从其他网络过来的数据报仍然是通过网络号来找到该单位所在的网络，进入该单位的网络后在根据子网号去找到目的子网。再由目的子网的路由器将数据包交给目的主机。</li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>从IP数据包的首部是没有办法看出源主机或者目的主机是否进行了子网划分，因为IP数据包的首部没有任何字段表示是否进行了子网划分，所以我们必须另想办法，那就是<strong>子网掩码</strong>。</p>
<p>使用子网掩码的好处很明显，那就是就算是二级IP地址也可以使用子网掩码的方法去获取目的IP的网络号。<strong>使用了子网掩码，通过二级或三级IP地址获取网络号的方法是相同的</strong>，就是将子网掩码的每一位与目的IP做“与”运算。</p>
<p>那么子网掩码是怎么计算出来的呢？其实很简单，就是所有的网络号（包括网络号和子网号）所占据的位为1，剩下的为0。</p>
<p>加入了子网划分之后，就需要再路由转发表中多维护一列子网掩码，<strong>现在的路由表中有三列，目的网络地址，子网掩码，下一跳地址</strong>，当一个数据包过来时，逐行将子网掩码与目的IP相与，结果如果和目的网络地址相同，则匹配成功，将该列的下一跳地址封装进MAC帧中。</p>
<h4 id="使用子网时的分组转发"><a href="#使用子网时的分组转发" class="headerlink" title="使用子网时的分组转发"></a>使用子网时的分组转发</h4><ol>
<li>从收到的数据报的首部中提取目的IP地址D。</li>
<li>首先判断是否为直接交付。对路由器直接相连的每个网络逐个进行检查：用各网络的子网掩码和D进行逐位相“与”，看结果是否和相应的网络地址匹配。如果匹配，则把分组直接交付（首先要利用匹配的这一条路由，将D转化为物理地址，再封装成MAC帧），完成任务，否则就是间接交付，执行3。</li>
<li>若路由表中有目的地址为D的特定主机路由，则把数据报直接交付给路由表中所指明的下一跳路由，否则执行4 。</li>
<li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码与D逐位相“与”，其结果为N，如果N和目的网络地址相匹配，则把数据包传给该行指明的下一跳地址。</li>
<li>如果路由表中有一个默认路由，则把数据报传送给默认路由，否则执行6 。</li>
<li>报告转发分组出现错误 。</li>
</ol>
<h2 id="子网与内网"><a href="#子网与内网" class="headerlink" title="子网与内网"></a>子网与内网</h2><p>刚才说到了，子网划分并不能解决IP地址不够的问题，那么什么技术才可以缓解IP地址不够的问题呢？这里就要说到<strong>NAT技术</strong>了。</p>
<h3 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h3><p>NAT技术简单来说就是将内网的IP（内网的IP地址都是公网IP所不适用的，如192.168.0.1）地址与公网IP进行映射，NAT也分为很多种，如静态映射，也就是一对一映射，这种方式内部有多少私有地址就需要多少外部地址，并不节省IP资源，第二种是，动态NAT，该协议维护一个外部IP的池，，当内部IP需要发送数据到外部时，动态分配一个外部IP给他，有点类似DHCP租用IP地址。第三种则是最有效的，也叫PAT，将内网的IP+端口映射为外网的IP+端口。</p>
<p>有兴趣的可以去看一下<a href="https://sunra.top/2019/12/20/nat-and-ddns/">NAT与内网穿透</a>。</p>
<h2 id="CIDR构造超网"><a href="#CIDR构造超网" class="headerlink" title="CIDR构造超网"></a>CIDR构造超网</h2><p>上面所讲的NAT是让内网中的多个主机共享一个公网IP，有点类似于开源，而CIDR则更偏向于节流，通过打破网络地址的分类，让网络地址不局限于ABC类，可以更灵活地为不同需求地单位分配不同长度网络号的网络地址号，来减少IP地址不必要的消耗。</p>
<p>早在RFC1009中就指出可以再子网中使用不同长度的子网掩码，叫做<strong>变长子网掩码(Variable Length Subnet Mask, VLSM)</strong>，在VLSM中基础上又研究出了<strong>无分类编址</strong>方法，正式的名字是<strong>无分类域间路由选择CIDR（Classless Inter-Domian Routing）</strong>。</p>
<p>CIDR最主要的两个特点：</p>
<ul>
<li><strong>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念</strong>，因而更加有效分配IPv4地址空间，因而能够更加有效地分配IPv4的地址空间，并且在新的IPv6使用之前容许互联网的规模持续增长。CIDR把32位的IP地址划分为前后两个部分，前面是<strong>网络前缀</strong>，用来指名网络，后面部分用来指明主机，因此<strong>CIDR使得IP地址又从三级变回了二级</strong>。</li>
<li>CIDR将<strong>网络前缀</strong>都相同的<strong>连续</strong>的IP地址组成<strong>CIDR地址块</strong>。</li>
</ul>
<p>CIDR也使用地址掩码，其作用和生成方式与子网掩码相同。</p>
<p>需要注意的是，所谓的CIDR不使用子网，指的是CIDR并没有在32为的地址中指明若干位为子网号。但是一旦分配到一个CIDR地址块，仍然可以在本单位内去划分子网。</p>
<p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合称为<strong>路由聚合</strong>，也可以叫做<strong>构成超网</strong>。</p>
<p>假设某个ISP有拥有地址块206.0.64.0/18，相当于有了64个C类网络，如果我们使用了CIDR就可以非常灵活地为不同需求的单位分配不同大小的地址块。同时如果不使用CIDR，那么与该ISP交换信息的每个路由器都需要保存该ISP的64个路由信息，但是有了CIDR的<strong>地址聚合</strong>，每个路由器只需要保存一个206.0.64.0/18就好。</p>
<p>当出现了地址聚合，那么就不可避免出现另一个问题，那就是有可能一个请求的目的地址可以在路由表中找到多个匹配项，这个时候我们就要使用<strong>最长前缀匹配</strong>的策略，顾名思义，就是选择匹配项目中前缀最长的路由。</p>
<h3 id="使用二叉搜索查找路由"><a href="#使用二叉搜索查找路由" class="headerlink" title="使用二叉搜索查找路由"></a>使用二叉搜索查找路由</h3><p>在使用了CIDR之后，由于要寻找最长前缀匹配，导致路由表的查找过程变得更加复杂，所以我们需要很好的数据结构和先进的快速查找方法。</p>
<p>其中最常用的就是<strong>二叉线索</strong>，在这个树结构中，IP地址中从左到右的比特值决定了从根节点逐层向下延伸的路径，而二叉线索中的各个路径就代表了路由表中存放的各个地址。</p>
<p>二叉线索树的构造过程也很简单，输入是当前路由表中的所有IP地址，我们找出每个IP地址的<strong>唯一前缀</strong>，所谓唯一前缀，指的是在表中所有的IP地址中，该前缀是唯一的，只要唯一前缀是匹配的，就只能找到唯一一条路由。</p>
<p>通过这种方式去构造二叉线索树，最大的深度是32层，也就是说必须使用32位才能在这个路由器的路由表中找到唯一一条路由。</p>
<p>当然，只是通过二叉线索树得到前缀匹配还不够，如果我们通过二叉线索树找到了唯一一条记录，还要去利用记录中的子网掩码和网络前缀来检验是否为目的地址的网络地址。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>程序员的数学（一）迭代法与数学归纳法</title>
    <url>/2020/12/26/iteration-and-induction/</url>
    <content><![CDATA[<h2 id="我想传递的是一种感觉"><a href="#我想传递的是一种感觉" class="headerlink" title="我想传递的是一种感觉"></a>我想传递的是一种感觉</h2><p>我一直和师弟师妹们说，一个知识，你不学出点哲学的意思，就不算了解它的原理，只停留在表面，别人说什么就是什么，永远停留在“器”的层面，也没法举一反三。</p>
<p>有的时候我们对一个知识点可以很容易地深入理解，有时候则需要和我们其他的知识点联系一下，你才能总结出它们之间的共性部分，也就是原理。</p>
<p>这次博客的内容也是这样的，我们初中的数学知识，数学归纳法。但不仅仅是数学归纳，还包括如何将其与我们平时的编程相互印证，找到二者的共性。</p>
<p>这次博客看起来很简单，但是我想传递的是一种感觉，一种思考方式。</p>
<a id="more"></a>

<p>首先我们先讲一个我们初中学习指数的时候，数学老师为了让我们理解指数爆炸的威力时举的一个例子：</p>
<blockquote>
<p>古印度国王舍罕酷爱下棋，他打算重赏国际象棋的发明人宰相西萨·班·达依尔。这位聪明的大臣指着象棋盘对国王说：“陛下，我不要别的赏赐，请您在这张棋盘的第一个小格内放入一粒麦子，在第二个小格内放入两粒，第三小格内放入给四粒，以此类推，每一小格内都比前一小格加一倍的麦子，直至放满 64 个格子，然后将棋盘上所有的麦粒都赏给您的仆人我吧！”</p>
</blockquote>
<p>听过这个故事的应该都知道，如果真的按照这个方法赏赐，当时整个印度未来50年的所有税收都不够。</p>
<p>放满这 64 格到底需要多少粒麦子呢？这是个相当相当大的数字，想要手动算出结果并不容易。如果你觉得自己厉害，可以试着拿笔算算。其实，这整个算麦粒的过程，在数学上，是有对应方法的，这也正是我们今天要讲的第一个概念：<strong>迭代法（Iterative Method）</strong>。</p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><h3 id="到底什么是迭代法？"><a href="#到底什么是迭代法？" class="headerlink" title="到底什么是迭代法？"></a>到底什么是迭代法？</h3><p><strong>迭代法，简单来说，其实就是不断地用旧的变量值，递推计算新的变量值。</strong></p>
<p>我这么说可能还是比较抽象，不容易理解。我们还回到刚才的故事。大臣要求每一格的麦子都是前一格的两倍，那么前一格里麦子的数量就是旧的变量值，我们可以先记作 Xn−1；而当前格子里麦子的数量就是新的变量值，我们记作 Xn。这两个变量的递推关系就是这样的：f(n) = f(n - 1) * 2</p>
<p>如果你稍微有点编程经验，应该能发现，迭代法的思想，很容易通过计算机语言中的循环语言来实现。你知道，计算机本身就适合做重复性的工作，我们可以通过循环语句，让计算机重复执行迭代中的递推步骤，然后推导出变量的最终值。</p>
<p>具体怎么实现我就不放代码了，很简单。</p>
<h3 id="迭代法有什么具体应用？"><a href="#迭代法有什么具体应用？" class="headerlink" title="迭代法有什么具体应用？"></a>迭代法有什么具体应用？</h3><p>看到这里，你可能大概已经理解迭代法的核心理念了。迭代法在无论是在数学，还是计算机领域都有很广泛的应用。大体上，迭代法可以运用在以下几个方面：</p>
<ul>
<li><p><strong>求数值的精确或者近似解</strong>。典型的方法包括二分法（Bisection method）和牛顿迭代法（Newton’s method）。</p>
</li>
<li><p><strong>在一定范围内查找目标值</strong>。典型的方法包括二分查找。</p>
</li>
<li><p><strong>机器学习算法中的迭代</strong>。相关的算法或者模型有很多，比如 K- 均值算法（K-means clustering）、PageRank 的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。</p>
</li>
</ul>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><h3 id="什么是数学归纳法？"><a href="#什么是数学归纳法？" class="headerlink" title="什么是数学归纳法？"></a>什么是数学归纳法？</h3><p>上节我们提到，在棋盘上放麦粒的规则是，第一格放一粒，第二格放两粒，以此类推，每一小格内都比前一小格多一倍的麦子，直至放满 64 个格子。</p>
<p>我们假想一下自己穿越到了古印度，正站在国王的身边，看着这个棋盘，你发现第 1 格到第 8 格的麦子数分别是：1、2、4、8、16、32、64、128。<strong>这个时候，国王想知道总共需要多少粒麦子。</strong></p>
<p>如果按照刚才迭代法的思想，我们需要循环64次，计算出每个格子的数量，然后相加。</p>
<p>那我们能不能试着找出一个规律，让我们直接求出总数来。</p>
<p>我们是不是可以大胆假设，前 n 个格子的麦粒总数就是 2n−1 呢？如果这个假设成立，那么填满 64 格需要的麦粒总数，就是 1+2+22+23+24+……＋263＝264−1＝18446744073709551615。</p>
<p>这个假设是否成立，我们还有待验证。但是对于类似这种无穷数列的问题，我们通常可以采用<strong>数学归纳法（Mathematical Induction）</strong>来证明。</p>
<p>在数论中，数学归纳法用来证明任意一个给定的情形都是正确的，也就是说，第一个、第二个、第三个，一直到所有情形，概不例外。</p>
<h3 id="数学归纳法的一般步骤"><a href="#数学归纳法的一般步骤" class="headerlink" title="数学归纳法的一般步骤"></a>数学归纳法的一般步骤</h3><ul>
<li><p>证明基本情况（通常是 n=1 的时候）是否成立；</p>
</li>
<li><p>假设 n=k−1 成立，再证明 n=k 也是成立的（k 为任意大于 1 的自然数）。只要学过数学，我想你对这个步骤都不陌生。但是，现在你需要牢记这个步骤，然后我们用这个步骤来证明下开头的例子。</p>
</li>
</ul>
<h4 id="如何解决这个题目"><a href="#如何解决这个题目" class="headerlink" title="如何解决这个题目"></a>如何解决这个题目</h4><p>为了让你更好地理解，我将原有的命题分为两个子命题来证明。第一个子命题是，第 n 个棋格放的麦粒数为 2n−1。第二个子命题是，前 n 个棋格放的麦粒数总和为 2n−1。</p>
<p>首先，我们来证明第一个子命题。</p>
<ul>
<li><p>基本情况：我们已经验证了 n=1 的时候，第一格内的麦粒数为 1，和 21−1 相等。因此，命题在 k=1 的时候成立。</p>
</li>
<li><p>假设第 k−1 格的麦粒数为 2k−2。那么第 k 格的麦粒数为第 k−1 格的 2 倍，也就是 2k−2∗2=2k−1。因此，如果命题在 k=n−1 的时候成立，那么在 k=n 的时候也成立。</p>
</li>
</ul>
<p>所以，第一个子命题成立。在这个基础之上，我再来证明第二个子命题。</p>
<ul>
<li><p>基本情况：我们已经验证了 n=1 的时候，所有格子的麦粒总数为 1。因此命题在 k=1 的时候成立。</p>
</li>
<li><p>假设前 k−1 格的麦粒总数为 2k−1−1，基于前一个命题的结论，第 k 格的麦粒数为 2k−1。那么前 k 格的麦粒总数为 (2k−1−1)+(2k−1)=2∗2k−1−1=2k−1。</p>
</li>
</ul>
<p>因此，如果命题在 k=n−1 的时候成立，那么在 k=n 的时候也成立。说到这里，我已经证明了这两个命题都是成立的。<strong>和使用迭代法的计算相比，数学归纳法最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正确的，就没有必要进行逐步的推算，可以节省很多时间和资源</strong>。</p>
<h3 id="递归调用和数学归纳的逻辑是相同的"><a href="#递归调用和数学归纳的逻辑是相同的" class="headerlink" title="递归调用和数学归纳的逻辑是相同的"></a>递归调用和数学归纳的逻辑是相同的</h3><p>不知道大家发现没有，其实我们数学归纳的证明过程类似于递归调用的过程。</p>
<p>但只是过程和思想相似，其实还是有细微的差别，比如我们例子这种归纳出来的结果只和n有关，这种就可以直接求取，有的则不仅和n有关，比如斐波那契数列这种，那就需要用到迭代法了，只不过我们可以用动态规划的思想去优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再重复一下我想传递的思想：</p>
<p><strong>一个知识，你不学出点哲学的意思，就不算了解它的原理，只停留在表面，别人说什么就是什么，永远停留在“器”的层面，也没法举一反三。</strong></p>
<p>迭代法和数学归纳是我们初中的基础数学知识，也是我们编程中常用的思想，只是我们可能没有意识到。</p>
<p>计算机擅长做重复性问题，一般遇到重复性问题：</p>
<ul>
<li>我们第一反应就是用循环，这就是很朴素的迭代法思想。</li>
<li>但是我们可以在迭代的基础上考虑下能不能用数学归纳的思想总结出第n次的结果，因为一般用迭代解决的都可以用递归解决，而<strong>数学归纳的证明过程就是递归的过程</strong>。</li>
<li>如果总结出的<strong>结果只与n有关，我们就可以跳过n次循环</strong>，直接得出结果。</li>
<li>如果不可以，我们可以考虑<strong>用动态规划来减少迭代中的重复计算</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>iteator</title>
    <url>/2019/10/12/iterator/</url>
    <content><![CDATA[<h3 id="什么是迭代器（Iterator）？"><a href="#什么是迭代器（Iterator）？" class="headerlink" title="什么是迭代器（Iterator）？"></a>什么是迭代器（Iterator）？</h3><p>迭代器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<p>迭代器是一个拥有next()方法的特殊对象，每次调用next()都返回一个结果对象。这个对象有两个键值对，分别是value和done，value就是迭代器每次返回的结果，而done则标志着迭代器是否结束。我们可以用es5的语法来模拟一个迭代器。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>
<p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p>
<p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p>
<p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p>
<p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。</p>
<h3 id="可迭代（Iterable）对象"><a href="#可迭代（Iterable）对象" class="headerlink" title="可迭代（Iterable）对象"></a>可迭代（Iterable）对象</h3><p>在es6中，所有的集合对象（数组，set，map）还有字符串都是可迭代对象，而可迭代对象都绑定了默认的迭代器，我们可以使用es6的新语法<code>for-of</code> 来使用这些迭代器。<br><code>for-of</code>循环，可作用在可迭代对象上，正是利用了可迭代对象上的默认迭代器。大致过程是：<code>for-of</code>循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在变量中，循环将继续执行这一过程直到返回对象的<code>done</code>属性的值为<code>true</code>。</p>
<h4 id="访问默认的迭代器"><a href="#访问默认的迭代器" class="headerlink" title="访问默认的迭代器"></a>访问默认的迭代器</h4><p>可迭代对象，都有一个Symbol.iterator方法(不知道Symbol是什么的可以看一下<a href="http://es6.ruanyifeng.com/#docs/symbol" rel="external nofollow noopener noreferrer" target="_blank">Symbol</a>)，<code>for-of</code>循环时，通过调用<code>colors</code>数组的Symbol.iterator方法来获取默认迭代器的，这一过程是在<code>JavaScript</code>引擎背后完成的。</p>
<p>我们可以主动获取一下这个默认迭代器来感受一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 1, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 2, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 3, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: undefined, done: true&#125;"</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，通过Symbol.iterator获取了数组values的默认迭代器，并用它遍历数组中的元素。在JavaScript引擎中执行for-of循环语句也是类似的处理过程。</p>
<p>用Symbol.iterator属性来检测对象是否为可迭代对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterator</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h4><p>当我们在创建对象时，<strong>给Symbol.iterator属性添加一个生成器</strong>，则可以将其变成可迭代对象：</p>
<p>这里不用担心在for-of的时候会把迭代器也给遍历出来。</p>
<p>可以看到我们自定义的可迭代对象其实就是添加了键值为Symbol.iterator的函数，该函数就是在利用items这个array默认的迭代器。</p>
<p>当我们在collection上调用for-of的时候，其实就是调用collection的Symbol.iterator函数。</p>
<p><strong>综上所述，其实一个对象是否可迭代就是看它有没有一个Symbol.iterator函数子对象，默认情况下数组，集合，字符串有，所以他们可以直接使用for-of,但是当我们给一个对象添加Symbol.iterator函数时，它也可以调用for-of</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123; <span class="comment">// 将生成器赋值给对象的Symbol.iterator属性来创建默认的迭代器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>);</span><br><span class="line">collection.items.push(<span class="number">2</span>);</span><br><span class="line">collection.items.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h4><p><code>ES6</code>中的集合对象，数组、<code>Set</code>集合和<code>Map</code>集合，都内建了三种迭代器：</p>
<ul>
<li>entries() 返回一个迭代器，其值为多个键值对。<br>如果是数组，第一个元素是索引位置；如果是<code>Set</code>集合，第一个元素与第二个元素一样，都是值。</li>
<li>values() 返回一个迭代器，其值为集合的值。</li>
<li>keys() 返回一个迭代器，其值为集合中的所有键名。<br>如果是数组，返回的是索引；如果是<code>Set</code>集合，返回的是值（<code>Set</code>的值被同时用作键和值）。</li>
</ul>
<h4 id="默认迭代器"><a href="#默认迭代器" class="headerlink" title="默认迭代器"></a>默认迭代器</h4><p>每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显式指定则使用默认的迭代器。按常规使用习惯，我们很容易猜到，数组和<code>Set</code>集合的默认迭代器是values()，<code>Map</code>集合的默认迭代器是entries()。</p>
<h3 id="调用迭代器的场合"><a href="#调用迭代器的场合" class="headerlink" title="调用迭代器的场合"></a>调用迭代器的场合</h3><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><strong>解构赋值</strong></h4><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x,y] = <span class="keyword">set</span>;</span><br><span class="line">// x='a'; y='b'</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = <span class="keyword">set</span>;</span><br><span class="line">// first='a'; rest=['b','c'];</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a><strong>扩展运算符</strong></h4><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] <span class="comment">//  ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>

<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure>

<h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a><strong>yield*</strong></h4><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a><strong>其他场合</strong></h4><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h3 id="迭代器的高级功能"><a href="#迭代器的高级功能" class="headerlink" title="迭代器的高级功能"></a>迭代器的高级功能</h3><h4 id="给迭代器传参"><a href="#给迭代器传参" class="headerlink" title="给迭代器传参"></a>给迭代器传参</h4><p>前面我们看到，在迭代器内部使用yield关键字可以生成值，在外面可以用迭代器的next()方法获得返回值。<br>其实next()方法还可以接收参数，这个参数的值就会代替生成器内部上一条yield语句的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;  <span class="comment">// 4 + 2</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;  <span class="comment">// 5 + 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">// "&#123; value: 6, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)); <span class="comment">// "&#123; value: 8, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h3><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p>
<p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.close();</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next</code>方法，还部署了<code>return</code>方法。下面的两种情况，都会触发执行<code>return</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return</code>方法，关闭这个文件；情况二会在执行<code>return</code>方法关闭文件之后，再抛出错误。</p>
<p>注意，<code>return</code>方法必须返回一个对象，这是 Generator 规格决定的。</p>
<p><code>throw</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</p>
<h3 id="什么是生成器（Generator）？"><a href="#什么是生成器（Generator）？" class="headerlink" title="什么是生成器（Generator）？"></a>什么是生成器（Generator）？</h3><p>生成器其实就是es6语法提供给我们的封装好的语法糖，它的效果与刚才我们模拟实现的迭代器大致相同，但是有了生成器，我们就不必每次都自己实现迭代器。</p>
<p><strong>生成器是一种返回迭代器的函数</strong>，通过<code>function</code>关键字后的星号（*）来表示，函数中会用到新的关键字<code>yield</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然生成器返回的是迭代器，自然就可以调用迭代器的next()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 1, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 2, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: 3, done: false&#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: undefiend, done: true&#125;"</span></span><br><span class="line"><span class="comment">// 之后所有的调用都会返回相同内容</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">// "&#123; value: undefiend, done: true&#125;"</span></span><br></pre></td></tr></table></figure>

<p>上面，我们用<code>ES6</code>的生成器，大大简化了迭代器的创建过程。我们给生成器函数createIterator()传入一个items数组，函数内部，for循环不断从数组中生成新的元素放入迭代器中，每遇到一个<code>yield</code>语句循环都会停止；每次调用迭代器的next()方法，循环便继续运行并停止在下一条<code>yield</code>语句处。</p>
<h4 id="生成器的创建方式"><a href="#生成器的创建方式" class="headerlink" title="生成器的创建方式"></a>生成器的创建方式</h4><p>生成器是个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>可以用函数表达式方式书写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">item</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>也可以添加到对象中，<code>ES5</code>风格对象字面量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p><code>ES6</code>风格的对象方法简写方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    *createIterator(items) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://es6.ruanyifeng.com/#docs/generator" rel="external nofollow noopener noreferrer" target="_blank">https://es6.ruanyifeng.com/#docs/generator</a></p>
<p><a href="https://segmentfault.com/a/1190000010747122" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000010747122</a></p>
<p><a href="https://es6.ruanyifeng.com/#docs/iterator" rel="external nofollow noopener noreferrer" target="_blank">https://es6.ruanyifeng.com/#docs/iterator</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（九）阶段总结</title>
    <url>/2021/08/15/javascript-conclusion/</url>
    <content><![CDATA[<p>Google V8是如何执行一段JavaScript代码的</p>
<p>本文主要是对一些老生常谈的JavaScript特性进行一个简单的统一的总结，并对于V8如何实现这些特性的进行一定的解释。</p>
<p>主要目的是通过介绍V8的执行流程将耳熟能详的特性串到一起，形成一个整体的认知，以及为什么JavaScript要这样设计。</p>
<p>中间会穿插一些思考，比如，我们在编码中应该避免的一些问题。</p>
<a id="more"></a>

<h2 id="V8如何执行JavaScript"><a href="#V8如何执行JavaScript" class="headerlink" title="V8如何执行JavaScript"></a>V8如何执行JavaScript</h2><h3 id="高级语言执行的两种方式"><a href="#高级语言执行的两种方式" class="headerlink" title="高级语言执行的两种方式"></a>高级语言执行的两种方式</h3><p>一段代码最终是要变成CPU能够识别的二进制代码才能够运行的。</p>
<p>所以高级语言的代码必须进行编译才能够被执行。</p>
<p>但是执行方式有两种，第一种是解释执行，一种是编译执行</p>
<blockquote>
<p>注意，这里的解释执行和编译执行与平时所说的解释性语言和编译性语言不完全一样：<a href="https://www.huaweicloud.com/articles/a3b99542fd3f5b563f191340a39eb478.html" rel="external nofollow noopener noreferrer" target="_blank">解释性语言和编译性语言的区别 - 华为云</a></p>
</blockquote>
<p>所谓解释执行，指的是解析器将高级语言解析为中间代码，然后由语言自带的虚拟机去模拟CPU的堆栈等特性去执行这个中间代码。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629333912/origin-of-ray/image_i6nsuc.png" alt="img"></p>
<p>所谓编译执行，指的是编译器再将中间代码编译为二进制代码，然后直接交给CPU去执行。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629333910/origin-of-ray/image_1_brpduf.png" alt="img"></p>
<p>我们看起来只能选一种，但是V8表示，小孩子才做选择，我全都要。</p>
<p>V8采取的是是一种混合使用编译器和解释器的JIT（Just In Time）的技术，这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参考下面完整的 V8 执行 JavaScript 的流程图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629333911/origin-of-ray/image_2_oggn7i.png" alt="img"></p>
<p>V8启动后，会从内存中申请堆和栈的内存空间。栈的存储是连续的，而堆中的数据存储可以是不连续的。</p>
<p>然后V8会初始化全局上下文，内部包含很多的信息，比如当前上下文的变量环境，这个变量环境中全局作用域中的变量。</p>
<p>初始化事件循环系统。其实就是一个消息队列，而这个消息队列中的每一个函数就是我们平时所说的宏任务。</p>
<h3 id="V8为什么要用字节码"><a href="#V8为什么要用字节码" class="headerlink" title="V8为什么要用字节码"></a>V8为什么要用字节码</h3><p>所谓字节码，是指编译过程中的中间代码，你可以把字节码看成是机器代码的抽象，在 V8 中，字节码有两个作用：</p>
<ul>
<li>第一个是解释器可以直接解释执行字节码 ;</li>
<li>第二个是优化编译器可以将字节码编译为二进制代码，然后再执行二进制机器代码。</li>
</ul>
<p>虽然目前的架构使用了字节码，不过早期的 V8 并不是这样设计的，那时候 V8 团队认为这种“先生成字节码再执行字节码”的方式，多了个中间环节，多出来的中间环节会牺牲代码的执行速度。</p>
<p>早期的 V8 为了提升代码的执行速度，直接将 JavaScript 源代码编译成了没有优化的二进制的机器代码，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为热点代码，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。</p>
<p>当 JavaScript 代码在浏览器中被执行的时候，需要先被 V8 编译，早期的 V8 会将 JavaScript 编译成未经优化的二进制机器代码，然后再执行这些未优化的二进制代码，通常情况下，编译占用了很大一部分时间，下面是一段代码的编译和执行时间图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629333910/origin-of-ray/34853ef8-c9f1-4b94-b697-128e4aeb7ef0_ktq7xf.png" alt="img"></p>
<p>从图中可以看出，编译所消耗的时间和执行所消耗的时间是差不多的，试想一下，如果在浏览器中再次打开相同的页面，当页面中的 JavaScript 文件没有被修改，那么再次编译之后的二进制代码也会保持不变， 这意味着编译这一步白白浪费了 CPU 资源，因为之前已经编译过一次了。</p>
<p>这就是 Chrome 浏览器引入二进制代码缓存的原因，通过把二进制代码保存在内存中来消除冗余的编译，重用它们完成后续的调用，这样就省去了再次编译的时间。</p>
<p>不过随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两个致命的问题：</p>
<ul>
<li>时间问题：编译时间过久，影响代码启动速度；</li>
<li>空间问题：缓存编译后的二进制代码占用更多的内存。</li>
</ul>
<p>这两个问题无疑会阻碍 V8 在移动设备上的普及，于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：</p>
<ul>
<li>解决启动问题：生成字节码的时间很短；</li>
<li>解决空间问题：字节码占用内存不多，缓存字节码会大大降低内存的使用；</li>
<li>代码架构清晰：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。</li>
</ul>
<h2 id="变量：如何存储以及如何快速查找"><a href="#变量：如何存储以及如何快速查找" class="headerlink" title="变量：如何存储以及如何快速查找"></a>变量：如何存储以及如何快速查找</h2><h3 id="作用域提升：没有块级上下文，那就不设计块级作用域"><a href="#作用域提升：没有块级上下文，那就不设计块级作用域" class="headerlink" title="作用域提升：没有块级上下文，那就不设计块级作用域"></a>作用域提升：没有块级上下文，那就不设计块级作用域</h3><p><a href="https://sunra.top/2020/11/20/javascript-variable-promotion/">Javascript执行机制（一）变量提升</a></p>
<p>存在作用域提升的原因在于，JavaScript在创造的时候用时很短，只有全局作用域和函数作用域对于编译来说比较简单。</p>
<p>为什么这么说呢？我们可以看一下栈就明白了，JavaScript的调用栈中只有全局上下文和函数上下文，天然就可以映射到全局作用域和函数作用域。</p>
<blockquote>
<p>没有块级上下文，就不设计块级作用域。</p>
</blockquote>
<blockquote>
<p>那既然这个变量的作用域是函数级别的，那就要整个函数都能访问到，所以变量提升</p>
</blockquote>
<p>“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。<strong>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong>。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615119851/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210307201954_os3t8h.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615119851/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210307201954_os3t8h.png"></p>
<h3 id="作用域：加入块级作用域，如何在当前上下文中找到变量"><a href="#作用域：加入块级作用域，如何在当前上下文中找到变量" class="headerlink" title="作用域：加入块级作用域，如何在当前上下文中找到变量"></a>作用域：加入块级作用域，如何在当前上下文中找到变量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036133/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204157_g15aka.png" alt></p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJhN2M2N2Q4ZTgyYzJjYWNhMDg3ZmJhMWUxOGY4ZmJfUWRVNGxYYzJCRG1pQ1Z0dUdvUUt5OEltcXdoUWxNSG5fVG9rZW46Ym94Y252NlpHTGM5U3pURUV0Nzh3bFRFS0djXzE2MjkzMzM5NzI6MTYyOTMzNzU3Ml9WNA" alt="img"></p>
<p><a href="https://sunra.top/2020/11/22/javascript-scope/">Javascript执行机制（二）作用域</a></p>
<h3 id="作用域链：如果在当前上下文找不到，如何在调用栈中找到变量"><a href="#作用域链：如果在当前上下文找不到，如何在调用栈中找到变量" class="headerlink" title="作用域链：如果在当前上下文找不到，如何在调用栈中找到变量"></a>作用域链：如果在当前上下文找不到，如何在调用栈中找到变量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"大树"</span></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"bigTree"</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615206965/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308203554_ww6kdz.png" alt></p>
<h3 id="找到变量后，如何在一个变量本身上找到一个属性"><a href="#找到变量后，如何在一个变量本身上找到一个属性" class="headerlink" title="找到变量后，如何在一个变量本身上找到一个属性"></a>找到变量后，如何在一个变量本身上找到一个属性</h3><p><a href="https://sunra.top/2021/07/27/javascript-obj-attr-search/">Javascript执行机制（七）如何快速查找对象上的属性</a></p>
<h3 id="原型链：如果变量本身没有该属性，去哪里找"><a href="#原型链：如果变量本身没有该属性，去哪里找" class="headerlink" title="原型链：如果变量本身没有该属性，去哪里找"></a>原型链：如果变量本身没有该属性，去哪里找</h3><p><a href="https://sunra.top/2020/12/10/javascript-prototype/">Javascript执行机制（五）用公式讲清楚原型链</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>const a = new A(); 那么 a.<code>__proto__</code> === A.prototype(Object.prototype.<code>__proto__</code> === null特殊)</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203215_aj5gbh.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(); <span class="comment">// 因为</span></span><br><span class="line">p1.__proto__ === Parent.prototype; <span class="comment">// 所以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">Parent.__proto__ === Fuction.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span> = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line">所有的prototype都是普通对象，也就是都是<span class="keyword">new</span> <span class="built_in">Object</span>()而来</span><br><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br><span class="line"></span><br><span class="line">因为<span class="built_in">Object</span>, <span class="built_in">Function</span>可以放在<span class="keyword">new</span>后面，所以也是个构造函数，也就是说<span class="built_in">Object</span> = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>

<h4 id="思考：原型链会带来什么代码安全问题？"><a href="#思考：原型链会带来什么代码安全问题？" class="headerlink" title="思考：原型链会带来什么代码安全问题？"></a>思考：原型链会带来什么代码安全问题？</h4><p><a href="https://juejin.cn/post/6963950629240733727" rel="external nofollow noopener noreferrer" target="_blank">前端原型链污染漏洞竟可以拿下服务器shell?</a></p>
<h3 id="变量存在哪里？堆？栈？"><a href="#变量存在哪里？堆？栈？" class="headerlink" title="变量存在哪里？堆？栈？"></a>变量存在哪里？堆？栈？</h3><p>普通类型存在调用栈中，对象，函数存在堆中？？？？？？</p>
<blockquote>
<p>如果普通类型就是存在栈上，那闭包怎么实现？</p>
</blockquote>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>this就是个指针，存的是变量的地址，就像一个普通对象变量中存的是对象在堆中的地址一样</p>
<p><a href="https://sunra.top/2020/12/10/javascript-this/">Javascript执行机制（四）this指向的是什么？</a></p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>第一步，通过 GC Root 标记空间中活动对象和非活动对象‘目前 V8 采用的可访问性（reachability）算法来判断堆中的对象是否是活动对象。</p>
<p>第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>第三步，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>
<p>目前 V8 采用了两个垃圾回收器，主垃圾回收器 -Major GC 和副垃圾回收器 -Minor GC (Scavenger)。V8 之所以使用了两个垃圾回收器，主要是受到了代际假说（The Generational Hypothesis）的影响。</p>
<ul>
<li>第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。</li>
</ul>
<p>所以，在 V8 中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。</p>
<p>新生代通常只支持 1～8M 的容量，而老生代支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<p>副垃圾回收器 -Minor GC (Scavenger)，主要负责新生代的垃圾回收。主垃圾回收器 -Major GC，主要负责老生代的垃圾回收。</p>
<p><a href="https://sunra.top/2021/08/04/javascript-gc/">Javascript执行机制（八）垃圾回收机制</a></p>
<h3 id="思考：几种常见的内存问题"><a href="#思考：几种常见的内存问题" class="headerlink" title="思考：几种常见的内存问题"></a>思考：几种常见的内存问题</h3><p>内存问题可以定义为下面这三类：</p>
<ul>
<li>内存泄漏 (Memory leak)，它会导致页面的性能越来越差；</li>
<li>内存膨胀 (Memory bloat)，它会导致页面的性能会一直很差；</li>
<li>频繁垃圾回收，它会导致页面出现延迟或者经常暂停。</li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>本质上，内存泄漏可以定义为：当进程不再需要某些内存的时候，这些不再被需要的内存依然没有被进程回收。在 JavaScript 中，造成内存泄漏 (Memory leak) 的主要原因是不再需要 (没有作用) 的内存数据依然被其他对象引用着。</p>
<ol>
<li>将数据挂载到window上</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个临时的temp_array</span></span><br><span class="line">    temp_array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">200000</span>)</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用temp_array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行这段代码时，由于函数体内的对象没有被 var、let、const 这些关键字声明，那么 V8 就会使用 this.temp_array 替换 temp_array。</p>
<p>在浏览器，默认情况下，this 是指向 window 对象的，而 window 对象是常驻内存的，所以即便 foo 函数退出了，但是 temp_array 依然被 window 对象引用了， 所以 temp_array 依然也会和 window 对象一样，会常驻内存。因为 temp_array 已经是不再被使用的对象了，但是依然被 window 对象引用了，这就造成了 temp_array 的泄漏。</p>
<ol>
<li>闭包</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp_object = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    temp_object.x = <span class="number">1</span></span><br><span class="line">    temp_object.y = <span class="number">2</span></span><br><span class="line">    temp_object.array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">200000</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *   使用temp_object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(temp_object.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，foo 函数使用了一个局部临时变量 temp_object，temp_object 对象有三个属性，x、y，还有一个非常占用内存的 array 属性。最后 foo 函数返回了一个匿名函数，该匿名函数引用了 temp_object.x。那么当调用完 foo 函数之后，由于返回的匿名函数引用了 foo 函数中的 temp_object.x，这会造成 temp_object 无法被销毁，即便只是引用了 temp_object.x，也会造成整个 temp_object 对象依然保留在内存中。</p>
<p>要解决这个问题，我就需要根据实际情况，来判断闭包中返回的函数到底需要引用什么数据，不需要引用的数据就绝不引用，因为上面例子中，返回函数中只需要 temp_object.x 的值，因此我们可以这样改造下这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp_object = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    temp_object.x = <span class="number">1</span></span><br><span class="line">    temp_object.y = <span class="number">2</span></span><br><span class="line">    temp_object.array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">200000</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *   使用temp_object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">let</span> closure = temp_object.x</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(closure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>detached ”节点</li>
</ol>
<p>由于 JavaScript 引用了 DOM 节点而造成的内存泄漏的问题，只有同时满足 DOM 树和 JavaScript 代码都不引用某个 DOM 节点，该节点才会被作为垃圾进行回收。 如果某个节点已从 DOM 树移除，但 JavaScript 仍然引用它，我们称此节点为“detached ”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> detachedTree;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line">        ul.appendChild(li);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    detachedTree = ul;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create()</span><br></pre></td></tr></table></figure>

<h4 id="内存膨胀"><a href="#内存膨胀" class="headerlink" title="内存膨胀"></a>内存膨胀</h4><p>内存膨胀和内存泄漏有一些差异，内存膨胀主要表现在程序员对内存管理的不科学，比如只需要 50M 内存就可以搞定的，有些程序员却花费了 500M 内存。</p>
<p>额外使用过多的内存有可能是没有充分地利用好缓存，也有可能加载了一些不必要的资源。通常表现为内存在某一段时间内快速增长，然后达到一个平稳的峰值继续运行。</p>
<h4 id="频繁的垃圾回收"><a href="#频繁的垃圾回收" class="headerlink" title="频繁的垃圾回收"></a>频繁的垃圾回收</h4><p>除了内存泄漏和内存膨胀，还有另外一类内存问题，那就是频繁使用大的临时变量，导致了新生代空间很快被装满，从而频繁触发垃圾回收。频繁的垃圾回收操作会让你感觉到页面卡顿。比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strToArray</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> len = str.length</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(str.length)</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; len; ++i) &#123;</span><br><span class="line">    arr[i] = str.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">'test V8 GC'</span></span><br><span class="line">  <span class="keyword">while</span> (i++ &lt; <span class="number">1e5</span>) &#123;</span><br><span class="line">    strToArray(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>这段代码就会频繁创建临时变量，这种方式很快就会造成新生代内存内装满，从而频繁触发垃圾回收。为了解决频繁的垃圾回收的问题，你可以考虑将这些临时变量设置为上层作用域的变量。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为什么函数在JavaScript是一等公民。"><a href="#为什么函数在JavaScript是一等公民。" class="headerlink" title="为什么函数在JavaScript是一等公民。"></a>为什么函数在JavaScript是一等公民。</h3><p>如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。</p>
<ul>
<li>函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值；</li>
<li>函数之所以成为特殊的对象，这个特殊的地方是函数可以“被调用”，所以一个函数被调用时，它还需要关联相关的执行上下文。</li>
</ul>
<p>基于函数是一等公民的设计，使得 JavaScript 非常容易实现一些特性，比如闭包，还有函数式编程等，而其他语言要实现这些特性就显得比较困难。</p>
<h3 id="延迟解析与闭包"><a href="#延迟解析与闭包" class="headerlink" title="延迟解析与闭包"></a>延迟解析与闭包</h3><h4 id="延迟解析"><a href="#延迟解析" class="headerlink" title="延迟解析"></a>延迟解析</h4><p>在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：</p>
<ul>
<li>首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li>
<li>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> f = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> d + f + a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>当把这段代码交给 V8 处理时，V8 会自上而下解析这段代码，在解析过程中首先会遇到 foo 函数，由于这只是一个函数声明语句，V8 在这个阶段只需要将该函数转换为函数对象，如下图所示：注意，这里只是将该函数声明转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为 foo 函数的内部代码生成抽象语法树。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334292/origin-of-ray/4380eae2-e84e-412d-a72f-7a95180fb897_wxblbk.png" alt></p>
<p>代码解析完成之后，V8 便会按照顺序自上而下执行代码，首先会先执行“a=1”和“c=4”这两个赋值表达式，接下来执行 foo 函数的调用，过程是从 foo 函数对象中取出函数代码，然后和编译顶层代码一样，V8 会先编译 foo 函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行。</p>
<h4 id="闭包的基础：函数是一等公民"><a href="#闭包的基础：函数是一等公民" class="headerlink" title="闭包的基础：函数是一等公民"></a>闭包的基础：函数是一等公民</h4><p>JavaScript 语言允许在函数内部定义新的函数</p>
<p>可以在内部函数中访问父函数中定义的变量</p>
<p>因为函数是一等公民，所以函数可以作为返回值</p>
<h4 id="思考：延迟解析下，如何实现闭包"><a href="#思考：延迟解析下，如何实现闭包" class="headerlink" title="思考：延迟解析下，如何实现闭包"></a>思考：延迟解析下，如何实现闭包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> c = a + b + d</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo()</span><br></pre></td></tr></table></figure>

<p>我们可以分析下上面这段代码的执行过程：</p>
<ul>
<li>当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；</li>
<li>然后 foo 函数执行结束，执行上下文被 V8 销毁；</li>
<li>虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。</li>
</ul>
<p>所以说，如果闭包的变量如果存储在调用栈中，当函数调用结束，会被销毁</p>
<p>为了解决这个问题，就需要预解析器+将变量从栈复制到堆中</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><h4 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h4><p><a href="https://sunra.top/2021/01/01/electron-multi-process/">Electron 多进程方案</a></p>
<h4 id="消息队列（宏任务）"><a href="#消息队列（宏任务）" class="headerlink" title="消息队列（宏任务）"></a>消息队列（宏任务）</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629333909/origin-of-ray/4b286cfd-0164-4d55-b9bb-29568b622b81_wqnhy4.png" alt></p>
<h4 id="微任务（解决了宏任务执行时机不可控的问题）"><a href="#微任务（解决了宏任务执行时机不可控的问题）" class="headerlink" title="微任务（解决了宏任务执行时机不可控的问题）"></a>微任务（解决了宏任务执行时机不可控的问题）</h4><p>宏任务需要先被放到消息队列中，如果某些宏任务的执行时间过久，那么就会影响到消息队列后面的宏任务的执行，而且这个影响是不可控的，因为你无法知道前面的宏任务需要多久才能执行完成。于是 JavaScript 中又引入了微任务，微任务会在当前的任务快要执行结束时执行，利用微任务，你就能比较精准地控制你的回调函数的执行时机。</p>
<p>V8 会为每个宏任务维护一个微任务队列。当 V8 执行一段 JavaScript 时，会为这段代码创建一个环境对象，微任务队列就是存放在该环境对象中的。当你通过 Promise.resolve 生成一个微任务，该微任务会被 V8 自动添加进微任务队列，等整段代码快要执行结束时，该环境对象也随之被销毁，但是在销毁之前，V8 会先处理微任务队列中的微任务。</p>
<ul>
<li>首先，如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张；</li>
<li>其次，和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(</span><br><span class="line">    (str) =&gt;<span class="built_in">console</span>.log(<span class="string">'micro-bar'</span>)</span><br><span class="line">  ) </span><br><span class="line">  setTimeout(<span class="function">(<span class="params">str</span>) =&gt;</span><span class="built_in">console</span>.log(<span class="string">'macro-bar'</span>),<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(</span><br><span class="line">    (str) =&gt;<span class="built_in">console</span>.log(<span class="string">'micro-foo'</span>)</span><br><span class="line">  ) </span><br><span class="line">  setTimeout(<span class="function">(<span class="params">str</span>) =&gt;</span><span class="built_in">console</span>.log(<span class="string">'macro-foo'</span>),<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(</span><br><span class="line">  (str) =&gt;<span class="built_in">console</span>.log(<span class="string">'micro-global'</span>)</span><br><span class="line">) </span><br><span class="line">setTimeout(<span class="function">(<span class="params">str</span>) =&gt;</span><span class="built_in">console</span>.log(<span class="string">'macro-global'</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334393/origin-of-ray/1_gkzipy.png" alt></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334394/origin-of-ray/5c4d6601-2746-4ebe-92a8-69f4721bb956_rt0a1c.png" alt></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334395/origin-of-ray/7d99c846-3ad9-435a-8947-3218c8587e77_cx6wnz.png" alt></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334396/origin-of-ray/657aecbf-c219-42f2-a2d3-89bc3a2a299b_vgprhc.png" alt></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334394/origin-of-ray/6d0c4f0a-6126-419b-a0af-0d0a1c56a408_mkfmzt.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">global</span><br><span class="line">micro-foo</span><br><span class="line">micro-bar</span><br><span class="line">micro-global</span><br><span class="line">macro-foo</span><br><span class="line">macro-bar</span><br><span class="line">macro-global</span><br></pre></td></tr></table></figure>

<h3 id="异步语法的前进"><a href="#异步语法的前进" class="headerlink" title="异步语法的前进"></a>异步语法的前进</h3><p><a href="https://sunra.top/2020/06/02/javascript_async/">JavaScript 异步编程语法</a></p>
<h3 id="思考：Node中很多API都提供了同步和异步两种函数，有什么区别？"><a href="#思考：Node中很多API都提供了同步和异步两种函数，有什么区别？" class="headerlink" title="思考：Node中很多API都提供了同步和异步两种函数，有什么区别？"></a>思考：Node中很多API都提供了同步和异步两种函数，有什么区别？</h3><p>以readFile为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'test.js'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileHanlder</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">  data.toString()  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>, fileHanlder)</span><br></pre></td></tr></table></figure>

<h4 id="异步读文件"><a href="#异步读文件" class="headerlink" title="异步读文件"></a>异步读文件</h4><p>比如当在 Node 的主线程上执行 readFile 的时候，主线程会将 readFile 的文件名称和回调函数，提交给文件读写线程来处理，具体过程如下所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629334521/origin-of-ray/1f181f36-9544-4b9b-850c-70630a8a8f17_st0vsg.png" alt></p>
<p>文件读写线程完成了文件读取之后，会将结果和回调函数封装成新的事件，并将其添加进消息队列中。比如文件线程将读取的文件内容存放在内存中，并将 data 指针指向了该内存，然后文件读写线程会将 data 和回调函数封装成新的事件，并将其丢进消息队列中</p>
<h4 id="同步读文件"><a href="#同步读文件" class="headerlink" title="同步读文件"></a>同步读文件</h4><p>不过，总有些人觉得异步读写文件操作过于复杂了，如果读取的文件体积不大或者项目瓶颈不在文件读写，那么依然使用异步调用和回调函数的模式就显得有点过度复杂了。因此 Node 还提供了一套同步读写的 API。第一段代码中的 readFileSync 就是同步实现的，同步代码非常简单，当 libuv 读取到 readFileSync 的任务后，就直接在主线程上执行读写操作，等待读写结束，直接返回读写的结果，这也是同步回调的一种应用。当然在读写过程中，消息队列中的其他任务是无法被执行的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>V8在执行一段代码之前，会先初始化运行环境，如初始化堆栈空间，消息队列等。</li>
<li>先对整段代码进行编译，生成AST，生成AST之后：</li>
<li>对var声明的变量进行变量提升，放到全局上下文的变量环境中。</li>
<li>对let，const声明的变量，加入全局上下文的词法环境中</li>
<li>如果该变量是普通变量，直接存储在调用栈中，如果是对象或者函数，存储在堆上，并在堆的上下文中存指针，如果是函数，并不是直接生成上下文，而只是简单预解析，如果存在闭包情况，再把变量复制到堆上。</li>
<li>将整个函数当作一个宏任务丢进消息队列，开始执行代码，如果遇到函数，再解析该函数，在栈上生成上下文，并继续执行上面三步，只不过，全局上下文替换为函数上下文。</li>
<li>如果函数执行过程中遇到了宏任务的回调，放入消息队列的尾部，如果遇到了微任务的回调，放进全局上下文的微任务队列中。</li>
<li>全局上下为退出之前，会不断取出微任务中的函数执行。</li>
<li>执行完微任务之后，全局上下文销毁，从消息队列中取出下一个宏任务执行。</li>
</ul>
<h3 id="编码注意"><a href="#编码注意" class="headerlink" title="编码注意"></a>编码注意</h3><ul>
<li>不要轻易改动对象的结构</li>
<li>注意内存问题</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Javascript执行机制（八）垃圾回收机制</title>
    <url>/2021/08/04/javascript-gc/</url>
    <content><![CDATA[<p>我们都知道，JavaScript 是一门自动垃圾回收的语言，也就是说，我们不需要去手动回收垃圾数据，这一切都交给 V8 的垃圾回收器来完成。V8 为了更高效地回收垃圾，引入了两个垃圾回收器，它们分别针对着不同的场景。</p>
<p>我们就来一起分析下，这两个回收机制的使用场景以及工作原理。</p>
<a id="more"></a>

<h2 id="垃圾数据是如何产生的？"><a href="#垃圾数据是如何产生的？" class="headerlink" title="垃圾数据是如何产生的？"></a>垃圾数据是如何产生的？</h2><p>比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会先在栈上创建函数执行上下文，然后在堆中创建一个新的对象，然后把该对象的指针存储在<code>gc</code>的上下文中。</p>
<p>那么当<code>gc</code>函数退出以后，栈中的a被删除，那a中存储的指针对应的对象，就会成为堆中的垃圾数据，是无效的。</p>
<p>从这个例子中我们也可以看出，<strong>垃圾回收算法针对的是堆</strong>。</p>
<h2 id="垃圾回收算法步骤"><a href="#垃圾回收算法步骤" class="headerlink" title="垃圾回收算法步骤"></a>垃圾回收算法步骤</h2><p>那么垃圾回收是怎么实现的呢？大致可以分为以下几个步骤：</p>
<p><strong>第一步</strong>，通过 GC Root 标记空间中<strong>活动对象</strong>和<strong>非活动对象</strong>。</p>
<p>目前 V8 采用的<strong>可访问性（reachability）算法</strong>来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 <strong>GC Root</strong> 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：</p>
<p>这有点像多源BFS/DFS，从多个根节点出发，搜索整个树，如果能搜索到，说明对应的内存地址还在使用中，那么堆中剩下的空间就是未被使用的。</p>
<ul>
<li><p>通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象；</p>
</li>
<li><p>通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。</p>
</li>
</ul>
<p>在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：</p>
<ul>
<li><p>全局的 window 对象（位于每个 iframe 中）；</p>
</li>
<li><p>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；</p>
</li>
<li><p>存放栈上变量。</p>
</li>
</ul>
<p><strong>第二步</strong>，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，<strong>统一清理内存中所有被标记为可回收的对象</strong>。</p>
<p><strong>第三步</strong>，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要<strong>整理这些内存碎片</strong>。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>
<h2 id="两种垃圾回收器"><a href="#两种垃圾回收器" class="headerlink" title="两种垃圾回收器"></a>两种垃圾回收器</h2><p>目前 V8 采用了两个垃圾回收器，<strong>主垃圾回收器 -Major GC 和副垃圾回收器 -Minor GC (Scavenger)</strong>。V8 之所以使用了两个垃圾回收器，主要是受到了代际假说（The Generational Hypothesis）的影响</p>
<p>代际假说是垃圾回收领域中一个重要的术语，它有以下两个特点：</p>
<ul>
<li><p>第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；</p>
</li>
<li><p>第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。</p>
</li>
</ul>
<p>对于那些存活时间短对象，由于其这个存活时间短的特性，我们需要对其进行频繁地回收，所以我们首先并不需要为这种对象申请多大的空间，因为它们很快就会被回收，其次，由于频繁地回收，如果每次都要进行内存碎片的整理，会很消耗性能。</p>
<p>针对这两点，我们就需要为这种变量申请一个不大的内存空间，叫新生代，对新生代的垃圾回收器，就是副回收器，其特点就是不要产生内存碎片。</p>
<p>而对于存活时间久的对象，就是需要一个大的内存空间，叫做老生代，对老生代的垃圾回收器，就是主回收器，其特点就是会产生内存碎片且需要内存整理，但是因为它几乎不会死，所以也几乎不需要整理内存。</p>
<h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>副垃圾回收器主要负责新生代的垃圾回收。通常情况下，大多数小的对象都会被分配到新生代，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。新生代中的垃圾数据用 <strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，<strong>一半是对象区域 (from-space)，一半是空闲区域 (to-space)</strong>，如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642353/origin-of-ray/screenshot-20210811-083742_tf2rdn.png" alt></p>
<p>新加入的对象都会存放到对象区域，<strong>当对象区域快被写满时，就需要执行一次垃圾清理操作</strong>。</p>
<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段。副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，<strong>也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了</strong>。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642437/origin-of-ray/12519a0d1f2484cd24297e821f2f1887_oaspxk.jpg" alt></p>
<p>完成复制后，<strong>对象区域与空闲区域进行角色翻转</strong>，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时，这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>
<p>副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>
<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域，副垃圾回收器一旦监控对象装满了，便执行垃圾回收。同时，副垃圾回收器还会采用<strong>对象晋升策略</strong>，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。</p>
<h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。因此，老生代中的对象有两个特点：</p>
<ul>
<li><p>一个是对象占用空间大；</p>
</li>
<li><p>另一个是对象存活时间长。</p>
</li>
</ul>
<p>由于老生代的对象比较大，若要在老生代中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。所以，主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）的算法</strong>进行垃圾回收的。</p>
<p><strong>首先是标记过程阶段</strong>。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>
<p>接下来就是<strong>垃圾的清除过程</strong>。它和副垃圾回收器的垃圾清除过程完全不同，<strong>主垃圾回收器会直接将标记为垃圾的数据清理掉</strong>。</p>
<p>对垃圾数据进行标记，然后清除，这就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，<strong>会产生大量不连续的内存碎片</strong>。而碎片过多会导致大对象无法分配到足够的连续内存，于是又引入了<strong>另外一种算法——标记 - 整理（Mark-Compact）</strong></p>
<p>这个算法的标记过程仍然与标记 - 清除算法里的是一样的，先标记可回收对象，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉这一端之外的内存。你可以参考下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642627/origin-of-ray/6a558a6731fd68757e1a43c1dbc27ed8_t4jw7a.jpg" alt></p>
<h2 id="V8如何提高垃圾回收效率"><a href="#V8如何提高垃圾回收效率" class="headerlink" title="V8如何提高垃圾回收效率"></a>V8如何提高垃圾回收效率</h2><p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p>
<p>一次完整的垃圾回收分为标记和清理两个阶段，垃圾数据标记之后，V8 会继续执行清理和整理操作，虽然主垃圾回收器和副垃圾回收器的处理方式稍微有些不同，但它们都是主线程上执行的，执行垃圾回收过程中，会暂停主线程上的其他任务，具体全停顿的执行效果如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1628642991/origin-of-ray/9004196c53f2f381a1321bcbc346fc23_fogdhf.jpg" alt></p>
<p>可以看到，执行垃圾回收时会占用主线程的时间，如果在执行垃圾回收的过程中，垃圾回收器占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如，页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行，造成页面的卡顿 (Jank)，用户体验不佳。</p>
<p>为了解决全停顿而造成的用户体验的问题，V8 团队经过了很多年的努力，向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术，并且也已经取得了一些成效。这些技术主要是从两方面来解决垃圾回收效率问题的：</p>
<ul>
<li><p>第一，将一个完整的垃圾回收的任务拆分成<strong>多个小的任务</strong>，这样就消灭了单个长的垃圾回收任务；</p>
</li>
<li><p>第二，将标记对象、移动对象等任务转移到<strong>后台线程</strong>进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。</p>
</li>
</ul>
<h3 id="并行回收"><a href="#并行回收" class="headerlink" title="并行回收"></a>并行回收</h3><p>既然执行一次完整的垃圾回收过程比较耗时，那么解决效率问题，第一个思路就是主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理，这样就会加速垃圾回收的执行速度，因此 V8 团队引入了并行回收机制</p>
<p>所谓并行回收，是指垃圾回收器在主线程上执行的过程中，还会开启多个<strong>协助线程</strong>，同时执行同样的回收工作。</p>
<p>采用并行回收时，垃圾回收所消耗的时间，等于总体辅助线程所消耗的时间（辅助线程数量乘以单个线程所消耗的时间），再加上一些同步开销的时间。这种方式比较简单，因为在执行垃圾标记的过程中，主线程并不会同时执行 JavaScript 代码，因此 JavaScript 代码也不会改变回收的过程。<strong>所以我们可以假定内存状态是静态的</strong>，因此只要确保同时只有一个协助线程在访问对象就好了。</p>
<p><strong>V8 的副垃圾回收器所采用的就是并行策略</strong>，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。</p>
<h3 id="增量回收（拆解任务）"><a href="#增量回收（拆解任务）" class="headerlink" title="增量回收（拆解任务）"></a>增量回收（拆解任务）</h3><p>虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这仍然是一种全停顿的垃圾回收方式，在主线程执行回收工作的时候才会开启辅助线程，这依然还会存在效率问题。比如老生代存放的都是一些大的对象，如 window、DOM 这种，完整执行老生代的垃圾回收，时间依然会很久。这些大的对象都是主垃圾回收器的，所以在 2011 年，V8 又引入了增量标记的方式，我们把这种垃圾回收的方式称之为增量式垃圾回收。</p>
<p>所谓增量式垃圾回收，是指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，<strong>垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/be/6f/be18e6dc6c93e761a37d50aed48f246f.jpg" alt></p>
<p>增量标记的算法，比全停顿的算法要稍微复杂，这主要是因为增量回收是并发的（concurrent），要实现增量执行，需要满足两点要求：</p>
<ul>
<li><p>垃圾回收可以被随时暂停和重启，<strong>暂停时需要保存当时的扫描结果</strong>，等下一波垃圾回收来了之后，才能继续启动。</p>
</li>
<li><p>在暂停期间，被标记好的<strong>垃圾数据如果被 JavaScript 代码修改了</strong>，那么垃圾回收器需要能够正确地处理。</p>
</li>
</ul>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>这里我们需要知道，在没有采用增量算法之前，V8 使用黑色和白色来标记数据。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从 GC Roots 出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据。</p>
<p>如果内存中的数据只有两种状态，非黑即白，那么当你暂停了当前的垃圾回收器之后，再次恢复垃圾回收器，那么垃圾回收器就不知道从哪个位置继续开始执行了。比如垃圾回收器执行了一小段增量回收后，被 V8 暂停了，然后主线程执行了一段 JavaScript 代码，然后垃圾回收器又被恢复了，那么恢复时内存状态就如下图所示</p>
<p><img src="https://static001.geekbang.org/resource/image/2c/4d/2cd1ef856522ad0c8176c60b75e63c4d.jpg" alt></p>
<p><strong>如果是单纯得认为从黑色开始继续执行标记，那么从哪个黑色节点开始呢？</strong>从A？B？还是其他的黑色节点，甚至从头开始？</p>
<p>为了解决这个问题，V8 采用了三色标记法，除了黑色和白色，还额外引入了灰色：</p>
<ul>
<li><p>黑色表示这个节点被 GC Root 引用到了，而且该节点的子节点都已经标记完成了</p>
</li>
<li><p>灰色表示这个节点被 GC Root 引用到，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点；</p>
</li>
<li><p>白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。</p>
</li>
</ul>
<p>引入灰色标记之后，垃圾回收器就可以依据当前内存中有没有灰色节点，来判断整个标记是否完成，如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。</p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>单纯的三色标记其实还是有点问题，比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="built_in">Object</span>()</span><br><span class="line"><span class="built_in">window</span>.a.b = <span class="built_in">Object</span>()</span><br><span class="line"><span class="built_in">window</span>.a.b.c=<span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/19/17/19bbfb35d274064b253814b58413bc17.jpg" alt></p>
<p>然后又执行了另外一个代码，这段代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a.b = <span class="built_in">Object</span>() <span class="comment">//d</span></span><br></pre></td></tr></table></figure>

<p>执行完之后，垃圾回收器又恢复执行了增量标记过程，由于 b 重新指向了 d 对象，所以 b 和 c 对象的连接就断开了。这时候代码的应用如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/75/15/759f6a8105d64d3aebdc16f81a2b5e15.jpg" alt></p>
<p>这就说明一个问题，当垃圾回收器将某个节点标记成了黑色，然后这个黑色的节点被续上了一个白色节点，那么垃圾回收器不会再次将这个白色节点标记为黑色节点了，因为它已经走过这个路径了。但是这个新的白色节点的确被引用了，所以我们还是需要想办法将其标记为黑色。</p>
<p>为了解决这个问题，增量垃圾回收器添加了一个约束条件：不能让黑色节点指向白色节点。通常我们使用写屏障 (Write-barrier) 机制实现这个约束条件，也就是说，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这样就保证了黑色节点不能指向白色节点的约束条件。</p>
<p>这个方法也被称为<strong>强三色不变性</strong>，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是不可到达的，可以安全释放。</p>
<h3 id="V8的综合垃圾回收策略"><a href="#V8的综合垃圾回收策略" class="headerlink" title="V8的综合垃圾回收策略"></a>V8的综合垃圾回收策略</h3><p><img src="https://static001.geekbang.org/resource/image/7b/42/7b8b901cb2eb575bb8907e1ad7dc1842.jpg" alt></p>
<p>可以看出来，主垃圾回收器同时采用了这三种策略：</p>
<ul>
<li><p>首先主垃圾回收器主要使用并发标记，我们可以看到，在主线程执行 JavaScript，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。</p>
</li>
<li><p>标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。</p>
</li>
<li><p>另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 JavaScript 任务之间执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 继承</title>
    <url>/2021/02/16/javascript-inherit/</url>
    <content><![CDATA[<p>最近突然发现自己对于JavaScript的继承有些生疏，再来回顾一下。</p>
<p>在看这篇博客之前最好回顾下关于原型链的博客：<a href="https://sunra.top/2020/12/10/javascript-prototype/">https://sunra.top/2020/12/10/javascript-prototype/</a></p>
<a id="more"></a>

<h2 id="原型链的设计思想"><a href="#原型链的设计思想" class="headerlink" title="原型链的设计思想"></a>原型链的设计思想</h2><h3 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h3><p>要理解Javascript的设计思想，必须从它的诞生说起。</p>
<p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏”用户名”要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。</p>
<p>因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师<a href="http://brendaneich.com/" rel="external nofollow noopener noreferrer" target="_blank">Brendan Eich</a>负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。</p>
<p>1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。</p>
<p>Brendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计”继承”机制呢？</p>
<h3 id="抉择"><a href="#抉择" class="headerlink" title="抉择"></a>抉择</h3><p>如果真的是一种简易的脚本语言，其实不需要有”继承”机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了”继承”。</p>
<p>但是，他不打算引入”类”（class）的概念，因为一旦有了”类”，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。</p>
<p>他考虑到，C++和Java语言都使用new命令，生成实例。</p>
<p>C++的写法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ClassName *object = <span class="keyword">new</span> ClassName(param);</span><br></pre></td></tr></table></figure>

<p>Java的写法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Foo foo = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有”类”，怎么来表示原型对象呢？</p>
<p>这时，他想到C++和Java使用new命令时，都会调用”类”的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。</p>
<p>举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个构造函数使用new，就会生成一个狗对象的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"></span><br><span class="line">alert(dogA.name); <span class="comment">// 大毛</span></span><br></pre></td></tr></table></figure>

<p>注意构造函数中的<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" rel="external nofollow noopener noreferrer" target="_blank">this关键字</a>，它就代表了新创建的实例对象。</p>
<h3 id="new运算符的缺点"><a href="#new运算符的缺点" class="headerlink" title="new运算符的缺点"></a>new运算符的缺点</h3><p>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p>
<p>比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">'犬科'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，生成两个实例对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br></pre></td></tr></table></figure>

<p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dogA.species = <span class="string">'猫科'</span>;</span><br><span class="line"></span><br><span class="line">alert(dogB.species); <span class="comment">// 显示"犬科"，不受dogA的影响</span></span><br></pre></td></tr></table></figure>

<p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>
<h3 id="prototype属性的引入"><a href="#prototype属性的引入" class="headerlink" title="prototype属性的引入"></a>prototype属性的引入</h3><p>考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。</p>
<p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>
<p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p>
<p>还是以DOG构造函数为例，现在用prototype属性进行改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.spec = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.species);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = &#123; <span class="attr">species</span>: <span class="string">'犬科'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">dog.spec();</span><br></pre></td></tr></table></figure>

<p>现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DOG.prototype.species = <span class="string">'猫科'</span>;</span><br><span class="line"></span><br><span class="line">alert(dogA.species); <span class="comment">// 猫科</span></span><br><span class="line"></span><br><span class="line">alert(dogB.species); <span class="comment">// 猫科</span></span><br></pre></td></tr></table></figure>

<p>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。</p>
<p>这就是JavaScript继承机制的设计思想。</p>
<h2 id="JavaScript的继承方式"><a href="#JavaScript的继承方式" class="headerlink" title="JavaScript的继承方式"></a>JavaScript的继承方式</h2><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> animal(<span class="string">"犬科"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.species);</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>species并不是dog实例上的属性，而是<code>dog.__proto__</code>，也就是<code>Dog.prototype</code>，也就是new animal()实例上的</p>
<p>优点：</p>
<p>简单易于实现，父类的新增的实例与属性子类都能访问</p>
<p>缺点：</p>
<p>可以在子类中增加实例属性，如果要新增加原型属性和方法需要在new 父类构造函数的后面</p>
<p>无法实现多继承</p>
<p>创建子类实例时，不能向父类构造函数中传参数</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, <span class="string">"犬科"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = species;</span><br><span class="line">    <span class="keyword">this</span>.setCount = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">dog.setCount(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.species);</span><br><span class="line"><span class="built_in">console</span>.log(dog.count);</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>species就是dog实例上的，因为在new Dog()的时候，调用了Animal.call方法，这个this就是后面的dog实例，所以其实是在dog的上下文上调用Animal方法，也就是说Animal执行的时候，上下文是dog，就直接在dog上挂在了species属性</p>
<p>count则是执行setCount时挂载在dog实例上的。</p>
<p>优点：</p>
<p>解决了子类构造函数向父类构造函数中传递参数</p>
<p>可以实现多继承（call或者apply多个父类）</p>
<p>缺点：</p>
<p>方法都在构造函数中定义，无法复用</p>
<p>不能继承原型属性/方法，只能继承父类的实例属性和方法</p>
<h4 id="原型式继承（实例继承）"><a href="#原型式继承（实例继承）" class="headerlink" title="原型式继承（实例继承）"></a>原型式继承（实例继承）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> Animal(<span class="string">"犬科"</span>);</span><br><span class="line">    instance.name = name;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.species);</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>这里的dog其实是Animal的实例，并不是Dog的实例，也就是说dog instanceof Dog 是false。</p>
<p>这种方法就是先创建一个Animal实例，然后在实例上创建新的属性。</p>
<p>优点：</p>
<p>不限制调用方式</p>
<p>简单，易实现</p>
<p>缺点：不能多次继承</p>
<h4 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h4><p>调用父类构造函数，继承父类的属性，通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = species;</span><br><span class="line">    <span class="keyword">this</span>.setCount = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, <span class="string">"犬科"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(<span class="string">"quanke"</span>);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'first'</span>);</span><br><span class="line"></span><br><span class="line">dog.setCount(<span class="number">2</span>);</span><br><span class="line">dog.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog.species);</span><br><span class="line"><span class="built_in">console</span>.log(dog.count);</span><br><span class="line"><span class="built_in">console</span>.log(dog.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//犬科</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>利用构造函数继承来创建每个子类实例的属性，也就是说每个子类上的属性都是独享的。</p>
<p>利用原型链继承的方式共享父类原型上的方法。</p>
<p>缺点：</p>
<p>由于调用了两次父类，所以产生了两份实例</p>
<p>优点：</p>
<p>函数可以复用</p>
<p>不存在引用属性问题</p>
<p>可以继承属性和方法，并且可以继承原型的属性和方法</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'wangxiao'</span></span><br><span class="line">  <span class="keyword">this</span>.age = age || <span class="number">27</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line">People.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">'eat sleep'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Woman</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承父类属性</span></span><br><span class="line">  People.call(<span class="keyword">this</span>,name,age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类方法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建空类</span></span><br><span class="line">  <span class="keyword">let</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  Super.prototype = People.prototype;</span><br><span class="line">  <span class="comment">//父类的实例作为子类的原型</span></span><br><span class="line">  Woman.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//修复构造函数指向问题</span></span><br><span class="line">Woman.prototype.constructor = Woman;</span><br><span class="line"><span class="keyword">let</span> womanObj = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>在组合式继承的基础上，利用寄生式继承的思想，改造原型链继承方式，因为原型链继承的方式会再次创建一个父类的实例，会造成内存的浪费，所以就创建一个空类，然后把空类的原型对象置为父类的原型对象，再让子类的<code>__proto__</code>指向空类的一个实例。</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class 相当于es5中构造函数</span></span><br><span class="line"><span class="comment">//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中</span></span><br><span class="line"><span class="comment">//class中定义的所有方法是不可枚举的</span></span><br><span class="line"><span class="comment">//class中只能定义方法，不能定义对象，变量等</span></span><br><span class="line"><span class="comment">//class和方法内默认都是严格模式</span></span><br><span class="line"><span class="comment">//es5中constructor为隐式属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name='wang',age='27')&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> eat food`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123; </span><br><span class="line">   <span class="keyword">constructor</span>(name = 'ren',age = '27')&#123; </span><br><span class="line">     <span class="comment">//继承父类属性</span></span><br><span class="line">     <span class="keyword">super</span>(name, age); </span><br><span class="line">   &#125; </span><br><span class="line">    eat()&#123; </span><br><span class="line">     <span class="comment">//继承父类方法</span></span><br><span class="line">      <span class="keyword">super</span>.eat() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> wonmanObj=<span class="keyword">new</span> Woman(<span class="string">'xiaoxiami'</span>); </span><br><span class="line">wonmanObj.eat();</span><br></pre></td></tr></table></figure>

<h3 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a><strong>ES5继承和ES6继承的区别</strong></h3><p>es5继承首先是在子类中创建自己的this指向，最后将方法添加到this中</p>
<p>Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</p>
<p>es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this</p>
<p>参考链接</p>
<p><a href="https://zhuanlan.zhihu.com/p/37735247" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/37735247</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（七）如何快速查找对象上的属性</title>
    <url>/2021/07/27/javascript-obj-attr-search/</url>
    <content><![CDATA[<p>上一篇博客我们讲了V8的整体执行的流程，这次我就继续总结下，V8是如何实现对象上属性的快速查找的。</p>
<p>注意，这部分内容不是作用域链，也不是原型链。作用域链是用来找到对象的，如obj，原型链是如果obj上没有属性a，去它的原型上找，而本文的主题，是如何快速在obj上找到a。</p>
<a id="more"></a>

<h2 id="快属性和慢属性"><a href="#快属性和慢属性" class="headerlink" title="快属性和慢属性"></a>快属性和慢属性</h2><p>JavaScript 中的对象是由一组组属性和值的集合，从 JavaScript 语言的角度来看，JavaScript 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。</p>
<p>然而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8 为了提升存储和查找效率，采用了一套复杂的存储策略。</p>
<h3 id="常规属性和排序属性"><a href="#常规属性和排序属性" class="headerlink" title="常规属性和排序属性"></a>常规属性和排序属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'test-100'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'test-1'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="string">"B"</span>] = <span class="string">'bar-B'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'test-50'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">9</span>] =  <span class="string">'test-9'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">8</span>] = <span class="string">'test-8'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'test-3'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">5</span>] = <span class="string">'test-5'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="string">"A"</span>] = <span class="string">'bar-A'</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="string">"C"</span>] = <span class="string">'bar-C'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> bar)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`index:<span class="subst">$&#123;key&#125;</span>  value:<span class="subst">$&#123;bar[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们利用构造函数 Foo 创建了一个 bar 对象，在构造函数中，我们给 bar 对象设置了很多属性，包括了数字属性和字符串属性，然后我们枚举出来了 bar 对象中所有的属性，并将其一一打印出来，下面就是执行这段代码所打印出来的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">index:1  value:test-1</span><br><span class="line">index:3  value:test-3</span><br><span class="line">index:5  value:test-5</span><br><span class="line">index:8  value:test-8</span><br><span class="line">index:9  value:test-9</span><br><span class="line">index:50  value:test-50</span><br><span class="line">index:100  value:test-100</span><br><span class="line">index:B  value:bar-B</span><br><span class="line">index:A  value:bar-A</span><br><span class="line">index:C  value:bar-C</span><br></pre></td></tr></table></figure>

<p>观察这段打印出来的数据，我们发现打印出来的属性顺序并不是我们设置的顺序，我们设置属性的时候是乱序设置的，比如开始先设置 100，然后又设置了 1，但是输出的内容却非常规律，总的来说体现在以下两点：</p>
<ul>
<li><p>设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的；</p>
</li>
<li><p>设置的字符串属性依然是按照之前的设置顺序打印的，比如我们是按照 B、A、C 的顺序设置的，打印出来依然是这个顺序。</p>
</li>
</ul>
<p>之所以出现这样的结果，是因为在 <strong>ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。在这里我们把对象中的数字属性称为排序属性，在 V8 中被称为 elements，字符串属性就被称为常规属性，在 V8 中被称为 properties</strong>。</p>
<p>在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性，具体结构如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627345375/origin-of-ray/af2654db3d3a2e0b9a9eaa25e862cc75_cpbshg.jpg" alt></p>
<p>通过上图我们可以发现，bar 对象包含了两个隐藏属性：elements 属性和 properties 属性，elements 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。</p>
<p>分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。</p>
<h3 id="快慢属性"><a href="#快慢属性" class="headerlink" title="快慢属性"></a>快慢属性</h3><p>将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 bar.B这个语句来查找 B 的属性值，那么在 V8 会先查找出 properties 属性所指向的对象 properties，然后再在 properties 对象中查找 B 属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。</p>
<p>基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个<strong>策略是将部分常规属性直接存储到对象本身</strong>，我们把这称为对象内属性 (in-object properties)。对象在内存中的展现形式你可以参看下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627345848/origin-of-ray/f12b4c6f6e631ce51d5b4f288dbfb13e_r3pqv1.jpg" alt></p>
<p>采用对象内属性之后，常规属性就被保存到 bar 对象本身了，这样当再次使用bar.B来查找 B 的属性值时，V8 就可以直接从 bar 对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。</p>
<p>不过对象内属性的数量是固定的，默认是 10 个，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。</p>
<p>通常，我们将保存在线性数据结构中的属性称之为“快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。</p>
<p>因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“慢属性”策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627346039/origin-of-ray/e8ce990dce53295a414ce79e38149917_geaimq.jpg" alt></p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">property_num,element_num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//添加可索引属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加常规属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">        <span class="keyword">this</span>[ppt] = ppt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> bar2 = <span class="keyword">new</span> Foo(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> bar3 = <span class="keyword">new</span> Foo(<span class="number">100</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以在浏览器控制台运行这段代码，然后利用Memory的快照功能看看这三个对象中的属性。</p>
<p>首先是第一个，可以看到所有的排序属性都在elements中，而常规属性都直接在对象上，没有在properties上</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627430095/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210728075159_fidca2.png" alt></p>
<p>然后是第二个，对象上有了properties属性，内部有10个根据键排序的常规属性。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627430095/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210728075332_bpvmeg.png" alt></p>
<p>最后就是第三个，我们可以看到，此时的properties中的属性已经是乱序的了，是个map</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627430095/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210728075404_mnr0oh.png" alt></p>
<h2 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h2><p>在上一部分讲快慢属性的时候，chrome的快照中，还有一个属性，叫做map，也叫作隐藏类，那这个map是做什么的呢？</p>
<p>我们知道 JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。今天我们来重点分析下 V8 中的隐藏类，看看它是怎么提升访问对象属性值速度的。</p>
<h3 id="为什么静态语言的效率更高？"><a href="#为什么静态语言的效率更高？" class="headerlink" title="为什么静态语言的效率更高？"></a><strong>为什么静态语言的效率更高？</strong></h3><p>由于隐藏类借鉴了部分静态语言的特性，因此要解释清楚这个问题，我们就先来分析下为什么静态语言比动态语言的执行效率更高。</p>
<p>我们通过下面两段代码，来对比一下动态语言和静态语言在运行时的一些特征，一段是动态语言的 JavaScript，另外一段静态语言的 C++ 的源码，具体源码你可以参看下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627430731/origin-of-ray/205a2fa05c6aba57ade25f3a1df2bad7_rl8g2x.jpg" alt></p>
<p>那么在运行时，这两段代码的执行过程有什么区别呢？</p>
<p>我们知道，JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 start.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也可以说 V8 并不知道该对象的具体的形状。</p>
<p>那么，当在 JavaScript 中要查询对象 start 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时</p>
<p>这种动态查询对象属性的方式和 C++ 这种静态语言不同，C++ 在声明一个对象之前需要定义该对象的结构，我们也可以称为形状，比如 Point 结构体就是一种形状，我们可以使用这个形状来定义具体的对象。C++ 代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，Point 的形状是无法被改变的。那么在 C++ 中访问一个对象的属性时，自然就知道该属性相对于该对象地址的偏移值了，比如在 C++ 中使用 start.x 的时候，编译器会直接将 x 相对于 start 的地址写进汇编指令中，那么当使用了对象 start 中的 x 属性时，CPU 就可以直接去内存地址中取出该内容即可，没有任何中间的查找环节。因为静态语言中，可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。</p>
<h3 id="什么是隐藏类-Hidden-Class）？"><a href="#什么是隐藏类-Hidden-Class）？" class="headerlink" title="什么是隐藏类 (Hidden Class）？"></a>什么是隐藏类 (Hidden Class）？</h3><p>既然静态语言的查询效率这么高，那么是否能将这种静态的特性引入到 V8 中呢？</p>
<p>答案是可行的。目前所采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的，具体地讲，V8 对每个对象做如下两点假设：</p>
<ul>
<li><p>对象创建好了之后就不会添加新的属性；</p>
</li>
<li><p>对象创建好了之后也不会删除属性。</p>
</li>
</ul>
<p>符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了，那么怎么优化呢？</p>
<p>具体地讲，V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：</p>
<ul>
<li><p>对象中所包含的所有的属性；</p>
</li>
<li><p>每个属性相对于对象的偏移量。</p>
</li>
</ul>
<p>有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对于的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏类描述了对象的属性布局，它主要包括了属性名称和每个属性所对应的偏移量，比如 point 对象的隐藏类就包括了 x 和 y 属性，x 的偏移量是 4，y 的偏移量是 8。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627430911/origin-of-ray/51f5034a7f80e4e5684d5a301178c2f8_w760bb.jpg" alt></p>
<p>有了 map 之后，当你再次使用 point.x 访问 x 属性时，V8 会查询 point 的 map 中 x 属性相对 point 对象的偏移量，然后将 point 对象的起始位置加上偏移量，就得到了 x 属性的值在内存中的位置，有了这个位置也就拿到了 x 的值，这样我们就省去了一个比较复杂的查找过程。</p>
<p>多个对象共用一个隐藏类现在我们知道了在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。</p>
<p>不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：</p>
<ul>
<li><p>减少隐藏类的创建次数，也间接加速了代码的执行速度；</p>
</li>
<li><p>减少了隐藏类的存储空间。</p>
</li>
</ul>
<p>那么，什么情况下两个对象的形状是相同的，要满足以下两点：</p>
<ul>
<li><p>相同的属性名称；</p>
</li>
<li><p>相等的属性个数。</p>
</li>
</ul>
<h3 id="重新构建隐藏类"><a href="#重新构建隐藏类" class="headerlink" title="重新构建隐藏类"></a>重新构建隐藏类</h3><p>关于隐藏类，还有一个问题你需要注意一下。在这节课开头我们提到了，V8 为了实现隐藏类，需要两个假设条件：</p>
<ul>
<li><p>对象创建好了之后就不会添加新的属性；</p>
</li>
<li><p>对象创建好了之后也不会删除属性。</p>
</li>
</ul>
<p>但是，JavaScript 依然是动态语言，在执行过程中，对象的形状是可以被改变的，如果某个对象的形状改变了，隐藏类也会随着改变，这意味着 V8 要为新改变的对象重新构建新的隐藏类，这对于 V8 的执行效率来说，是一笔大的开销。通俗地理解，给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>好了，现在我们知道了 V8 会为每个对象分配一个隐藏类，在执行过程中：</p>
<ul>
<li><p>如果对象的形状没有发生改变，那么该对象就会一直使用该隐藏类；</p>
</li>
<li><p>如果对象的形状发生了改变，那么 V8 会重建一个新的隐藏类给该对象。</p>
</li>
</ul>
<p>我们当然希望对象中的隐藏类不要随便被改变，因为这样会触发 V8 重构该对象的隐藏类，直接影响到了程序的执行性能。那么在实际工作中，我们应该尽量注意以下几点：</p>
<ul>
<li><p>使用字面量初始化对象时，要保证属性的顺序是一致的</p>
</li>
<li><p>尽量使用字面量一次性初始化完整对象属性</p>
</li>
<li><p>尽量避免使用 delete 方法</p>
</li>
</ul>
<h2 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h2><p>首先看一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>,<span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">x</span>: <span class="number">3</span> ,<span class="attr">y</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">90000</span>; i++) &#123;</span><br><span class="line">    loadX(o)</span><br><span class="line">    loadX(o1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常 V8 获取 o.x 的流程是这样的：查找对象 o 的隐藏类，再通过隐藏类查找 x 属性偏移量，然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 o.x 流程也需要反复被执行。我们有没有办法再度简化这个查找过程，最好能一步到位查找到 x 的属性值呢？答案是，有的。</p>
<p>其实这是一个关于内联缓存的思考题。我们可以看到，函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC。</p>
<h3 id="什么是内联缓存"><a href="#什么是内联缓存" class="headerlink" title="什么是内联缓存"></a>什么是内联缓存</h3><p>要回答这个问题，我们需要知道 IC 的工作原理。其实 IC 的原理很简单，直观地理解，就是在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。</p>
<p>IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。关于函数和反馈向量的关系你可以参看下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627516476/origin-of-ray/0f49d225b1ed71aaccd3cca2d1226dd3_tol5ss.jpg" alt></p>
<p>反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。比如下面这段函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line"> o.y = <span class="number">4</span></span><br><span class="line"> <span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 V8 执行这段函数的时候，它会判断 o.y = 4 和 return o.x 这两段是调用点 (CallSite)，因为它们使用了对象和属性，那么 V8 会在 loadX 函数的反馈向量中为每个调用点分配一个插槽。每个插槽中包括了插槽的索引 (slot index)、插槽的类型 (type)、插槽的状态 (state)、隐藏类 (map) 的地址、还有属性的偏移量，比如上面这个函数中的两个调用点都使用了对象 o，那么反馈向量两个插槽中的 map 属性也都是指向同一个隐藏类的，因此这两个插槽的 map 地址是一样的。</p>
<h3 id="多态和超态"><a href="#多态和超态" class="headerlink" title="多态和超态"></a>多态和超态</h3><p>好了，通过缓存执行过程中的基础信息，就能够提升下次执行函数时的效率，但是这有一个前提，那就是多次执行时，对象的形状是固定的，如果对象的形状不是固定的，那 V8 会怎么处理呢？我们调整一下上面这段 loadX 函数的代码，调整后的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> o.x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>,<span class="attr">y</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>:<span class="number">6</span>,<span class="attr">z</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">90000</span>; i++) &#123;</span><br><span class="line">    loadX(o)</span><br><span class="line">    loadX(o1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次执行时 loadX 时，V8 会将 o 的隐藏类记录在反馈向量中，并记录属性 x 的偏移量。那么当再次调用 loadX 函数时，V8 会取出反馈向量中记录的隐藏类，并和新的 o1 的隐藏类进行比较，发现不是一个隐藏类，那么此时 V8 就无法使用反馈向量中记录的偏移量信息了。面对这种情况，V8 会选择将新的隐藏类也记录在反馈向量中，同时记录属性值的偏移量，这时，反馈向量中的第一个槽里就包含了两个隐藏类和偏移量。</p>
<p>现在我们知道了，一个反馈向量的一个插槽中可以包含多个隐藏类的信息，那么：</p>
<ul>
<li><p>如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；</p>
</li>
<li><p>如果一个插槽中包含了 2～4 个隐藏类，那我们称这种状态为多态 (polymorphic)；</p>
</li>
<li><p>如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。</p>
</li>
</ul>
<p>总的来说，我们只需要记住一条就足够了，那就是单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（五）用公式讲清楚原型链</title>
    <url>/2020/12/10/javascript-prototype/</url>
    <content><![CDATA[<p>前面几篇文章我们从调用栈和执行上下文角度讲清楚了作用域和闭包，同时讲了作用域和this的区别，现在JavaScript中最难理解的几个概念就只剩下一个原型链了。</p>
<p>如果我们看过《JavaScript高级程序设计》的话应该就对其中那个原型的章节有印象，它有一个非常复杂的图，通过这图来讲了JavaScript的<code>_proto_</code>，<code>prototype</code>，<code>constructor</code>之间的指向关系。</p>
<p>一开始读那本书对这一块我是似懂非懂的，终于借这次重新梳理的机会搞清楚了。</p>
<p>这篇博客的内容还是分为两部分：</p>
<ul>
<li>通过几个公式来理清楚<code>_proto_</code>，<code>prototype</code>，<code>constructor</code>的指向关系。</li>
<li>原型链的使用</li>
</ul>
<a id="more"></a>

<h2 id="用公式讲清楚原型链"><a href="#用公式讲清楚原型链" class="headerlink" title="用公式讲清楚原型链"></a>用公式讲清楚原型链</h2><p>首先上一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>这段代码的原型链关系如下图所示</p>
<p>其中Parent()指的是构造函数</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203152_tccbro.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203152_tccbro.png"></p>
<p>怎么样，是不是有点晕？</p>
<p>不过不用急，我们通过公式一个个分析其中的指向关系。</p>
<p>在此之前有几个前置的知识需要大家了解：</p>
<ul>
<li>JavaScript所有的变量都是对象，分为两类，普通对象，也就是Object，和函数对象，也就是Function</li>
<li>任何函数都可以是构造函数，只要它用在new后面，比如上面的Parent函数，如果没有通过new Parent(),它就是一个普通的函数，但是在new后面，他就叫做构造函数了</li>
<li><code>_proto_</code>，<code>constructor</code>是对象独有的</li>
<li><code>prototype</code>是函数独有的，并且是一个普通对象</li>
</ul>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035555/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203207_eihbzw.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035555/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203207_eihbzw.png"></p>
<p>prototype是函数独有的属性，是从一个<strong>函数指向一个普通对象，代表着对象是函数的原型对象，这个对象也是当前函数所创建的实例的原型对象</strong></p>
<p>prototype设计之初就是为了实现继承，让有特定函数所创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象找到公共的属性和方法，有了prototype我们不需要为每一个实例创建重复的属性和方法，而是将属性方法创建在构造函数的原型对象（prototype）上</p>
<p>由此我们得出本文的<u><strong>第一个公式</strong></u>，或者说是结论：</p>
<p><u><strong>每个函数对象都有一个指针prototype，指向自己的原型对象，该对象是一个普通对象</strong></u></p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203215_aj5gbh.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203215_aj5gbh.png"></p>
<p><code>__proto__</code>属性是所有对象都有的，包括函数对象，<strong>它是从一个对象指向另外一个对象，即从一个对象指向该对象的原型对象（prototype）</strong>。</p>
<p>刚才我们说过，Parent.prototype上的属性和方法都叫做原型属性和原型方法，所有实例都可以访问。</p>
<p>那实例是如何与原型对象联系的呢？这就是本文的<strong><u>第二个公式</u></strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1.__proto__ === Parent.prototype</span><br></pre></td></tr></table></figure>

<p><code>__proto__</code>称为隐式原型，prototype称为显示原型，而原型链的也是通过<code>__proto__</code>的指向而形成的。</p>
<p>上面那个公式我们更具一般性的写法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.__proto__ === A.prototype(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>特殊)</span><br></pre></td></tr></table></figure>

<p>这样一写，我们就可以把其中的a和A进行替换，a是一个普通对象，A是它的构造函数。</p>
<p>通过上面这个公式我们可以分析下上图的指向问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(); <span class="comment">// 因为</span></span><br><span class="line">p1.__proto__ === Parent.prototype; <span class="comment">// 所以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">Parent.__proto__ === Fuction.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span> = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line">所有的prototype都是普通对象，也就是都是<span class="keyword">new</span> <span class="built_in">Object</span>()而来</span><br><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br><span class="line"></span><br><span class="line">因为<span class="built_in">Object</span>, <span class="built_in">Function</span>可以放在<span class="keyword">new</span>后面，所以也是个构造函数，也就是说<span class="built_in">Object</span> = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure>

<p>怎么样这样一分析，是不是一个公式就搞清楚了<code>__proto__</code>的指向问题</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor是对象才有的属性，是<strong>从一个对象指向一个函数，这个函数就是对象的构造函数</strong>。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203222_hiqpqf.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608035556/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215203222_hiqpqf.png"></p>
<p>这里我们得出本文的<strong><u>第三个公式</u></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.constructor === A;</span><br><span class="line">A.prototype其实也是A的一个实例 <span class="comment">// 这一点要非常注意</span></span><br></pre></td></tr></table></figure>

<p>通过这个结论，上面那个图就很好分析了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里总结下本文的所有公式和结论，大家看完可以回过头去看开头的图片，看看能不能分析出来</p>
<ul>
<li>JavaScript所有的变量都是对象，分为两类，普通对象，也就是Object，和函数对象，也就是Function</li>
<li>任何函数都可以是构造函数，只要它用在new后面，比如上面的Parent函数，如果没有通过new Parent(),它就是一个普通的函数，但是在new后面，他就叫做构造函数了</li>
<li><code>_proto_</code>，<code>constructor</code>是对象独有的</li>
<li><code>prototype</code>是函数独有的，并且是一个普通对象</li>
<li>每个函数对象都有一个指针prototype，指向自己的原型对象，该对象是一个普通对象</li>
<li>如果 const a = new A();  那么 a.<code>__proto__</code> === A.prototype(Object.prototype.<code>__proto__</code> === null特殊)</li>
<li>如果 const a = new A();  那么 a.constructor === A;</li>
</ul>
<h2 id="原型链应用"><a href="#原型链应用" class="headerlink" title="原型链应用"></a>原型链应用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br><span class="line">alert(instance.getFatherValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这段是比较常见的继承方式</p>
<p>那为什么我们可以在Son的一个实例上点出Father.prototype上的getFatherValue方法呢？</p>
<ul>
<li>首先因为instance = new Son()，new操作符会先创建一个临时对象tempObj，然后执行Son.call(tempObj)，最终返回整个tempObj，这样就在tempObj上挂载了属性sonProperty，并赋值给instance。</li>
<li>本来Son.prototype是一个普通对象，也就是Son的一个实例，它的原型链指针<code>__proto__</code>指向了一个普通对象，也就是说这个时候<code>Son.prototype.__proto__ === Object.prototype</code>，再往上<code>Object.prototype.__proto__ === null</code>原型链的寻找就结束了。</li>
<li>但是我们修改了Son.prototype为Father的一个实例，我们在执行Son.prototype = new Father()的时候会创建一个新的普通对象，并且该对象上有fatherPrototype。所以说这个时候<code>Son.prototype.__proto__ === Father.prototype</code>。</li>
<li>这个时候如果我们在instance上找不到getFatherValue()，我们回去Son.prototype上找，再找不到，我们会沿着<code>__proto__</code>构建的原型链去向上找，这个时候就找到了<code>Son.prototype.__proto__</code>，也就是Father.prototype，而getFatherValue()正好就是我们定义在这里的。</li>
<li>多提一句，getSonVaule()是定义在Son.prototype上的，也就是new Father()这个实例上的</li>
</ul>
<p>所以说我们能通过instance点出sonPrototypt, fatherPrototype, getFatherValue()，getSonVaule()的原因是完全不同的。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（三）作用域链和闭包</title>
    <url>/2020/12/07/javascript-scope-chain-and-closure/</url>
    <content><![CDATA[<p>在<a href="https://sunra.top/2020/11/22/javascript-scope/">上一篇关于作用域的文章</a>中我们通过调用栈讲什么是作用域。</p>
<p><strong>每当我们调用一个函数时就会在调用栈中为该函数创建执行上下文，到目前为止我们知道了该执行上下文中有变量环境，用于存储通过var声明的变量，也有一个词法环境，词法环境又是一个栈，依次放置了函数中通过let和const声明的在不同层级的块级作用域中的变量</strong>。</p>
<p>基于上面的变量环境和词法环境，我们可以明白如何在一个函数的执行上下文中找到正确的变量。</p>
<p>那如果我们所需要的变量其实不在当前执行上下文，而是在上一级的执行上下文中呢？我们怎么确定上一级的执行上下文是哪个？</p>
<p>这个问题就涉及了我们今天的主题：作用域链。</p>
<p>理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。所以，如果你想学透一门语言，作用域和作用域链一定是绕不开的。</p>
<a id="more"></a>

<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>首先我们来看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"大树"</span></span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"bigTree"</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>你觉得这段代码中的 bar 函数和 foo 函数打印出来的内容是什么？</p>
<p>那么当这段代码执行到 bar 函数内部时，其调用栈的状态图如下所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615206801/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308203206_ik52ug.png" alt="函数调用栈"></p>
<p>从图中可以看出，全局执行上下文和 foo 函数的执行上下文中都包含变量 myName，那 bar 函数里面 myName 的值到底该选择哪个呢？</p>
<p>也许你的第一反应是按照调用栈的顺序来查找变量，查找方式如下：</p>
<ol>
<li>先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo 函数中的变量。</li>
<li>在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的 myName。</li>
</ol>
<p>如果按照这种方式来查找变量，那么最终执行 bar 函数打印出来的结果就应该是“大树”。但实际情况并非如此，如果你试着执行上述代码，你会发现打印出来的结果是“bigTree”。为什么会是这种情况呢？要解释清楚这个问题，那么你就需要先搞清楚作用域链了。</p>
<h3 id="Outer指针"><a href="#Outer指针" class="headerlink" title="Outer指针"></a>Outer指针</h3><p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。</p>
<p>当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，</p>
<p>比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615206965/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308203554_ww6kdz.png" alt="函数调用栈及outer指针"></p>
<p>从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。</p>
<p>我们把这个查找的链条就称为作用域链。现在你知道变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？</p>
<p>要回答这个问题，你还需要知道什么是<strong>词法作用域</strong>。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。</p>
<blockquote>
<p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<p>也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p>
</blockquote>
<h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><p>前面我们通过全局作用域和函数级作用域来分析了作用域链，那接下来我们再来看看块级作用域中变量是如何查找的？在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"bigTree2"</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">"Chrome浏览器"</span></span><br><span class="line">        <span class="built_in">console</span>.log(test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"大树"</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"bigTree"</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>你可以自己先分析下这段代码的执行流程，看看能否分析出来执行结果。要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。</p>
<p>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615207688/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308204757_sxwhgi.png" alt="函数作用域链查找顺序"></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>首先说一下闭包是什么。</p>
<p>这里首先用一种通俗的，比较基于表象的说法来解释：首先它是闭合的，也就是说外界无法直接访问其中的变量，第二，它又是个包，所以它暴露出来某些方法可以让外界来操作它的内部数据。</p>
<p>这里你可以结合下面这段代码来理解什么是闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"bigTree"</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        setName:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">"大树"</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>首先我们看看当执行到 foo 函数内部的return innerBar这行代码时调用栈的情况，你可以参考下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615207902/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308205133_amqnac.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615207902/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308205133_amqnac.png"></p>
<p>从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。</p>
<p><strong>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量</strong>，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615208011/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210308205319_qlouxj.png" alt="闭包原理"></p>
<p>从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。</p>
<p>之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。</p>
<p>好了，现在我们终于可以给闭包一个正式的定义了。<strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包</strong>。</p>
<h3 id="闭包的回收"><a href="#闭包的回收" class="headerlink" title="闭包的回收"></a>闭包的回收</h3><p>理解什么是闭包之后，接下来我们再来简单聊聊闭包是什么时候销毁的。因为如果闭包使用不正确，会很容易造成内存泄漏的，关注闭包是如何回收的能让你正确地使用闭包。</p>
<p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p>
<p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p>
<p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（二）作用域</title>
    <url>/2020/11/22/javascript-scope/</url>
    <content><![CDATA[<p>在<a href="https://sunra.top/2020/11/20/javascript-variable-promotion/">上一篇博客</a>中，我们从执行机制和上下文的角度讲了javascript中的变量提升。</p>
<p>正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。</p>
<p>虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统中的。</p>
<a id="more"></a>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
<p>在 ES6 之前，ES 的作用域只有两种：<strong>全局作用域和函数作用域</strong>。</p>
<ul>
<li><p>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</p>
</li>
<li><p>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</p>
</li>
</ul>
<p>在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持<strong>块级作用域</strong>。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</p>
<p>简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。</p>
<h2 id="ES6-是如何解决变量提升带来的缺陷"><a href="#ES6-是如何解决变量提升带来的缺陷" class="headerlink" title="ES6 是如何解决变量提升带来的缺陷"></a>ES6 是如何解决变量提升带来的缺陷</h2><p>ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span> <span class="comment">//报错，const声明的变量不可以修改</span></span><br></pre></td></tr></table></figure>

<p>从这段代码你可以看出来，两者之间的区别是，使用 let 关键字声明的变量是可以被改变的，而使用 const 声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域，为了简单起见，在下面的代码中，我统一使用 let 关键字来演示。</p>
<p>那么接下来，我们就通过实际的例子来分析下，ES6 是如何通过块级作用域来解决上面的问题的。你可以先参考下面这段存在变量提升的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，有两个地方都定义了变量 x，第一个地方在函数块的顶部，第二个地方在 if 块的内部，由于 var 的作用范围是整个函数，所以在编译阶段，会生成如下的执行上下文：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036132/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204135_tf6mt8.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036132/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204135_tf6mt8.png"></p>
<p>从执行上下文的变量环境中可以看出，<strong>最终只生成了一个变量 x，函数体内所有对 x 的赋值操作都会直接改变变量环境中的 x 值</strong>。</p>
<p>所以上述代码最后通过 console.log(x) 输出的是 2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是 1，因为在 if 块里面的声明不应该影响到块外面的变量。</p>
<p>既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这段代码，其输出结果就和我们的预期是一致的。这是因为 let 关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常符合我们的编程习惯了：作用域块内声明的变量不影响块外面的变量。</p>
<h2 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h2><p>你已经知道 JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行上面这段代码的时候，JavaScript 引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了 let 关键字，let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？</p>
<p>第一步是编译并创建执行上下文，下面是我画出来的执行上下文示意图:</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036132/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204144_dzlkwq.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036132/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204144_dzlkwq.png"></p>
<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li><p>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</p>
</li>
<li><p>通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</p>
</li>
<li><p>在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</p>
</li>
</ul>
<p>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036133/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204151_izno2z.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036133/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204151_izno2z.png"></p>
<p>从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。</p>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036133/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204157_g15aka.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1608036133/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20201215204157_g15aka.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也就是说JavaScript一开始的设计只有全局作用域和函数作用域，对应的就是全局执行上下文和函数执行上下文，我们在函数执行过程中首先就在自身的执行上下文中查找变量，如果找不到就会依次沿着调用栈中的上下文去查找一直到全局执行上下文。</p>
<p>后来为了引入块级作用域，我们就又在上下文中创建了一个新的栈结构，叫做词法环境，每当遇到块级作用域，就在词法环境中进行压栈，并把本块级作用域中使用let和const声明的变量放入其中，而var声明的变量还是放在变量环境中，这样既能够实现块级作用域，又能兼容var的变量提升。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（四）this指向的是什么？</title>
    <url>/2020/12/10/javascript-this/</url>
    <content><![CDATA[<p>在以前的文章中，我们通过调用栈执行上下文讲清楚了JavaScript的作用域链和闭包的原理。</p>
<p>这次我们来讲一下JavaScript中另外一个非常重要的概念this。</p>
<p>这篇文章有两个要点，第一，this是个什么东西，第二，this指向如何判断。</p>
<a id="more"></a>

<h2 id="this是个什么东西"><a href="#this是个什么东西" class="headerlink" title="this是个什么东西"></a>this是个什么东西</h2><p>首先我们需要知道的一点是，JavaScript中所有的变量其实都是对象，而<strong>对象又分为两类，普通对象，也就是Object，另一类就是函数对象，也就是Function。</strong></p>
<p>关于这两点的区别我们下一篇关于原型链的文章会详细解释。</p>
<p>我们现在只需要知道this指向的是一个对象，这个对象可以是普通对象，也可以是函数对象。</p>
<p>而this的指向是在代码运行过程中动态变化的，它最终指向的是调用函数的对象。</p>
<p>这里可能会有人稍微有些疑惑：作用域和this是什么关系？</p>
<p>其实严格来说，这二者没什么关系：</p>
<ul>
<li>通过前面的文章我们能够知道，变量声明之后，是存储在执行上下文中的，我们通过变量名去查找变量时，是通过作用域链，能通过这条链找到这个变量的位置，就说明这个变量的作用域包括到哪里。</li>
<li>而this是什么呢？它也是执行上下文中的一个变量，每个执行上下文（只有函数有执行上下文）中都有一个this指针，而这个指针了，它指向的就是调用当前函数的对象，当然如果this上如果点不出一个变量，会想普通对象一样沿着原型链往上找。</li>
</ul>
<p>所以说这二者根本就是两个体系，前者如何通过执行上下文栈维护的链去找到一个变量，当前找不到就去上一级找，而<strong>this不同，它不存在根据名字沿着链找这个过程，它就是一个指针，指向了调用创建当前执行上下文的函数的对象</strong>。</p>
<h2 id="this的指向如何判断"><a href="#this的指向如何判断" class="headerlink" title="this的指向如何判断"></a>this的指向如何判断</h2><h3 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h3><p>首先我们来看看全局执行上下文中的 this 是什么。</p>
<p>你可以在控制台中输入console.log(this)来打印出来全局执行上下文中的 this，最终输出的是 window 对象。所以你可以得出这样一个结论：全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p>
<h3 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h3><p>现在你已经知道全局对象中的 this 是指向 window 对象了，那么接下来，我们就来重点分析函数执行上下文中的 this。还是先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>我们在 foo 函数内部打印出来 this 值，执行这段代码，打印出来的也是 window 对象，这说明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。估计你会好奇，那能不能设置执行上下文中的 this 来指向其他对象呢？答案是肯定的。通常情况下，有下面三种方式来设置函数执行上下文中的 this 值。</p>
<h4 id="通过函数的-call-方法设置"><a href="#通过函数的-call-方法设置" class="headerlink" title="通过函数的 call 方法设置"></a>通过函数的 call 方法设置</h4><p>你可以通过函数的 call 方法来设置函数执行上下文的 this 指向，比如下面这段代码，我们就并没有直接调用 foo 函数，而是调用了 foo 的 call 方法，并将 bar 对象作为 call 方法的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  myName : <span class="string">"极客邦"</span>,</span><br><span class="line">  test1 : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.myName = <span class="string">"极客时间"</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar)</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="built_in">console</span>.log(myName)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，然后观察输出结果，你就能发现 foo 函数内部的 this 已经指向了 bar 对象，因为通过打印 bar 对象，可以看出 bar 的 myName 属性已经由“极客邦”变为“极客时间”了，同时在全局执行上下文中打印 myName，JavaScript 引擎提示该变量未定义。</p>
<p>其实除了 call 方法，你还可以使用 bind 和 apply 方法来设置函数执行上下文中的 this。</p>
<h4 id="通过对象调用方法设置"><a href="#通过对象调用方法设置" class="headerlink" title="通过对象调用方法设置"></a>通过对象调用方法设置</h4><p>要改变函数执行上下文中的 this 指向，除了通过函数的 call 方法来实现外，还可以通过对象调用的方式，比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">"极客时间"</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们定义了一个 myObj 对象，该对象是由一个 name 属性和一个 showThis 方法组成的，然后再通过 myObj 对象来调用 showThis 方法。</p>
<p>执行这段代码，你可以看到，最终输出的 this 值是指向 myObj 的。所以，你可以得出这样的结论：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。其实，你也可以认为 JavaScript 引擎在执行myObject.showThis()时，将其转化为了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<h4 id="通过构造函数中设置"><a href="#通过构造函数中设置" class="headerlink" title="通过构造函数中设置"></a>通过构造函数中设置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"极客时间"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> CreateObj()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们使用 new 创建了对象 myObj，那你知道此时的构造函数 CreateObj 中的 this 到底指向了谁吗？</p>
<p>其实，当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：</p>
<ul>
<li><p>首先创建了一个空对象 tempObj；</p>
</li>
<li><p>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</p>
</li>
<li><p>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</p>
</li>
<li><p>最后返回 tempObj 对象。</p>
</li>
</ul>
<p>为了直观理解，我们可以用代码来演示下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>

<h2 id="特例：箭头函数"><a href="#特例：箭头函数" class="headerlink" title="特例：箭头函数"></a>特例：箭头函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">"极客时间"</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">"极客邦"</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 <strong>ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（六）V8 是怎么执行 JavaScript 代码的</title>
    <url>/2021/07/24/javascript-v8-run-flow/</url>
    <content><![CDATA[<p>这周在极客时间上买了李兵老师的另一门课，关于Google V8原理简介的课程。很多知识点，包括V8的整体执行流程，变量是如何存储的，对象是如何快速检索属性的，函数是如何编译的，闭包是如何实现的，不同的调用方法是是如何影响堆栈的分布的等。</p>
<p>感觉内容很多，就继续原本的系列，这一次总结下我看完以后对V8执行JavaScript的流程的理解。</p>
<a id="more"></a>

<p>处理器不能直接识别由高级语言所编写的代码，那怎么办呢？通常，要有两种方式来执行这些代码。</p>
<p>第一种是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果，这就需要解释器自己去模拟实现CPU和内存的一些特性，比如堆和栈。</p>
<p>第二种是编译执行。采用这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。</p>
<p>那么，V8 作为 JavaScript 的虚拟机的一种，它到底是怎么执行 JavaScript 代码的呢？是解释执行，还是编译执行呢？</p>
<p>实际上，V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。</p>
<p>这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参考下面完整的 V8 执行 JavaScript 的流程图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1627084451/origin-of-ray/8a34ae8c1a7a0f87e19b1384a025e354_qm24us.jpg" alt></p>
<h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><p>我们先看上图中的最左边的部分，在 V8 启动执行 JavaScript 之前，它还需要准备执行 JavaScript 时所需要的一些基础环境，这些基础环境包括了“堆空间”“栈空间”“全局执行上下文”“全局作用域”“消息循环系统”“内置函数”等，这些内容都是在执行 JavaScript 过程中需要使用到的，比如：</p>
<ul>
<li><p>JavaScript 全局执行上下文就包含了执行过程中的全局信息，比如一些内置函数，全局变量等信息；</p>
</li>
<li><p>全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；</p>
</li>
<li><p>而 V8 是采用了经典的堆和栈的内存管理模式，所以 V8 还需要初始化内存中的堆和栈结构；</p>
</li>
<li><p>另外，想要我们的 V8 系统活起来，还需要初始化消息循环系统，消息循环系统包含了消息驱动器和消息队列，它如同 V8 的心脏，不断接受消息并决策如何处理消息。</p>
</li>
</ul>
<h2 id="生成AST"><a href="#生成AST" class="headerlink" title="生成AST"></a>生成AST</h2><p>基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript 代码了。</p>
<p>首先 V8 会接收到要执行的 JavaScript 源代码，不过这对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义，它需要结构化这段字符串。</p>
<p>结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有明确的层次结构，方便使用和维护，并有一定的操作规范。</p>
<p>V8 源代码的结构化之后，就生成了抽象语法树 (AST)，我们称为 AST，AST 是便于 V8 理解的结构。</p>
<p>关于如何生成AST的，可以看一下我另外一个关于<a href="https://sunra.top/2021/06/22/babel-1/">Babel的系列博客</a>，讲了Babel是如何将一串代码解析成AST的，虽然和V8不完全一样，但是解析的思路是相同的</p>
<h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><p>有了 AST 和作用域之后，接下来就可以生成字节码了，字节码是介于 AST 和机器代码的中间代码。但是与特定类型的机器代码无关，解释器可以直接解释执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。</p>
<p>这里还需要注意一点，在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量，这里又有两点比较关键的地方了，第一，<a href="https://sunra.top/2020/12/07/javascript-scope-chain-and-closure/">作用域链</a>，这个我之前的博客已经讲过了，还有就是，闭包是如何实现的，这一点其实很有意思，下一篇博客我再继续总结。</p>
<h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>好了，生成了字节码之后，解释器就登场了，它会按照顺序解释执行字节码，并输出执行结果。</p>
<p>相信你注意到了，我们在解释器附近画了个监控机器人，这是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。</p>
<p>当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。</p>
<p>不过，和静态语言不同的是，JavaScript 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript执行机制（一）变量提升</title>
    <url>/2020/11/20/javascript-variable-promotion/</url>
    <content><![CDATA[<p>只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包等。不仅如此，理解执行上下文和调用栈的概念还能助你成为一名更合格的前端开发者。这次我们就从上下文的角度讲一下js的变量提升。</p>
<a id="more"></a>

<p>先看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">'ray'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数showName被执行'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于熟悉js的人来说，这段代码的输出很容易判断，它会分别打印出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">函数showName被执行</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>而如果我们把上面的代码改成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数showName被执行'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就会抛出一个变量未定义的错误。</p>
<ul>
<li><p>从上面两段代码的执行结果来看，我们可以得出如下三个结论。</p>
</li>
<li><p>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。</p>
</li>
<li><p>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。在一个函数定义之前使用它，不会出错，且函数能正确执行。</p>
</li>
</ul>
<p>第一个结论很好理解，因为变量没有定义，这样在执行 JavaScript 代码时，就找不到该变量，所以 JavaScript 会抛出错误。</p>
<p>但是对于第二个和第三个结论，就挺让人费解的：</p>
<ul>
<li><p>变量和函数为什么能在其定义之前使用？这似乎表明 JavaScript 代码并不是一行一行执行的。</p>
</li>
<li><p><strong>同样的方式，变量和函数的处理结果为什么不一样</strong>？比如上面的执行结果，提前使用的 showName 函数能打印出来完整结果，但是提前使用的 myname 变量值却是 undefined，而不是定义时使用的“ray”这个值。</p>
</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>要解释这两个问题，你就需要先了解下什么是<strong>变量提升</strong>。</p>
<p>不过在介绍变量提升之前，我们先通过下面这段代码，来看看什么是 JavaScript 中的<strong>声明</strong>和<strong>赋值</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">'ray'</span></span><br></pre></td></tr></table></figure>

<p>这段代码你可以把它看成是两行代码组成的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname    <span class="comment">//声明部分</span></span><br><span class="line">myname = <span class="string">'ray'</span>  <span class="comment">//赋值部分</span></span><br></pre></td></tr></table></figure>

<p>上面是变量的声明和赋值，那接下来我们再来看看函数的声明和赋值，结合下面这段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把function(){console.log(‘bar’)}赋值给 bar。</p>
<p>好了，理解了声明和赋值操作，那接下来我们就可以聊聊什么是变量提升了。所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 变量提升部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 把变量 myname提升到开头，</span></span><br><span class="line"><span class="comment">// 同时给myname赋值为undefined</span></span><br><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 把函数showName提升到开头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'showName被调用'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可执行代码部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="comment">// 去掉var声明部分，保留赋值语句</span></span><br><span class="line">myname = <span class="string">'ray'</span></span><br></pre></td></tr></table></figure>

<h2 id="javascript执行顺序"><a href="#javascript执行顺序" class="headerlink" title="javascript执行顺序"></a>javascript执行顺序</h2><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但，这并不准确。<strong>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong>。对，你没听错，一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。</p>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>那么编译阶段和变量提升存在什么关系呢？为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1615119851/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210307201954_os3t8h.png" alt="JavaScript 编译执行流程"></p>
<p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。</p>
<p><strong>执行上下文</strong>是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，<strong>确定该函数在执行期间用到的诸如 this、变量、对象以及函数</strong>等。</p>
<p><strong>在执行上下文中存在一个变量环境的对象（Viriable Environment）</strong>，该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。</p>
<p>你可以简单地把变量环境对象看成是如下结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">VariableEnvironment: </span><br><span class="line">	myname -&gt; <span class="literal">undefined</span>, </span><br><span class="line">	showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>

<p>了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">'ray'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数showName被执行'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以一行一行来分析上述代码：</p>
<ul>
<li><p>第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</p>
</li>
<li><p>第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；</p>
</li>
<li><p>第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置（不了解堆也没关系，JavaScript 的执行堆和执行栈我会在后续文章中介绍）。</p>
</li>
</ul>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程：</p>
<ul>
<li><p>当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</p>
</li>
<li><p>接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</p>
</li>
<li><p>接下来执行第 3 行，把“ray”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“ray”，变量环境如下所示：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; <span class="string">"ray"</span>, </span><br><span class="line">     showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>

<p>好了，以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 异步编程语法</title>
    <url>/2020/06/02/javascript_async/</url>
    <content><![CDATA[<p>这篇文章讲的是异步编程语法的发展过程，异步方法的调用是如何逐渐变成同步语法的。</p>
<p>异步编程的方法，大概有<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html" rel="external nofollow noopener noreferrer" target="_blank">下面四种</a>。</p>
<blockquote>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
</blockquote>
<p>ECMAScript 6 （简称 ES6 ）作为下一代 JavaScript 语言，将 JavaScript 异步编程带入了一个全新的阶段。<strong>这组系列文章的主题，就是介绍更强大、更完善的 ES6 异步编程方法。</strong></p>
<p>新方法比较抽象，初学时，我常常感到费解，直到很久以后才想通，<strong>异步编程的语法目标，就是怎样让它更像同步编程。</strong></p>
<p>这边文章讲的是这几种语法之间的关联，如果阅读过程中对于任意一个语法有深入理解的需求，可以去看一下<a href="https://es6.ruanyifeng.com/#README" rel="external nofollow noopener noreferrer" target="_blank">阮一峰老师的ES6语法入门</a>。</p>
<a id="more"></a>

<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>总的来说，async 是Generator函数的语法糖，并对Generator函数进行了改进。</p>
<h3 id="Generator函数简介"><a href="#Generator函数简介" class="headerlink" title="Generator函数简介"></a>Generator函数简介</h3><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p>
<p>有这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p>调用及运行结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hw.next()<span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>由结果可以看出，<code>Generator函数</code>被调用时并不会执行，只有当调用<code>next方法</code>、内部指针指向该语句时才会执行，<code>即函数可以暂停，也可以恢复执行</code>。每次调用遍历器对象的next方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<h3 id="Generator函数暂停恢复执行原理"><a href="#Generator函数暂停恢复执行原理" class="headerlink" title="Generator函数暂停恢复执行原理"></a>Generator函数暂停恢复执行原理</h3><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。</p>
<blockquote>
<p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
</blockquote>
<p>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下：</p>
<ol>
<li>协程<code>A</code>开始执行</li>
<li>协程<code>A</code>执行到某个阶段，进入暂停，执行权转移到协程<code>B</code></li>
<li>协程<code>B</code>执行完成或暂停，将执行权交还<code>A</code></li>
<li>协程<code>A</code>恢复执行</li>
</ol>
<p>协程遇到<code>yield命令</code>就暂停，等到执行权返回（调用next方法），再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>通常，<strong>我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器</strong>,<code>co 模块</code>就是一个著名的执行器。</p>
<p><strong>Generator 是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权</strong>。两种方法可以做到这一点：</p>
<ol>
<li>回调函数。将异步操作包装成 <a href="https://sunra.top/2020/05/08/curry/">Thunk 函数</a>，在回调函数里面交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。</li>
</ol>
<h4 id="回调函数的执行器（yield-Thunk函数）"><a href="#回调函数的执行器（yield-Thunk函数）" class="headerlink" title="回调函数的执行器（yield Thunk函数）"></a>回调函数的执行器（yield Thunk函数）</h4><p>下面就是一个基于 Thunk 函数的 Generator 执行器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line"> <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"> result.value(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。</p>
<p>有了这个执行器，执行 Generator 函数方便多了。不管有多少个异步操作，直接传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'fileA'</span>);  <span class="comment">//readFile是一个Thunk函数，返回一个函数用于传入回调函数</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'fileB'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">yield</span> readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h4 id="Promise对象的执行器（yield-Promise）"><a href="#Promise对象的执行器（yield-Promise）" class="headerlink" title="Promise对象的执行器（yield Promise）"></a>Promise对象的执行器（yield Promise）</h4><p>一个基于 Promise 对象的简单自动执行器（或者说一个只能yield Promise的执行器）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();  <span class="comment">//调用生成器，生成迭代器g</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;  <span class="comment">//定义执行器的next函数</span></span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);  <span class="comment">//调用迭代器g的next函数，运行直至遇到下一个yield</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;  <span class="comment">//如果迭代器执行完成，则返回结果</span></span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;  <span class="comment">//result.value是个promise，在then中继续调用执行器的next方法，并传入promise。resolve的data</span></span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next(); <span class="comment">// 直接调用一次执行器的next方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用时，可以这样使用即可，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">yield</span> fetch(<span class="string">'https://xxx'</span>) <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response1)</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">yield</span> fetch(<span class="string">'https://xxx'</span>) <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response2'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response2)</span><br><span class="line">&#125;</span><br><span class="line">run(foo);</span><br><span class="line"><span class="comment">//1. g = foo();生成器foo执行后生成迭代器g</span></span><br><span class="line"><span class="comment">//2. 第一次运行执行器的next方法，不传入参数，此时的result=g.next(data)的data为undefined，result为&#123;value: fetch('https://xxx'), done: false&#125;</span></span><br><span class="line"><span class="comment">// 3. done为false，继续执行，result.value.then其实就是fetch('https://xxx').then,then的回调函数中传入的data就是fetch函数的结果，回调函数中再次调用执行器的next方法，此时把fetch的结果传入。</span></span><br><span class="line"><span class="comment">// 4. 第二次运行执行器的next方法，传入的data为上一步fetch返回的结果，通过g.next(data)继续运行foo函数，并把data赋值给response1，然后打印data，知道遇到第二个yield，此时执行器的next函数中的result.value就等于第二个fetch。重复上一步。</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p>
<p><strong>上面这种方式看起来就很像async/await了，把上面的yield换成await，function* 换成async，其实就是await在等待执行器将运行权限返回回来。</strong>有一点通过内置执行器的不断回调将回调或者then给捋直了，捋成了同步的样子，<strong>通过yield将线程的执行权交出去，执行器中的异步函数返回数据后，将数据连同执行权通过next方法交会给生成器中</strong>。</p>
<h4 id="CO函数"><a href="#CO函数" class="headerlink" title="CO函数"></a>CO函数</h4><p>有一个 Generator 函数，用于依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>co 函数库可以让你不用编写 Generator 函数的执行器。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p>
<p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>
<h4 id="CO函数源码"><a href="#CO函数源码" class="headerlink" title="CO函数源码"></a>CO函数源码</h4><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">     <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</span><br><span class="line">     <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">     onFulfilled();</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> ret;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         ret = gen.next(res);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         <span class="keyword">return</span> reject(e);</span><br><span class="line">       &#125;</span><br><span class="line">       next(ret);</span><br><span class="line">     &#125;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就是关键的 next 函数，它会反复调用自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">    <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">    <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<blockquote>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
</blockquote>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>ES7 中引入了 async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可<strong>以说async 是Generator函数的语法糖</strong>，并对Generator函数进行了改进。</p>
<p>前文中的代码，用<code>async</code>实现是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">await</span> fetch(<span class="string">'https://xxx'</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response1)</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">await</span> fetch(<span class="string">'https://xxx'</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response2'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点：</p>
<ol>
<li><code>内置执行器</code>。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。</li>
<li><code>更好的语义</code>。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
<li><code>更广的适用性</code>。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li>
<li><code>返回值是 Promise</code>。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li>
</ol>
<p>这里的重点是自带了执行器，相当于把我们要额外做的(写执行器/依赖co模块)都封装了在内部。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123; <span class="comment">//spawn函数就是自动执行器，跟简单版的思路是一样的，多了Promise和容错处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF(); <span class="comment">// 执行生成器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF(); <span class="comment">// next就是gen.next()</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;  <span class="comment">//如果所有await执行完了，则async就可以resolve了</span></span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;  <span class="comment">//如果还有await，则将下一个await的内容（可以是promise，或者一个值等）变为Promsie</span></span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;); <span class="comment">//在then中执行gen.next（v），将执行权连同数据v交回给async函数继续执行到下一个await。</span></span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;); <span class="comment">//调用step，传入一个函数，函数返回gen.next()</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，也就是说async/await其实就是将生成器和执行器封装在了一起，把本来要执行的函数封装进了生成器中，并用内置的执行器去执行它。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator可以在等待异步方法（回调函数，Promise）返回的时候将线程执行权暂时交出去，而执行器可以帮忙执行生成器的同时去等待异步方法返回后调用生成器的next方法，将异步方法的返回数据连同执行权交还给生成器。</p>
<p>总的来说，我们可以通过回调，Promise等方法进行异步编程，Promise解决了回调噩梦，但是还是和同步编程语法有所区别，所以就利用了生成器Generator，在yiled Promise的结果的时候先将线程的执行权交出去，等到Promise resolve时，通过next方法把执行权连同Promise的结果一起交给生成器继续执行直到下一个yield或结束。</p>
<p>此时看起来已经像是同步编程了，yield在等待异步的结果返回后继续执行，但是上述的这个过程中需要我们编写一个执行器去执行生成器，在yield的时候将执行权交出去，在yield的Promise resolve后调用Generator的next把执行权交回来，这个执行器一开始比较出名的是CO，它能够帮助我们执行Generator，但是yield的只能是Thunk或Promise。</p>
<p>于是后来就出现了async/await，<strong>用async定义的函数，会被放入一个生成器中，然后返回一个Promise。它不仅让语法更好理解，而且内置了一个支持范围更广的执行器（Promise）去执行这个生成器，这个Promise就是一个执行器，然后利用执行器内部函数的不断递归回调去调用生成器的next方法</strong>，去逐个执行所有的异步函数，直到所有的await执行完成后调用Promise的resolve，将结果返回。</p>
<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2015/05/co.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 箭头函数探索</title>
    <url>/2019/12/13/js-arrow-function-context/</url>
    <content><![CDATA[<p>想要明白箭头函数与普通函数，匿名函数的区别，首先要搞清楚三个概念，原型链，作用域，上下文。这三个概念很重要，也很容易混淆。</p>
<p>总的来说，作用域阐述的是变量起作用的范围，原型链表述的是我们按照什么样的路径去查找一个变量，上下文则大部分情况下指的是this是谁，通过this去获取一个变量不会像原型链那样一路向上查找。</p>
<a id="more"></a>

<p>关于原型链和作用域的部分是截取了<a href="https://github.com/mqyqingfeng/Blog" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a>的部分内容，并加上了一些个人的理解和解释</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">'Ray'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>上述代码中Person就是一个构造函数（js中没有专门的类和构造函数，只要你可以通过new去调用某个函数，这个函数就可以是构造函数）。我们通过new创建了一个Person的实例person，并给这个实例添加了一个属性name。</p>
<p>但是如果我们再new一个新的Person，这个新的实例中是不会有name这个属性的。</p>
<p>那么我们如何让每个Person的实例上都有一个name属性呢？</p>
<p>答案就是将name属性写在原型上</p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>每个函数都有一个 prototype 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虽然写在注释里，但是你要注意：</span></span><br><span class="line"><span class="comment">// prototype是函数才会有的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>这个函数的prototype指向的是一个对象，这个对象就是调用构造函数创建的实例的原型，也就是所有通过构造函数创建的实例的共有的原型</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>原型无法指向构造函数，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h4><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'Daisy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<h4 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h4><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.name = &apos;Kevin&apos;</span><br><span class="line">console.log(obj.name) // Kevin</span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><p>那 Object.prototype 的原型呢？</p>
<p>null，我们可以打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure>

<p>然而 null 究竟代表了什么呢？null 表示“没有对象”，即该处不应该有值。</p>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>图中由相互关联的原型组成的链状结构就是原型链，也就是最右侧的这条线。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>
<p>让我们认真看个例子就能明白之间的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>

<p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p>
<p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p>
<p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>上下文的讲解是翻译的一篇国外大佬的博客，这是<a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" rel="external nofollow noopener noreferrer" target="_blank">链接</a></p>
<p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p>
<h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>JavaScript 中有三种执行上下文类型。</p>
<ul>
<li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li>
<li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li>
<li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'Hello World!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside first function'</span>);</span><br><span class="line">  second();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Again inside first function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside second function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Inside Global Execution Context'</span>);</span><br></pre></td></tr></table></figure>

<p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p>
<p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>first()</code> 函数的执行上下文。</p>
<p>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<p>现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。</p>
<p>创建执行上下文有两个阶段：<strong>1) 创建阶段</strong> 和 <strong>2) 执行阶段</strong>。</p>
<h4 id="The-Creation-Phase"><a href="#The-Creation-Phase" class="headerlink" title="The Creation Phase"></a>The Creation Phase</h4><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li><strong>this</strong> 值的决定，即我们所熟知的 <strong>This 绑定</strong>。</li>
<li>创建<strong>词法环境</strong>组件。</li>
<li>创建<strong>变量环境</strong>组件。</li>
</ol>
<p>所以执行上下文在概念上表示如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LexicalEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="xml">  VariableEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="This-绑定："><a href="#This-绑定：" class="headerlink" title="This 绑定："></a><strong>This 绑定：</strong></h5><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  baz: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.baz();   <span class="comment">// 'this' 引用 'foo', 因为 'baz' 被</span></span><br><span class="line">             <span class="comment">// 对象 'foo' 调用</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.baz;</span><br><span class="line">bar();       <span class="comment">// 'this' 指向全局 window 对象，因为</span></span><br><span class="line">             <span class="comment">// 没有指定引用对象</span></span><br></pre></td></tr></table></figure>

<h5 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h5><p><a href="http://ecma-international.org/ecma-262/6.0/" rel="external nofollow noopener noreferrer" target="_blank">官方的 ES6</a> 文档把词法环境定义为</p>
<blockquote>
<p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p>
</blockquote>
<p>简单来说<strong>词法环境</strong>是一种持有<strong>标识符—变量映射</strong>的结构。（这里的<strong>标识符</strong>指的是变量/函数的名字，而<strong>变量</strong>是对实际对象[包含函数类型对象]或原始数据的引用）。</p>
<p>现在，在词法环境的<strong>内部</strong>有两个组件：(1) <strong>环境记录器</strong>和 (2) 一个<strong>外部环境的引用</strong>。</p>
<ol>
<li><strong>环境记录器</strong>是存储变量和函数声明的实际位置。</li>
<li><strong>外部环境的引用</strong>意味着它可以访问其父级词法环境（作用域）。</li>
</ol>
<p><strong>词法环境</strong>有两种类型：</p>
<ul>
<li><strong>全局环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 <strong>null</strong>。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象。</li>
<li>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li>
</ul>
<p><strong>环境记录器</strong>也有两种类型（如上！）：</p>
<ol>
<li><strong>声明式环境记录器</strong>存储变量、函数和参数。</li>
<li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。</li>
</ol>
<p>简而言之，</p>
<ul>
<li>在<strong>全局环境</strong>中，环境记录器是对象环境记录器。</li>
<li>在<strong>函数环境</strong>中，环境记录器是声明式环境记录器。</li>
</ul>
<p><strong>注意 —</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p>
<p>抽象地讲，词法环境在伪代码中看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">"Object"</span>,</span><br><span class="line">      <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">FunctionExectionContext = &#123;</span></span><br><span class="line"><span class="xml">  LexicalEnvironment: &#123;</span></span><br><span class="line"><span class="xml">    EnvironmentRecord: &#123;</span></span><br><span class="line"><span class="xml">      Type: "Declarative",</span></span><br><span class="line"><span class="xml">      // 在这里绑定标识符</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="变量环境："><a href="#变量环境：" class="headerlink" title="变量环境："></a>变量环境：</h5><p>它同样是一个词法环境，其环境记录器持有<strong>变量声明语句</strong>在执行上下文中创建的绑定关系。</p>
<p>如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p>
<p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p>
<p>我们看点样例代码来理解上面的概念：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>执行上下文看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  LexicalEnvironment: &#123;</span></span><br><span class="line"><span class="xml">    EnvironmentRecord: &#123;</span></span><br><span class="line"><span class="xml">      Type: "Object",</span></span><br><span class="line"><span class="xml">      // 在这里绑定标识符</span></span><br><span class="line"><span class="xml">      a: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">      b: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">      multiply: <span class="tag">&lt; <span class="attr">func</span> &gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: "Object",</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: "Declarative",</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: "Declarative",</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> — 只有遇到调用函数 <code>multiply</code> 时，函数执行上下文才会被创建。</p>
<p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p>
<p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p>
<p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p>
<p>这就是我们说的变量声明提升。</p>
<h2 id="箭头函数探索"><a href="#箭头函数探索" class="headerlink" title="箭头函数探索"></a>箭头函数探索</h2><h3 id="箭头函数与匿名函数的区别"><a href="#箭头函数与匿名函数的区别" class="headerlink" title="箭头函数与匿名函数的区别"></a>箭头函数与匿名函数的区别</h3><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>如果使用箭头函数，以前的那种hack写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>

<p>就不再需要了。</p>
<p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(<span class="number">2015</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h3 id="普通函数与箭头函数的区别"><a href="#普通函数与箭头函数的区别" class="headerlink" title="普通函数与箭头函数的区别"></a>普通函数与箭头函数的区别</h3><h4 id="箭头函数的this指向"><a href="#箭头函数的this指向" class="headerlink" title="箭头函数的this指向:"></a>箭头函数的this指向:</h4><h5 id="1-箭头函数没有prototype，所以箭头函数本身没有this"><a href="#1-箭头函数没有prototype，所以箭头函数本身没有this" class="headerlink" title="1. 箭头函数没有prototype，所以箭头函数本身没有this"></a>1. 箭头函数没有prototype，所以箭头函数本身没有this</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="2-箭头函数的this指向它定义的时候继承自外层的第一个普通函数的this"><a href="#2-箭头函数的this指向它定义的时候继承自外层的第一个普通函数的this" class="headerlink" title="2. 箭头函数的this指向它定义的时候继承自外层的第一个普通函数的this"></a>2. 箭头函数的this指向它定义的时候继承自外层的第一个普通函数的this</h5><blockquote>
<p>这里的定义指的不是我们编码时的定义代码，而是真正运行到定义函数的位置时的在内存中的定义</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, barObj = &#123; <span class="attr">msg</span>: <span class="string">'bar的this指向'</span> &#125;;</span><br><span class="line">fooObj = &#123; <span class="attr">msg</span>: <span class="string">'foo的this指向'</span> &#125;;</span><br><span class="line">bar.call(barObj); <span class="comment">// 将bar的this指向barObj</span></span><br><span class="line">foo.call(fooObj); <span class="comment">// 将foo的this指向fooObj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a(); <span class="comment">// 结果：&#123; msg: 'bar的this指向' &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'this指向定义的时候外层第一个普通函数'</span>); <span class="comment">// </span></span><br><span class="line">  &#125;; <span class="comment">// 在bar中定义 this继承于bar函数的this指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中在bar函数中定义箭头函数a,在foo中执行，那么在bar.call()执行的时候传入的对象就是箭头函数this指向的对象，因为bar.call执行的时候定义了箭头函数，而这个时候箭头函数的外层函数的this被call改成了barObj。</p>
<h5 id="3-我们无法直接改变箭头函数的this指向"><a href="#3-我们无法直接改变箭头函数的this指向" class="headerlink" title="3. 我们无法直接改变箭头函数的this指向"></a>3. 我们无法直接改变箭头函数的this指向</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fnObj = &#123; <span class="attr">msg</span>: <span class="string">'尝试直接修改箭头函数的this指向'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a.call(fnObj); <span class="comment">// 结果：&#123; msg: 'bar的this指向' &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能通过重新调用定义的外层函数并改变外层函数的this指向来改变</p>
<h5 id="4-箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window-全局对象"><a href="#4-箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window-全局对象" class="headerlink" title="4. 箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)"></a>4. 箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向<code>window</code>(全局对象)</h5><p>参考文章</p>
<p><a href="https://juejin.im/post/5c76972af265da2dc4538b64" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5c76972af265da2dc4538b64</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mqyqingfeng/Blog</a></p>
<p><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5ba32171f265da0ab719a6d7</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>js_modules</title>
    <url>/2020/01/17/js-modules2/</url>
    <content><![CDATA[<p>今天在补测试的时候，遇到了无法识别import的问题，在通过babel的动态导入插件解决了之后，就对import，export，exports，require这些平时经常用的关键字产生了一点疑惑，于是就梳理了一下它们之间的演变过程与关系。</p>
<a id="more"></a>

<p>我主要通过这三篇博客再结合自己平时的实际开发经验来理解这个问题：</p>
<p><a href="https://segmentfault.com/a/1190000011081338" rel="external nofollow noopener noreferrer" target="_blank">JavaScript模块化演进历史</a></p>
<p><a href="https://www.zhihu.com/question/56820346" rel="external nofollow noopener noreferrer" target="_blank">require和import的区别</a></p>
<p><a href="https://juejin.im/post/5a2e5f0851882575d42f5609" rel="external nofollow noopener noreferrer" target="_blank">import, require, export, module.exports混合使用详解</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>总结起来就是，js的模块化大概经历了三个重要的阶段，第一个阶段就是完全没有模块化，所有的变量和方法都是全局的。第二个阶段是js的开发者在社区中提出的各种方式来实现模块化，这其中就有最初的CommonJS，以AMD为核心的RequireJS，以CMD为核心的SeaJS。第三个阶段就是es6推出的esModule规范，也就是import 和 export。这其中第二个阶段其实完全就不是js语法本身的规范，而是开发者自己提出的一种模块的封装方式。而第三种方式是es6的新语法，大部分情况下并没有得到很好地支持，一般情况下会被babel给转化会CommonJS的require，exports这种语法，这也是为什么我们在开发中有的时候各种关键字可以混用的原因，你以为你是在用esmodule，其实已经被babel转化成为了es5的旧语法。</p>
<p>在第一个阶段，所有的变量都是全局的，所以根本就没有模块化的概念。</p>
<p>第二个阶段，首先是开发者们提出的各种模块封装的方式，比如命名空间，可以解决遍地全局变量的问题，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// greeting.js</span></span><br><span class="line"><span class="keyword">var</span> app = &#123;&#125;;</span><br><span class="line">app.helloInLang = &#123;</span><br><span class="line">  en: <span class="string">'Hello world!'</span>,</span><br><span class="line">  es: <span class="string">'¡Hola mundo!'</span>,</span><br><span class="line">  ru: <span class="string">'Привет мир!'</span></span><br><span class="line">&#125;;</span><br><span class="line">app.writeHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(helloInLang[lang]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// third_party_script.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'The script is broken'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样并没有隐私可言，所有的属性都是暴露到了全局对象上，所有地方都可以访问和操作</p>
<p>于是有人就结合立即执行函数和闭包 ，解决了私有变量的问题，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> helloInLang = &#123;</span><br><span class="line">    en: <span class="string">'Hello world!'</span>,</span><br><span class="line">    es: <span class="string">'¡Hola mundo!'</span>,</span><br><span class="line">    ru: <span class="string">'Привет мир!'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.getHello = <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloInLang[lang];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.writeHello = <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="built_in">module</span>.getHello(lang));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>立即执行函数本身有自己的独立的作用域，其中声明的变量仅在该作用域之下，其他地方只能通过立即执行函数返回的方法去访问私有变量。</p>
<p>上面两种方式虽然解决了一点模块的问题，但是还是不能很好的管理模块之间的关系，这一点直到Node.js到来，CommonJS规范的落地才得以一定程度上解决。</p>
<p>CommonJS是一套同步的方案，它考虑的是在服务端运行的Node.js，主要是通过<code>require</code>来加载依赖项，通过<code>exports</code>或者<code>module.exports</code>来暴露接口或者数据的方式。</p>
<p>由于服务器上通过<code>require</code>加载资源是直接读取文件的，因此中间所需的时间可以忽略不计，但是在浏览器这种需要依赖HTTP获取资源的就不行了，资源的获取所需的时间不确定，这就导致必须使用异步机制，代表主要有2个：</p>
<ul>
<li>基于 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" rel="external nofollow noopener noreferrer" target="_blank">AMD</a> 的RequireJS</li>
<li>基于 <a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" rel="external nofollow noopener noreferrer" target="_blank">CMD</a> 的SeaJS</li>
</ul>
<p>它们分别在浏览器实现了<code>define</code>、<code>require</code>及<code>module</code>的核心功能，虽然两者的目标是一致的，但是实现的方式或者说是思路，还是有些区别的，AMD偏向于依赖前置，CMD偏向于用到时才运行的思路，从而导致了依赖项的加载和运行时间点会不同，关于这2者的比较，网上有很多了，这里推荐几篇仅供参考：</p>
<ul>
<li>《<a href="https://lifesinger.wordpress.com/2011/05/17/the-difference-between-seajs-and-requirejs/" rel="external nofollow noopener noreferrer" target="_blank">SeaJS 和 RequireJS 的异同</a>》</li>
<li>《<a href="https://div.io/topic/430" rel="external nofollow noopener noreferrer" target="_blank">再谈 SeaJS 与 RequireJS 的差异</a>》</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function (require) &#123;</span><br><span class="line">    var a = require(&apos;./a&apos;); // &lt;- 运行到此处才开始加载并运行模块a</span><br><span class="line">    var b = require(&apos;./b&apos;); // &lt;- 运行到此处才开始加载并运行模块b</span><br><span class="line">    // more code ..</span><br><span class="line">&#125;)</span><br><span class="line">// AMD</span><br><span class="line">define(</span><br><span class="line">    [&apos;./a&apos;, &apos;./b&apos;], // &lt;- 前置声明，也就是在主体运行前就已经加载并运行了模块a和模块b</span><br><span class="line">    function (a, b) &#123;</span><br><span class="line">        // more code ..</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过例子，你可以看到除了语法上面的区别，这2者主要的差异还是在于：</p>
<blockquote>
<p>何时加载和运行依赖项？</p>
</blockquote>
<p>这也是CommonJS社区中质疑AMD最主要原因之一，不少人认为它破坏了规范，反观CMD模式，简单的去除<code>define</code>的外包装，这就是标准的CommonJS实现，所以说CMD是最贴近CommonJS的异步模块化方案。</p>
<p>再后来就出现了ES6的对于模块的正式定义</p>
<p>2015年6月，<strong>ECMAScript2015</strong>也就是<strong>ES6</strong>发布了，JavaScript终于在语言标准的层面上，实现了模块功能，使得在编译时就能确定模块的依赖关系，以及其输入和输出的变量，不像 CommonJS、AMD之类的需要在运行时才能确定（例如FIS这样的工具只能预处理依赖关系，本质上还是运行时解析），成为浏览器和服务器通用的模块解决方案。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/greeting.js</span></span><br><span class="line"><span class="keyword">const</span> helloInLang = &#123;</span><br><span class="line">    en: <span class="string">'Hello world!'</span>,</span><br><span class="line">    es: <span class="string">'¡Hola mundo!'</span>,</span><br><span class="line">    ru: <span class="string">'Привет мир!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHello = <span class="function">(<span class="params">lang</span>) =&gt;</span> (</span><br><span class="line">    helloInLang[lang];</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sayHello = <span class="function">(<span class="params">lang</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getHello(lang));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sayHello &#125; <span class="keyword">from</span> <span class="string">'./lib/greeting'</span>;</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">'ru'</span>);</span><br></pre></td></tr></table></figure>

<p>与CommonJS用<code>require()</code>方法加载模块不同，在ES6中，<code>import</code>命令可以具体指定加载模块中用<code>export</code>命令暴露的接口（不指定具体的接口，默认加载<code>export default</code>），没有指定的是不会加载的，因此会在编译时就完成模块的加载，这种加载方式称为<strong>编译时加载</strong>或者<strong>静态加载</strong>。</p>
<p>而CommonJS的<code>require()</code>方法是在运行时才加载的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/greeting.js</span></span><br><span class="line"><span class="keyword">const</span> helloInLang = &#123;</span><br><span class="line">    en: <span class="string">'Hello world!'</span>,</span><br><span class="line">    es: <span class="string">'¡Hola mundo!'</span>,</span><br><span class="line">    ru: <span class="string">'Привет мир!'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helloInLang[lang];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.getHello = getHello;</span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(getHello(lang))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="built_in">require</span>(<span class="string">'./lib/greeting'</span>).sayHello;</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">'ru'</span>);</span><br></pre></td></tr></table></figure>

<p>可以看出，CommonJS中是将整个模块作为一个对象引入，然后再获取这个对象上的某个属性。</p>
<h2 id="使用方面"><a href="#使用方面" class="headerlink" title="使用方面"></a>使用方面</h2><h3 id="require-exports-和-import-export-形式不一样"><a href="#require-exports-和-import-export-形式不一样" class="headerlink" title="require/exports 和 import/export 形式不一样"></a>require/exports 和 import/export 形式不一样</h3><p>require/exports 的用法只有以下三种简单的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">exports.fs = fs</span><br><span class="line">module.exports = fs</span><br></pre></td></tr></table></figure>

<p>而 import/export 的写法就多种多样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import fs from &apos;fs&apos;</span><br><span class="line">import &#123;default as fs&#125; from &apos;fs&apos;</span><br><span class="line">import * as fs from &apos;fs&apos;</span><br><span class="line">import &#123;readFile&#125; from &apos;fs&apos;</span><br><span class="line">import &#123;readFile as read&#125; from &apos;fs&apos;</span><br><span class="line">import fs, &#123;readFile&#125; from &apos;fs&apos;</span><br><span class="line"></span><br><span class="line">export default fs</span><br><span class="line">export const fs</span><br><span class="line">export function readFile</span><br><span class="line">export &#123;readFile, read&#125;</span><br><span class="line">export * from &apos;fs&apos;</span><br></pre></td></tr></table></figure>

<h3 id="require-exports-和-import-export-本质上的差别"><a href="#require-exports-和-import-export-本质上的差别" class="headerlink" title="require/exports 和 import/export 本质上的差别"></a>require/exports 和 import/export 本质上的差别</h3><p>形式上看起来五花八门，但本质上：</p>
<ol>
<li>CommonJS 还是 ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象；</li>
<li>default 是 ES6 Module 所独有的关键字，export default fs 输出默认的接口对象，import fs from ‘fs’ 可直接导入这个对象；</li>
<li>ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。</li>
</ol>
<p>1、2 相对比较好理解，3 需要看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line">exports.count = <span class="number">0</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'increase count to'</span>, ++exports.count, <span class="string">'in counter.js after 500ms'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;count&#125; = <span class="built_in">require</span>(<span class="string">'./counter'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'read count after 1000ms in commonjs is'</span>, count)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">'./counter'</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'read count after 1000ms in es6 is'</span>, count)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>分别运行 commonjs.js 和 es6.js：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> node commonjs.js</span><br><span class="line">increase count to 1 <span class="keyword">in</span> counter.js after 500ms</span><br><span class="line"><span class="built_in">read</span> count after 1000ms <span class="keyword">in</span> commonjs is 0</span><br><span class="line">➜  <span class="built_in">test</span> babel-node es6.js</span><br><span class="line">increase count to 1 <span class="keyword">in</span> counter.js after 500ms</span><br><span class="line"><span class="built_in">read</span> count after 1000ms <span class="keyword">in</span> es6 is 1</span><br></pre></td></tr></table></figure>

<p>上述只是我对三篇博客以及自己理解的一点总结，具体详细的解释可以去看上面的三篇博客再自己实现一下会有更好的理解。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>CommonJs，Requirejs和ES6</title>
    <url>/2019/09/15/js_modules1/</url>
    <content><![CDATA[<p>CommonJs，Requirejs和ES6模块的使用。</p>
<a id="more"></a>

<h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>commonjs是nodejs这也就是服务器端广泛使用的模块化机制。</p>
<p>该规范的主要内容是，模块必须通过module.exports导出对外的变量或接口，通过require（）来导入其他模块的输出到当前模块的作用域中</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域，文件中的变量，函数，类等都是对其他文件不可见的，如果想在多个文件分享变量，必须定义为global对象的属性（不推荐）</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>在每个模块内部，module变量代表当前模块，它的exports属性时对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取module.exports变量</p>
<h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>，后缀名默认为js</p>
<p>模块的加载顺序，按照其在代码中的出现顺序</p>
<p>根据require的参数不同，require命令回去不同的路径寻找模块文件</p>
<p>（1）如果参数字符串以 / 开头，则表示加载的是一个位于绝对路径的模块文件</p>
<p>（2）如果参数字符串以 ./ 开头，则表示加载的是一个位于相对路径的模块文件</p>
<p>（3）如果参数字符串不以上述两种方式开头，表示加载的是一个默认提供的核心模块（node核心模块，或者通过全局安装或局部安装在node_modules中的模块）</p>
<h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>一般都会有一个主文件（入口文件），在index.html中加载这个入口文件，然后在这个入口文件中加载其他文件，可以在package.json中配置main字段指定入口文件</p>
<h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><p>第一次加载某个模块时，Node会缓存该模块，以后再加载该模块，就直接从缓存中取出该模块的module.exports</p>
<h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h4><p>CommonJS的加载机制是，输入的是被输入值的拷贝，也就是一旦输出了一个值，模块内部的变化就影响不到这个值</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD（异步模块定义）是为浏览器环境设计的，因为commonjs模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件</p>
<h3 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h3><p>define方法用于定义模块，RequireJS要求每个模块放到一个单独的文件中</p>
<p>按照是否依赖其他模块，可以分为两种，第一种是定义独立模块，第二种是定义非独立模块</p>
<h4 id="独立模块"><a href="#独立模块" class="headerlink" title="独立模块"></a>独立模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	***</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="comment">//返回接口</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="非独立模块"><a href="#非独立模块" class="headerlink" title="非独立模块"></a>非独立模块</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'module1'</span>, <span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">	***</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="comment">//返回接口</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="加载模块-1"><a href="#加载模块-1" class="headerlink" title="加载模块"></a>加载模块</h3><p>使用require方法加载模块，但由于是异步的因此使用回调函数的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'m1'</span>, <span class="string">'m2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">	***</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码表示加载m1和m2两个模块，当加载成功之后，执行回调函数，该回调函数就用来完成具体的任务</p>
<p>require方法也可以用在define方法内部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> otherModule = <span class="built_in">require</span>(<span class="string">'otherModule'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>require方法也支持第三个参数，即错误处理的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(</span><br><span class="line">    [<span class="string">'backbone'</span>], </span><br><span class="line">    (Backbone) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Backbone.View.extend(&#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    (err) =&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>require方法本身也是一个对象，它有一个config方法，用于配置require.js的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        jquery: <span class="string">'lib/jquery'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h4><p>paths参数指定各个模块的位置，这个位置既可以是同一个服务器上的位置，也可以是外部网址，也可以为同一个模块定义多个位置，这样当第一个位置加载失败，会加载第二个位置。上述代码指定了jquery的位置，这样在文件中就可以直接在文件中直接使用require([‘jquery’], function(){})了</p>
<h4 id="shim"><a href="#shim" class="headerlink" title="shim"></a>shim</h4><p>有些库是AMD不兼容的，所以就需要指定shim属性，该属性用于帮助AMD加载非AMD规范的库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">'backbone'</span>: <span class="string">'vendor/backbone'</span>,</span><br><span class="line">        <span class="string">'underscore'</span>: <span class="string">'vendor/underscore'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        <span class="string">'backbone'</span>: &#123;</span><br><span class="line">            deps: [<span class="string">'underscore'</span>],</span><br><span class="line">            exports: <span class="string">'Backbone'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'underscore'</span>: &#123;</span><br><span class="line">            exports: <span class="string">"_"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES6-Modules"><a href="#ES6-Modules" class="headerlink" title="ES6 Modules"></a>ES6 Modules</h2><p>ES6正式提出了内置的模块化语法，我们在浏览器端无需额外引入requirejs来进行模块化。</p>
<p>ES6中的模块有以下特点：</p>
<p>模块自动运行在严格模式下<br>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；<br>模块顶级作用域的 this 值为 undefined<br>对于需要让模块外部代码访问的内容，模块必须导出它们</p>
<h3 id="定义模块-2"><a href="#定义模块-2" class="headerlink" title="定义模块"></a>定义模块</h3><p>使用export关键字将任意变量，函数或者类公开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"cz"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象，即导出引用</span></span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重命名模块"><a href="#重命名模块" class="headerlink" title="重命名模块"></a>重命名模块</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h3><p>模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中**只能设置一个默认导出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用export导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。</p>
<p>也可以使用重命名方法导出默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="加载模块-2"><a href="#加载模块-2" class="headerlink" title="加载模块"></a>加载模块</h3><p>在模块中使用<strong>import关键字</strong>来导入其他模块。<br>import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1,identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h4 id="重命名导入"><a href="#重命名导入" class="headerlink" title="重命名导入"></a>重命名导入</h4><p>与导出相同，我们同样可以重命名导入的绑定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>

<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export与import。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/crystal6918/article/details/74906757" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/crystal6918/article/details/74906757</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JWT</title>
    <url>/2019/10/26/jwt/</url>
    <content><![CDATA[<p> JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案 </p>
<a id="more"></a>

<h2 id="JWT背景"><a href="#JWT背景" class="headerlink" title="JWT背景"></a>JWT背景</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p>
<blockquote>
<p>1、用户向服务器发送用户名和密码。</p>
<p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>
<p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p>
<p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p>
<p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
</blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
<h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>jwt是一个很长的字符串，有三部分，中间用点号隔开。</p>
<p>JWT 的三个部分依次如下。</p>
<blockquote>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
</blockquote>
<p>写成一行，就是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; Header.Payload.Signature</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">&gt;   <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<blockquote>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
</blockquote>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">&gt;   <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">&gt;   <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; HMACSHA256(</span><br><span class="line">&gt;   base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">&gt;   base64UrlEncode(payload),</span><br><span class="line">&gt;   secret)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h2 id="JWT的特点"><a href="#JWT的特点" class="headerlink" title="JWT的特点"></a>JWT的特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1. 该方案更易于水平扩展</strong></p>
<p>在cookie-session方案中，cookie内仅包含一个session标识符，而诸如用户信息、授权列表等都保存在服务端的session中。如果把session中的认证信息都保存在JWT中，在服务端就没有session存在的必要了。当服务端水平扩展的时候，就不用处理session复制（session replication）/ session黏连（sticky session）或是引入外部session存储了。</p>
<p><strong>2. 该方案可防护CSRF攻击</strong></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p><strong>更多的空间占用。</strong></p>
<p>如果将原存在服务端session中的各类信息都放在JWT中保存在客户端，可能造成JWT占用的空间变大，需要考虑cookie的空间限制等因素，如果放在Local Storage，则可能受到XSS攻击。</p>
</li>
<li><p><strong>更不安全。</strong></p>
<p>这里是特指将JWT保存在Local Storage中，然后使用Javascript取出后作为HTTP header发送给服务端的方案。在Local Storage中保存敏感信息并不安全，容易受到跨站脚本攻击，跨站脚本（Cross site script，简称xss）是一种“HTML注入”，由于攻击的脚本多数时候是跨域的，所以称之为“跨域脚本”，这些脚本代码可以盗取cookie或是Local Storage中的数据。可以从这篇文章查看 <a href="http://www.cnblogs.com/luminji/archive/2012/05/22/2507185.html" rel="external nofollow noopener noreferrer" target="_blank">XSS攻击</a>的原理解释。</p>
</li>
<li><p><strong>无法作废已颁布的令牌。</strong></p>
<p>所有的认证信息都在JWT中，由于在服务端没有状态，即使你知道了某个JWT被盗取了，你也没有办法将其作废。在JWT过期之前（你绝对应该设置过期时间），你无能为力。</p>
</li>
<li><p><strong>不易应对数据过期。</strong></p>
<p>与上一条类似，JWT有点类似缓存，由于无法作废已颁布的令牌，在其过期前，你只能忍受“过期”的数据。</p>
</li>
</ol>
<p>参考文章：</p>
<p> <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a> </p>
<p> <a href="https://juejin.im/entry/5993a030f265da24941202c2" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/5993a030f265da24941202c2</a> </p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 猜字谜</title>
    <url>/2021/02/27/leetcode-1178/</url>
    <content><![CDATA[<p>昨天是元宵节，leetcode的每日一题也很应景出了一道猜字谜的题目。</p>
<p>既然真正的猜字谜我不擅长，还是来看看这道算法的猜字谜吧。</p>
<p>首先上题目的链接：</p>
<p><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以设计出解决该字谜问题的一个算法流程：</p>
<ul>
<li>首先我们计算出每一个word 对应的集合 Sw，存放在某一「数据结构」中，便于后续操作中的快速查找；</li>
</ul>
<ul>
<li>随后我们依次枚举每一个puzzle，计算出其对应的集合 Sp，并枚举满足要求的子集 S’p。对于每一个 S’p，我们在「数据结构」中查找其出现的次数，那么所有的 S’p出现次数之和就是puzzle 对应的谜底个数。</li>
</ul>
<p>有了这个方案我们就可以思考如何设计这个数据结构，让我们能快速的存储和查找。</p>
<a id="more"></a>

<h2 id="二进制状态压缩"><a href="#二进制状态压缩" class="headerlink" title="二进制状态压缩"></a>二进制状态压缩</h2><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>由于题目中规定word 和puzzle 均只包含小写字母，因此 Sw和 Sp的大小最多为 26，我们可以考虑使用一个长度为 26的二进制数 bw或 bp 来表示这一集合。</p>
<blockquote>
<p>为什么叫状态压缩呢？其实这个数据结构我们也可以用一个长度为26的数组来表示，但是这样就需要26个Number的空间，但是如果我们用一个Number的二进制形式来表示26个字母是否出现，就可以省下26倍的空间。</p>
</blockquote>
<p>因此我们可以使用一个哈希映射来表示需要的「数据结构」：对于哈希映射中的每一个键值对，其中的键表示一个长度为 26 的二进制数，值表示其出现的次数，即数组 words 中多少个 word 压缩成的二进制数等于键。构造哈希映射的过程也很简单：我们只需要遍历每一个 word，并遍历 word 中的每一个字母，将对应位置的二进制位标记为 1，这样就计算出了word 对应的二进制表示，将其在哈希映射中作为键对应的值增加 1 即可。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> freq = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">    <span class="keyword">let</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> ch <span class="keyword">of</span> word) &#123;</span><br><span class="line">        mask |= (<span class="number">1</span> &lt;&lt; (ch.charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CountOne(mask) &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">        freq.set(mask, (freq.get(mask) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环中的mask就是压缩后的二进制数，CountOne的作用是返回mask转换为二进制后1的数量</p>
<p>因为每个puzzle长度都为7，所以只有mask中1的数量不超过7的时候才有可能有答案。</p>
<h3 id="二进制遍历"><a href="#二进制遍历" class="headerlink" title="二进制遍历"></a>二进制遍历</h3><p>接下来我们要对每个puzzle也进行二进制的状态压缩，计算每个puzzle的状态，然后遍历每个状态的子集，看看freq中有几个相同的。</p>
<h4 id="枚举二进制的伪代码"><a href="#枚举二进制的伪代码" class="headerlink" title="枚举二进制的伪代码"></a>枚举二进制的伪代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_subset</span>(<span class="params">bitmask</span>)</span></span><br><span class="line"><span class="function">    <span class="title">subset</span> = <span class="title">bitmask</span></span></span><br><span class="line">    answer = [bitmask]</span><br><span class="line">    <span class="keyword">while</span> subset != <span class="number">0</span></span><br><span class="line">        subset = (subset - <span class="number">1</span>) &amp; bitmask</span><br><span class="line">        put subset into the answer list</span><br><span class="line">    end <span class="keyword">while</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">end <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> puzzle <span class="keyword">of</span> puzzles) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123; <span class="comment">//注意，这里从第二位开始，因为第一位是必须有的</span></span><br><span class="line">        mask |= (<span class="number">1</span> &lt;&lt; (puzzle[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subset = mask;</span><br><span class="line">    <span class="keyword">while</span>(subset) &#123;</span><br><span class="line">        <span class="comment">// 后6位的子集，然后补上第一位</span></span><br><span class="line">        <span class="keyword">let</span> s = subset | (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">        <span class="keyword">if</span> (freq.has(s)) &#123;</span><br><span class="line">            total += freq.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        subset = (subset - <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的循环会漏掉后六位的空集</span></span><br><span class="line">    <span class="keyword">if</span> (freq.has(<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()))) &#123;</span><br><span class="line">        total += freq.get(<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">words</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">puzzles</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CountOne</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = n.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(ch) === <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumOfValidWords = <span class="function"><span class="keyword">function</span>(<span class="params">words, puzzles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> freq = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">        <span class="keyword">let</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> ch <span class="keyword">of</span> word) &#123;</span><br><span class="line">            mask |= (<span class="number">1</span> &lt;&lt; (ch.charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CountOne(mask) &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            freq.set(mask, (freq.get(mask) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> puzzle <span class="keyword">of</span> puzzles) &#123;</span><br><span class="line">        <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            mask |= (<span class="number">1</span> &lt;&lt; (puzzle[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> subset = mask;</span><br><span class="line">        <span class="keyword">while</span>(subset) &#123;</span><br><span class="line">            <span class="keyword">let</span> s = subset | (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">            <span class="keyword">if</span> (freq.has(s)) &#123;</span><br><span class="line">                total += freq.get(s);</span><br><span class="line">            &#125;</span><br><span class="line">            subset = (subset - <span class="number">1</span>) &amp; mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (freq.has(<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()))) &#123;</span><br><span class="line">            total += freq.get(<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>].charCodeAt() - <span class="string">'a'</span>.charCodeAt()));</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-1423</title>
    <url>/2021/02/06/leetcode-1423/</url>
    <content><![CDATA[<p>这个周的每日一题，做算法，要有想象力，要足够充分发掘已知条件。</p>
<a id="more"></a>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/</a></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="回溯-双指针"><a href="#回溯-双指针" class="headerlink" title="回溯 + 双指针"></a>回溯 + 双指针</h3><p>这道题目每次都只能从开头或者末尾拿一个，那么做决策的过程可以是为一个二叉树。</p>
<p>我们分别用两个指针指向还未遍历的队头结尾，用作指向左子树和右子树的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> trackback = <span class="function">(<span class="params">cardPoints, k, count, left, right, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> leftresult = trackback(cardPoints, k, count + <span class="number">1</span>, left + <span class="number">1</span>, right, result + cardPoints[left]);</span><br><span class="line">        <span class="keyword">const</span> rightresult = trackback(cardPoints, k, count + <span class="number">1</span>, left, right - <span class="number">1</span>, result + cardPoints[right]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftresult, rightresult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxScore = <span class="function"><span class="keyword">function</span>(<span class="params">cardPoints, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> trackback(cardPoints, k, <span class="number">0</span>, <span class="number">0</span>, cardPoints.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="反向思考-滑动窗口"><a href="#反向思考-滑动窗口" class="headerlink" title="反向思考+滑动窗口"></a>反向思考+滑动窗口</h3><p>上面这种解法是常规解法，但是其实这个题目还有个已知条件我们没有好好利用。</p>
<p>就是每次只能从头或者尾取值，那也就是说完成k个的取值后，剩下的是连续的。</p>
<p>那么假设数组长度为n，则取完k个值后剩n-k个连续数组。</p>
<p>我们只需要求出n-k的连续数组的最小值，就可以推出取值的最大值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxScore = <span class="function"><span class="keyword">function</span>(<span class="params">cardPoints, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = cardPoints.length;</span><br><span class="line">    <span class="comment">// 滑动窗口大小为 n-k</span></span><br><span class="line">    <span class="keyword">const</span> windowSize = n - k;</span><br><span class="line">    <span class="comment">// 选前 n-k 个作为初始值</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; windowSize; ++i) &#123;</span><br><span class="line">        sum += cardPoints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> minSum = sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = windowSize; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口每向右移动一格，增加从右侧进入窗口的元素值，并减少从左侧离开窗口的元素值</span></span><br><span class="line">        sum += cardPoints[i] - cardPoints[i - windowSize];</span><br><span class="line">        minSum = <span class="built_in">Math</span>.min(minSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        totalSum += cardPoints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalSum - minSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode-1631</title>
    <url>/2021/01/29/leetcode-1631/</url>
    <content><![CDATA[<p>今天的leetcode每日一题是一道中等难度的题目，但是题解的各种思路确实是很有新意，在这里记录一下。</p>
<p>每次遇到这种很有想象力的题解，都会让我感到非常快乐，它们只是使用了一些你早已熟练的方法，却能用的非常巧妙。</p>
<a id="more"></a>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/path-with-minimum-effort/</a></p>
<p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p>
<p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p>
<p>请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>第一种方法是我最先想到的，利用回溯的思想枚举出所有的可能，然后选出最小的。</p>
<p>这种方法可行，但是会超时，也不是我这次记录的重点，就不放代码了。</p>
<h3 id="方法二：二分法-BFS"><a href="#方法二：二分法-BFS" class="headerlink" title="方法二：二分法+BFS"></a>方法二：二分法+BFS</h3><p>我们可以将这个问题转化成一个「判定性」问题，即：</p>
<blockquote>
<p>是否存在一条从左上角到右下角的路径，其经过的所有边权的最大值不超过 x<em>x</em>？</p>
</blockquote>
<p>这个判定性问题解决起来并不复杂，我们只要从左上角开始进行深度优先搜索或者广度优先搜索，在搜索的过程中只允许经过边权不超过 xx 的边，搜索结束后判断是否能到达右下角即可。    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumEffortPath = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dirs = [[<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> m = heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">999999</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> queue = [[<span class="number">0</span>, <span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Array</span>(m * n).fill(<span class="number">0</span>);</span><br><span class="line">        seen[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> [x, y] = queue.shift();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> nx = x + dirs[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">const</span> ny = y + dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !seen[nx * n + ny] &amp;&amp; <span class="built_in">Math</span>.abs(heights[x][y] - heights[nx][ny]) &lt;= mid) &#123;</span><br><span class="line">                    queue.push([nx, ny]);</span><br><span class="line">                    seen[nx * n + ny] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seen[m * n - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码核心思路：</p>
<ul>
<li>通过二分法不断取得mid值</li>
<li>从（0,0）开始对图进行广度优先遍历，但不同于普通的BFS，如果父子之间的权重超过mid，那么就视为父子之间的关系被切断</li>
<li>根据上一步的遍历结果看一下是否能够遍历到右下角的节点，如果可以， 说明当我们的体力消耗为mid时有一条让我们走到右下角的路，则继续二分</li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集的介绍可以看这里：<a href="https://sunra.top/2020/06/08/union-find-algorithm/">https://sunra.top/2020/06/08/union-find-algorithm/</a></p>
<p>我们将这 mn 个节点放入并查集中，实时维护它们的连通性。</p>
<p>由于我们需要找到从左上角到右下角的最短路径，因此我们可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当我们加入一条权值为 xx 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 xx 即为答案。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumEffortPath = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = heights.length;</span><br><span class="line">    <span class="keyword">const</span> n = heights[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> edges = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">const</span> id = i * n + j;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                edges.push([id - n, id, <span class="built_in">Math</span>.abs(heights[i][j] - heights[i - <span class="number">1</span>][j])]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                edges.push([id - <span class="number">1</span>, id, <span class="built_in">Math</span>.abs(heights[i][j] - heights[i][j - <span class="number">1</span>])]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    edges.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uf = <span class="keyword">new</span> UnionFind(m * n);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> edge <span class="keyword">of</span> edges) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = edge[<span class="number">0</span>], y = edge[<span class="number">1</span>], v = edge[<span class="number">2</span>];</span><br><span class="line">        uf.unite(x, y);</span><br><span class="line">        <span class="keyword">if</span> (uf.connected(<span class="number">0</span>, m * n - <span class="number">1</span>)) &#123;</span><br><span class="line">            ans = v;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">element, index</span>) =&gt;</span> index);</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当前连通分量数目</span></span><br><span class="line">        <span class="keyword">this</span>.setCount = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findset (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent[x] === x) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parent[x] = <span class="keyword">this</span>.findset(<span class="keyword">this</span>.parent[x]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unite (a, b) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="keyword">this</span>.findset(a), y = <span class="keyword">this</span>.findset(b);</span><br><span class="line">        <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size[x] &lt; <span class="keyword">this</span>.size[y]) &#123;</span><br><span class="line">            [x, y] = [y, x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parent[y] = x;</span><br><span class="line">        <span class="keyword">this</span>.size[x] += <span class="keyword">this</span>.size[y];</span><br><span class="line">        <span class="keyword">this</span>.setCount -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connected (a, b) &#123;</span><br><span class="line">        <span class="keyword">const</span> x = <span class="keyword">this</span>.findset(a), y = <span class="keyword">this</span>.findset(b);</span><br><span class="line">        <span class="keyword">return</span> x === y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>矩形区域不超过 K 的最大数值和</title>
    <url>/2021/04/22/leetcode-363/</url>
    <content><![CDATA[<p>今天leetcode的每日一题是一道困难的题目，但我总结一下他不是因为它的难度，而是这是一道结合了前缀和的变体以及二叉搜索树的题目，可以帮我回顾一下。</p>
<a id="more"></a>

<p>首先是题目链接：<a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/</a></p>
<h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><p>首先上来我们很容易想到，暴力枚举所有的子矩阵，那么这个时候的复杂度是O(m^2 * n^2)，这样很容易超时。不过这是基本思路，我们来一步步优化</p>
<h2 id="朴素二维前缀和"><a href="#朴素二维前缀和" class="headerlink" title="朴素二维前缀和"></a>朴素二维前缀和</h2><p>在暴力枚举的过程中，其实很多计算我们都做过了。</p>
<p>我们可以定义<code>sum[i][j]</code>为从（0,0）到（i，j）所有单元格值的和</p>
<p>那么，<code>sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i][j]</code></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619079599/origin-of-ray/1614650837-SAIiWg-1_djwemy.png" alt></p>
<p>因此当我们要求 (x1, y1) 作为左上角，(x2, y2) 作为右下角 的区域和的时候，可以直接利用前缀和数组快速求解：</p>
<p><code>sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]</code></p>
<p>这样一来我们就可以先通过O(m * n)来初始化前缀和数组，再通过O(m * n)来计算所有子矩阵的和，这样就把时间复杂度降低到了O(m * n);</p>
<h2 id="主体解题思路（将二维前缀和抽象为一维）"><a href="#主体解题思路（将二维前缀和抽象为一维）" class="headerlink" title="主体解题思路（将二维前缀和抽象为一维）"></a>主体解题思路（将二维前缀和抽象为一维）</h2><p>我们来细想一下「朴素二维前缀和」解法是如何搜索答案（子矩阵）：通过枚举「左上角」&amp;「右下角」来唯一确定某个矩阵。</p>
<p>换句话说是通过枚举 (i,j)(i,j) 和 (p,q)(p,q) 来唯一确定子矩阵的四条边，每个坐标点可以看作确定子矩阵的某条边。</p>
<p>既然要确定的边有四条，我们可以如何降低复杂度呢？</p>
<p>我们可以枚举其中三条边，然后使用数据结构来加速找第四条边。</p>
<p>当我们确定了三条边（红色）之后，形成的子矩阵就单纯取决于第四条边的位置（黄色）：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619079626/origin-of-ray/1618906986-JMALHO-image_xkmnqr.png" alt></p>
<p>于是问题转化为「<strong>如何快速求得第四条边（黄色）的位置在哪</strong>」。</p>
<p>我们可以进一步将问题缩小，考虑矩阵只有一行（一维）的情况：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619079646/origin-of-ray/1618907001-HvoRxP-image_oxr9sq.png" alt></p>
<p>这时候问题进一步转化为「在一维数组中，求解和不超过 K 的最大连续子数组之和」。</p>
<blockquote>
<p>如何做到这一步的？</p>
<p>当前原始一维数组（不是前缀和数组）中的值是该列在上下边界之间所有单元格的和</p>
</blockquote>
<p>对于这个一维问题，我们可以先预处理出「前缀和」，然后枚举子数组的左端点，然后通过「二分」来求解其右端点的位置。</p>
<p>假定我们已经求得一维数组的前缀和数组 sum，即可得下标范围 [i,j][i,j] 的和为：<br>areaSum(i,j)=sum[j]−sum[i−1]⩽k</p>
<p>经过变形后得：<br>sum[j]⩽k+sum[i−1]</p>
<p>我们有两种思路来最大化 areaSum(i, j)：</p>
<ul>
<li>确定（枚举）左端点位置 i，求得符合条件的最大右端点 sum[j]</li>
<li>确定（枚举）右端点位置 j，求得符合条件的最小左端点 sum[i]</li>
</ul>
<p>对于没有负权值的一维数组，我们可以枚举左端点 i，同时利用前缀和的「单调递增」特性，通过「二分」找到符合 sum[j]⩽k+sum[i−1] 条件的最大值 sum[j]，从而求解出答案。</p>
<p>但是如果是含有负权值的话，前缀和将会丢失「单调递增」的特性，我们也就无法使用枚举 i 并结合「二分」查找 j 的做法。</p>
<p>这时候需要将过程反过来处理：我们从左到右枚举 j，并使用「有序集合」结构维护遍历过的位置，找到符合 sum[i]sum[j]−k⩽sum[i] 条件的最小值 sum[i]，从而求解出答案。</p>
<p>基于上述分析，解决这样的一维数组问题复杂度是O(nlogn) 的。</p>
<p>同时，将一维思路应用到本题（二维），复杂度要么是O(m^2 ∗nlogn) 要么是 O(n^2 * mlogm);</p>
<p><strong>重点是如何与「一维」问题进行关联：显然「目标子矩阵的和」等于「子矩阵的右边列 与 原矩阵的左边列 形成的子矩阵和」-「子矩阵左边列 与 原矩阵左边列 形成的子矩阵和」</strong></p>
<p>我们可以使用 area[r] 代表「子矩阵的右边列 与 原矩阵的左边列 形成的子矩阵和」，使用 area[l - 1] 代表「子矩阵的左边列 与 原矩阵的左边列 形成的子矩阵和」的话，则有：<br>target=area[r]−area[l−1]⩽k</p>
<p>这与我们「一维问题」完全一致，同时由「上下行」&amp;「右边列」可以直接确定 area[r] 的大小，通过「有序集合」存储我们遍历 r 过程中的所有的 area[r] 从而实现「二分」查找符合area[r]−k⩽area[l−1] 条件的 最小 的 area[l - 1]。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumSubmatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="built_in">Number</span>.MIN_SAFE_INTEGER;</span><br><span class="line">  <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 初始化前缀和数组，sum[i][j]表示的是从（0,0）到（i - 1, j - 1）之间所有单元格的和</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历子矩阵的上边界</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> top = <span class="number">1</span>; top &lt;= m; top++) &#123;</span><br><span class="line">    <span class="comment">// 遍历子矩阵的下边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> bot = top; bot &lt;= m; bot++) &#123;</span><br><span class="line">      <span class="comment">// 到这里，我们就可以着手把二维矩阵问题转化为一维矩阵问题了</span></span><br><span class="line">      <span class="comment">// 因为上下边界的问题已经在双层循环中解决了</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用有序集合维护所有遍历到的右边界</span></span><br><span class="line">      <span class="comment">// 也就是上下边界之间，从第0列到右边界的和</span></span><br><span class="line">      <span class="keyword">const</span> sumSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">      sumSet.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> r = <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">        <span class="comment">// 从第0列到r列，top行到bot行之间所有单元格的和。</span></span><br><span class="line">        <span class="keyword">const</span> right = sum[bot][r] - sum[top - <span class="number">1</span>][r];</span><br><span class="line">        <span class="comment">// 通过二分法找一个大于等于right - k的最小值</span></span><br><span class="line">        <span class="keyword">const</span> left = sumSet.ceiling(right - k);</span><br><span class="line">        <span class="keyword">if</span> (left !== <span class="literal">null</span>) &#123;</span><br><span class="line">          ans = <span class="built_in">Math</span>.max(ans, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把遍历到的right加入到有序集合中，待下一次循环使用</span></span><br><span class="line">        <span class="comment">// 这里有一点，这个right一定是递增的，因为单元格中没有负值</span></span><br><span class="line">        sumSet.add(right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h2><p>不难发现，我们在原矩阵搜索目标子矩阵的过程是严格的「从上到下」&amp;「从左到右」的。</p>
<p>因此我们可以将计算前缀和的逻辑下放到搜索子矩阵的循环里去做，从而将O(m∗n) 的空间复杂度下降到O(n)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumSubmatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="built_in">Number</span>.MIN_SAFE_INTEGER;</span><br><span class="line">  <span class="keyword">const</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">const</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// i是行数的起点</span></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; m; j++) &#123; <span class="comment">// j是行数的终点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">        sum[c] += matrix[j][c]; <span class="comment">// sum[c]指的就是从第i行到第j行之间第c列所有单元格内数据的和</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> sumSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">      sumSet.add(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">let</span> s = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> sum) &#123;</span><br><span class="line">        s += v;</span><br><span class="line">        <span class="keyword">const</span> ceil = sumSet.ceiling(s - k); </span><br><span class="line">        <span class="keyword">if</span> (ceil != <span class="literal">null</span>) &#123;</span><br><span class="line">          ans = <span class="built_in">Math</span>.max(ans, s - ceil);</span><br><span class="line">        &#125;</span><br><span class="line">        sumSet.add(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="有序集合TreeSet"><a href="#有序集合TreeSet" class="headerlink" title="有序集合TreeSet"></a>有序集合TreeSet</h2><p>其实由于本题的特殊原因，每次add的都是递增的，不需要额外排序，所以add可以直接在数组中push。</p>
<p>而二分查找可以看我的另外一篇博客：<a href="https://sunra.top/2020/04/05/binary-search/">https://sunra.top/2020/04/05/binary-search/</a></p>
<p>参考链接：</p>
<p><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/</a></p>
<p><a href="https://leetcode-cn.com/u/ac_oier/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/u/ac_oier/</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>loopback4 体验</title>
    <url>/2021/03/13/loopback4-introduction/</url>
    <content><![CDATA[<p>最近心血来潮看了一遍loopback4的文档，说实话，看的有点吐血，可能是我太菜了，全英的不说，这个还好，没什么奇怪的单词，但东一头西一头的。总体看下来就是两个感觉，第一，看起来敲几行命令代码就出来了，但是你搞不懂那些奇奇怪怪语法糖的话，你没法敲自己的代码，就是不灵活，第二，文档确实没有看到一个完整的例子，都是说到一半突然给你个github链接，让你去看项目。</p>
<p>但是看了这么久，也简单总结下怎么用它去搭建个项目</p>
<a id="more"></a>

<h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g @loopback/cli</span><br></pre></td></tr></table></figure>

<p>如果你用的是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn global add @loopback/cli</span><br></pre></td></tr></table></figure>

<p>注意要把你yarn的bin配到环境变量里，不然下面一步你执行不了</p>
<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lb4 app</span><br></pre></td></tr></table></figure>

<p>Answer the prompts as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Project name: getting-started</span><br><span class="line">? Project description: Getting started tutorial</span><br><span class="line">? Project root directory: (getting-started)</span><br><span class="line">? Application class name: StarterApplication</span><br><span class="line">? Select features to enable in the project:</span><br><span class="line">❯◉ Enable eslint: add a linter with pre-configured lint rules</span><br><span class="line"> ◉ Enable prettier: install prettier to format code conforming to rules</span><br><span class="line"> ◉ Enable mocha: install mocha to run tests</span><br><span class="line"> ◉ Enable loopbackBuild: use @loopback/build helpers (e.g. lb-eslint)</span><br><span class="line"> ◉ Enable vscode: add VSCode config files</span><br><span class="line"> ◉ Enable docker: include Dockerfile and .dockerignore</span><br><span class="line"> ◉ Enable repositories: include repository imports and RepositoryMixin</span><br><span class="line"> ◉ Enable services: include service-proxy imports and ServiceMixin</span><br></pre></td></tr></table></figure>

<p>然后这个时候，你就可以跑起来自己的项目了。</p>
<h3 id="创建空的Controller"><a href="#创建空的Controller" class="headerlink" title="创建空的Controller"></a>创建空的Controller</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lb4 controller</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>Note: If your application is still running, press <strong>CTRL+C</strong> to stop it before calling the command</em></p>
</li>
<li><p>Answer the prompts as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? Controller class name: hello</span><br><span class="line">? What kind of controller would you like to generate? Empty Controller</span><br><span class="line">  create src/controllers/hello.controller.ts</span><br><span class="line">  update src/controllers/index.ts</span><br><span class="line"></span><br><span class="line">Controller hello was now created in src/controllers/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Paste the following contents into the file <code>/src/controllers/hello.controller.ts</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;get&#125; from &apos;@loopback/rest&apos;;</span><br><span class="line"></span><br><span class="line">export class HelloController &#123;</span><br><span class="line">  @get(&apos;/hello&apos;)</span><br><span class="line">  hello(): string &#123;</span><br><span class="line">    return &apos;Hello world!&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start the application using <code>npm start</code>.</p>
</li>
<li><p>Visit <a href="http://127.0.0.1:3000/hello" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:3000/hello</a> to see <code>Hello world!</code></p>
</li>
</ul>
<p>目前看起来一起都好。</p>
<h3 id="创建CRUD-Controller"><a href="#创建CRUD-Controller" class="headerlink" title="创建CRUD Controller"></a>创建CRUD Controller</h3><p>要创建带有CRUD项目的Controller，首先你就要有model，还是借用官方文档，而且这几步的步骤不能乱</p>
<h4 id="创建model"><a href="#创建model" class="headerlink" title="创建model"></a>创建model</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lb4 model</span><br><span class="line">? Model class name: todo</span><br><span class="line">? Please select the model base class Entity (A persisted model with an ID)</span><br><span class="line">? Allow additional (free-form) properties? No</span><br><span class="line">Model Todo will be created in src/models/todo.model.ts</span><br><span class="line"></span><br><span class="line">Let&apos;s add a property to Todo</span><br><span class="line">Enter an empty property name when done</span><br><span class="line"></span><br><span class="line">? Enter the property name: id</span><br><span class="line">? Property type: number</span><br><span class="line">? Is id the ID property? Yes</span><br><span class="line">? Is id generated automatically? No</span><br><span class="line">? Is it required?: No</span><br><span class="line">? Default value [leave blank for none]:</span><br><span class="line"></span><br><span class="line">Let&apos;s add another property to Todo</span><br><span class="line">Enter an empty property name when done</span><br><span class="line"></span><br><span class="line">? Enter the property name: title</span><br><span class="line">? Property type: string</span><br><span class="line">? Is it required?: Yes</span><br><span class="line">? Default value [leave blank for none]:</span><br><span class="line"></span><br><span class="line">Let&apos;s add another property to Todo</span><br><span class="line">Enter an empty property name when done</span><br><span class="line"></span><br><span class="line">? Enter the property name: desc</span><br><span class="line">? Property type: string</span><br><span class="line">? Is it required?: No</span><br><span class="line">? Default value [leave blank for none]:</span><br><span class="line"></span><br><span class="line">Let&apos;s add another property to Todo</span><br><span class="line">Enter an empty property name when done</span><br><span class="line"></span><br><span class="line">? Enter the property name: isComplete</span><br><span class="line">? Property type: boolean</span><br><span class="line">? Is it required?: No</span><br><span class="line">? Default value [leave blank for none]:</span><br><span class="line"></span><br><span class="line">Let&apos;s add another property to Todo</span><br><span class="line">Enter an empty property name when done</span><br><span class="line"></span><br><span class="line">? Enter the property name:</span><br><span class="line"></span><br><span class="line">   create src/models/todo.model.ts</span><br><span class="line">   update src/models/index.ts</span><br><span class="line"></span><br><span class="line">Model Todo was created in src/models/</span><br></pre></td></tr></table></figure>

<h4 id="创建DataSource"><a href="#创建DataSource" class="headerlink" title="创建DataSource"></a>创建DataSource</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lb4 datasource</span><br><span class="line">? Datasource name: db</span><br><span class="line">? Select the connector for db: In-memory db (supported by StrongLoop)</span><br><span class="line">? window.localStorage key to use for persistence (browser only):</span><br><span class="line">? Full path to file for persistence (server only): ./data/db.json</span><br><span class="line"></span><br><span class="line">  create src/datasources/db.datasource.ts</span><br><span class="line">  update src/datasources/index.ts</span><br><span class="line"></span><br><span class="line">Datasource Db was created in src/datasources/</span><br></pre></td></tr></table></figure>

<h4 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lb4 repository</span><br><span class="line">? Please select the datasource DbDatasource</span><br><span class="line">? Select the model(s) you want to generate a repository Todo</span><br><span class="line">? Please select the repository base class DefaultCrudRepository (Juggler bridge)</span><br><span class="line"></span><br><span class="line">   create src/repositories/todo.repository.ts</span><br><span class="line">   update src/repositories/index.ts</span><br><span class="line"></span><br><span class="line">Repository TodoRepository was created in src/repositories/</span><br></pre></td></tr></table></figure>

<h4 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lb4 controller</span><br><span class="line">? Controller class name: todo</span><br><span class="line">Controller Todo will be created in src/controllers/todo.controller.ts</span><br><span class="line"></span><br><span class="line">? What kind of controller would you like to generate? REST Controller with CRUD functions</span><br><span class="line">? What is the name of the model to use with this CRUD repository? Todo</span><br><span class="line">? What is the name of your CRUD repository? TodoRepository</span><br><span class="line">? What is the name of ID property? id</span><br><span class="line">? What is the type of your ID? number</span><br><span class="line">? Is the id omitted when creating a new instance? Yes</span><br><span class="line">? What is the base HTTP path name of the CRUD operations? /todos</span><br><span class="line">   create src/controllers/todo.controller.ts</span><br><span class="line">   update src/controllers/index.ts</span><br><span class="line"></span><br><span class="line">Controller Todo was created in src/controllers/</span><br></pre></td></tr></table></figure>

<h3 id="创建Relation"><a href="#创建Relation" class="headerlink" title="创建Relation"></a>创建Relation</h3><p>通过上面的步骤我们再创建一个TodoList 的 model和repositorie</p>
<p>然后我们创建他们两之间的联系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lb4 relation</span></span><br><span class="line">? Please select the relation type hasMany</span><br><span class="line">? Please select source model TodoList</span><br><span class="line">? Please select target model Todo</span><br><span class="line">? Foreign key name to define on the target model todoListId</span><br><span class="line">? Source property name for the relation getter (will be the relation name) todos</span><br><span class="line">? Allow TodoList queries to include data from related Todo instances? Yes</span><br><span class="line">   create src/controllers/todo-list-todo.controller.ts</span><br><span class="line"></span><br><span class="line">Relation HasMany was created in src/</span><br></pre></td></tr></table></figure>

<p>这样我们就给两个model之间创建了联系。</p>
<p>注意，二者必须都有repositorie才可以，不然没法创建关联。</p>
<p>因为创建关联这一步会创建一个Controller出来。</p>
<h2 id="添加JWT校验"><a href="#添加JWT校验" class="headerlink" title="添加JWT校验"></a>添加JWT校验</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lb4 example todo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> loopback4-example-todo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm i --save @loopback/authentication @loopback/authentication-jwt</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定Component"><a href="#绑定Component" class="headerlink" title="绑定Component"></a>绑定Component</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">src/application.ts</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- ADD IMPORTS -------------</span></span><br><span class="line"><span class="keyword">import</span> &#123;AuthenticationComponent&#125; <span class="keyword">from</span> <span class="string">'@loopback/authentication'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  JWTAuthenticationComponent,</span><br><span class="line">  SECURITY_SCHEME_SPEC,</span><br><span class="line">  UserServiceBindings,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@loopback/authentication-jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;DbDataSource&#125; <span class="keyword">from</span> <span class="string">'./datasources'</span>;</span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TodoListApplication <span class="keyword">extends</span> BootMixin(</span><br><span class="line">  ServiceMixin(RepositoryMixin(RestApplication)),</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">options: ApplicationConfig = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// ------ ADD SNIPPET AT THE BOTTOM ---------</span></span><br><span class="line">    <span class="comment">// Mount authentication system</span></span><br><span class="line">    <span class="keyword">this</span>.component(AuthenticationComponent);</span><br><span class="line">    <span class="comment">// Mount jwt component</span></span><br><span class="line">    <span class="keyword">this</span>.component(JWTAuthenticationComponent);</span><br><span class="line">    <span class="comment">// Bind datasource</span></span><br><span class="line">    <span class="keyword">this</span>.dataSource(DbDataSource, UserServiceBindings.DATASOURCE_NAME);</span><br><span class="line">    <span class="comment">// ------------- END OF SNIPPET -------------</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建UserController"><a href="#创建UserController" class="headerlink" title="创建UserController"></a>创建UserController</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lb4 controller</span></span><br><span class="line">? Controller class name: User</span><br><span class="line">Controller User will be created in src/controllers/user.controller.ts</span><br><span class="line"></span><br><span class="line">? What kind of controller would you like to generate? Empty Controller</span><br><span class="line"></span><br><span class="line">create src/controllers/user.controller.ts</span><br><span class="line">   update src/controllers/index.ts</span><br><span class="line"></span><br><span class="line">Controller User was created in src/controllers/</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">/src/controllers/user.controller.ts</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- ADD IMPORTS -------------</span></span><br><span class="line"><span class="keyword">import</span> &#123;inject&#125; <span class="keyword">from</span> <span class="string">'@loopback/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  TokenServiceBindings,</span><br><span class="line">  MyUserService,</span><br><span class="line">  UserServiceBindings,</span><br><span class="line">  UserRepository,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@loopback/authentication-jwt'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;TokenService&#125; <span class="keyword">from</span> <span class="string">'@loopback/authentication'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;SecurityBindings, UserProfile&#125; <span class="keyword">from</span> <span class="string">'@loopback/security'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;repository&#125; <span class="keyword">from</span> <span class="string">'@loopback/repository'</span>;</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(TokenServiceBindings.TOKEN_SERVICE)</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> jwtService: TokenService,</span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(UserServiceBindings.USER_SERVICE)</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> userService: MyUserService,</span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(SecurityBindings.USER, &#123;optional: <span class="literal">true</span>&#125;)</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> user: UserProfile,</span></span><br><span class="line"><span class="params">    <span class="meta">@repository</span>(UserRepository) <span class="keyword">protected</span> userRepository: UserRepository,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加JWT校验-1"><a href="#添加JWT校验-1" class="headerlink" title="添加JWT校验"></a>添加JWT校验</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ---------- ADD IMPORTS -------------</span></span><br><span class="line"><span class="keyword">import</span> &#123;authenticate&#125; <span class="keyword">from</span> <span class="string">'@loopback/authentication'</span>;</span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="meta">@authenticate</span>(<span class="string">'jwt'</span>) <span class="comment">// &lt;---- Apply the @authenticate decorator at the class level</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TodoController &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>到目前为止，你已经可以通过loopback提供的api来进行todo的CRUD了，看起来很happy是不是</p>
<p>但是有几个问题我在文档没有找到答案</p>
<ul>
<li><p>我没找到可以通过一个请求更新两个model的地方，比如上面的TodoList和Todo，我想要更新这两个相关的model，我必须发两个请求才可以。</p>
</li>
<li><p>自定义Request body非常麻烦，你必须严格符合它的规范。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requestBodyObject = &#123;</span><br><span class="line">  description: <span class="string">'data'</span>,</span><br><span class="line">  content: &#123;</span><br><span class="line">    <span class="string">'application/x-www-form-urlencoded'</span>: &#123;</span><br><span class="line">      schema: &#123;</span><br><span class="line">        type: <span class="string">'object'</span>,</span><br><span class="line">        properties: &#123;</span><br><span class="line">          name: &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,</span><br><span class="line">          location: &#123;</span><br><span class="line">            type: <span class="string">'object'</span>,</span><br><span class="line">            properties: &#123;</span><br><span class="line">              lat: &#123;<span class="attr">type</span>: <span class="string">'number'</span>&#125;,</span><br><span class="line">              lng: &#123;<span class="attr">type</span>: <span class="string">'number'</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          tags: &#123;</span><br><span class="line">            type: <span class="string">'array'</span>,</span><br><span class="line">            items: &#123;<span class="attr">type</span>: <span class="string">'string'</span>&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Model中我定义一个变量的类型是我自定义的一个enum类型，项目没法启动，错误原因是无法解析我自定义的类型。</p>
</li>
<li><p>用它的JWT校验，可以不用自定义UserModel，虽然省事，但是我也没找到可以让我自定义User的地方，那我就没法给User加我需要的字段了。</p>
</li>
<li><p>鉴权用了一个叫casbin的包，文档也是全英的，看不太懂。</p>
</li>
</ul>
<p>以上就是我遇到的一些问题，希望随着我对它理解的加深，可以解决吧。</p>
<h2 id="2021-03-20更新（填上期的坑）"><a href="#2021-03-20更新（填上期的坑）" class="headerlink" title="2021.03.20更新（填上期的坑）"></a>2021.03.20更新（填上期的坑）</h2><h3 id="如何自定义RequestBody"><a href="#如何自定义RequestBody" class="headerlink" title="如何自定义RequestBody"></a>如何自定义RequestBody</h3><p>目前发现最快捷的方法就是通过 <code>lb4 model</code>，创建一个Model，格式就是你需要的RequestBody，当然你也可以自己完全手打一个，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@model()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NewUserRequest</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  @property(&#123;</span><br><span class="line">    type: <span class="string">'string'</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在请求上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@requestBody(&#123;</span><br><span class="line">    content: &#123;</span><br><span class="line">        <span class="string">'application/json'</span>: &#123;</span><br><span class="line">            schema: getModelSchemaRef(NewUserRequest, &#123;</span><br><span class="line">                title: <span class="string">'NewUser'</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="JWT校验如何用自己的Model"><a href="#JWT校验如何用自己的Model" class="headerlink" title="JWT校验如何用自己的Model"></a>JWT校验如何用自己的Model</h2><p>在application.ts中改变User，UserCredentials，RefreshToken，的Model，Repository，Service的绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//application.ts</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount authentication system</span></span><br><span class="line"><span class="keyword">this</span>.component(AuthenticationComponent);</span><br><span class="line"><span class="comment">// Mount jwt component</span></span><br><span class="line"><span class="keyword">this</span>.component(JWTAuthenticationComponent);</span><br><span class="line"><span class="comment">// Bind datasource</span></span><br><span class="line"><span class="keyword">this</span>.dataSource(MemoryDataSource, UserServiceBindings.DATASOURCE_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.bind(UserServiceBindings.USER_REPOSITORY).toClass(UserRepository);</span><br><span class="line"><span class="keyword">this</span>.bind(UserServiceBindings.USER_CREDENTIALS_REPOSITORY).toClass(</span><br><span class="line">    UserCredentialsRepository,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">this</span>.bind(UserServiceBindings.USER_SERVICE).toClass(MyUserService);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.bind(TokenServiceBindings.TOKEN_SECRET).to(<span class="string">'my-secret'</span>);</span><br><span class="line"><span class="keyword">this</span>.bind(TokenServiceBindings.TOKEN_SERVICE).toClass(JWTService);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.bind(RefreshTokenServiceBindings.REFRESH_REPOSITORY).toClass(RefreshTokenRepository);</span><br><span class="line"><span class="keyword">this</span>.bind(RefreshTokenServiceBindings.REFRESH_TOKEN_SERVICE).toClass(RefreshtokenService);</span><br><span class="line"><span class="keyword">this</span>.bind(RefreshTokenServiceBindings.REFRESH_SECRET).to(</span><br><span class="line">    <span class="string">'my-refresh-secret'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.bind(TokenServiceBindings.TOKEN_EXPIRES_IN).to((<span class="number">60</span> * <span class="number">60</span>).toString());</span><br><span class="line"><span class="keyword">this</span>.bind(RefreshTokenServiceBindings.REFRESH_EXPIRES_IN).to(</span><br><span class="line">    (<span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>).toString(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>VsCode 插件语言插件开发</title>
    <url>/2021/06/04/lsp/</url>
    <content><![CDATA[<p>最近对如何开发一个VsCode的插件比较感兴趣，于是特意去读了一些插件的开发文档，主要看的是一个<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/" rel="external nofollow noopener noreferrer" target="_blank">中文翻译的文档</a>，不过这个文档并不全，基本属于重点功能的罗列，但是用来入门是挺好的，不过如果想要深入，还是要去看<a href="https://code.visualstudio.com/api/extension-capabilities/overview" rel="external nofollow noopener noreferrer" target="_blank">英文的文档</a>。</p>
<p>大部分内容都比较简单，主要就是配置，就可以生效，我这次主要想总结的是如何开发一个全新的语言插件，也就是说，如果你想定义一门新类似JSX的语言，如果提供VsCode的支持，比如语法高亮，代码片段，标签自闭和，错误提示，自动补全等等。</p>
<a id="more"></a>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1623800006/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210616073111_tylgg9.png" alt></p>
<h1 id="插件目录结构"><a href="#插件目录结构" class="headerlink" title="插件目录结构"></a>插件目录结构</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── .vscode</span><br><span class="line">│   ├── launch.json     // 插件加载和调试的配置</span><br><span class="line">│   └── tasks.json      // 配置TypeScript编译任务</span><br><span class="line">├── .gitignore          // 忽略构建输出和node_modules文件</span><br><span class="line">├── README.md           // 一个友好的插件文档</span><br><span class="line">├── src</span><br><span class="line">│   └── extension.ts    // 插件源代码</span><br><span class="line">├── package.json        // 插件配置清单</span><br><span class="line">├── tsconfig.json       // TypeScript配置</span><br></pre></td></tr></table></figure>

<h2 id="插件清单"><a href="#插件清单" class="headerlink" title="插件清单"></a>插件清单</h2><p>每个VS Code插件都必须包含一个<code>package.json</code>，它就是插件的<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/references/extension-manifest" rel="external nofollow noopener noreferrer" target="_blank">配置清单</a>。<code>package.json</code>混合了Node.js字段，如：<code>scripts</code>、<code>dependencies</code>，还加入了一些VS Code独有的字段，如：<code>publisher</code>、<code>activationEvents</code>、<code>contributes</code>等。关于这些VS Code字段说明都在<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/" rel="external nofollow noopener noreferrer" target="_blank">插件清单参考</a>中可以找到。我们在本节介绍一些非常重要的字段：</p>
<ul>
<li><p><code>name</code> 和 <code>publisher</code>: VS Code 使用<code>&lt;publisher&gt;.&lt;name&gt;</code>作为一个插件的ID。你可以这么理解，Hello World 例子的 ID 就是<code>vscode-samples.helloworld-sample</code>。VS Code 使用 ID 来区分各个不同的插件。</p>
</li>
<li><p><code>main</code>: 插件的主入口。</p>
</li>
<li><p><code>activationEvents</code> 和 <code>contributes</code>: <a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/references/activation-events" rel="external nofollow noopener noreferrer" target="_blank">激活事件</a> and <a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/references/contribution-points" rel="external nofollow noopener noreferrer" target="_blank">发布内容配置</a>。</p>
</li>
<li><p><code>engines.vscode</code>: 描述了这个插件依赖的最低VS Code API版本。</p>
</li>
<li><p><code>postinstall</code> 脚本: 如果你的<code>engines.vscode</code>声明的是1.25版的VS Code API，那它就会按照这个声明去安装目标版本。一旦<code>vscode.d.ts</code>文件存在于<code>node_modules/vscode/vscode.d.ts</code>，IntelliSense就会开始运作，你就可以对所有VS Code API进行定义跳转或者语法检查了。</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"helloworld-sample"</span>,</span><br><span class="line">    <span class="attr">"displayName"</span>: <span class="string">"helloworld-sample"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"HelloWorld example for VS Code"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">    <span class="attr">"publisher"</span>: <span class="string">"vscode-samples"</span>,</span><br><span class="line">    <span class="attr">"repository"</span>: <span class="string">"https://github.com/Microsoft/vscode-extension-samples/helloworld-sample"</span>,</span><br><span class="line">    <span class="attr">"engines"</span>: &#123;</span><br><span class="line">        <span class="attr">"vscode"</span>: <span class="string">"^1.25.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"categories"</span>: [<span class="string">"Other"</span>],</span><br><span class="line">    <span class="attr">"activationEvents"</span>: [<span class="string">"onCommand:extension.helloWorld"</span>],<span class="comment">//激活事件，也就是什么事件会激活这个插件，这里个例子里就是当发生extension.helloWorld这个命令时会激活这个插件</span></span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"./out/extension.js"</span>,<span class="comment">//插件的入口文件</span></span><br><span class="line">    <span class="attr">"contributes"</span>: &#123;<span class="comment">//插件的发布配置，非常重要，注册事件，文件图标，标签自闭合等等绝大部分插件的配置都在这里</span></span><br><span class="line">        <span class="attr">"commands"</span>: [<span class="comment">//注册命令</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span>: <span class="string">"extension.helloWorld"</span>,<span class="comment">//这就是上面那个activationEvent里面的那个命令，也就是我们comman+shift+P时候中选择运行的命令</span></span><br><span class="line">                <span class="attr">"title"</span>: <span class="string">"Hello World"</span><span class="comment">//命令列表里显示的内容</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"vscode:prepublish"</span>: <span class="string">"npm run compile"</span>,</span><br><span class="line">        <span class="attr">"compile"</span>: <span class="string">"tsc -p ./"</span>,</span><br><span class="line">        <span class="attr">"watch"</span>: <span class="string">"tsc -watch -p ./"</span>,</span><br><span class="line">        <span class="attr">"postinstall"</span>: <span class="string">"node ./node_modules/vscode/bin/install"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"@types/node"</span>: <span class="string">"^8.10.25"</span>,</span><br><span class="line">        <span class="attr">"tslint"</span>: <span class="string">"^5.11.0"</span>,</span><br><span class="line">        <span class="attr">"typescript"</span>: <span class="string">"^2.6.1"</span>,</span><br><span class="line">        <span class="attr">"vscode"</span>: <span class="string">"^1.1.22"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="入口文件（package-json中的main）"><a href="#入口文件（package-json中的main）" class="headerlink" title="入口文件（package.json中的main）"></a>入口文件（package.json中的main）</h2><p>插件入口文件会导出两个函数，<code>activate</code> 和 <code>deactivate</code>，你注册的<strong>激活事件</strong>被触发之时执行<code>activate</code>，<code>deactivate</code>则提供了插件关闭前执行清理工作的机会。</p>
<p><code>vscode</code>模块包含了一个位于<code>node ./node_modules/vscode/bin/install</code>的脚本，这个脚本会拉取<code>package.json</code>中<code>engines.vscode</code>字段定义的VS Code API。这个脚本执行过后，你就得到了智能代码提示，定义跳转等TS特性了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &apos;vscode&apos;模块包含了VS Code extensibility API</span><br><span class="line">// 按下述方式导入这个模块</span><br><span class="line">import * as vscode from &apos;vscode&apos;;</span><br><span class="line">// 一旦你的插件激活，vscode会立刻调用下述方法</span><br><span class="line">export function activate(context: vscode.ExtensionContext) &#123;</span><br><span class="line"></span><br><span class="line">    // 用console输出诊断信息(console.log)和错误(console.error)</span><br><span class="line">    // 下面的代码只会在你的插件激活时执行一次</span><br><span class="line">    console.log(&apos;Congratulations, your extension &quot;my-first-extension&quot; is now active!&apos;);</span><br><span class="line"></span><br><span class="line">    // 入口命令已经在package.json文件中定义好了，现在调用registerCommand方法</span><br><span class="line">    // registerCommand中的参数必须与package.json中的command保持一致</span><br><span class="line">    let disposable = vscode.commands.registerCommand(&apos;extension.sayHello&apos;, () =&gt; &#123;</span><br><span class="line">        // 把你的代码写在这里，每次命令执行时都会调用这里的代码</span><br><span class="line">        // ...</span><br><span class="line">        // 给用户显示一个消息提示</span><br><span class="line">        vscode.window.showInformationMessage(&apos;Hello World!&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布内容配置"><a href="#发布内容配置" class="headerlink" title="发布内容配置"></a>发布内容配置</h2><h1 id="插件可以做什么"><a href="#插件可以做什么" class="headerlink" title="插件可以做什么"></a>插件可以做什么</h1><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ul>
<li><p>注册命令、配置、快捷键绑定、菜单等。</p>
</li>
<li><p>保存工作区或全局数据。</p>
</li>
<li><p>显示通知信息。</p>
</li>
<li><p>使用快速选择获得用户输入。</p>
</li>
<li><p>打开系统的文件选择工具，以便用户选择文件或文件夹。</p>
</li>
<li><p>使用进度API提示耗时较长的操作。</p>
</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>使用pacakge.json中的contributes.commands注册命令，只有在这里注册的命令才可以在命令面板中搜索到。</li>
<li>默认情况下，所有<em>命令面板</em>中出现的命令都可以在<code>package.json</code>的<code>commands</code>部分中配置。不过，有些命令是场景相关的，比如在特定的语言的编辑器中，或者只有用户设置了某些选项时才展示。<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts" rel="external nofollow noopener noreferrer" target="_blank">Visual Studio Code Key Bindings</a>：可以查看如何写这个when命令</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"contributes"</span>: &#123;</span><br><span class="line">        <span class="string">"menus"</span>: &#123;</span><br><span class="line">            <span class="string">"commandPalette"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"command"</span>: <span class="string">"myExtension.sayHello"</span>,</span><br><span class="line">                    <span class="string">"when"</span>: <span class="string">"editorLangId == markdown"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在myExtension.sayHello命令只会出现在用户的Markdown文件中了。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用vscode.command.registerCommand为命令注册回调函数</li>
<li>使用vscode.command.excuteCommand执行命令</li>
</ul>
<p>vscode也有很多内置的命令（<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/references/commands" rel="external nofollow noopener noreferrer" target="_blank">VS Code内置命令清单</a>）</p>
<p>我们看个例子🌰：<code>editor.action.addCommentLine</code>命令可以将当前选中行变成注释(你可以偷偷把这个功能地集成到你自己的插件中哦)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as vscode from &apos;vscode&apos;;</span><br><span class="line">function commentLine() &#123;</span><br><span class="line">    vscode.commands.executeCommand(&apos;editor.action.addCommentLine&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>插件需要在<code>contributes.configuration</code>发布内容配置点<a href="https://code.visualstudio.com/docs/extensionAPI/overview" rel="external nofollow noopener noreferrer" target="_blank">发布内容配置点</a>package.json的一部分，用于配置插件启动命令、用户可更改的插件配置，可以理解为插件的主要配置文件。中填写有关的配置，你可以<code>workspace.getConfiguration</code>API中阅读有关内容。</p>
<h3 id="键位绑定"><a href="#键位绑定" class="headerlink" title="键位绑定"></a>键位绑定</h3><p>插件可以添加自定义键位映射，在<code>contributes.keybindings</code>和<a href="https://code.visualstudio.com/docs/getstarted/keybindings" rel="external nofollow noopener noreferrer" target="_blank">键位绑定</a>中了解更多有关内容。</p>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>插件可以自定义上下文菜单项，菜单会根据用户右击VS Code UI的不同位置而各不相同。查看更多<code>contributes.menus</code>发布内容配置。</p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>VS Code中有三种数据储存方式：</p>
<ul>
<li><p><code>ExtensionContext.workspaceState</code>：键值对组成的工作区数据。当同一个工作区再次打开时会重新取出数据。</p>
</li>
<li><p><code>ExtensionContext.globalState</code>：键值对组成的全局数据。当插件激活时会再次取出这些数据。</p>
</li>
<li><p><code>ExtensionContext.storagePath</code>：指向你的插件可以读写的本地文件夹的路径。如果你要储存比较大的数据，这是一个非常好的选择。</p>
</li>
<li><p><code>ExtensionContext.globalStoragePath</code>：指向你的插件可以读写的本地存储的路径。如果你要存储所有工作区内的大文件，这是一个非常好的选择。</p>
</li>
</ul>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>几乎所有的插件都需要在某些时候为用户提示信息。VS Code提供了3个API来展示不同重要程度的信息：</p>
<ul>
<li><p><code>window.showInformationMessage</code></p>
</li>
<li><p><code>window.showWarningMessage</code></p>
</li>
<li><p><code>window.showErrorMessage</code></p>
</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>产品图标主题和色彩主题可以参考文档：<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/extension-guides/color-theme" rel="external nofollow noopener noreferrer" target="_blank">VS Code插件创作中文开发文档 - 色彩主题</a></p>
<h3 id="文件图标主题"><a href="#文件图标主题" class="headerlink" title="文件图标主题"></a>文件图标主题</h3><p>VS Code的UI在文件名称左边显示图标，插件配置的图标系列可以让用户自由选择他们喜爱的图标。</p>
<p>但是Vscode目前不支持某个语言插件只定义自己语言文件的图标，如果用户切换到你的插件提供的主题，却不能支持所有文件类型，就会出现问题</p>
<p>首先，创建一个VS Code插件，然后把<code>iconTheme</code>配置点(contribution point)添加进去</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"contributes": &#123;</span><br><span class="line">    "iconThemes": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"turtles"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Turtles"</span>,</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"./fileicons/turtles-icon-theme.json"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制到剪贴板复制错误已复制</p>
<ul>
<li><p><code>id</code>作为这个图标主题的标识，目前只做内部使用，未来可能会用在设置里面，所以最好设置一个可读性强的唯一值。</p>
</li>
<li><p><code>label</code>会显示在<em>主题选择</em>下拉框中。</p>
</li>
<li><p><code>path</code>指示了图标集所在的位置。如果你的图标系列名称遵循<code>*icon-theme.json</code>命名规范，那么VS Code就能提供完整的支持。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//turtles-icon-theme.json&#123;</span></span><br><span class="line">    "iconDefinitions": &#123;</span><br><span class="line">        "_folder_dark": &#123;</span><br><span class="line">            "iconPath": "./images/Folder_16x_inverse.svg"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<strong>图标定义</strong>包含了一个标识符<code>_folder_dark</code>。除此之外还支持以下属性：</p>
<ul>
<li><p><code>iconPath</code>：当使用svg/png文件时：指向图片的路径。</p>
</li>
<li><p><code>fontCharacter</code>：当使用glyph字体时：字体中使用的字符。</p>
</li>
<li><p><code>fontColor</code>：当使用glyph字体时：设置glyph的颜色。</p>
</li>
<li><p><code>fontSize</code>：当使用字体时：设置字体大小。默认情况下会使用字体本身定义的字体大小。这个值应为父级字号的相对值(如 150%)。</p>
</li>
<li><p><code>fontId</code>：当使用字体时: 字体的ID。如果没有指定，则会采用<code>font specification</code>部分的第一个字体。</p>
</li>
</ul>
<p>在iconDefinitions中定义之后，就可以引用了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"iconDefinitions"</span>: &#123;</span><br><span class="line">        <span class="attr">"_folder_dark"</span>: &#123;</span><br><span class="line">            <span class="attr">"iconPath"</span>: <span class="string">"./images/Folder_16x_inverse.svg"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"file"</span>: <span class="string">"_file_dark"</span>,</span><br><span class="line">    <span class="attr">"folder"</span>: <span class="string">"_folder_dark"</span>,</span><br><span class="line">    <span class="attr">"folderExpanded"</span>: <span class="string">"_folder_open_dark"</span>,</span><br><span class="line">    <span class="attr">"folderNames"</span>: &#123;</span><br><span class="line">        <span class="attr">".vscode"</span>: <span class="string">"_vscode_folder"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"fileExtensions"</span>: &#123;</span><br><span class="line">        <span class="attr">"ini"</span>: <span class="string">"_ini_file"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"fileNames"</span>: &#123;</span><br><span class="line">        <span class="attr">"win.ini"</span>: <span class="string">"_win_ini_file"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"languageIds"</span>: &#123;</span><br><span class="line">        <span class="attr">"ini"</span>: <span class="string">"_ini_file"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"light"</span>: &#123;</span><br><span class="line">        <span class="attr">"folderExpanded"</span>: <span class="string">"_folder_open_light"</span>,</span><br><span class="line">        <span class="attr">"folder"</span>: <span class="string">"_folder_light"</span>,</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"_file_light"</span>,</span><br><span class="line">        <span class="attr">"fileExtensions"</span>: &#123;</span><br><span class="line">            <span class="attr">"ini"</span>: <span class="string">"_ini_file_light"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highContrast"</span>: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>file</code>是一个默认文件图标，为那些没有匹配到任何插件、文件名、语言类型的文件所准备的。目前所有文件图标属性都会被继承(只适用于：glyphs字体、字体大小(fontSize))。</p>
</li>
<li><p><code>folder</code>收起的文件夹图标，如果<code>folderExpanded</code>没有设置，那么展开的文件夹也会使用这个图标。使用<code>folderNames</code>关联特殊名称的文件夹。文件夹图标是可选的，如果不设置，那文件夹就不会显示任何图标。</p>
</li>
<li><p><code>folderExpanded</code>展开的文件夹图标。这个图标是可选的，如果不设置就会使用<code>folder</code>定义好的图标。</p>
</li>
<li><p><code>folderNames</code>特殊名称文件夹图标。这个键是用于文件夹名称的，不支持包含路径的名称，不支持匹配模式和通配符。大小写不敏感。</p>
</li>
<li><p><code>folderNamesExpanded</code>展开的特殊名称文件夹图标。</p>
</li>
<li><p><code>rootFolder</code> 收起的工作区根文件夹图标，如果<code>rootFolderExpanded</code>没有设置，那么展开的工作区根文件夹也会使用这个图标。如果不设置，则会使用<code>folder</code>定义的文件夹图标。</p>
</li>
<li><p><code>rootFolderExpanded</code> 展开的工作区根文件夹图标。如果没有设置，则会使用<code>rootFolder</code>定义的文件夹图标。</p>
</li>
<li><p><code>languageIds</code>语言类型图标。这个键将匹配在<em>语言配置点（contribution point）</em>配置的<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/references/contribution-points?id=contributeslanguages" rel="external nofollow noopener noreferrer" target="_blank">语言id</a>。注意语言配置的’第一行’是不考虑在内的。</p>
</li>
<li><p><code>fileExtensions</code>文件插件图标。根据文件插件的名称匹配。插件名称是文件名点号后面（不包含点号）。拥有多重点号的文件名称，如<code>lib.d.ts</code>会匹配多个模式——<code>d.ts</code>和<code>ts</code>。大小写敏感。</p>
</li>
<li><p><code>fileNames</code>文件图标。这个键需要文件的全称进行匹配，不支持包含路径的名称，不支持模式和通配符。大小写敏感。<code>fileNames</code>是最高优先匹配。</p>
</li>
</ul>
<p>匹配优先级：<code>fileNames</code> &gt; <code>fileExtensions</code> &gt; <code>languageIds</code></p>
<p><code>light</code>和<code>highContrast</code>部分的属性表和上面相同，只是会在对应的主题下覆盖原有图标配置。</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="声明式语言特性"><a href="#声明式语言特性" class="headerlink" title="声明式语言特性"></a>声明式语言特性</h3><p><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/language-extensions/README?id=声明式语言特性" rel="external nofollow noopener noreferrer" target="_blank">声明式语言特性</a>添加了基础的编程语言编辑支持，如括号匹配、自动缩进和语法高亮。这些功能都可以通过声明配置而不用写任何代码就可以获得，更高级的语言特性如IntelliSense或调试，请看<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/extension-capabilities/README?id=编程式添加语言特性" rel="external nofollow noopener noreferrer" target="_blank">编程式添加语言特性</a></p>
<ul>
<li><p>将常用的JS代码片段打包到插件中</p>
</li>
<li><p>为VS Code添加新的语言支持</p>
</li>
<li><p>为一门语言添加或替换语法</p>
</li>
<li><p>通过注入的方式，扩展一门语法</p>
</li>
<li><p>将现有的 TextMate 语法迁移到VS Code中</p>
</li>
</ul>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/language-extensions/snippet-guide" rel="external nofollow noopener noreferrer" target="_blank">VS Code插件创作中文开发文档 - 代码片段</a></p>
<h4 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h4><p>通过<code>contributes.languages</code>发布内容配置，你可以配置以下<em>声明式语言特性</em>：</p>
<ul>
<li><p>启用/关闭注释</p>
</li>
<li><p>定义括号</p>
</li>
<li><p>自动闭合符号</p>
</li>
<li><p>自动环绕符号</p>
</li>
<li><p>代码折叠</p>
</li>
<li><p>单词匹配</p>
</li>
<li><p>缩进规则</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"language-configuration-sample"</span>,</span><br><span class="line">  <span class="attr">"displayName"</span>: <span class="string">"Language Configuration Sample"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Language Configuration Sample"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"publisher"</span>: <span class="string">"vscode-samples"</span>,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"vscode"</span>: <span class="string">"^1.28.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"categories"</span>: [</span><br><span class="line">    <span class="string">"Programming Languages"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"contributes"</span>: &#123;</span><br><span class="line">    <span class="attr">"languages"</span>: [ <span class="comment">// 定义新的语言</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"vnm"</span>, <span class="comment">// 语言的id</span></span><br><span class="line">        <span class="attr">"extensions"</span>: [</span><br><span class="line">          <span class="string">".js"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"aliases"</span>: [</span><br><span class="line">          <span class="string">"js"</span>,</span><br><span class="line">          <span class="string">"JavaScript"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"configuration"</span>: <span class="string">"./language-configuration.json"</span> <span class="comment">// 该语言的配置</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"comments"</span>: &#123; <span class="comment">// 定义注释方式</span></span><br><span class="line">        <span class="attr">"lineComment"</span>: <span class="string">"//"</span>,</span><br><span class="line">        <span class="attr">"blockComment"</span>: [<span class="string">"/*"</span>, <span class="string">"*/"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"brackets"</span>: [[<span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>], [<span class="string">"["</span>, <span class="string">"]"</span>], [<span class="string">"("</span>, <span class="string">")"</span>]], <span class="comment">//定义括号，当鼠标移动到某个括号上时，会自动高亮对应的括号</span></span><br><span class="line">    <span class="attr">"autoClosingPairs"</span>: [<span class="comment">//自动闭合括号</span></span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"&#123;"</span>, <span class="attr">"close"</span>: <span class="string">"&#125;"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"["</span>, <span class="attr">"close"</span>: <span class="string">"]"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"("</span>, <span class="attr">"close"</span>: <span class="string">")"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"'"</span>, <span class="attr">"close"</span>: <span class="string">"'"</span>, <span class="attr">"notIn"</span>: [<span class="string">"string"</span>, <span class="string">"comment"</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"\""</span>, <span class="attr">"close"</span>: <span class="string">"\""</span>, <span class="attr">"notIn"</span>: [<span class="string">"string"</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"`"</span>, <span class="attr">"close"</span>: <span class="string">"`"</span>, <span class="attr">"notIn"</span>: [<span class="string">"string"</span>, <span class="string">"comment"</span>] &#125;,</span><br><span class="line">        &#123; <span class="attr">"open"</span>: <span class="string">"/**"</span>, <span class="attr">"close"</span>: <span class="string">" */"</span>, <span class="attr">"notIn"</span>: [<span class="string">"string"</span>] &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"autoCloseBefore"</span>: <span class="string">";:.,=&#125;])&gt;` \n\t"</span>,<span class="comment">//默认情况下只有在右侧有空白时才会闭合标签，可以通过这个配置覆盖默认行为</span></span><br><span class="line">    <span class="attr">"surroundingPairs"</span>: [ <span class="comment">// 自动环绕括号</span></span><br><span class="line">        [<span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>],</span><br><span class="line">        [<span class="string">"["</span>, <span class="string">"]"</span>],</span><br><span class="line">        [<span class="string">"("</span>, <span class="string">")"</span>],</span><br><span class="line">        [<span class="string">"'"</span>, <span class="string">"'"</span>],</span><br><span class="line">        [<span class="string">"\""</span>, <span class="string">"\""</span>],</span><br><span class="line">        [<span class="string">"`"</span>, <span class="string">"`"</span>]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"folding"</span>: &#123;</span><br><span class="line">        <span class="attr">"markers"</span>: &#123;</span><br><span class="line">            <span class="attr">"start"</span>: <span class="string">"^\\s*//\\s*#?region\\b"</span>,</span><br><span class="line">            <span class="attr">"end"</span>: <span class="string">"^\\s*//\\s*#?endregion\\b"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"wordPattern"</span>: <span class="string">"(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\&#123;\\]\\&#125;\\\\\\|\\;\\:\\'\\\"\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)"</span>,</span><br><span class="line">    <span class="attr">"indentationRules"</span>: &#123;</span><br><span class="line">        <span class="attr">"increaseIndentPattern"</span>: <span class="string">"^((?!\\/\\/).)*(\\&#123;[^&#125;\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$"</span>,</span><br><span class="line">        <span class="attr">"decreaseIndentPattern"</span>: <span class="string">"^((?!.*?\\/\\*).*\\*/)?\\s*[\\&#125;\\]].*$"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式语言特性-监听用户动作"><a href="#编程式语言特性-监听用户动作" class="headerlink" title="编程式语言特性(监听用户动作)"></a>编程式语言特性(监听用户动作)</h3><p><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/language-extensions/programmatic-language-features?id=程序性语言特性" rel="external nofollow noopener noreferrer" target="_blank">VS Code插件创作中文开发文档 - 程序性语言特性</a></p>
<p>下面这表对应的是我们可以实现的编程性语言特性，每个特性都可以单独通过左边一列的VScode API来实现，同时可以单独通过<a href="https://microsoft.github.io/language-server-protocol/" rel="external nofollow noopener noreferrer" target="_blank">Language Server Protocol</a>在语言服务器中实现。</p>
<p>理论上所有通过语言服务器实现的特性都可以单独用客户端实现</p>
<p>Unable to copy while content loads</p>
<p><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/language-extensions/README?id=编程式语言特性" rel="external nofollow noopener noreferrer" target="_blank">编程式添加语言特性</a>可以为编程语言添加更为丰富的特性，如：悬停提示、转跳定义、错误诊断、IntelliSense和CodeLens。这些语言特性暴露于<code>vscode.languages.*</code>API。语言插件可以直接使用这些API，或是自己写一个语言服务器，通过<a href="https://github.com/Microsoft/vscode-languageserver-node" rel="external nofollow noopener noreferrer" target="_blank">语言服务器库</a>将它适配到VS Code。</p>
<p>虽然我们提供了一个<a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/language-extensions/programmatic-language-features" rel="external nofollow noopener noreferrer" target="_blank">语言特性</a>列表，但是并不阻碍你发挥想象，自由使用这些API。比方说，在行内显示额外信息，使用CodeLens和代码悬停是非常好的方式，而错误诊断可以高亮拼写或代码风格错误。</p>
<ul>
<li><p>鼠标悬停于API上时, 出现用法示例</p>
</li>
<li><p>使用诊断，报告代码风格错误</p>
</li>
<li><p>注册新的HTML代码格式化</p>
</li>
<li><p>提供丰富的IntelliSense中间件</p>
</li>
<li><p>为一门语言添加代码折叠、面包屑、轮廓支持</p>
</li>
</ul>
<h4 id="以自动补全为例子说明用法"><a href="#以自动补全为例子说明用法" class="headerlink" title="以自动补全为例子说明用法"></a>以自动补全为例子说明用法</h4><p>客户端实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GoCompletionItemProvider implements vscode.CompletionItemProvider &#123;</span><br><span class="line">    public provideCompletionItems(</span><br><span class="line">        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):</span><br><span class="line">        Thenable&lt;vscode.CompletionItem[]&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export function activate(ctx: vscode.ExtensionContext): void &#123;</span><br><span class="line">    ...</span><br><span class="line">    //registerCompletionItemProvider返回的是解除本身注册的函数，这里猜测添加订阅的一个目的是为了以后的unregister</span><br><span class="line">    ctx.subscriptions.push(</span><br><span class="line">        vscode.languages.registerCompletionItemProvider(</span><br><span class="line">            GO_MODE, new GoCompletionItemProvider(), &apos;.&apos;, &apos;\&quot;&apos;));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LSP实现</p>
<p>在接收响应的<code>initialize</code>方法中，你的语言服务器需要声明它是否能提供补全，以及它是否支持动态计算补全项的<code>completionItem\resolve</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;capabilities&quot; : &#123;</span><br><span class="line">        &quot;completionProvider&quot; : &#123;</span><br><span class="line">            &quot;resolveProvider&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;triggerCharacters&quot;: [ &apos;.&apos; ]</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了这个配置，客户端才会在输入完成后发送textDocument/completion事件给语言服务器，语言服务器通过onCompletion事件监听这个事件，监听后返回匹配的列表。</p>
<p>当我们具体选择了某一个补全项之后，会发送completionItem/resolve事件，该事件被onCompletionResolve事件监听，可以补全具体的信息，或者进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//server.ts</span><br><span class="line">connection.onCompletion(</span><br><span class="line">  (&#123; textDocument, position, context &#125;: CompletionParams): CompletionItem[] =&gt; &#123;</span><br><span class="line">    const doc = documentService.getDocument(textDocument.uri)!;</span><br><span class="line"></span><br><span class="line">    //返回类型为CompletionItem[]</span><br><span class="line">    const completionItems = doComplete(doc, position);</span><br><span class="line"> </span><br><span class="line">    return completionItems || [];</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 这个函数为补全列表的选中项提供了更多信息</span><br><span class="line">connection.onCompletionResolve((item: CompletionItem): CompletionItem =&gt; &#123;</span><br><span class="line">  if (item.label === &apos;$store&apos;) &#123;</span><br><span class="line">    item.insertText = &apos;store&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  return item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="监听文档的变化"><a href="#监听文档的变化" class="headerlink" title="监听文档的变化"></a>监听文档的变化</h3><p>上面的编程式语言特性主要做的当我们进行了某些动作之后，客户端本身监听到或者客户端将监听到的动作与服务器之间利用事件进行通信。</p>
<p>还有一种方式，是文本本身发生变化时通知客户端或者告诉语言服务器文本的内容</p>
<p>客户端本身监听到的内容改变，可以在vscode.workspace.*中找到对应的api，如vscode.workspace.onDidChangeTextDocument</p>
<p>LSP则稍微复杂一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//DocumentService.ts</span><br><span class="line">import &#123; Connection, TextDocuments &#125; from &apos;vscode-languageserver&apos;;</span><br><span class="line">import &#123; TextDocument &#125; from &apos;vscode-languageserver-textdocument&apos;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Service responsible for managing documents being syned through LSP</span><br><span class="line"> */</span><br><span class="line">export class DocumentService &#123;</span><br><span class="line">  private documents: TextDocuments&lt;TextDocument&gt;;</span><br><span class="line"></span><br><span class="line">  constructor(conn: Connection) &#123;</span><br><span class="line">    this.documents = new TextDocuments(TextDocument);</span><br><span class="line">    this.documents.listen(conn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getDocument(uri: string) &#123;</span><br><span class="line">    return this.documents.get(uri);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAllDocuments() &#123;</span><br><span class="line">    return this.documents.all();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get onDidChangeContent() &#123;</span><br><span class="line">    return this.documents.onDidChangeContent;</span><br><span class="line">  &#125;</span><br><span class="line">  get onDidClose() &#123;</span><br><span class="line">    return this.documents.onDidClose;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//server.ts</span><br><span class="line">documentService.onDidChangeContent((change) =&gt; &#123;</span><br><span class="line">  const textDocument = change.document;</span><br><span class="line">  connection.sendDiagnostics(&#123; uri: textDocument.uri, diagnostics: validateTextDocument(textDocument) &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式每次都是发送全量文本，对性能会有影响，所以vscode又提供了增量文本更新同步</p>
</blockquote>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>微前端概念及方案对比</title>
    <url>/2021/04/28/micro-frontend/</url>
    <content><![CDATA[<p>做了一年多的前端，今天突然听到了一个名词叫做微前端，很好奇，于是去查询了一些资料，在这里总结下。</p>
<a id="more"></a>

<h2 id="微前端是什么"><a href="#微前端是什么" class="headerlink" title="微前端是什么"></a>微前端是什么</h2><p>微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系</strong>，这个概念最早在2016年底被提出，可以参考在Google上搜索Micro-Frontends。</p>
<p>也就是说微前端更像是一种理念，像是微服务将一个大的系统拆分为多个系统一样，微前端也将一个大的前端项目拆分为多个。</p>
<p>从这个角度讲，微前端并不是一定要用前端技术来实现，而事实也确实如此，微前端有很多方案，我们下面就会逐一介绍并进行比较。</p>
<h2 id="微前端是为了解决什么问题？"><a href="#微前端是为了解决什么问题？" class="headerlink" title="微前端是为了解决什么问题？"></a>微前端是为了解决什么问题？</h2><p>任何新技术的产生都是为了解决现有场景和需求下的技术痛点，微前端也不例外：</p>
<ol>
<li><strong>拆分和细化</strong>：当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。</li>
<li><strong>整合历史系统</strong>：在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。</li>
</ol>
<p>也就是说微前端一方面可以将已有的大型项目进行拆分，便于以后的项目维护，另一方面，也可以将新的项目和旧的历史项目整合到一起，即使它们的语言，框架完全不同。</p>
<h2 id="为了解决上述问题，微前端要做什么？"><a href="#为了解决上述问题，微前端要做什么？" class="headerlink" title="为了解决上述问题，微前端要做什么？"></a>为了解决上述问题，微前端要做什么？</h2><p>说白了，微前端就是为了把一个大的前端项目拆分为多个小的前端项目。而这几个前端项目之间可以使用完全不同的框架，但同时这几个项目之间还能通信。</p>
<p>为了实现这个目的，我们需要设计几个东西：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1619705600/origin-of-ray/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210429221252_no36wf.png" alt></p>
<p>说实话，这个图一画出来，我就想起了electron，electron的主进程就像这里的主工程，electron的每个渲染进程就像这里的微应用。</p>
<p>不同的是electron只有主进程和渲染进程之间可以通信，渲染进程之间不可以。</p>
<p>简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：</p>
<ol>
<li>路由切换的分发问题。</li>
<li>主微应用的隔离问题。</li>
<li>通信问题。</li>
</ol>
<p>下面针对这些问题来一一阐述。</p>
<h2 id="几种方案的比较"><a href="#几种方案的比较" class="headerlink" title="几种方案的比较"></a>几种方案的比较</h2><p>单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Nginx路由转发</td>
<td>通过Nginx配置反向代理来实现不同路径映射到不同应用，例如<a href="http://www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。" rel="external nofollow noopener noreferrer" target="_blank">www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。</a></td>
<td>简单，快速，易配置</td>
<td>在切换应用时会触发浏览器刷新，影响体验</td>
</tr>
<tr>
<td>iframe嵌套</td>
<td>父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式</td>
<td>实现简单，子应用之间自带沙箱，天然隔离，互不影响</td>
<td>iframe的样式显示、兼容性等都具有局限性；太过简单而显得low</td>
</tr>
<tr>
<td>Web Components</td>
<td>每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式</td>
<td>每个子应用拥有独立的script和css，也可单独部署</td>
<td>对于历史系统改造成本高，子应用通信较为复杂易踩坑</td>
</tr>
<tr>
<td>组合式应用路由分发</td>
<td>每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制</td>
<td>纯前端改造，体验良好，可无感知切换，子应用相互隔离</td>
<td>需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点</td>
</tr>
</tbody></table>
<p>上述方案中，每种都有自己的优劣，最原始的Nginx配置反向代理是从接入层的角度来将系统进行分离，但是需要运维配置，而iframe嵌套是最简单和最快速的方案，但是iframe的弊端也是无法避免的，而Web Components的方案则需要大量的改造成本，最后的组合式应用路由分发方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案，本文后面的内容也是主要基于这种方案进行阐述。</p>
<h2 id="路由分发问题"><a href="#路由分发问题" class="headerlink" title="路由分发问题"></a>路由分发问题</h2><p>作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：</p>
<ol>
<li><p>作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要<strong>远程拉取机制</strong>。</p>
</li>
<li><p>远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。</p>
<blockquote>
<p>这里其实也可以用new Function的方法来执行JavaScript</p>
<p>而微应用切换的时候我们应该也可以模仿单核CPU的进程切换，先保存当前应用的镜像，然后再切换，等切换回来的时候再恢复镜像</p>
</blockquote>
</li>
<li><p>当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染</p>
</li>
</ol>
<p>对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：</p>
<ol>
<li>当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。</li>
<li>最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。</li>
</ol>
<p>可以采取命名空间或者basePath的方式去做路由的分发判断</p>
<h2 id="应用隔离"><a href="#应用隔离" class="headerlink" title="应用隔离"></a>应用隔离</h2><p>应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。</p>
<p><strong>CSS隔离</strong>：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。</p>
<p>而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。</p>
<p><strong>JavaScript隔离</strong>：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个<code>window.$</code>对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。</p>
<p>沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。</p>
<h2 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h2><p>应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制。</p>
<p>如果采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。</p>
<h2 id="待检索问题"><a href="#待检索问题" class="headerlink" title="待检索问题"></a>待检索问题</h2><ul>
<li>with</li>
<li>sandbox</li>
<li>iframe的优缺点</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微服务入门笔记</title>
    <url>/2020/03/25/microservices-reading/</url>
    <content><![CDATA[<h2 id="微服务简介"><a href="#微服务简介" class="headerlink" title="微服务简介"></a>微服务简介</h2><h3 id="单片应用"><a href="#单片应用" class="headerlink" title="单片应用"></a>单片应用</h3><p>应用程序的核心是业务逻辑，该业务逻辑由定义服务，域对象和事件的模块实现。围绕核心的是与外部世界接口的适配器。适配器的示例包括数据库访问组件，生成和使用消息的消息传递组件以及公开API或实现UI的Web组件。</p>
<p>尽管具有逻辑模块化的体系结构，但该应用程序却作为一个整体打包和部署。实际格式取决于应用程序的语言和框架。例如，许多Java应用程序打包为WAR文件，并部署在诸如Tomcat或Jetty之类的应用程序服务器上。其他Java应用程序打包为独立的可执行JAR。</p>
<p>成功的应用程序具有随着时间的流逝并最终变得庞大的习惯。在每次冲刺期间，开发团队都会实施更多Story，这当然意味着要添加许多行代码。几年后，小型，简单的应用程序将变得庞然大物。</p>
<a id="more"></a>

<ul>
<li>应用程序的绝对大小也会减慢开发速度。应用程序越大，启动时间越长。</li>
<li>大型，复杂的整体应用程序的另一个问题是，这是持续部署的障碍。如今，SaaS应用程序的最新技术是每天将变更推送到生产中多次。</li>
<li>当不同的模块具有冲突的资源需求时，单片应用程序也可能难以扩展。例如，一个模块可能实现CPU密集型图像处理逻辑，并且理想情况下将部署在Amazon <a href="https://aws.amazon.com/about-aws/whats-new/2013/11/14/announcing-new-amazon-ec2-compute-optimized-instances/" rel="external nofollow noopener noreferrer" target="_blank">EC2 Compute Optimized实例中</a>。另一个模块可能是内存数据库，最适合<a href="https://aws.amazon.com/about-aws/whats-new/2014/04/10/r3-announcing-the-next-generation-of-amazon-ec2-memory-optimized-instances/" rel="external nofollow noopener noreferrer" target="_blank">EC2内存优化的实例</a>。但是，由于这些模块是一起部署的，因此您必须在硬件选择上进行折衷。</li>
<li>由于所有模块都在同一个进程中运行，因此任何模块中的错误（例如内存泄漏）都可能导致整个进程中断。</li>
<li>单片应用程序使采用新框架和语言变得极为困难。</li>
</ul>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>服务通常实现一组不同的特征或功能，例如订单管理，客户管理等。每个微服务都是一个微型应用程序，具有自己的六边形体系结构，该体系结构由业务逻辑和各种适配器组成。某些微服务会公开其他微服务或应用程序客户端使用的API。其他微服务可能实现Web UI。在运行时，每个实例通常是云VM或Docker容器。</p>
<p>现在，应用程序的每个功能区域都由其自己的微服务实现。此外，该Web应用程序被分为一组简单的Web应用程序（例如，在我们的出租车叫车示例中，一个用于乘客，一个用于驾驶员）。这使得为特定用户，设备或特殊用例部署不同的体验变得更加容易。</p>
<p>每个后端服务公开一个REST API，大多数服务使用其他服务提供的API。例如，驾驶员管理使用通知服务器来通知可用的驾驶员潜在的行程。UI服务调用其他服务以呈现网页。服务还可以使用基于消息的异步通信。本系列后面的内容将更详细地介绍服务间通信。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>将原本是巨大的整体应用程序分解为一组服务。虽然功能总数不变，但该应用程序已分为可管理的块或服务。每个服务都有以RPC或消息驱动的API形式定义的边界。</li>
<li>使每个服务可以由专注于该服务的团队独立开发。开发人员可以自由选择任何有意义的技术，只要该服务遵守API合同即可。</li>
<li>微服务架构模式使每个微服务可以独立部署。开发人员无需协调其服务本地更改的部署。这些更改只要经过测试就可以部署。</li>
<li>微服务架构模式使每个服务都可以独立扩展。可以仅部署满足其容量和可用性约束的每个服务的实例数。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>微服务应用程序是分布式系统</strong>这一事实而导致的复杂性。开发人员需要选择并实现基于消息传递或RPC的进程间通信机制。此外，由于请求的目的地可能很慢或不可用，它们还必须编写代码来处理部分失败。</li>
<li>另一个挑战是分区数据库体系结构。更新多个业务实体的业务交易相当普遍。由于只有一个数据库，因此在单一应用程序中实现这类事务很简单。但是，在基于微服务的应用程序中，您需要更新不同服务拥有的多个数据库。</li>
<li>测试微服务应用程序也要复杂得多。</li>
<li>实现跨多个服务的更改较难。</li>
</ul>
<h2 id="使用API网关构建微服务"><a href="#使用API网关构建微服务" class="headerlink" title="使用API网关构建微服务"></a>使用API网关构建微服务</h2><h3 id="客户端与微服务之间的直接通信"><a href="#客户端与微服务之间的直接通信" class="headerlink" title="客户端与微服务之间的直接通信"></a>客户端与微服务之间的直接通信</h3><p>从理论上讲，客户端可以直接向每个微服务发出请求。每个微服务都有一个公共终结点（<strong>https：// *serviceName* .api.company.name</strong>）。该URL将映射到微服务的负载平衡器，该负载平衡器在可用实例之间分配请求。要检索产品详细信息，移动客户端将向上面列出的每个服务发出请求。</p>
<p>不幸的是，此选项存在挑战和局限性。一个问题是客户端需求与每个微服务公开的细粒度API之间的不匹配。</p>
<p>客户端直接调用微服务的另一个问题是，有些服务可能使用不支持Web的协议。一个服务可能使用Thrift二进制RPC，而另一服务可能使用AMQP消息传递协议。两种协议都不是特别适合浏览器或防火墙的协议，并且最好在内部使用。应用程序应在防火墙外部使用HTTP和WebSocket之类的协议。</p>
<p>这种方法的另一个缺点是很难重构微服务。随着时间的流逝，我们可能想更改将系统划分为服务的方式。例如，我们可以合并两个服务或将一个服务拆分为两个或多个服务。但是，如果客户直接与服务进行通信，那么执行这种重构可能会非常困难。</p>
<h3 id="使用API网关"><a href="#使用API网关" class="headerlink" title="使用API网关"></a>使用API网关</h3><p>API网关是服务器，是系统的单个入口点。它与面向对象设计中的“ <a href="https://en.wikipedia.org/wiki/Facade_pattern" rel="external nofollow noopener noreferrer" target="_blank">外观”</a>模式相似。API网关封装了内部系统架构，并提供了针对每个客户端量身定制的API。它可能还具有其他职责，例如身份验证，监视，负载平衡，缓存，请求整形和管理以及静态响应处理。</p>
<p>API网关负责请求路由，组合和协议转换。来自客户端的所有请求都首先通过API网关。然后，它将请求路由到适当的微服务。API网关通常会通过调用多个微服务并汇总结果来处理请求。它可以在内部使用的HTTP和WebSocket之类的Web协议与Web不友好的协议之间转换。</p>
<p>API网关还可以为每个客户端提供自定义API。它通常为移动客户端提供粗粒度的API。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>使用API网关的主要好处是它封装了应用程序的内部结构。客户端不必调用特定的服务，而只是与网关进行对话。API网关为每种客户端提供特定的API。这减少了客户端与应用程序之间的往返次数。它还简化了客户端代码。</p>
<p>API网关也有一些缺点。它是另一个必须开发，部署和管理的高可用性组件。API网关也有成为开发瓶颈的风险。开发人员必须更新API网关才能公开每个微服务的端点。重要的是，更新API网关的过程应尽可能轻巧。否则，开发人员将被迫排队等待更新网关。</p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul>
<li>性能和可伸缩性。</li>
<li>使用反应式编程模型。API网关通过简单地将请求路由到适当的后端服务来处理一些请求。它通过调用多个后端服务并汇总结果来处理其他请求。对于某些请求（例如产品详细信息请求），对后端服务的请求彼此独立。为了最小化响应时间，API网关应同时执行独立的请求。但是，有时请求之间存在依赖关系。</li>
<li>服务调用。基于微服务的应用程序是一个分布式系统，必须使用进程间通信机制。进程间通信有两种样式。一种选择是使用基于消息的异步机制。一些实现使用消息代理，例如JMS或AMQP。诸如Zeromq之类的其他公司则没有经纪人，服务可以直接通信。进程间通信的另一种形式是同步机制，例如HTTP或Thrift。系统通常会同时使用异步和同步样式。</li>
<li>服务发现。API网关需要知道与之通信的每个微服务的位置（IP地址和端口）。在传统的应用程序中，您可能需要对位置进行硬连线，但是在现代的基于云的微服务应用程序中，这是一个不小的问题。基础结构服务（例如消息代理）通常将具有静态位置，可以通过OS环境变量指定该位置。但是，确定应用程序服务的位置并非易事。应用程序服务具有动态分配的位置。而且，服务的实例集会由于自动缩放和升级而动态更改。因此，与系统中的任何其他服务客户端一样，API网关也需要使用系统的服务发现机制。</li>
<li>故障处理。实现API网关时必须解决的另一个问题是部分失败的问题。每当一个服务调用另一个响应缓慢或不可用的服务时，在所有分布式系统中都会出现此问题。API网关绝不应无限期地阻塞等待下游服务。但是，它如何处理故障取决于特定的情况以及哪个服务出现故障。</li>
</ul>
<h2 id="微服务架构中的进程间通信"><a href="#微服务架构中的进程间通信" class="headerlink" title="微服务架构中的进程间通信"></a>微服务架构中的进程间通信</h2><p>在整体应用程序中，组件通过语言级方法或函数调用相互调用。相反，基于微服务的应用程序是在多台计算机上运行的分布式系统。每个服务实例通常是一个进程。因此，如下图所示，服务必须使用进程间通信（IPC）机制进行交互。</p>
<h3 id="互动方式"><a href="#互动方式" class="headerlink" title="互动方式"></a>互动方式</h3><p>为服务选择IPC机制时，首先考虑服务如何交互是很有用的。客户端⇔服务交互方式多种多样。它们可以沿两个维度进行分类。第一个维度是互动是一对一还是一对多：</p>
<ul>
<li>一对一–每个客户端请求仅由一个服务实例处理。</li>
<li>一对多–每个请求由多个服务实例处理。</li>
</ul>
<p>第二个维度是交互是同步还是异步：</p>
<ul>
<li>同步–客户端期望服务及时响应，甚至在等待时可能会阻塞。</li>
<li>异步–客户端在等待响应时不会阻塞，并且响应（如果有的话）不一定会立即发送。</li>
</ul>
<p>一对一交互：</p>
<ul>
<li>请求/响应–客户端向服务发出请求并等待响应。客户希望响应能够及时到达。在基于线程的应用程序中，发出请求的线程甚至可能在等待时阻塞。</li>
<li>通知（也称为单向请求）–客户端向服务发送请求，但不希望或未发送答复。</li>
<li>请求/异步响应–客户端将请求发送到服务，该服务以异步方式答复。客户端在等待时不会阻塞，并假设响应可能不会在一段时间内到达。</li>
</ul>
<p>一对多互动有以下几种：</p>
<ul>
<li>发布/订阅–客户端发布通知消息，该消息由零个或更多感兴趣的服务使用。</li>
<li>发布/异步响应–客户端发布请求消息，然后等待一定时间以等待感兴趣的服务的响应。</li>
</ul>
<h3 id="不断变化的API"><a href="#不断变化的API" class="headerlink" title="不断变化的API"></a>不断变化的API</h3><p>服务的API始终会随着时间而变化。在整体应用程序中，更改API和更新所有调用程序通常很简单。在基于微服务的应用程序中，即使API的所有使用者都是同一应用程序中的其他服务，也要困难得多。通常，您无法强制所有客户端与服务同步升级。</p>
<p>处理API更改的方式取决于更改的大小。某些更改是次要的，并且与以前的版本向后兼容。</p>
<p>但是，有时您必须对API进行重大的，不兼容的更改。由于您不能强制客户端立即升级，因此服务必须在一段时间内支持较旧版本的API。</p>
<h3 id="故障处理原则"><a href="#故障处理原则" class="headerlink" title="故障处理原则"></a>故障处理原则</h3><ul>
<li>网络超时–永远不会无限阻塞，并且在等待响应时始终使用超时。使用超时可确保资源不会无限期地被占用。</li>
<li>限制未完成请求的数量–限制客户端可以使用特定服务的未完成请求的数量。如果已达到限制，则发出其他请求可能毫无意义，并且这些尝试必须立即失败。</li>
<li><a href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="external nofollow noopener noreferrer" target="_blank">断路器模式</a> –跟踪成功和失败请求的数量。如果错误率超过配置的阈值，请使断路器跳闸，以便进一步尝试立即失败。如果大量请求失败，则表明该服务不可用，并且发送请求毫无意义。超时后，客户端应重试，如果成功，则合上断路器。</li>
<li>提供回退–当请求失败时执行回退逻辑。例如，返回缓存的数据或默认值，例如空的建议集。</li>
</ul>
<h3 id="IPC技术"><a href="#IPC技术" class="headerlink" title="IPC技术"></a>IPC技术</h3><h4 id="基于消息的异步通信"><a href="#基于消息的异步通信" class="headerlink" title="基于消息的异步通信"></a>基于消息的异步通信</h4><p>使用消息传递时，进程通过异步交换消息进行通信。客户端通过向其发送消息来向服务发出请求。如果期望该服务进行答复，则通过将单独的消息发送回客户端来进行答复。由于通信是异步的，因此客户端不会阻止等待答复。而是编写客户端，假定不会立即收到答复。</p>
<p>一条<a href="https://www.enterpriseintegrationpatterns.com/Message.html" rel="external nofollow noopener noreferrer" target="_blank">消息</a>由标头（例如发送方之类的元数据）和一条消息主体组成。消息通过<a href="https://www.enterpriseintegrationpatterns.com/MessageChannel.html" rel="external nofollow noopener noreferrer" target="_blank">通道</a>交换。任何数量的生产者都可以将消息发送到一个频道。同样，任何数量的使用者都可以从频道接收消息。有两种渠道，<a href="https://www.enterpriseintegrationpatterns.com/PointToPointChannel.html" rel="external nofollow noopener noreferrer" target="_blank">点对点</a>渠道和<a href="https://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html" rel="external nofollow noopener noreferrer" target="_blank">发布订阅</a>渠道。点对点通道将消息传递给正从该通道读取的消费者中的一个。服务使用点对点渠道进行前面所述的一对一交互样式。发布订阅通道将每个消息传递给所有附加的使用者。服务将发布-订阅通道用于上述一对多交互样式。</p>
<p>使用消息传递有很多优点：</p>
<ul>
<li>使客户端与服务脱钩–客户端仅通过向适当的通道发送消息即可发出请求。客户端完全不知道服务实例。它不需要使用发现机制来确定服务实例的位置。</li>
<li>消息缓冲–使用同步请求/响应协议（例如HTTP），客户端和服务在交换期间必须都可用。相反，消息代理将写入通道的消息排队，直到消费者可以处理它们为止。例如，这意味着即使订单履行系统很慢或不可用，在线商店也可以接受来自客户的订单。订单消息只是排队。</li>
<li>灵活的客户端-服务交互–消息支持前面描述的所有交互样式。</li>
<li>显式进程间通信–基于RPC的机制试图使调用远程服务看起来与调用本地服务相同。但是，由于物理定律和部分失效的可能性，它们实际上是完全不同的。消息传递使这些差异非常明显，因此开发人员不会陷入错误的安全感中。</li>
</ul>
<p>但是，使用消息传递有一些缺点：</p>
<ul>
<li>额外的操作复杂性–邮件系统是又一个必须安装，配置和操作的系统组件。消息代理必须高度可用，否则系统可靠性会受到影响。</li>
<li>实现基于请求/响应的交互的复杂性–请求/响应式的交互需要一些工作来实现。每个请求消息必须包含一个回复通道标识符和一个相关标识符。服务将包含相关ID的响应消息写入回复通道。客户端使用相关性ID将响应与请求进行匹配。使用直接支持请求/响应的IPC机制通常会更容易。</li>
</ul>
<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><p>当使用基于请求/响应的同步IPC机制时，客户端会将请求发送到服务。该服务处理请求并发送回响应。在许多客户端中，发出请求的线程在等待响应时会阻塞。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务实例具有动态分配的网络位置。而且，服务实例集会由于自动缩放，故障和升级而动态更改。因此，您的客户端代码需要使用更复杂的服务发现机制。</p>
<p>有两种主要的服务发现模式：<a href="https://microservices.io/patterns/client-side-discovery.html" rel="external nofollow noopener noreferrer" target="_blank">客户端发现</a>和<a href="https://microservices.io/patterns/server-side-discovery.html" rel="external nofollow noopener noreferrer" target="_blank">服务器端发现</a>。</p>
<h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>使用<a href="https://microservices.io/patterns/client-side-discovery.html" rel="external nofollow noopener noreferrer" target="_blank">客户端发现时</a>，客户端负责确定可用服务实例的网络位置，并在它们之间进行负载平衡请求。客户端查询服务注册表，该服务注册表是可用服务实例的数据库。然后，客户端使用负载平衡算法来选择可用的服务实例之一并发出请求。</p>
<p>服务实例的网络位置在启动时会在服务注册表中注册。实例终止时，将从服务注册表中将其删除。通常使用心跳机制定期刷新服务实例的注册。</p>
<p>客户端发现模式具有多种优点和缺点。这种模式相对简单，除了服务注册表之外，没有其他活动部分。此外，由于客户端知道可用的服务实例，因此它可以做出智能的，特定于应用程序的负载平衡决策，例如一致地使用哈希。这种模式的一个重大缺陷是它将客户端与服务注册表耦合在一起。您必须为服务客户端使用的每种编程语言和框架实现客户端服务发现逻辑。</p>
<h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>客户端通过负载平衡器向服务发出请求。负载平衡器查询服务注册表，并将每个请求路由到可用的服务实例。与客户端发现一样，服务实例在服务注册表中注册和注销。</p>
<p>HTTP服务器和负载平衡器（例如<a href="https://www.nginx.com/products/" rel="external nofollow noopener noreferrer" target="_blank">NGINX Plus</a>和NGINX）也可以用作服务器端发现负载平衡器。</p>
<p>服务器端发现模式具有多个优点和缺点。这种模式的一大好处是发现细节从客户端被抽象出来。客户只需向负载均衡器发出请求。这样就无需为服务客户端使用的每种编程语言和框架实现发现逻辑。</p>
<h3 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h3><p><a href="https://microservices.io/patterns/service-registry.html" rel="external nofollow noopener noreferrer" target="_blank">服务注册表</a>是服务发现的一个关键部分。它是一个数据库，其中包含服务实例的网络位置。服务注册表需要高度可用且最新。客户端可以缓存从服务注册表获得的网络位置。但是，该信息最终将过时，并且客户端将无法发现服务实例。因此，服务注册表由使用复制协议维护一致性的服务器群集组成。</p>
<p><a href="https://github.com/Netflix/eureka" rel="external nofollow noopener noreferrer" target="_blank">Netflix Eureka</a>是服务注册表的一个很好的例子。它提供了一个REST API，用于注册和查询服务实例。服务实例使用<code>POST</code>请求注册其网络位置。每隔30秒，它必须使用<code>PUT</code>请求刷新其注册。通过使用HTTP <code>DELETE</code>请求或实例注册超时来删除注册。如您所料，客户端可以使用HTTP <code>GET</code>请求来检索注册的服务实例。</p>
<h4 id="服务注册方式"><a href="#服务注册方式" class="headerlink" title="服务注册方式"></a>服务注册方式</h4><h5 id="自我注册"><a href="#自我注册" class="headerlink" title="自我注册"></a>自我注册</h5><p>使用<a href="https://microservices.io/patterns/self-registration.html" rel="external nofollow noopener noreferrer" target="_blank">自我注册模式时</a>，服务实例负责在服务注册表中进行自身注册和注销。同样，如果需要，服务实例会发送心跳请求以防止其注册过期。</p>
<p>自注册模式具有各种优点和缺点。好处之一是它相对简单，不需要任何其他系统组件。但是，主要缺点是它将服务实例耦合到服务注册表。您必须使用服务使用的每种编程语言和框架来实现注册码。</p>
<h5 id="第三方注册"><a href="#第三方注册" class="headerlink" title="第三方注册"></a>第三方注册</h5><p>使用<a href="https://microservices.io/patterns/3rd-party-registration.html" rel="external nofollow noopener noreferrer" target="_blank">第三方注册模式时</a>，服务实例不负责在服务注册表中自行注册。取而代之的是另一个称为<em>服务注册器的</em>系统组件来处理注册。服务注册商通过轮询部署环境或订阅事件来跟踪对正在运行的实例集的更改。当发现新的可用服务实例时，它将在服务注册表中注册该实例。服务注册商还注销终止的服务实例。下图显示了此模式的结构。</p>
<h2 id="分布式数据管理问题"><a href="#分布式数据管理问题" class="headerlink" title="分布式数据管理问题"></a>分布式数据管理问题</h2><p>整体应用程序通常具有单个关系数据库。使用关系数据库的主要好处是您的应用程序可以使用<a href="https://en.wikipedia.org/wiki/ACID" rel="external nofollow noopener noreferrer" target="_blank">ACID事务</a>，这提供了一些重要的保证：</p>
<ul>
<li>原子性–原子地进行更改</li>
<li>一致性–数据库状态始终是一致的</li>
<li>隔离–即使事务是同时执行的，看起来它们还是串行执行的</li>
<li>耐用性–交易一旦提交，便不会撤消</li>
</ul>
<p>结果，您的应用程序可以简单地开始事务，更改（插入，更新和删除）多行并提交事务。</p>
<p>我们转向微服务架构时，数据访问变得更加复杂。这是因为每个微服务拥有的数据是<a href="http://microservices.io/patterns/data/database-per-service.html" rel="external nofollow noopener noreferrer" target="_blank">该微</a>服务<a href="http://microservices.io/patterns/data/database-per-service.html" rel="external nofollow noopener noreferrer" target="_blank">专用的，</a>并且只能通过其API访问。封装数据可确保微服务松散耦合，并且可以彼此独立发展。如果多个服务访问相同的数据，则模式更新需要对所有服务进行耗时且协调的更新。</p>
<p>更糟糕的是，不同的微服务通常使用不同种类的数据库。现代应用程序存储和处理各种数据，而关系数据库并不总是最佳选择。对于某些用例，特定的NoSQL数据库可能具有更方便的数据模型，并提供更好的性能和可伸缩性。</p>
<p>第一个挑战是如何实现在多个服务之间保持一致性的业务交易。</p>
<p>第二个挑战是如何实现从多个服务检索数据的查询。</p>
<h3 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h3><p>对于许多应用程序，解决方案是使用<a href="http://martinfowler.com/eaaDev/EventNarrative.html" rel="external nofollow noopener noreferrer" target="_blank">事件驱动的体系结构</a>。在这种体系结构中，微服务会在发生显着事件（例如更新业务实体）时发布事件。其他微服务订阅了这些事件。当微服务收到事件时，它可以更新自己的业务实体，这可能导致发布更多事件。</p>
<p>您可以使用事件来实现跨多个服务的业务交易。交易包括一系列步骤。每个步骤都包含一个微服务，该微服务更新业务实体并发布触发下一步的事件。</p>
<p>重要的是要注意，这些不是ACID交易。它们提供的保证要弱得多，例如<a href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="external nofollow noopener noreferrer" target="_blank">最终的一致性</a>。此事务处理模型已称为<a href="http://queue.acm.org/detail.cfm?id=1394128" rel="external nofollow noopener noreferrer" target="_blank">BASE模型</a>。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>在事件驱动的体系结构中，还存在原子更新数据库并发布事件的问题。例如，订购服务必须在ORDER表中插入一行并发布订购创建事件。这两个操作必须原子完成。如果服务在更新数据库之后但在发布事件之前崩溃，则系统会变得不一致。</p>
<h4 id="使用本地事务发布事件"><a href="#使用本地事务发布事件" class="headerlink" title="使用本地事务发布事件"></a>使用本地事务发布事件</h4><p>诀窍是在存储业务实体状态的数据库中具有一个EVENT表，该表充当消息队列。应用程序开始（本地）数据库事务，更新业务实体的状态，将事件插入EVENT表，然后提交事务。单独的应用程序线程或进程查询EVENT表，将事件发布到Message Broker，然后使用本地事务将事件标记为已发布。</p>
<h4 id="挖掘数据库事务日志"><a href="#挖掘数据库事务日志" class="headerlink" title="挖掘数据库事务日志"></a>挖掘数据库事务日志</h4><p>在没有2PC的情况下实现原子性的另一种方法是，事件由挖掘数据库事务或提交日志的线程或进程发布。该应用程序更新数据库，这导致更改被记录在数据库的事务日志中。事务日志挖掘器线程或进程读取事务日志并将事件发布到Message Broker。</p>
<p>事务日志挖掘具有各种优点和缺点。一个好处是，它保证了每次更新都可以发布事件，而无需使用2PC。事务日志挖掘还可以通过将事件发布与应用程序的业务逻辑分开来简化应用程序。一个主要的缺点是事务日志的格式是每个数据库专有的，甚至可以在数据库版本之间进行更改。</p>
<h4 id="使用事件源（类似区块链账本）"><a href="#使用事件源（类似区块链账本）" class="headerlink" title="使用事件源（类似区块链账本）"></a>使用事件源（类似区块链账本）</h4><p>通过使用根本不同的，以事件为中心的方法来持久化业务实体，<a href="https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing" rel="external nofollow noopener noreferrer" target="_blank">事件采购</a>无需2PC就可以实现原子性。该应用程序不是存储实体的当前状态，而是存储一系列状态更改事件。该应用程序通过重播事件来重建实体的当前状态。只要业务实体的状态发生变化，就会在事件列表中附加一个新事件。由于保存事件是单个操作，因此它本质上是原子的。</p>
<p>事件源有几个好处。它解决了实现事件驱动的体系结构中的关键问题之一，并使得在状态改变时可靠地发布事件成为可能。结果，它解决了微服务体系结构中的数据一致性问题。另外，由于它保留事件而不是域对象，因此它可以避免<a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" rel="external nofollow noopener noreferrer" target="_blank">对象关系阻抗不匹配的问题</a>。事件源还提供了对业务实体所做的更改的100％可靠的审核日志，并使得可以实施临时查询来确定实体在任何时间点的状态。事件源的另一个主要优点是您的业务逻辑由交换事件的松散耦合的业务实体组成。这使得从单片应用程序迁移到微服务架构变得容易得多。</p>
<p>事件源也有一些缺点。这是一种不同且陌生的编程风格，因此存在学习曲线。事件存储区仅直接支持通过主键查找业务实体。您必须使用<a href="https://github.com/cer/event-sourcing-examples/wiki" rel="external nofollow noopener noreferrer" target="_blank">命令查询职责隔离</a>（CQRS）来实现查询。结果，应用程序必须处理最终一致的数据。</p>
<h2 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h2><h3 id="每个主机模式有多个服务实例"><a href="#每个主机模式有多个服务实例" class="headerlink" title="每个主机模式有多个服务实例"></a>每个主机模式有多个服务实例</h3><p>部署微服务的一种方法是使用“ <a href="https://microservices.io/patterns/deployment/multiple-services-per-host.html" rel="external nofollow noopener noreferrer" target="_blank">每个主机多个服务实例”</a>模式。使用此模式时，您将配置一个或多个物理或虚拟主机，并在每个虚拟或虚拟主机上运行多个服务实例。在许多方面，这是应用程序部署的传统方法。每个服务实例在一个或多个主机上的一个知名端口上运行。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>资源使用相对高效。多个服务实例共享服务器及其操作系统。如果一个进程或进程组运行多个服务实例，例如共享同一个Apache Tomcat服务器和JVM的多个Web应用程序，则效率更高。</li>
<li>部署服务实例相对较快。您只需将服务复制到主机并启动即可。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>除非每个服务实例是一个单独的进程，否则服务实例几乎没有隔离。尽管可以准确地监视每个服务实例的资源利用率，但是不能限制每个实例使用的资源。行为异常的服务实例可能会消耗主机的所有内存或CPU。</li>
<li>部署服务的运营团队必须知道如何执行服务的具体细节。服务可以用多种语言和框架编写，因此开发团队必须与操作共享许多细节。这种复杂性增加了部署期间出错的风险。</li>
</ul>
<h3 id="每个主机模式的服务实例"><a href="#每个主机模式的服务实例" class="headerlink" title="每个主机模式的服务实例"></a>每个主机模式的服务实例</h3><p>使用此模式时，每个服务实例都在其自己的主机上独立运行。此模式有两种不同的专业化：每个虚拟机的服务实例和每个容器的服务实例。</p>
<h4 id="每个虚拟机模式的服务实例"><a href="#每个虚拟机模式的服务实例" class="headerlink" title="每个虚拟机模式的服务实例"></a>每个虚拟机模式的服务实例</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>每个服务实例都可以完全隔离地运行。它具有固定数量的CPU和内存，无法从其他服务中窃取资源。</li>
<li>可以利用成熟的云基础架构。</li>
<li>封装了服务的实现技术。将服务打包为VM后，它将变成一个黑匣子。VM的管理API成为用于部署服务的API。部署变得更加简单和可靠。</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>资源利用效率较低。每个服务实例都有整个VM（包括操作系统）的开销。</li>
</ul>
<h4 id="每个容器模式的服务实例"><a href="#每个容器模式的服务实例" class="headerlink" title="每个容器模式的服务实例"></a>每个容器模式的服务实例</h4><p>当您使用“ <a href="https://microservices.io/patterns/deployment/service-per-container.html" rel="external nofollow noopener noreferrer" target="_blank">每个容器</a>的<a href="https://microservices.io/patterns/deployment/service-per-container.html" rel="external nofollow noopener noreferrer" target="_blank">服务实例”</a>模式时，每个服务实例都在其自己的容器中运行。容器是<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" rel="external nofollow noopener noreferrer" target="_blank">操作系统级别</a>的<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" rel="external nofollow noopener noreferrer" target="_blank">虚拟化机制</a>。容器由在沙箱中运行的一个或多个进程组成。从进程的角度来看，它们具有自己的端口名称空间和根文件系统。您可以限制容器的内存和CPU资源。一些容器实现也具有I / O速率限制。容器技术的示例包括<a href="https://www.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker</a>和<a href="https://en.wikipedia.org/wiki/Solaris_Containers" rel="external nofollow noopener noreferrer" target="_blank">Solaris Zones</a>。</p>
<h3 id="无服务器部署"><a href="#无服务器部署" class="headerlink" title="无服务器部署"></a>无服务器部署</h3><p><a href="https://aws.amazon.com/lambda/" rel="external nofollow noopener noreferrer" target="_blank">AWS Lambda</a>是无服务器部署技术的示例。它支持Java，Node.js和Python服务。要部署微服务，请将其打包为ZIP文件，然后将其上传到AWS Lambda。您还提供元数据，元数据除其他事项外，还指定为处理请求（又称为事件）而调用的函数的名称。AWS Lambda自动运行您的微服务的足够实例来处理请求。您只需根据花费的时间和消耗的内存为每个请求付费。</p>
<h2 id="将单片应用重构为微服务方法"><a href="#将单片应用重构为微服务方法" class="headerlink" title="将单片应用重构为微服务方法"></a>将单片应用重构为微服务方法</h2><h3 id="不再增大整体项目"><a href="#不再增大整体项目" class="headerlink" title="不再增大整体项目"></a>不再增大整体项目</h3><p>在实现新功能时，不应将更多代码添加到整体中。相反，此策略的主要思想是将新代码放入独立的微服务中。</p>
<h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>缩小整体应用程序的一种策略是将表示层与业务逻辑和数据访问层分开。典型的企业应用程序至少包含三种不同类型的组件：</p>
<ul>
<li>表示层–处理HTTP请求并实现（REST）API或基于HTML的Web UI的组件。在具有复杂用户界面的应用程序中，表示层通常是大量的代码。</li>
<li>业务逻辑层–作为应用程序核心并实现业务规则的组件。</li>
<li>数据访问层–访问基础结构组件的组件，例如数据库和消息代理。</li>
</ul>
<h3 id="提取服务"><a href="#提取服务" class="headerlink" title="提取服务"></a>提取服务</h3><p>第三种重构策略是将整体中的现有模块转变为独立的微服务。每次提取模块并将其转换为服务时，整体都会收缩。一旦转换了足够多的模块，整体将不再是问题。它要么完全消失，要么变得足够小，以至于它只是另一种服务。</p>
<h4 id="提取哪些模块"><a href="#提取哪些模块" class="headerlink" title="提取哪些模块"></a>提取哪些模块</h4><p>大型，复杂的整体应用程序由数十个或数百个模块组成，所有这些模块都是提取的候选对象。找出首先要转换的模块通常很困难。一个好的方法是从几个容易提取的模块开始。这将为您提供一般的微服务经验，尤其是提取过程的经验。之后，您应该提取那些将为您带来最大利益的模块。</p>
<h4 id="如何提取"><a href="#如何提取" class="headerlink" title="如何提取"></a>如何提取</h4><p>提取模块的第一步是定义模块和整体之间的粗粒度界面。它最有可能是双向API，因为整体将需要服务拥有的数据，反之亦然。由于模块和应用程序其余部分之间存在复杂的依赖关系和细粒度的交互模式，因此实现这样的API通常具有挑战性。由于域模型类之间存在大量关联，因此使用<a href="https://martinfowler.com/eaaCatalog/domainModel.html" rel="external nofollow noopener noreferrer" target="_blank">域模型模式</a>实现的业务逻辑尤其难以重构。您通常需要进行重大的代码更改才能打破这些依赖性。下图显示了重构。</p>
<p>一旦实现了粗粒度接口，就可以将模块变成独立的服务。为此，您必须编写代码以使整体组件和服务能够通过使用<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/inter-process-communication" rel="external nofollow noopener noreferrer" target="_blank">进程间通信</a>（IPC）机制的API进行<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/inter-process-communication" rel="external nofollow noopener noreferrer" target="_blank">通信</a>。</p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>最小生成树算法</title>
    <url>/2021/01/19/minimum-spanning-tree/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。</p>
<p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p>
<a id="more"></a>

<h2 id="克鲁斯克尔算法"><a href="#克鲁斯克尔算法" class="headerlink" title="克鲁斯克尔算法"></a>克鲁斯克尔算法</h2><p>克鲁斯克尔算法（Kruskal’s algorithm），是一种用来查找最小生成树的算法，但算法的实现不一样，它是通过对权值从小到大顺序排列来查找最小生成树的。</p>
<p>1.将原图中所有的边按权值从小到大排序。</p>
<p>2.从权值最小的边开始，如果这条边连接的两个节点于图中不在同一个已连接的边中，则记录该顶点为已选择。</p>
<p>3.重复步骤2，直至图中所有的节点都连通，就找到了连通图的最小生成树。</p>
<blockquote>
<p>对于节点之间是否连接，属于连通性问题，可以采用并查集来实现，具体细节可以看我<a href="https://sunra.top/2020/06/08/union-find-algorithm/">以前的博客</a></p>
</blockquote>
<p>基于以上的思路，我们可以得出以下的算法：</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.f = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.f[x] === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.f[x] = <span class="keyword">this</span>.find(<span class="keyword">this</span>.f[x]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f[x];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  union(x, y) &#123;</span><br><span class="line">    <span class="keyword">let</span> fx = <span class="keyword">this</span>.find(x), fy = <span class="keyword">this</span>.find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx === fy) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.f[fy] = <span class="keyword">this</span>.f[fx];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostConnectPoints = <span class="function"><span class="keyword">function</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      edges.push([dist(i, j), i, j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edges.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 以上几行代码其实只是初始化边的数据</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> dist = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">Math</span>.abs(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> n = points.length;</span><br><span class="line">  <span class="keyword">const</span> uni = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">  <span class="keyword">const</span> edges = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> [length, x, y] <span class="keyword">of</span> edges) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uni.union(x, y)) &#123;</span><br><span class="line">      ret += length;</span><br><span class="line">      num++;</span><br><span class="line">      <span class="keyword">if</span> (num === n) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>上面的并查集算法只是加入了路径压缩，但是<strong>这个路径压缩仅仅是减少了我们并查集中维护的连通性树的深度，而并不是我们实际连接的树的深度</strong>，所以我们引入了一个新的概念，叫做<strong>秩</strong>。</p>
<p>我们将连接过程中的产生的每个树的实际深度都叫做秩，我们要做的就是在合并的时候尽量将秩小的树连接到秩大的树的根节点，如果将要合并的两个树的秩相同，就挑选其中一个，插入另一个树的根节点，另一个树的秩加一，这样就可以保证最后生成出的树的秩是最小的。</p>
<p>所以我们改造下我们的并查集算法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.rank = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);  <span class="comment">// 秩</span></span><br><span class="line">    <span class="keyword">this</span>.f = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.f[x] === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.f[x] = <span class="keyword">this</span>.find(<span class="keyword">this</span>.f[x]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f[x];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  union(x, y) &#123;</span><br><span class="line">    <span class="keyword">let</span> fx = <span class="keyword">this</span>.find(x), fy = <span class="keyword">this</span>.find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx === fy) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank[fx] &lt; <span class="keyword">this</span>.rank[fy]) &#123; <span class="comment">// 保证fx是秩大的树的根节点</span></span><br><span class="line">      [fx, fy] = [fy, fx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rank[fx] === <span class="keyword">this</span>.rank[fy]) &#123; <span class="comment">// 如果fx和fy的秩相同，就把fy插入fx中，所以fx的秩加一</span></span><br><span class="line">      <span class="keyword">this</span>.rank[fx]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.f[fy] = <span class="keyword">this</span>.f[fx];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>Prim算法的步骤包括：</p>
<ol>
<li>将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。</li>
<li>针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。</li>
<li>递归执行步骤2，直到V中的集合为空。</li>
<li>U中所有节点构成的树就是最小生成树。</li>
</ol>
<h3 id="算法的基本实现"><a href="#算法的基本实现" class="headerlink" title="算法的基本实现"></a>算法的基本实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostConnectPoints = <span class="function"><span class="keyword">function</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dist = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">Math</span>.abs(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> n = points.length;</span><br><span class="line">  <span class="keyword">const</span> visited = [];</span><br><span class="line">  <span class="keyword">const</span> unVisited = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> index);</span><br><span class="line">  visited.push(unVisited.shift()) ;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(visited.length &lt; n) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    <span class="keyword">let</span> next = unVisited[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; unVisited.length; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tempDist = dist(visited[i], unVisited[j]);</span><br><span class="line">        <span class="keyword">if</span> (min &gt; tempDist) &#123;</span><br><span class="line">          min = tempDist;</span><br><span class="line">          next = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += min;</span><br><span class="line">    visited.push(unVisited.splice(next, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个版本是对算法最基本的实现，但是其实还有很多优化的空间。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>方法上：Kruskal在所有边中不断寻找最小的边，Prim在U和V两个集合之间寻找权值最小的连接，共同点是构造过程都不能形成环。</p>
<p>时间上：Prim适合稠密图，复杂度为O(n * n)，因此通常使用邻接矩阵储存，复杂度为O(e * loge)，而Kruskal多用邻接表，稠密图 Prim &gt; Kruskal，稀疏图 Kruskal &gt; Prim。</p>
<p>空间上： Prim适合点少边多，Kruskal适合边多点少。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>记忆化搜索</title>
    <url>/2021/04/17/mnemonic-search/</url>
    <content><![CDATA[<p>今天的leetcode每日一题是一道关于记忆化搜索的题目，这里简单记录一下。</p>
<p>这是题目链接：<a href="https://leetcode-cn.com/problems/scramble-string/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/scramble-string/</a></p>
<a id="more"></a>

<h2 id="什么是记忆化搜索"><a href="#什么是记忆化搜索" class="headerlink" title="什么是记忆化搜索"></a>什么是记忆化搜索</h2><p>要明白这个，首先要明白什么是搜索。</p>
<p>搜索大家很熟悉，DFS，BFS，深度优先搜索和广度优先搜索。</p>
<p>那记忆化搜索又是什么呢？就是在这个递归搜索过程中，对于一些重复的子问题，找个数据结构记下来上一次计算的结果。</p>
<p>听起来是不是有点像动态规划？</p>
<p>是的，记忆化搜索时递归，自顶向下，而动态规划是把递归的过程抽取成状态转移方程，记忆化数据结构变成DP数组，然后自底向上地去计算。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://leetcode-cn.com/problems/scramble-string/solution/rao-luan-zi-fu-chuan-by-leetcode-solutio-8r9t/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/scramble-string/solution/rao-luan-zi-fu-chuan-by-leetcode-solutio-8r9t/</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们可以先写出普通的DFS，然后加上某种数据结构去记忆已有的结果防止重复计算</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> checkIfSimilar = <span class="function"><span class="keyword">function</span>(<span class="params">i1, i2, length, s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> freq = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = s1[i];</span><br><span class="line">      freq.set(c, (freq.get(c) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = s2[i];</span><br><span class="line">      freq.set(c, (freq.get(c) || <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> freq.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">i1, i2, length, s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1.slice(i1, i1 + length) === s2.slice(i2, i2 + length)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length, s1, s2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dfs(i1, i2, i, s1, s2) &amp;&amp; dfs(i1 + i, i2 + i, length - i, s1, s2)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfs(i1, i2 + length - i, i, s1, s2) &amp;&amp; dfs(i1 + i, i2, length - i, s1, s2)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isScramble = <span class="function"><span class="keyword">function</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, s1.length, s1, s2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="加上记忆化搜索"><a href="#加上记忆化搜索" class="headerlink" title="加上记忆化搜索"></a>加上记忆化搜索</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isScramble = <span class="function"><span class="keyword">function</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = s1.length;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>).fill(<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, length, s1, s2, memo);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">i1, i2, length, s1, s2, memo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[i1][i2][length] !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i1][i2][length] === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.slice(i1, i1 + length) === s2.slice(i2, i2 + length)) &#123;</span><br><span class="line">        memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkIfSimilar(i1, i2, length, s1, s2)) &#123;</span><br><span class="line">        memo[i1][i2][length] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(i1, i2, i, s1, s2, memo) &amp;&amp; dfs(i1 + i, i2 + i, length - i, s1, s2, memo)) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs(i1, i2 + length - i, i, s1, s2, memo) &amp;&amp; dfs(i1 + i, i2, length - i, s1, s2, memo)) &#123;</span><br><span class="line">            memo[i1][i2][length] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[i1][i2][length] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkIfSimilar = <span class="function"><span class="keyword">function</span>(<span class="params">i1, i2, length, s1, s2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> freq = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = i1; i &lt; i1 + length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s1[i];</span><br><span class="line">        freq.set(c, (freq.get(c) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = i2; i &lt; i2 + length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s2[i];</span><br><span class="line">        freq.set(c, (freq.get(c) || <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> freq.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="记忆化搜索和动态规划"><a href="#记忆化搜索和动态规划" class="headerlink" title="记忆化搜索和动态规划"></a>记忆化搜索和动态规划</h2><p>应该说记忆化搜索算法是自顶向下的，动态规划算法是自底向上的，二者都是动态规划算法思想的一种实现。</p>
<p>所以二者的使用条件是相同的，具体可以去看我的另一篇博客：<a href="https://sunra.top/2020/10/26/four-algorithm-thought/">https://sunra.top/2020/10/26/four-algorithm-thought/</a></p>
<p>理论上动态规划算法是某些记忆化搜索的更进一步，也就是说理论上，所有的DP算法都可以写成记忆化搜索。</p>
]]></content>
  </entry>
  <entry>
    <title>MongoDB Tutorails</title>
    <url>/2019/09/20/mongoDB/</url>
    <content><![CDATA[<p>After reading the official mongoDb documentation, the author sorted out the basic concepts, CRUD, and related operations</p>
<a id="more"></a>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><table>
<thead>
<tr>
<th>RDBMS</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>Database</td>
<td>Database</td>
</tr>
<tr>
<td>Table</td>
<td>Collection</td>
</tr>
<tr>
<td>Tuple/Row</td>
<td>Document</td>
</tr>
<tr>
<td>column</td>
<td>Field</td>
</tr>
<tr>
<td>Table Join</td>
<td>Embedded Documents</td>
</tr>
<tr>
<td>Primary Key</td>
<td>Primary Key (Default key _id provided by mongodb itself)</td>
</tr>
</tbody></table>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><ol>
<li><p>create databse or return the exists database</p>
<p>use DATABSE_NAME</p>
</li>
<li><p>check the current database</p>
<p>db</p>
</li>
<li><p>check the database lists</p>
<p>show dbs</p>
</li>
<li><p>new created db will not show when you use “show dbs” command, you need to insert at least on document into it</p>
<p>db.movie.insert({“name”: “tutorialspoints”})</p>
</li>
<li><p>dropdatabse</p>
<p>db.dropDatabse()</p>
<p>this will delete the selected databse, it not, it will delete the default ‘test’ databse</p>
</li>
<li><p>create collection</p>
<p>db.createCollection(name, options)</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>String</td>
<td>Name of the collection to be created</td>
</tr>
<tr>
<td>Options</td>
<td>Document</td>
<td>(Optional) Specify options about memory size and indexing</td>
</tr>
</tbody></table>
<p>Options parameter is optional, so you need to specify only the name of the collection. Following is the list of options you can use −</p>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Type</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">capped</td>
<td align="center">Boolean</td>
<td align="center">(Optional) If true, enables a capped collection. Capped collection is a fixed size collection that automatically overwrites its oldest entries when it reaches its maximum size. <strong>If you specify true, you need to specify size parameter also.</strong></td>
</tr>
<tr>
<td align="center">autoIndexId</td>
<td align="center">Boolean</td>
<td align="center">(Optional) If true, automatically create index on _id field.s Default value is false.</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">number</td>
<td align="center">(Optional) Specifies a maximum size in bytes for a capped collection. <strong>If capped is true, then you need to specify this field also.</strong></td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">number</td>
<td align="center">(Optional) Specifies the maximum number of documents allowed in the capped collection.</td>
</tr>
</tbody></table>
<p>example: db.createCollection(“mycollection”)</p>
<ol start="7">
<li><p>check the created collection </p>
<p>show collections</p>
</li>
<li><p>mongodb can create collection automatically, when you insert some document</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.tutorialspoint.insert(&#123;<span class="string">"name"</span>: <span class="string">"tutorialspoint"</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>drop collection</p>
<p>db.collection.drop() is used to drop a collection from the database</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.drop()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Data-type"><a href="#Data-type" class="headerlink" title="Data type"></a>Data type</h2><ol>
<li>String</li>
<li>Integer</li>
<li>Boolean</li>
<li>Double</li>
<li>Min/Max keys: This type is used to compare a value against the lowest and highest BSON elements</li>
<li>Arrays</li>
<li>Timestamp</li>
<li>Object</li>
<li>Null</li>
<li>Symbol: This datatype is used identically to a string, however, it’s generally reserved for languages that use a specific symbol type.</li>
<li>Date</li>
<li>Object ID: used to store the document’s ID</li>
<li>Binary data</li>
<li>Code: use to store JavaScript code into the document</li>
<li>Regular expression</li>
</ol>
<h2 id="Document-CRUD-to-Collection"><a href="#Document-CRUD-to-Collection" class="headerlink" title="Document CRUD to Collection"></a>Document CRUD to Collection</h2><ol>
<li><p>insert method</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.insert(&#123;</span><br><span class="line">   _id: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   title: 'MongoDB Overview', </span><br><span class="line">   description: 'MongoDB is no sql database',</span><br><span class="line">   by: 'tutorials point',</span><br><span class="line">   url: 'http://www.tutorialspoint.com',</span><br><span class="line">   keywords: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">   likes: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>if we don’t specify the _id parameter, the MongoDB assgin a unique ObjectId for this document, _id is 12 bytes hexadecimal number unique for every document in a collection, 12 bytes are divided as follows:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_id: ObjectId(<span class="number">4</span> bytes timestamp, <span class="number">3</span> bytes machine id, <span class="number">2</span> bytes process id, </span><br><span class="line">   <span class="number">3</span> bytes incrementer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>insert multiple</p>
<p>To insert multiple documents in a single  query, we can pass an array of documents in insert command</p>
<p>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123;</span><br><span class="line">      title: 'MongoDB Overview', </span><br><span class="line">      description: 'MongoDB is no sql database',</span><br><span class="line">      by: 'tutorials point',</span><br><span class="line">      url: 'http://www.tutorialspoint.com',</span><br><span class="line">      keywords: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">      likes: <span class="number">100</span></span><br><span class="line">   &#125;,</span><br><span class="line">	</span><br><span class="line">   &#123;</span><br><span class="line">      title: 'NoSQL Database', </span><br><span class="line">      description: <span class="string">"NoSQL database doesn't have tables"</span>,</span><br><span class="line">      by: 'tutorials point',</span><br><span class="line">      url: 'http://www.tutorialspoint.com',</span><br><span class="line">      keywords: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">      likes: <span class="number">20</span>, </span><br><span class="line">      comments: [	</span><br><span class="line">         &#123;</span><br><span class="line">            user:'user1',</span><br><span class="line">            message: 'My first comment',</span><br><span class="line">            dateCreated: <span class="keyword">new</span> Date(<span class="number">2013</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">35</span>),</span><br><span class="line">            like: <span class="number">0</span> </span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>To insert the document you can also use db.COLLECTION_NAME.save .</p>
<p>But if you specify the _id, it will replace the whole data with the specified _id</p>
</li>
<li><p>Query document</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find()</span><br></pre></td></tr></table></figure>

<p>find() method will display all documents in a non-structured way</p>
<p>if you want to display the result in a formatted way, we can use pretty method</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().pretty()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Operation</th>
<th align="center">Syntax</th>
<th align="center">Example</th>
<th align="center">RDBMS Equivalent</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Equality</td>
<td align="center">{<key>:<value>}</value></key></td>
<td align="center">db.mycol.find({“by”:”tutorials point”}).pretty()</td>
<td align="center">where by = ‘tutorials point’</td>
</tr>
<tr>
<td align="center">Less Than</td>
<td align="center">{<key>:{$lt:<value>}}</value></key></td>
<td align="center">db.mycol.find({“likes”:{$lt:50}}).pretty()</td>
<td align="center">where likes &lt; 50</td>
</tr>
<tr>
<td align="center">Less Than Equals</td>
<td align="center">{<key>:{$lte:<value>}}</value></key></td>
<td align="center">db.mycol.find({“likes”:{$lte:50}}).pretty()</td>
<td align="center">where likes &lt;= 50</td>
</tr>
<tr>
<td align="center">Greater Than</td>
<td align="center">{<key>:{$gt:<value>}}</value></key></td>
<td align="center">db.mycol.find({“likes”:{$gt:50}}).pretty()</td>
<td align="center">where likes &gt; 50</td>
</tr>
<tr>
<td align="center">Greater Than Equals</td>
<td align="center">{<key>:{$gte:<value>}}</value></key></td>
<td align="center">db.mycol.find({“likes”:{$gte:50}}).pretty()</td>
<td align="center">where likes &gt;= 50</td>
</tr>
<tr>
<td align="center">Not Equals</td>
<td align="center">{<key>:{$ne:<value>}}</value></key></td>
<td align="center">db.mycol.find({“likes”:{$ne:50}}).pretty()</td>
<td align="center">where likes != 50</td>
</tr>
</tbody></table>
<p><strong>AND</strong> in the find method, if you pass multiple keys by separating them by ‘,’, then mongoDB treats it as AND condition, following is the basic syntax of and.  example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.find(&#123;$<span class="keyword">and</span>:[&#123;<span class="string">"by"</span>:<span class="string">"tutorials point"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>&#125;]&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p><strong>OR</strong>  example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.find(&#123;$<span class="keyword">or</span>:[&#123;<span class="string">"by"</span>:<span class="string">"tutorials point"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>&#125;]&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p>USE <strong>AND</strong> and <strong>OR</strong> together</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.find(&#123;<span class="string">"likes"</span>: &#123;$gt:<span class="number">10</span>&#125;, $<span class="keyword">or</span>: [&#123;<span class="string">"by"</span>: <span class="string">"tutorials point"</span>&#125;,</span><br></pre></td></tr></table></figure>

<p>Equivalent SQL where clause is <strong>‘where likes&gt;10 AND (by = ‘tutorials point’ OR title = ‘MongoDB Overview’)’</strong></p>
</li>
<li><p>Update Document</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.update(SELECTION_CRITERIA, UPDATED_DATA)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.mycol.update(&#123;'title':'MongoDB Overview'&#125;,&#123;$set:&#123;'title':'New MongoDB Tutorial'&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>by default, MongoDB will update only a single document, To update multiple documents, you need to set a parameter ‘multi’ to true, example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.mycol.update(&#123;'title':'MongoDB Overview'&#125;,&#123;$set:&#123;'title':'New MongoDB Tutorial'&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>save</strong> method can also update the data</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.save(&#123;_id:ObjectId(),NEW_DATA&#125;)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.save(</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"Tutorials Point New Topic"</span>,</span><br><span class="line">      <span class="string">"by"</span>:<span class="string">"Tutorials Point"</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Delete Document</p>
<p>MongoDB’s <strong>remove()</strong> method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)  <span class="comment">//remove sepecified</span></span><br><span class="line">db.COLLECTION_NAME.remove(DELETION_CRITERIA,<span class="number">1</span>) <span class="comment">//remove one</span></span><br><span class="line">db.mycol.remove(&#123;&#125;)  <span class="comment">//remove all</span></span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.mycol.remove(&#123;'title':'MongoDB Overview'&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h2><p>In the MongoDB, projection means selecting only the necessary data rather than selecting whole of the data of a document.</p>
<p>MongoDB’s find method accept second optional parameter that is list of fields that you want to retrieve. In MongoDB, we can set a list of fields with value 1 or 0, 1 is used to show the fields</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find(&#123;&#125;,&#123;KEY: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Limiting"><a href="#Limiting" class="headerlink" title="Limiting"></a>Limiting</h2><p><strong>limit</strong> method accept one number type argument, which is the number of documents that you want to display</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>

<p><strong>skip</strong> method can accept number type argument and is used to skip the number of documents</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>

<p>example: following example will display only the second document</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mycol.find(&#123;&#125;, &#123;&quot;title&quot;: 1, _id: 0&#125;).limit(1).skip(1)</span><br></pre></td></tr></table></figure>

<h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><p><strong>sort</strong> method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.(default ascending order)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().sort(&#123;KEY:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.mycol.find(&#123;&#125;,&#123;<span class="string">"title"</span>:<span class="number">1</span>,_id:<span class="number">0</span>&#125;).sort(&#123;<span class="string">"title"</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><p>indexing support the efficient resolution of queries. Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement.</p>
<p>Indexes are special data structures, that store a small portion of data set in an easy-to-traverse form. The index stores the value of a specific field or set of fields, ordered by the value of the field as specified in the index.</p>
<p>Syntax:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.ensureIndex(&#123;KEY: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>key is the name of the field on which you want to create index and 1 is for ascending order</p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mycol.ensureIndex(&#123;&quot;title&quot;:1&#125;)</span><br></pre></td></tr></table></figure>

<p>we can also specify multiple fields:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mycol.ensureIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Parameter</th>
<th align="center">Type</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">background</td>
<td align="center">Boolean</td>
<td align="center">Builds the index in the background so that building an index does not block other database activities. Specify true to build in the background. The default value is <strong>false</strong>.</td>
</tr>
<tr>
<td align="center">unique</td>
<td align="center">Boolean</td>
<td align="center">Creates a unique index so that the collection will not accept insertion of documents where the index key or keys match an existing value in the index. Specify true to create a unique index. The default value is <strong>false</strong>.</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">string</td>
<td align="center">The name of the index. If unspecified, MongoDB generates an index name by concatenating the names of the indexed fields and the sort order.</td>
</tr>
<tr>
<td align="center">dropDups</td>
<td align="center">Boolean</td>
<td align="center">Creates a unique index on a field that may have duplicates. MongoDB indexes only the first occurrence of a key and removes all documents from the collection that contain subsequent occurrences of that key. Specify true to create unique index. The default value is <strong>false</strong>.</td>
</tr>
<tr>
<td align="center">sparse</td>
<td align="center">Boolean</td>
<td align="center">If true, the index only references documents with the specified field. These indexes use less space but behave differently in some situations (particularly sorts). The default value is <strong>false</strong>.</td>
</tr>
<tr>
<td align="center">expireAfterSeconds</td>
<td align="center">integer</td>
<td align="center">Specifies a value, in seconds, as a TTL to control how long MongoDB retains documents in this collection.</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">index version</td>
<td align="center">The index version number. The default index version depends on the version of MongoDB running when creating the index.</td>
</tr>
<tr>
<td align="center">weights</td>
<td align="center">document</td>
<td align="center">The weight is a number ranging from 1 to 99,999 and denotes the significance of the field relative to the other indexed fields in terms of the score.</td>
</tr>
<tr>
<td align="center">default_language</td>
<td align="center">string</td>
<td align="center">For a text index, the language that determines the list of stop words and the rules for the stemmer and tokenizer. The default value is <strong>english</strong>.</td>
</tr>
<tr>
<td align="center">language_override</td>
<td align="center">string</td>
<td align="center">For a text index, specify the name of the field in the document that contains, the language to override the default language. The default value is language.</td>
</tr>
</tbody></table>
<h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><p>Aggregate operations process data records and return computed results. Aggregate operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. In SQL count(*) and with group by is an equivalent of mongodb aggregation</p>
<p>Syntax</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.aggreagate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<p>if we have the following data</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: 'MongoDB Overview', </span><br><span class="line">   description: 'MongoDB is no sql database',</span><br><span class="line">   by_user: 'tutorials point',</span><br><span class="line">   url: 'http://www.tutorialspoint.com',</span><br><span class="line">   keywords: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902d)</span><br><span class="line">   title: 'NoSQL Overview', </span><br><span class="line">   description: 'No sql database is very fast',</span><br><span class="line">   by_user: 'tutorials point',</span><br><span class="line">   url: 'http://www.tutorialspoint.com',</span><br><span class="line">   keywords: ['mongodb', 'database', 'NoSQL'],</span><br><span class="line">   likes: 10</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902e)</span><br><span class="line">   title: 'Neo4j Overview', </span><br><span class="line">   description: 'Neo4j is no sql database',</span><br><span class="line">   by_user: 'Neo4j',</span><br><span class="line">   url: 'http://www.neo4j.com',</span><br><span class="line">   keywords: ['neo4j', 'database', 'NoSQL'],</span><br><span class="line">   likes: 750</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>if we want to display a list stating how many tutorials are written by each user</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">db.mycol.aggregate([&#123;$group: &#123;_id: '$by_user', num_tutorial: &#123;$sum: 1&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>

<p>is equal to <strong>select by_user, count(*) from mycol group by by_user</strong>.</p>
<p>in the above example, we have grouped documents by fields <strong>by_user</strong> and on each occurrence of by_user previous value of sum is incremented. Following is a list of available aggregation expressions.</p>
<table>
<thead>
<tr>
<th align="center">Expression</th>
<th align="center">Description</th>
<th align="center">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$sum</td>
<td align="center">Sums up the defined value from all documents in the collection.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>
</tr>
<tr>
<td align="center">$avg</td>
<td align="center">Calculates the average of all given values from all documents in the collection.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>
</tr>
<tr>
<td align="center">$min</td>
<td align="center">Gets the minimum of the corresponding values from all documents in the collection.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>
</tr>
<tr>
<td align="center">$max</td>
<td align="center">Gets the maximum of the corresponding values from all documents in the collection.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>
</tr>
<tr>
<td align="center">$push</td>
<td align="center">Inserts the value to an array in the resulting document.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>
</tr>
<tr>
<td align="center">$addToSet</td>
<td align="center">Inserts the value to an array in the resulting document but does not create duplicates.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>
</tr>
<tr>
<td align="center">$first</td>
<td align="center">Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>
</tr>
<tr>
<td align="center">$last</td>
<td align="center">Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.</td>
<td align="center">db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>
</tr>
</tbody></table>
<h3 id="Pipeline-Concept"><a href="#Pipeline-Concept" class="headerlink" title="Pipeline Concept"></a>Pipeline Concept</h3><p>In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.</p>
<p>Following are the possible stages in aggregation framework −</p>
<ul>
<li><strong>$project</strong> − Used to select some specific fields from a collection.</li>
<li><strong>$match</strong> − This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.</li>
<li><strong>$group</strong> − This does the actual aggregation as discussed above.</li>
<li><strong>$sort</strong> − Sorts the documents.</li>
<li><strong>$skip</strong> − With this, it is possible to skip forward in the list of documents for a given amount of documents.</li>
<li><strong>$limit</strong> − This limits the amount of documents to look at, by the given number starting from the current positions.</li>
<li><strong>$unwind</strong> − This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.</li>
</ul>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>Replication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.</p>
<p>MongoDB achieves replication by the use of replica set. A replica set is a group of <strong>mongod</strong> instances that host the same data set. In a replica, one node is primary node that receives all write operations. All other instances, such as secondaries, apply operations from the primary so that they have the same data set. Replica set can have only one primary node.</p>
<ul>
<li>Replica set is a group of two or more nodes (generally minimum 3 nodes are required).</li>
<li>In a replica set, one node is primary node and remaining nodes are secondary.</li>
<li>All data replicates from primary to secondary node.</li>
<li>At the time of automatic failover or maintenance, election establishes for primary and a new primary node is elected.</li>
<li>After the recovery of failed node, it again join the replica set and works as a secondary node.</li>
</ul>
<h3 id="Set-Up-a-Replica-Set"><a href="#Set-Up-a-Replica-Set" class="headerlink" title="Set Up a Replica Set"></a>Set Up a Replica Set</h3><p>In this tutorial, we will convert standalone MongoDB instance to a replica set. To convert to replica set, following are the steps −</p>
<ul>
<li>Shutdown already running MongoDB server.</li>
<li></li>
<li>Start the MongoDB server by specifying – replSet option. Following is the basic syntax of –replSet −</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --port &quot;PORT&quot; --dbpath &quot;YOUR_DB_DATA_PATH&quot; --replSet &quot;REPLICA_SET_INSTANCE_NAME&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --port 27017 --dbpath &quot;D:\set up\mongodb\data&quot; --replSet rs0</span><br></pre></td></tr></table></figure>

<ul>
<li>It will start a mongod instance with the name rs0, on port 27017.</li>
<li>Now start the command prompt and connect to this mongod instance.</li>
<li>In Mongo client, issue the command <strong>rs.initiate()</strong> to initiate a new replica set.</li>
<li>To check the replica set configuration, issue the command <strong>rs.conf()</strong>. To check the status of replica set issue the command <strong>rs.status()</strong>.</li>
</ul>
<h3 id="Add-Members-to-Replica-Set"><a href="#Add-Members-to-Replica-Set" class="headerlink" title="Add Members to Replica Set"></a>Add Members to Replica Set</h3><p>To add members to replica set, start mongod instances on multiple machines. Now start a mongo client and issue a command <strong>rs.add()</strong>.</p>
<h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><p>The basic syntax of <strong>rs.add()</strong> command is as follows −</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;rs.add(HOST_NAME:PORT)</span><br></pre></td></tr></table></figure>

<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>Suppose your mongod instance name is <strong>mongod1.net</strong> and it is running on port <strong>27017</strong>. To add this instance to replica set, issue the command <strong>rs.add()</strong> in Mongo client.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;rs.add(&quot;mongod1.net:27017&quot;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>You can add mongod instance to replica set only when you are connected to primary node. To check whether you are connected to primary or not, issue the command <strong>db.isMaster()</strong> in mongo client.</p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>单调栈的思想与应用</title>
    <url>/2021/03/06/monotonous-stack/</url>
    <content><![CDATA[<p>今天的每日一题涉及到了单调栈的使用，这里就大概总结下它的思路和应用。</p>
<p>首先这是今天每日一题的链接：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组nums 中对应的值是单调不升的。</p>
<p>每次我们移动到数组中的一个新的位置 ii，我们就将当前单调栈中所有对应值小于nums[i] 的下标弹出单调栈，<strong>这些值的下一个更大元素即为nums[i]（证明很简单：如果有更靠前的更大元素，那么这些位置将被提前弹出栈）</strong>。随后我们将位置 ii 入栈。</p>
<p>但是注意到只遍历一次序列是不够的，例如序列 [2,3,1]，最后单调栈中将剩余 [3,1]，其中元素 [1] 的下一个更大元素还是不知道的。</p>
<p>一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 n-1n−1 个元素拼接在原序列的后面。这样我们就可以将这个新序列当作普通序列，用上文的方法来处理。</p>
<p>而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。</p>
<h2 id="单调栈的定义"><a href="#单调栈的定义" class="headerlink" title="单调栈的定义"></a>单调栈的定义</h2><p>单调栈的定义：<strong>单调栈即满足单调性的栈结构。</strong>与单调队列相比，其只在一端进行进出</p>
<h2 id="代码及解析"><a href="#代码及解析" class="headerlink" title="代码及解析"></a>代码及解析</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nextGreaterElements = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">const</span> stk = [];<span class="comment">//单调栈，用于保存数组下标，从栈底到栈顶对应的nums中的数据单调不升</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//这个while循环像一个筛子，不断从栈顶拿出数据，如果小于当前下标（i）对应的的数据，就从栈中弹出来，并且弹出来的下标对应的后面的最大值就是i对应的数据</span></span><br><span class="line">        <span class="keyword">while</span> (stk.length &amp;&amp; nums[stk[stk.length - <span class="number">1</span>]] &lt; nums[i % n]) &#123;</span><br><span class="line">            ret[stk[stk.length - <span class="number">1</span>]] = nums[i % n];</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的筛子，已经可以保证栈中所有下标对应的数据没有比i对应的数据更小的</span></span><br><span class="line">        stk.push(i % n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给大家举个例子解释下整个算法的工作流程：</p>
<p>假设我们的数组是[1,2,5,4,3]</p>
<table>
<thead>
<tr>
<th>当前下标</th>
<th>stk before while</th>
<th>ret before while</th>
<th>stk after while</th>
<th>ret after while</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>[]</td>
<td>[-1, -1, -1, -1, -1]</td>
<td>[]</td>
<td>[-1, -1, -1, -1, -1]</td>
</tr>
<tr>
<td>0</td>
<td>[]</td>
<td>[-1, -1, -1, -1, -1]</td>
<td>[0]</td>
<td>[-1, -1, -1, -1, -1]</td>
</tr>
<tr>
<td>1</td>
<td>[0]</td>
<td>[-1, -1, -1, -1, -1]</td>
<td>[1]</td>
<td>[2, -1, -1, -1, -1]</td>
</tr>
<tr>
<td>2</td>
<td>[1]</td>
<td>[2, -1, -1, -1, -1]</td>
<td>[2]</td>
<td>[2, 5, -1, -1, -1]</td>
</tr>
<tr>
<td>3</td>
<td>[2]</td>
<td>[2, 5, -1, -1, -1]</td>
<td>[2, 3]</td>
<td>[2, 5, -1, -1, -1]</td>
</tr>
<tr>
<td>4</td>
<td>[2,3]</td>
<td>[2, 5, -1, -1, -1]</td>
<td>[2,3,4]</td>
<td>[2, 5, -1, -1, -1]</td>
</tr>
<tr>
<td>5 =&gt; 0</td>
<td>[2,3,4]</td>
<td>[2, 5, -1, -1, -1]</td>
<td>[2,3,4,0]</td>
<td>[2, 5, -1, -1, -1]</td>
</tr>
<tr>
<td>6 =&gt; 1</td>
<td>[2,3,4,0]</td>
<td>[2, 5, -1, -1, -1]</td>
<td>[2,3,4,1]</td>
<td>[2, 5, -1, -1, -1]</td>
</tr>
<tr>
<td>7 =&gt; 2</td>
<td>[2,3,4,1]</td>
<td>[2, 5, -1, -1, -1]</td>
<td>[2]</td>
<td>[2, 5, -1, 5, 5]</td>
</tr>
<tr>
<td>8 =&gt; 3</td>
<td>[2]</td>
<td>[2, 5, -1, 5, 5]</td>
<td>[2,3]</td>
<td>[2, 5, -1, 5, 5]</td>
</tr>
</tbody></table>
<p>这几步中最关键的是看懂 7 =&gt; 2这一步，进入while循环之后，我们依次拿出1,4,3，这几个下标对应的数据分别是2,3,4，都比当前2对应的下标5小，所以依次更新ret中的数据。</p>
<p>还有一点大家可能会有疑惑，就是为什么要到2 * n - 1；</p>
<p>其实举个例子就明白，对于下标为4的数据，其实我们要遍历 4,0,1,2,3的下标才可以、</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>多源广度优先搜索</title>
    <url>/2020/03/29/multisource-bfs/</url>
    <content><![CDATA[<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>通过一道题目<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" rel="external nofollow noopener noreferrer" target="_blank">地图分析</a>，来讲解和实践BFS。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>考虑最朴素的方法，即求出每一个海洋区域（grid[i][j] == 0 的区域）的「最近陆地区域」，然后记录下它们的距离，然后在这些距离里面取一个最大值。</p>
<a id="more"></a>

<p>对于一个给定的区域 (x, y)(x,y) ，求它的「最近陆地区域」，可以使用宽度优先搜索思想。我们把每个区域的坐标作以及这个区域与 (x, y)(x,y) 的曼哈顿距离为搜索状态，即 Coordinate 结构体的 x、y 和 step 属性。findNearestLand 方法实现了宽度优先搜索的过程，我们用一个 vis[u][v] 数组记录 (u, v)(u,v) 区域是否被访问过，在拓展新状态的时候按照如下四个方向：</p>
<p>(x - 1, y)(x−1,y)<br>(x, y + 1)(x,y+1)<br>(x + 1, y)(x+1,y)<br>(x, y - 1)(x,y−1)<br>在这里我们可以把四个方向定义为常量增量数组 dx 和 dy。</p>
<p>思考：我们需不需要搜索到队列为空才停止 BFS ？ 答案是不需要。当我们搜索到一个新入队的区域它的 grid 值为 1，即这个区域是陆地区域的时候我们就可以停止搜索，因为 BFS 能保证当前的这个区域是最近的陆地区域（BFS 的性质决定了这里求出来的一定是最短路）。</p>
<p>findNearestLand如果我们找不不到任何一个点是陆地区域则返回 -1。最终我们把 ans 的初始值置为 -1，然后与所有的 BFS 结果取最大。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>代码实现如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dx = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>];</span><br><span class="line"><span class="keyword">let</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findNearestLand = <span class="function">(<span class="params">x, y, grid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vis = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> q = [];</span><br><span class="line">    q.push(&#123;x, y, <span class="attr">step</span>: <span class="number">0</span>&#125;);</span><br><span class="line">    vis[<span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> f = q.shift();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;= n <span class="number">-1</span> &amp;&amp;  ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt;= m - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[<span class="string">`<span class="subst">$&#123;nx&#125;</span><span class="subst">$&#123;ny&#125;</span>`</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push(&#123; <span class="attr">x</span>: nx, <span class="attr">y</span>: ny, <span class="attr">step</span>: f.step + <span class="number">1</span> &#125;);</span><br><span class="line">                vis[<span class="string">`<span class="subst">$&#123;nx&#125;</span><span class="subst">$&#123;ny&#125;</span>`</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxDistance = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    n = grid.length;</span><br><span class="line">    m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!grid[i][j]) &#123;</span><br><span class="line">                ans = <span class="built_in">Math</span>.max(ans, findNearestLand(i, j, grid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码的核心就是遍历每一个海洋节点，计算离它最近的陆地节点的距离，这个计算过程使用的就是BFS，如果搜索完成还找不到就返回-1。</p>
<h2 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>所谓的多源bfs，其实就是在bfs的基础上创建一个虚拟的超级源点，这个源点连接向你想要作为多源源点的所有节点，这样一开始的时候按照单源思路，我们应该将超级源点加入队列，然后超级源点出队的时候，所有的实际源点进入队列，这个效果与一开始就将所有源点加入队列效果是相同的。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>题目：<a href="https://leetcode-cn.com/problems/01-matrix/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/01-matrix/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> updateMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dx = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">const</span> [m, n] = [matrix.length, matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">let</span> dist = [], seen = [];</span><br><span class="line">    <span class="keyword">let</span> q = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dist[i] = [];</span><br><span class="line">        seen[i] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dist[i][j] = seen[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                q.push([i, j]);</span><br><span class="line">                seen[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [i, j] = q.shift();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nx = i + dx[k], ny = j + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !seen[nx][ny]) &#123;</span><br><span class="line">                dist[nx][ny] = dist[i][j] + <span class="number">1</span>;</span><br><span class="line">                q.push([nx, ny]);</span><br><span class="line">                seen[nx][ny] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>NAT与内网穿透</title>
    <url>/2019/12/20/nat-and-ddns/</url>
    <content><![CDATA[<p>在IPv4地址不够用的时候，我们需要使用NAT技术来让我们减少对公网IP的消耗，这样在在互联网上一个个的局域网可以消耗一个公网IP，但是随之而来的就是局域网中的设备的IP地址是内网IP地址，对于公网而言是没有意义的。</p>
<p>那么我们如果在自己的机器上开发了一个应用希望其他人可以访问到我们需要怎么做呢？</p>
<a id="more"></a>

<p>如果我们有一个静态的公网IP，那很简单，只需要做一下端口映射就可以了，将公网的IP+端口映射到我们内网的IP+端口，不过这种一般需要我们的路由器可以设置端口映射并具有公网的IP。</p>
<p>如果我们具有的是动态的公网IP，则我们需要在端口映射的基础上加上DDNS（动态域名解析），就是首先获取一个域名，并且内网的机器每隔一段时间对DDNS服务器发送请求，将自身内网IP与域名的映射关系不断刷新到DDNS服务器中。</p>
<p>如果你的机器隐藏在多重路由器之下或者NAT类型为NAPT，那么就需要内网穿透技术了。</p>
<h2 id="NAT是什么"><a href="#NAT是什么" class="headerlink" title="NAT是什么"></a>NAT是什么</h2><h3 id="为什么需要NAT？"><a href="#为什么需要NAT？" class="headerlink" title="为什么需要NAT？"></a>为什么需要NAT？</h3><p>因为IPv4地址不够用，我们可以使用NAT去将局域网中的内部IP地址映射为公网的IP地址</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>NAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。那么，什么是内部网络IP地址？</p>
<p>RFC1918规定了三个保留地址段落：10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255。这三个范围分别处于A,B,C类的地址段，不向特定的用户分配，被IANA作为私有地址保留。这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向IANA提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p>
<p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p>
<h3 id="NAT原理"><a href="#NAT原理" class="headerlink" title="NAT原理"></a>NAT原理</h3><ol>
<li>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关； </li>
<li><strong>网络访问只能先由私网侧发起，公网无法主动访问私网主机；</strong> </li>
<li>NAT网关在两个访问方向上完成两次地址的转换或翻译，出方向做源信息替换，入方向做目的信息替换； </li>
<li>NAT网关的存在对通信双方是保持透明的；</li>
<li>NAT网关为了实现双向翻译的功能，需要维护一张关联表，把会话的信息保存下来。</li>
</ol>
<h3 id="三种NAT技术"><a href="#三种NAT技术" class="headerlink" title="三种NAT技术"></a>三种NAT技术</h3><h4 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h4><p>静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用</p>
<h4 id="动态NAT"><a href="#动态NAT" class="headerlink" title="动态NAT"></a>动态NAT</h4><p>动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。</p>
<h4 id="NPAT"><a href="#NPAT" class="headerlink" title="NPAT"></a>NPAT</h4><p>这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。</p>
<h2 id="内网穿透技术"><a href="#内网穿透技术" class="headerlink" title="内网穿透技术"></a>内网穿透技术</h2><h3 id="NAT的弊端"><a href="#NAT的弊端" class="headerlink" title="NAT的弊端"></a>NAT的弊端</h3><h4 id="NAT使IP会话的保持时效变短"><a href="#NAT使IP会话的保持时效变短" class="headerlink" title="NAT使IP会话的保持时效变短"></a>NAT使IP会话的保持时效变短</h4><p>因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT网关会进行老化操作。这是任何一个NAT网关必须做的事情，因为IP和端口资源有限，通信的需求无限，所以必须在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。通过定时器老化回收会带来一个问题，如果应用需要维持连接的时间大于NAT网关的设置，通信就会意外中断。因为网关回收相关转换表资源以后，新的数据到达时就找不到相关的转换信息，必须建立新的连接。当这个新数据是由公网侧向私网侧发送时，就会发生无法触发新连接建立，也不能通知到私网侧的主机去重建连接的情况。这时候通信就会中断，不能自动恢复。即使新数据是从私网侧发向公网侧，因为重建的会话表往往使用不同于之前的公网IP和端口地址，公网侧主机也无法对应到之前的通信上，导致用户可感知的连接中断。NAT网关要把回收空闲连接的时间设置到不发生持续的资源流失，又维持大部分连接不被意外中断，是一件比较有难度的事情。在NAT已经普及化的时代，很多应用协议的设计者已经考虑到了这种情况，所以一般会设置一个连接保活的机制，即在一段时间没有数据需要发送时，主动发送一个NAT能感知到而又没有实际数据的保活消息，这么做的主要目的就是重置NAT的会话定时器。</p>
<h4 id="依赖IP进行主机跟踪的机制失效"><a href="#依赖IP进行主机跟踪的机制失效" class="headerlink" title="依赖IP进行主机跟踪的机制失效"></a>依赖IP进行主机跟踪的机制失效</h4><p>NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了。如网络管理中需要的基于网络流量分析的应用无法跟踪到终端用户与流量的具体行为的关系。基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。即便有一些机制提供了在NAT网关上进行连接跟踪的方法，但是把这种变换关系接续起来也困难重重。基于IP的用户授权不再可靠，因为拥有一个IP的不等于一个用户或主机。一个服务器也不能简单把同一IP的访问视作同一主机发起的，不能进行关联。有些服务器设置有连接限制，同一时刻只接纳来自一个IP的有限访问(有时是仅一个访问)，这会造成不同用户之间的服务抢占和排队。有时服务器端这样做是出于DOS攻击防护的考虑，因为一个用户正常情况下不应该建立大量的连接请求，过度使用服务资源被理解为攻击行为。但是这在NAT存在时不能简单按照连接数判断。总之，因为NAT隐蔽了通信的一端，把简单的事情复杂化了。</p>
<h4 id="对IP端到端模型的破坏"><a href="#对IP端到端模型的破坏" class="headerlink" title="对IP端到端模型的破坏"></a>对IP端到端模型的破坏</h4><p>NAT通过修改IP首部的信息变换通信的地址。但是在这个转换过程中只能基于一个会话单位。当一个应用需要保持多个双向连接时，麻烦就很大。NAT不能理解多个会话之间的关联性，无法保证转换符合应用需要的规则。当NAT网关拥有多个公有IP地址时，一组关联会话可能被分配到不同的公网地址，这通常是服务器端无法接受的。更为严重的是，当公网侧的主机要主动向私网侧发送数据时，NAT网关没有转换这个连接需要的关联表，这个数据包无法到达私网侧的主机。这些反方向发送数据的连接总有应用协议的约定或在初始建立的会话中进行过协商。但是因为NAT工作在网络层和传输层，无法理解应用层协议的行为，对这些信息是无知的。</p>
<p>NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作。因为NAT篡改了IP地址、传输层端口号和校验和，这会导致认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。对于一些隧道协议，NAT的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过NAT的隧道会有IP复用关系，在另一端需要小心处理。ICMP是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP也要进行复用和解复用处理，很多情况下因为ICMP报文载荷无法提供足够的信息，解复用会失败。IP分片机制是在信息源端或网络路径上，需要发送的IP报文尺寸大于路径实际能承载最大尺寸时，IP协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。</p>
<h3 id="内网穿透的原理"><a href="#内网穿透的原理" class="headerlink" title="内网穿透的原理"></a>内网穿透的原理</h3><p>内网穿透，又叫NAT（Network Address Translation）穿透。对于在NAT之后的节点来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在NAT之后的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。</p>
<p>同样该技术除了可以访问隐藏在NAT之后的节点，同样可以穿透防火墙。由于防火墙只拦截了入站没有拦截出站，所以可以让防火墙内的服务器主动连接到一个公网服务器打通隧道，并通过该隧道最终链接到本地的其他端口。</p>
<ul>
<li><p>Step 1：打通隧道<br>出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。因此，位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的，所以我们首先需要打通隧道。假设公网IP为X.X.X.X，内网IP为192.168.1.2。公网主机先监听80端口，监听这个端口是用于向外部提供一个HTTP服务，80是WEB服务器的默认端口。同时其他任意一个端口（这里我们假设为7777），监听这个端口是用于让内网服务器主动连接进来打通一个隧道。接着内网再主动向公网主机的7777发起一个请求，这样内网就成功与公网主机建立了一个连接通道。然后当有任何客户端主动连接公网的80端口时，公网接收到连接请求之后马上把这连接请求通过先前建立好的隧道转发到内网主机。</p>
</li>
<li><p>Step 2：端口转发（公网主机80端口 转发至 内网80端口）<br>当有任何客户端主动连接公网的80端口时，公网接收到连接请求之后马上把这连接请求通过先前建立好的隧道转发到内网主机，内网主机接收到来自隧道的数据包后再主动连接内网主机自身的80端口，连接成功之后将数据包原封不动地转发数据包给80端口。</p>
</li>
<li><p>Step 3：原路转发响应报文<br>内网主机接收到来自隧道的数据包后再主动连接内网主机自身的80端口，连接成功之后将数据包原封不动地转发数据包给80端口，待HTTP服务器程序处理完这个数据包，生成了响应报文之后再原路转发回去，最终到达公网的80端口，然后返回给最开始请求公网服务器80端口的客户端。</p>
</li>
</ul>
<p>总的来说，内网穿透技术可以适用于所有能够连通公网的机器，提供了一个通用的打通内网的方式。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://gist.github.com/WangYihang/e7d36b744557e4673d2157499f6c6b5e" rel="external nofollow noopener noreferrer" target="_blank">python端口转发</a></p>
<p> 参考文章：</p>
<p><a href="https://www.jianshu.com/p/62028875d53e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/62028875d53e</a></p>
<p><a href="http://www.52im.net/article-64-1.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.52im.net/article-64-1.html</a></p>
<p><a href="https://blog.csdn.net/deng_xj/article/details/88922690" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/deng_xj/article/details/88922690</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>nginx理解与跨域解决方案</title>
    <url>/2019/08/07/nginx_and_cors/</url>
    <content><![CDATA[<p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p>
<a id="more"></a>

<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><h4 id="正向代理："><a href="#正向代理：" class="headerlink" title="正向代理："></a>正向代理：</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1565269970/v2-c8ac111c267ae0745f984e326ef0c47f_hd_xln6m2.jpg" alt="正向代理"><br>就像上图所示，由于防火墙存在的原因，我们无法直接访问谷歌，这个时候我们就可通过VPN来绕过防火墙，在这个过程中，客户端是明白自己的请求需要到达的目的地的，只是这个请求会被VPN去代理，所以服务器其实不知道请求实际来自于哪里，正向代理代理的是客户端。</p>
<h4 id="反向代理："><a href="#反向代理：" class="headerlink" title="反向代理："></a>反向代理：</h4><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1565269973/v2-4787a512240b238ebf928cd0651e1d99_hd_o9ma5f.jpg" alt="反向代理"><br>反向代理代理的则是服务器，对于客户端来说，他并不知道自己的请求最终去了哪里，被哪一台服务器处理，他只是把请求发送给了代理服务器，反向代理服务器将该请求发送给了内网中的另外一台服务器去处理，这个反向代理的过程对于客户端来说是透明的。</p>
<h3 id="Nginx的模块和工作原理"><a href="#Nginx的模块和工作原理" class="headerlink" title="Nginx的模块和工作原理"></a>Nginx的模块和工作原理</h3><p>Nginx由内核和模块组成，其中内核十分简单，仅仅就是通过查找配置文件将客户端请求映射到一个location的block中。</p>
<p>Nginx的模块从结构上分为核心模块，基础模块和第三方模块：<br>核心模块：HTTP模块，EVENT模块，MAIL模块<br>基础模块：HTTP Access模块，HTTP FastCGI模块，HTTP Proxy模块和HTTP Rewrite模块<br>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。</p>
<p>Nginx的模块从功能上分为如下三类。<br>Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。<br>Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。<br>Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。<br><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1565269988/20130515152325076_jd3uk5.png" alt="nginx"></p>
<p>所以其实nginx的本身只是将请求根据配置文件映射到不同的location中去处理，再将处理结果返回。</p>
<h3 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h3><p>nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。<br>但是如果存在多个worker，当一个请求进来时，所有的worker进程都可以监听到该请求，如何选择一个进程去处理该请求呢？<br>针对这种情况，nginx提供了互斥锁，只有拿到了这把锁才可以去接受请求</p>
<h3 id="热部署原理"><a href="#热部署原理" class="headerlink" title="热部署原理"></a>热部署原理</h3><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">events   &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">http        &#123;</span><br><span class="line">  ....</span><br><span class="line">  upstream myproject &#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">  server  &#123;</span><br><span class="line">    ....</span><br><span class="line">    location &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  server  &#123;</span><br><span class="line">    ....</span><br><span class="line">    location &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx的配置文件主要分为六个部分，分别为全局配置（main），nginx工作模式（events），http设置（http），主机设置（server），URL匹配（location），负载均衡服务器设置（upstream）</p>
<p>我们经常使用到的是http，server和location</p>
<h4 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  /usr/local/var/log/nginx/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line">    keepalive_timeout  10;</span><br><span class="line">    #gzip  on;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>include：用于设定文件的mime类型，类型在配置文件目录下的mime.type中定义，来告诉nginx识别文件的类型<br>default_type：设定了默认类型为二进制<br>log_format：设置日志的格式和记录哪些参数<br>access_log 用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。<br>sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。<br>keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p>
<h4 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost 192.168.12.10 www.yangyi.com;</span><br><span class="line">        # 全局定义，如果都是这一个目录，这样定义最简单。</span><br><span class="line">        root   /Users/yangyi/www;</span><br><span class="line">        index  index.php index.html index.htm; </span><br><span class="line">        charset utf-8;</span><br><span class="line">        access_log  usr/local/var/log/host.access.log  main;</span><br><span class="line">        aerror_log  usr/local/var/log/host.error.log  error;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server标志定义虚拟主机开始。<br>listen用于指定虚拟主机的服务端口。<br>server_name用来指定IP地址或者域名，多个域名之间用空格分开。<br>root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。<br>index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。<br>charset用于设置网页的默认编码格式。<br>access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p>
<h4 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   /Users/yangyi/www;</span><br><span class="line">            index  index.php index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>location /表示匹配访问根目录。<br>root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。<br>index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p>
<h4 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h4><p>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream iyangyi.com&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.12.1:80;</span><br><span class="line">    server 192.168.12.2:80 down;</span><br><span class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</span><br><span class="line">    server 192.168.12.4:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p>
<p>Nginx的负载均衡模块目前支持4种调度算法:</p>
<ol>
<li>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li>url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li>
</ol>
<h3 id="Nginx解决跨域问题"><a href="#Nginx解决跨域问题" class="headerlink" title="Nginx解决跨域问题"></a>Nginx解决跨域问题</h3><p>调试页面是：<a href="http://192.168.1.2:8080/" rel="external nofollow noopener noreferrer" target="_blank">http://192.168.1.2:8080/</a></p>
<p>请求的接口是：<a href="http://sun668.vip/api/get/info" rel="external nofollow noopener noreferrer" target="_blank">http://sun668.vip/api/get/info</a></p>
<p>步骤一：</p>
<p>请求的接口是：<a href="http://192.168.1.2/api/get/info" rel="external nofollow noopener noreferrer" target="_blank">http://192.168.1.2/api/get/info</a></p>
<p>PS：这样就解决了跨域问题。</p>
<p>步骤二：</p>
<p>修改nginx.conf文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8088;</span><br><span class="line">  server_name  192.168.1.2;</span><br><span class="line"></span><br><span class="line">  location /&#123;</span><br><span class="line">    proxy_pass http://192.168.1.2:8080;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /api&#123;</span><br><span class="line">    proxy_pass http://sun668.vip/api;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>参考文件：<br><a href="https://www.zybuluo.com/phper/note/89391" rel="external nofollow noopener noreferrer" target="_blank">https://www.zybuluo.com/phper/note/89391</a><br><a href="https://blog.csdn.net/mine_song/article/details/56678736" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/mine_song/article/details/56678736</a><br><a href="https://blog.csdn.net/hguisu/article/details/8930668" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hguisu/article/details/8930668</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Node 并行处理时共享变量需注意</title>
    <url>/2019/09/28/node_pipline_attention/</url>
    <content><![CDATA[<p>这个周在工作的时候遇到了一个奇怪的bug，找了很久，发现是并行计算的时候某个共享的对象变量会被篡改的原因</p>
<a id="more"></a>
<p>先直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'loadsh'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testForObject</span> (<span class="params">obj, change</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`=====berfore: <span class="subst">$&#123;obj.test&#125;</span>=============`</span>);</span><br><span class="line">    obj.test = change;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`=====after: <span class="subst">$&#123;obj.test&#125;</span>=============`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testForCloneObject</span> (<span class="params">obj, change</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cloneObj = _.cloneDeep(obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`=====berfore: <span class="subst">$&#123;cloneObj.test&#125;</span>=============`</span>);</span><br><span class="line">    cloneObj.test = change;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`=====after: <span class="subst">$&#123;cloneObj.test&#125;</span>=============`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> extParams = &#123;</span><br><span class="line">        test: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> indexs = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Promise</span>.map(indexs, (index) =&gt; &#123;</span><br><span class="line">        testForObject(extParams, index);    </span><br><span class="line">    &#125;, &#123;<span class="attr">concurrency</span>: <span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start2 = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> extParams = &#123;</span><br><span class="line">        test: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> indexs = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Promise</span>.map(indexs, (index) =&gt; &#123;</span><br><span class="line">        testForCloneObject(extParams, index);    </span><br><span class="line">    &#125;, &#123;<span class="attr">concurrency</span>: <span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start();</span><br><span class="line"><span class="comment">// =====berfore: 10=============</span></span><br><span class="line"><span class="comment">// =====after: 1=============</span></span><br><span class="line"><span class="comment">// =====berfore: 1=============</span></span><br><span class="line"><span class="comment">// =====after: 2=============</span></span><br><span class="line"></span><br><span class="line">start2();</span><br><span class="line"><span class="comment">// =====berfore: 10=============</span></span><br><span class="line"><span class="comment">// =====after: 1=============</span></span><br><span class="line"><span class="comment">// =====berfore: 10=============</span></span><br><span class="line"><span class="comment">// =====after: 2=============</span></span><br></pre></td></tr></table></figure>

<p>根据结果我们可以看到，如果传入的变量没有经过深复制，不同进程之间对于同一个传入的对象变量的修改会相互影响，这是因为在js中对象变量在传参时传入的是引用，所以如果你对于某个传入的对象参数直接修改，就会导致这种情况。</p>
<p>而且这种情况下，即使你传入的对象参数是const也是没有用的，因为const只是保证了该变量的引用地址是不变的，对于地址中保存的值是没有约束的。</p>
<p>最好的方法就是参数传入之后直接进行深复制。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs 异步IO与事件驱动</title>
    <url>/2020/05/30/nodejs-io-and-event/</url>
    <content><![CDATA[<p><code>nodejs</code>的两大特性，即<code>异步IO</code>和<code>事件驱动</code>。通过对<strong><em>《深入浅出nodejs》\</em></strong>和几篇博客的阅读以后，有了大致的了解，总结一下。</p>
<p><strong>注意本文的内容基于node11以上。</strong></p>
<h2 id="同步与异步，阻塞与非阻塞"><a href="#同步与异步，阻塞与非阻塞" class="headerlink" title="同步与异步，阻塞与非阻塞"></a>同步与异步，阻塞与非阻塞</h2><p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。<br><strong>1.同步与异步</strong><br>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<a id="more"></a>

<p>典型的异步编程模型比如Node.js</p>
<p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<p>\2. 阻塞与非阻塞<br>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，<br>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<h2 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h2><p>在开始之前，先来看几个简单例子，这也是我在使用<code>nodejs</code>时候遇到的几个比较困惑的例子。</p>
<hr>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example1&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;);</span><br><span class="line">/** 运行结果</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 begin</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 end</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 timeout1</span><br><span class="line">Sat, 21 May 2016 08:41:09 GMT example1 timeout2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>question 1</strong></p>
<blockquote>
<p>为何<code>timeout1</code>和<code>timeout2</code>的结果会在<code>end</code>后面？</p>
</blockquote>
<hr>
<h3 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example2&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;);</span><br><span class="line"></span><br><span class="line">while(true);</span><br><span class="line">/**  运行结果</span><br><span class="line">Sat, 21 May 2016 08:45:47 GMT example2 begin</span><br><span class="line">Sat, 21 May 2016 08:45:47 GMT example2 end</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>question 2</strong></p>
<blockquote>
<p>为何<code>timeout1</code>和<code>timeout2</code>没有输出到终端？<code>while(true)</code>到底阻塞了什么？</p>
</blockquote>
<hr>
<h3 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example3&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">    while (true);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;);</span><br><span class="line">/**  运行结果</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 begin</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 end</span><br><span class="line">Sat, 21 May 2016 08:49:12 GMT example3 timeout1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>question 3</strong></p>
<blockquote>
<p>为什么<code>timeout1</code>中回调函数会阻塞<code>timeout2</code>中的回调函数的执行？</p>
</blockquote>
<hr>
<h3 id="example-4"><a href="#example-4" class="headerlink" title="example 4"></a>example 4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example4&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout1&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 模拟计算密集</span><br><span class="line">     */</span><br><span class="line">    for(var i = 0 ; i &lt; 1000000 ; ++i)&#123;</span><br><span class="line">        for(var j = 0 ; j &lt; 100000 ; ++j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;);</span><br><span class="line">/**</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 begin</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 end</span><br><span class="line">Sat, 21 May 2016 08:53:27 GMT example4 timeout1</span><br><span class="line">Sat, 21 May 2016 08:54:09 GMT example4 timeout2  //注意这里的时间晚了好久</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>question 4</strong></p>
<blockquote>
<p>和上面的问题一样，为何<code>timeout1</code>的计算密集型工作将会阻塞<code>timeout2</code>的回调函数的执行？</p>
</blockquote>
<hr>
<h3 id="example-5"><a href="#example-5" class="headerlink" title="example 5"></a>example 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example5&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;package.json&apos;,&apos;utf-8&apos;,function(err,data)&#123;</span><br><span class="line">    if(err)  </span><br><span class="line">        debug(err);</span><br><span class="line">    else</span><br><span class="line">        debug(&quot;get file content&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;);</span><br><span class="line">/** 运行结果</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 begin</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 end</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 timeout2</span><br><span class="line">Sat, 21 May 2016 08:59:14 GMT example5 get file content</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>question 5</strong></p>
<blockquote>
<p>为何读取文件的<code>IO</code>操作不会阻塞<code>timeout2</code>的执行？</p>
</blockquote>
<hr>
<p>接下来我们就带着上面几个疑惑去理解<code>nodejs</code>中的<code>异步IO</code>和<code>事件驱动</code>是如何工作的。</p>
<h2 id="异步IO-asynchronous-I-O"><a href="#异步IO-asynchronous-I-O" class="headerlink" title="异步IO(asynchronous I/O)"></a>异步IO(asynchronous I/O)</h2><p>首先来理解几个容易混淆的概念，<code>阻塞IO(blocking I/O)</code>和<code>非阻塞IO(non-blocking I/O)</code>，<code>同步IO(synchronous I/O)和异步IO(synchronous I/O)</code>。</p>
<p>博主一直天真的以为<code>非阻塞I/O</code>就是<code>异步I/O</code> T_T，<code>apue</code>一直没有读懂。</p>
<h3 id="阻塞I-O-和-非阻塞I-O"><a href="#阻塞I-O-和-非阻塞I-O" class="headerlink" title="阻塞I/O 和 非阻塞I/O"></a>阻塞I/O 和 非阻塞I/O</h3><p>简单来说，<strong>阻塞I/O</strong>就是当用户发一个读取文件描述符的操作的时候，进程就会被阻塞，直到要读取的数据全部准备好返回给用户，这时候进程才会解除<code>block</code>的状态。</p>
<p>那<strong>非阻塞I/O</strong>呢，就与上面的情况相反，用户发起一个读取文件描述符操作的时，函数立即返回，不作任何等待，进程继续执行。但是程序如何知道要读取的数据已经准备好了呢？最简单的方法就是轮询。</p>
<p>除此之外，还有一种叫做<code>IO多路复用</code>的模式，就是用一个阻塞函数同时监听多个文件描述符，当其中有一个文件描述符准备好了，就马上返回，在<code>linux</code>下，<code>select</code>,<code>poll</code>,<code>epoll</code>都提供了<code>IO多路复用</code>的功能。</p>
<h3 id="同步I-O-和-异步I-O"><a href="#同步I-O-和-异步I-O" class="headerlink" title="同步I/O 和 异步I/O"></a>同步I/O 和 异步I/O</h3><p>那么<code>同步I/O</code>和<code>异步I/O</code>又有什么区别么？是不是只要做到<code>非阻塞IO</code>就可以实现<code>异步I/O</code>呢？</p>
<p>其实不然。</p>
<ul>
<li><code>同步I/O(synchronous I/O)</code>做<code>I/O operation</code>的时候会将process阻塞,所以<code>阻塞I/O</code>，<code>非阻塞I/O</code>，<code>IO多路复用I/O</code>都是<code>同步I/O</code>。</li>
<li><code>异步I/O(asynchronous I/O)</code>做<code>I/O opertaion</code>的时候将不会造成任何的阻塞。</li>
</ul>
<p><code>非阻塞I/O</code>都不阻塞了为什么不是<code>异步I/O</code>呢？其实当<code>非阻塞I/O</code>准备好数据以后还是要阻塞住进程去内核拿数据的。所以算不上<code>异步I/O</code>。</p>
<p>这里借一张图(图来自<a href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&utm_medium=shareLink&utm_campaign=socialShare" rel="external nofollow noopener noreferrer" target="_blank">这里</a>)来说明他们之间的区别</p>
<p><img src="https://segmentfault.com/img/remote/1460000005173228" alt></p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p><code>事件驱动(event-driven)</code>是<code>nodejs</code>中的第二大特性。何为<code>事件驱动</code>呢？简单来说，就是通过监听事件的状态变化来做出相应的操作。比如读取一个文件，文件读取完毕，或者文件读取错误，那么就触发对应的状态，然后调用对应的回掉函数来进行处理。</p>
<h3 id="线程驱动和事件驱动"><a href="#线程驱动和事件驱动" class="headerlink" title="线程驱动和事件驱动"></a>线程驱动和事件驱动</h3><p>那么<code>线程驱动</code>编程和<code>事件驱动</code>编程之间的区别是什么呢？</p>
<ul>
<li><code>线程驱动</code>就是当收到一个请求的时候，将会为该请求开一个新的线程来处理请求。一般存在一个线程池，线程池中有空闲的线程，会从线程池中拿取线程来进行处理，如果线程池中没有空闲的线程，新来的请求将会进入队列排队，直到线程池中空闲线程。</li>
<li><code>事件驱动</code>就是当进来一个新的请求的时，请求将会被压入队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。</li>
</ul>
<p>对于<code>事件驱动</code>编程来说，如果某个时间的回调函数是<code>计算密集型</code>，或者是<code>阻塞I/O</code>,那么这个回调函数将会阻塞后面所有事件回调函数的执行。这一点尤为重要。</p>
<h2 id="nodejs的事件驱动和异步I-O"><a href="#nodejs的事件驱动和异步I-O" class="headerlink" title="nodejs的事件驱动和异步I/O"></a>nodejs的事件驱动和异步I/O</h2><h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>上面介绍了那么多的概念，现在我们来看看<code>nodejs</code>中的<code>事件驱动</code>和<code>异步I/O</code>是如何实现的.</p>
<p><code>nodejs</code>是<strong>单线程(single thread)</strong>运行的，通过一个<strong>事件循环(event-loop)</strong>来循环取出<strong>消息队列(event-queue)</strong>中的消息进行处理,处理过程基本上就是去调用该<strong>消息</strong>对应的回调函数。<strong>消息队列</strong>就是当一个事件状态发生变化时，就将一个消息压入队列中。</p>
<p><code>nodejs</code>的时间驱动模型一般要注意下面几个点：</p>
<ul>
<li>因为是<strong>单线程</strong>的，所以当顺序执行<code>js</code>文件中的代码的时候，<strong>事件循环</strong>是被暂停的。</li>
<li>当<code>js</code>文件执行完以后，<strong>事件循环</strong>开始运行，并从<strong>消息队列</strong>中取出消息，开始执行回调函数</li>
<li>因为是<strong>单线程</strong>的，所以当回调函数被执行的时候，<strong>事件循环</strong>是被暂停的</li>
<li>当涉及到I/O操作的时候，<code>nodejs</code>会开一个独立的线程来进行<code>异步I/O</code>操作，操作结束以后将消息压入<strong>消息队列</strong>。</li>
</ul>
<p>下面我们从一个简单的<code>js</code>文件入手，来看看 <code>nodejs</code>是如何执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var debug = require(&apos;debug&apos;)(&apos;example1&apos;);</span><br><span class="line"></span><br><span class="line">debug(&quot;begin&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;package.json&apos;,&apos;utf-8&apos;,function(err,data)&#123;</span><br><span class="line">    if(err)  </span><br><span class="line">        debug(err);</span><br><span class="line">    else</span><br><span class="line">        debug(&quot;get file content&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    debug(&quot;timeout2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">debug(&apos;end&apos;); // 运行到这里之前，事件循环是暂停的</span><br></pre></td></tr></table></figure>

<ol>
<li>同步执行<code>debug(&quot;begin&quot;)</code></li>
<li>异步调用<code>fs.readFile()</code>，此时会开一个新的线程去进行<code>异步I/O</code>操作</li>
<li>异步调用<code>setTimeout()</code>，马上将超时信息压入到<strong>消息队列</strong>中</li>
<li>同步调用<code>debug(&quot;end&quot;)</code></li>
<li>开启<strong>事件循环</strong>，弹出<strong>消息队列</strong>中的信息(目前是超时信息)</li>
<li>然后执行信息对应的回调函数(<strong>事件循环</strong>又被暂停)</li>
<li><strong>回调函数</strong>执行结束后，开始<strong>事件循环</strong>(目前<strong>消息队列</strong>中没有任何东西，文件还没读完)</li>
<li><code>异步I/O</code>读取文件完毕，将消息压入<strong>消息队列(</strong>消息中含有文件内容或者是出错信息)</li>
<li><strong>事件循环</strong>取得消息，执行回调</li>
<li>程序退出。</li>
</ol>
<p>这里借一张图来说明<code>nodejs</code>的事件驱动模型（图来自<a href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/" rel="external nofollow noopener noreferrer" target="_blank">这里</a>）<br><img src="https://segmentfault.com/img/remote/1460000006792647" alt></p>
<h3 id="JS的事件循环-eventloop-是怎么运作的？"><a href="#JS的事件循环-eventloop-是怎么运作的？" class="headerlink" title="JS的事件循环(eventloop)是怎么运作的？"></a>JS的事件循环(eventloop)是怎么运作的？</h3><p>“先执行同步操作异步操作排在事件队列里”这样的理解其实也没有任何问题但如果深入的话会引出来很多其他概念，比如event table和event queue，我们来看运行过程：</p>
<ol>
<li>首先判断JS是同步还是异步，同步就进入主线程运行，异步就进入event table。</li>
<li>异步任务在event table中注册事件，当满足触发条件后（触发条件可能是延时也可能是ajax回调），被推入event queue。</li>
<li>同步任务进入主线程后一直执行，直到主线程空闲时，才会去event queue中查看是否有可执行的异步任务，如果有就推入主线程中。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2秒到了'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<p>我们用上面的第二条来分析一下这段脚本，setTimeout是异步操作首先进入event table，注册的事件就是他的回调，触发条件就是2秒之后，当满足条件回调被推入event queue，当主线程空闲时会去event queue里查看是否有可执行的任务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">// 同步任务进入主线程</span></span><br><span class="line">setTimeout(fun(),<span class="number">0</span>)   <span class="comment">// 异步任务，被放入event table， 0秒之后被推入event queue里</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// 同步任务进入主线程</span></span><br></pre></td></tr></table></figure>

<p>1、3是同步任务马上会被执行，执行完成之后主线程空闲去event queue(事件队列)里查看是否有任务在等待执行，这就是为什么setTimeout的延迟时间是0毫秒却在最后执行的原因。</p>
<p>关于setTimeout有一点要注意延时的时间有时候并不是那么准确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2秒到了'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">wait(<span class="number">9999999999</span>)</span><br></pre></td></tr></table></figure>

<p>分析运行过程：</p>
<ol>
<li>console进入Event Table并注册，计时开始。</li>
<li>执行sleep函数，sleep方法虽然是同步任务但sleep方法进行了大量的逻辑运算，耗时超过了2秒。</li>
<li>2秒到了，计时事件timeout完成，console进入Event Queue，但是sleep还没执行完，主线程还被占用，只能等着。</li>
<li>sleep终于执行完了，console终于从Event Queue进入了主线程执行，这个时候已经远远超过了2秒。</li>
</ol>
<p>其实延迟2秒只是表示2秒后，setTimeout里的函数被会推入event queue，而event queue(事件队列)里的任务，只有在主线程空闲时才会执行。上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为console)加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于2秒。 我们还经常遇到setTimeout(fn，0)这样的代码，它的含义是，指定某个任务在主线程最早的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。但是即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p>
<p>关于setInterval： 以setInterval(fn，ms)为例，setInterval是循环执行的，setInterval会每隔指定的时间将注册的函数置入Event Queue，不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。需要注意的一点是，一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。</p>
<p>上面的概念很基础也很容易理解但不幸的消息是上面讲的一切都不是绝对的正确，因为涉及到Promise、async/await、process.nextTick(node)所以要对任务有更精细的定义：</p>
<p>宏任务(macro-task)：包括整体代码script、setTimeout、setInterval、MessageChannel、postMessage、setImmediate。<br> 微任务(micro-task)：Promise、process.nextTick、MutationObsever。</p>
<p>在划分宏任务、微任务的时候并没有提到async/await因为async/await的本质就是Promise。</p>
<p><strong>事件循环机制到底是怎么样的？ *不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同(宏任务)的Event Queue。而Promise和process.nextTick会进入相同(微任务)的Event Queue</strong>。*</p>
<ol>
<li>「宏任务」、「微任务」都是队列，一段代码执行时，会先执行<strong>宏任务中的同步代码</strong>。</li>
<li>进行<strong>第一轮事件循环的时候会把全部的js脚本当成一个宏任务</strong>来运行。</li>
<li>如果执行中遇到setTimeout之类宏任务，那么就把这个setTimeout内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。</li>
<li>如果执行中遇到 promise.then() 之类的微任务，就会推入到「<strong>当前宏任务的微任务队列</strong>」（也就是说这些微任务仍属于当前宏任务）中，在本轮宏任务的同步代码都执行完成后，依次执行所有的微任务。</li>
<li>第一轮事件循环中当执行完全部的同步脚本以及微任务队列中的事件，这一轮事件循环就结束了，开始第二轮事件循环。</li>
<li>第二轮事件循环同理<strong>先执行宏任务中的同步脚本</strong>，遇到其他宏任务代码块继续追加到「宏任务的队列」中，遇到微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行当前所有的微任务。</li>
<li>开始第三轮，循环往复…</li>
</ol>
<p>下面用代码来深入理解上面的机制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>) <span class="comment">// 同步任务</span></span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。</li>
<li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li>
<li>遇到console.log()，立即执行。</li>
<li>整体代码script作为第一个宏任务执行结束。查看当前有没有可执行的微任务，执行then的回调。 （第一轮事件循环结束了，我们开始第二轮循环。）</li>
<li>从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 执行结果：`1 - 2 - 3 - 4</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)<span class="comment">// 宏任务一</span></span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>) <span class="comment">// 宏任务一的微任务</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务二</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务五</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'10'</span>)</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 宏任务七</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务三</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 宏任务四</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务六</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>) <span class="comment">// 宏任务一</span></span><br></pre></td></tr></table></figure>

<ol>
<li>全部的代码作为第一个宏任务进入主线程执行。</li>
<li>首先输出1，是同步代码。then回调作为微任务进入到宏任务一的微任务队列。</li>
<li>下面最外层的三个setTimeout分别是宏任务二、宏任务三、宏任务四按序排入宏任务队列。</li>
<li>输出2，现在宏任务一的同步代码都执行完成了接下来执行宏任务一的微任务输出3。 第一轮事件循环完成了</li>
<li>现在执行宏任务二输出4，后面的setTimeout作为宏任务五排入宏任务队列。</li>
<li>执行宏任务三输出5，执行宏任务四输出6，宏任务四里面的setTimeout作为宏任务六。</li>
<li>执行宏任务五输出7，8。then回调作为宏任务五的微任务排入宏任务五的微任务队列。</li>
<li>输出同步代码9，宏任务五的同步代码执行完了，现在执行宏任务五的微任务。</li>
<li>输出10，后面的setTimeout作为宏任务七排入宏任务的队列。 宏任务五执行完成了。</li>
<li>执行宏任务六输出11，执行宏任务七输出12。</li>
</ol>
<p><em><em>-^-\</em>，这个案例是有点恶心，目的是让大家明白各宏任务之间执行的顺序以及宏任务和微任务的执行关系。</em></p>
<p>我们把主线程（执行队列）中的内容从开始执行到结束叫做一次tick，一旦主线程内容执行完成，就回去宏任务队列头部拿一个加入主线程开始一次新的tick，如果在找个tick期间有其他方法注册了新的微任务或者宏任务本身注册了微任务，则回在本次tick结束之前拿出所有的微任务执行完成。</p>
<ol>
<li><p>在当前tick中添加的微任务都不会留到下一个tick，而是在tick的尾部触发执行</p>
</li>
<li><p>一个事件循环中，在tick里的任务执行完毕以后，会有一个单独的步骤，叫 Perform a microtask checkpoint，即执行微任务检查点。这个操作是检查否有微任务，如果有，便将微任务队列也会当作执行队列来继续执行，完毕后将执行队列置空。</p>
</li>
<li><p>同一个tick产生的微任务总是会在宏任务之前被执行，因为本次tick结束之前注册的微任务会在微任务检查点执行，但是宏任务要等到下一次tick。</p>
<p>（<strong>注意，这里讨论的所有的宏任务和微任务已经是进入event loop中的任务</strong>，也就是异步条件达成后从event table进入event queue的状态）。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)<span class="comment">// 宏任务一</span></span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>) <span class="comment">// 宏任务一的微任务</span></span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务二</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务五</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'10'</span>)</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 宏任务七</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务三</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 宏任务四</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 宏任务六</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>) <span class="comment">// 宏任务一</span></span><br></pre></td></tr></table></figure>

<p>如果进一步在timeout中加入延迟时间，不让他们的回调函数立即进入宏任务队列中，打印顺序又是什么呢？</p>
<p>先给出答案：1，2，3，6，5，4，7，8，9，10，11，12(或者1，2，3，6，5，4，11， 7，8，9，10，12)</p>
<blockquote>
<p>其实完全按照刚才我们讲的逻辑，顺序应该是1，2，3，6，5，4，11， 7，8，9，10，12</p>
<p>为什么会出现两种不同的可能呢？</p>
<p>是因为Chrome中根据 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetTimeout" rel="external nofollow noopener noreferrer" target="_blank">mdn</a> <code>setTimeout()</code>/<code>setInterval()</code> 的每调用一次定时器的最小间隔是4ms，所以被合入了一个宏任务一起执行。宏任务五和六都是嵌套的两个setTimeOut加起来2000ms，先后问题，也有可能被合并了。</p>
</blockquote>
<p>这个例子和上面那个例子的不同之处就在于通过设置了不同的timeout时间，使得回调函数按照不同的顺序被推入宏任务队列。</p>
<h2 id="问题答案"><a href="#问题答案" class="headerlink" title="问题答案"></a>问题答案</h2><p>好，到目前为止，已经可以回答上面的问题了</p>
<hr>
<p><strong>question 1</strong></p>
<blockquote>
<p>为何<code>timeout1</code>和<code>timeout2</code>的结果会在end后面？</p>
</blockquote>
<p><strong>answer 1</strong></p>
<blockquote>
<p>因为此时<code>timeout1</code>和<code>timeout2</code>只是被异步函数推入到了队列中，<strong>事件循环</strong>还是暂停状态</p>
</blockquote>
<hr>
<p><strong>question 2</strong></p>
<blockquote>
<p>为何<code>timeout1</code>和<code>timeout2</code>没有输出到终端？<code>while(true)</code>到底阻塞了什么？</p>
</blockquote>
<p><strong>answer 2</strong></p>
<blockquote>
<p>因为此处直接阻塞了<strong>事件循环</strong>，还没开始，就已经被阻塞了</p>
</blockquote>
<hr>
<p><strong>question 3,4</strong></p>
<blockquote>
<ol>
<li>为什么<code>timeout1</code>中回调函数会阻塞<code>timeout2</code>中的回调函数的执行？</li>
<li>为何<code>timeout1</code>的计算密集型工作将会阻塞<code>timeout2</code>的回调函数的执行？</li>
</ol>
</blockquote>
<p><strong>answer 3,4</strong></p>
<blockquote>
<p>因为该回调函数执行返回<strong>事件循环</strong>才会继续执行，回调函数将会阻塞事件循环的运行</p>
</blockquote>
<hr>
<p><strong>question 5</strong></p>
<blockquote>
<p>为何读取文件的IO操作不会阻塞<code>timeout2</code>的执行？</p>
</blockquote>
<p><strong>answer 5</strong></p>
<blockquote>
<p>因为<code>IO</code>操作是异步的，会开启一个新的线程，不会阻塞到<strong>事件循环</strong></p>
</blockquote>
<p>参考链接：</p>
<p><a href="https://www.zhihu.com/question/19732473" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/19732473</a></p>
<p><a href="https://segmentfault.com/a/1190000005173218" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000005173218</a></p>
<p><a href="https://juejin.im/post/5c148ec8e51d4576e83fd836" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5c148ec8e51d4576e83fd836</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>在Monorepo中开发一个新的npm package过程总结</title>
    <url>/2021/05/15/npm-package-develop/</url>
    <content><![CDATA[<p>这周在工作中需要开发一个npm的package，是辅助其他已有的pacakge。整个仓库采用了monorepo的形式，记录一下整个过程中踩的坑和学到的新技术</p>
<a id="more"></a>

<h1 id="Lerna的使用"><a href="#Lerna的使用" class="headerlink" title="Lerna的使用"></a>Lerna的使用</h1><p>venom仓库采用的是monorepo的方式</p>
<p>monorepo是一种与multirepo不同的代码组织方式，首先，我们解释一下什么是 monorepo 和 multirepo。这两者都是管理组织代码的方式，顾名思义 monorepo 就是把所有的相关项目都放在一个仓库中（比如 React, Angular, Babel, Google…），multirepo 则是按模块分为多个仓库。</p>
<p><a href="https://zhuanlan.zhihu.com/p/31289463" rel="external nofollow noopener noreferrer" target="_blank">Monorepo与MultiRepo</a></p>
<p><a href="https://segmentfault.com/a/1190000019309820" rel="external nofollow noopener noreferrer" target="_blank">Monorepo——大型前端项目的代码管理方式</a></p>
<p>总的来说，monorepo是为了将多个项目放在同一个仓库里面去管理，而lerna是实现monorepo的一种框架或者说途径。</p>
<p>这是它的github地址：<a href="https://github.com/lerna/lerna" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/lerna/lerna</a></p>
<p>首先我们可以通过lerna init命令在一个文件夹下初始化lerna的配置以及文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lerna-repo/</span><br><span class="line">  packages/</span><br><span class="line">  package.json</span><br><span class="line">  lerna.json</span><br></pre></td></tr></table></figure>

<p>lerna.json中的是lerna的配置项（在git的readme中有），package.json中是整个仓库的配置项，而packages下面是一个个的文件夹，每个文件夹都是一个mulitrepo实践下的仓库，也就是我们平时最常见的仓库形式，只不过没有自己的.git</p>
<h2 id="两种模式：Fixed和Independent"><a href="#两种模式：Fixed和Independent" class="headerlink" title="两种模式：Fixed和Independent"></a>两种模式：Fixed和Independent</h2><p>Fixed模式下，整个lerna仓库中所有的仓库的版本都是根目录下package.json中的version字段，也就是说都是同一个，也就是说所有的package要一起升版本，即使你只改动了其中一个。</p>
<p>Independent模式下，根目录下的package.json的version字段变为independent，而每个仓库自己的版本在自己目录下的package.json中</p>
<h2 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h2><p>大部分的devDependencies可以被提取到lerna仓库的根目录依赖中，通过lerna link convert命令</p>
<ul>
<li><p>这样可以减小重复依赖的空间占用</p>
</li>
<li><p>保证每个pacakge使用的是相同版本（如果一开始各个package使用的是不同版本， 提取后好像是使用的最大版本）</p>
</li>
<li><p>减少依赖的安装时间</p>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>lerna init：初始化lerna配置</p>
<p>Lerna bootstrap：安装所有的依赖</p>
<p>Lerna publish：发布新的版本</p>
<p>Lerna exec：执行命令（–scope可以指定在哪个pacakge中执行）</p>
<p>Lerna create：创建新的 package</p>
<p>Lerna link：将当前Lerna存储库中彼此依赖的所有Lerna软件包符号链接在一起（这个目前没有用过，本地调试我使用的是npm link）</p>
<p>其他的可以去参考github仓库</p>
<h1 id="Npm-link的使用（本地调试package）"><a href="#Npm-link的使用（本地调试package）" class="headerlink" title="Npm link的使用（本地调试package）"></a>Npm link的使用（本地调试package）</h1><p>在你要被其他包使用的包的根目录下执行npm link，就会在全局之中建立一个映射，即从global/a -&gt; a</p>
<p>在要使用a的包中调用npm link a（这个a就是a这个包的package.json中name字段指定的），就会建立起b/node_modules/a -&gt; global/a -&gt; a的映射。</p>
<p>这个时候去修改a，会直接在b中更新。</p>
<p><a href="https://docs.npmjs.com/cli/v7/commands/npm-link" rel="external nofollow noopener noreferrer" target="_blank">npm link</a></p>
<h1 id="NPM-Hooks（在安装以后执行脚本）"><a href="#NPM-Hooks（在安装以后执行脚本）" class="headerlink" title="NPM Hooks（在安装以后执行脚本）"></a>NPM Hooks（在安装以后执行脚本）</h1><p>通常情况下，应用程序只能处理来自内部的消息，如果希望对外部发来的消息也能拦截处理，那就需要一种叫钩子(Hook)的技术。想象一下，npm test这个过程你是控制不了的，但如果就非常想在test之前自动处理点什么事儿，怎么办？没次都手动在test之前执行什么，烦不烦、烦不烦、烦不烦？就是不烦，也会忘啊！</p>
<p>这时候就用到我们的Hook了。下面这些指令都是Hook，它们都可以在package.json的scripts属性里定义，并且会在生命周期的某个指定时刻被执行，这就是上面提到的“对外部发来的消息也能拦截处理”，这极大的方便了开发人员(或许你想做点坏事儿？)</p>
<ul>
<li><p>prepublish: 在publish该包之前执行。(在包目录下执行npm install时也会执行)</p>
</li>
<li><p>postpublish: 在该包publish之后执行</p>
</li>
<li><p>preinstall: 在该包被install之前执行</p>
</li>
<li><p>postinstall: 在该包被install之后执行</p>
</li>
<li><p>preuninstall: 在该包被uninstall之前执行</p>
</li>
<li><p>postuninstall: 在该包被uninstall之后执行</p>
</li>
<li><p>preversion: 在修改该包的version之前执行</p>
</li>
<li><p>postversion: 在修改该包的version之后执行</p>
</li>
<li><p>pretest, posttest: 在该包内执行test时执行，其中pretest先于posttest</p>
</li>
<li><p>prestop, poststop: 在该包内执行stop时执行，其中prestop先于poststop</p>
</li>
<li><p>prestart,poststart: 在该包内执行start时执行，其中prestart先于poststart</p>
</li>
<li><p>prerestart, postrestart: 在该包内执行restart脚本时执行，其中prerestart先于postrestart。注意: 如果没有在scripts里显示指定restart脚本，则会自动调用stop，然后再start</p>
</li>
</ul>
<p>上面这些Hooks都是npm预定义好的，也就是说，当你执行npm install时，如果你在scripts里定义了preinstall和postinstall，那它们分别会在npm install之前/后自动执行，不劳你操心！碉堡了，有木有？</p>
<p>还有，任何自定义脚本(通过npm run-script &lt;脚本名&gt;来执行)也可以前缀pre和post为其制作钩子。比如：premyscript，myscript，postmyscript</p>
<p>也就是说，pretest脚本也会在npm test之前运行</p>
<h1 id="Verdccio建立本地仓库（验证hook）"><a href="#Verdccio建立本地仓库（验证hook）" class="headerlink" title="Verdccio建立本地仓库（验证hook）"></a>Verdccio建立本地仓库（验证hook）</h1><p>为了测试postinstall的效果，又不想直接将未完成的包直接上传，就可以在本地创建一个自己私有的仓库，这里我采用的是<a href="https://github.com/verdaccio/verdaccio" rel="external nofollow noopener noreferrer" target="_blank">Verdccio</a></p>
<p>使用起来很简单，可以直接看上面的链接</p>
<p>目前遇到了三个坑：</p>
<ol>
<li>首先一定要新建一个用户才行，不然你没法publish（也可能有别的方法）</li>
<li>如果你publish包以后，想要从中npm install，而你的包依赖的包没有，会报错，这个时候可以去修改配置项，mac是在～/.config/verdaccio/config.yaml中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://npm.org</span><br><span class="line">  yarn:</span><br><span class="line">    url: https://npm.org/</span><br></pre></td></tr></table></figure>

<p>配置上游链接</p>
<ol>
<li>如果想要把已有的一个仓库删了，也很简单，因为全都会存在本地的~/.local/share/verdaccio/storage中。</li>
</ol>
<h1 id="node获取仓库地址"><a href="#node获取仓库地址" class="headerlink" title="node获取仓库地址"></a>node获取仓库地址</h1><p>有个需求是要通过node获取git的仓库地址，一开始是想读取.git/config</p>
<p>后来发现可以用child_process执行命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const gitRemoteUrl = childProcess.execSync(</span><br><span class="line">  &apos;git config --get remote.origin.url&apos;,</span><br><span class="line">);</span><br><span class="line">return gitRemoteUrl ? gitRemoteUrl.toString() : noGitRepositoryUrl;</span><br></pre></td></tr></table></figure>

<h1 id="如何指定打包的文件都有哪些"><a href="#如何指定打包的文件都有哪些" class="headerlink" title="如何指定打包的文件都有哪些"></a>如何指定打包的文件都有哪些</h1><p>由于我的postinstall中执行的脚本是独立的，没有在pacakge.json的main指向的index.js及其依赖中使用到，所以打包publish以后，我的脚本并没有在打包后的目录中，这个时候就需要在package.json的files中指定将我的脚本放进去。</p>
<h2 id="Npm-dependences-version的坑"><a href="#Npm-dependences-version的坑" class="headerlink" title="Npm dependences version的坑"></a>Npm dependences version的坑</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1621046584/origin-of-ray/asynccode_m00jtz.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>passport-azure-ad_无限刷新问题</title>
    <url>/2019/11/22/passport-azure-ad-infine-callback/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>passport-azure-ad 是我们在使用node express作为服务器，passport用于验证登陆，同时又需要去azure第三方认证登陆时需要用到的插件。</p>
<p>但是在使用过程中我们可能会遇到这样一种情况，就是明明我们的所有配置都已经配置好了，但是会遇到无限   回调的情况，具体表现形式就是我们利用微软账号登陆成功之后，页面会不断刷新，最终提示我们无法成功登录。</p>
<p>这个不断刷新的过程其实是， 首先发送一个OAuth登陆流程过程中的认证请求，认证成功之后会回调你事先配置好的redirectURL，这个url一般是我们自己服务器需要处理的请求，在这个请求中你需要用到passport的authenticate去认证是否登陆成功，如果这个认证中遇到id-token为空的情况，就会再次发起请求，一旦认证成功又会调用redirectURL。</p>
<p>在这个过程中，如果你确实在微软那里认证成功了，但是回调自己的服务器请求时又确实没有拿到id-token，就会出现无限回调的情况。</p>
<a id="more"></a>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>一般出现这样的情况都是因为项目中没有加入 bodyparser 插件，倒是无法解析微软认证请求回来的body，就无法获取其中的id-token，所以我们需要加入body-parser。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>假设我们的redirectURL是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:8080/auth/auth/openid/return</span><br></pre></td></tr></table></figure>

<p>它的处理函数是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">passport.authenticate(<span class="string">'azuread-openidconnect'</span>, &#123; <span class="attr">failureRedirect</span>: <span class="string">'/'</span> &#125;),</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    log.info(<span class="string">'Login was called in the Sample'</span>);</span><br><span class="line">    res.redirect(<span class="string">'/'</span>);</span><br></pre></td></tr></table></figure>

<p>那么我们去看一下为什么这个函数什么情况下会再次触发去微软的认证。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Strategy.prototype.authenticate = <span class="function"><span class="keyword">function</span> <span class="title">authenticateStrategy</span>(<span class="params">req, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * We should be careful using 'this'. Avoid the usage like `this.xxx = ...`</span></span><br><span class="line"><span class="comment">   * unless you know what you are doing.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * In the passport source code</span></span><br><span class="line"><span class="comment">   * (https://github.com/jaredhanson/passport/blob/master/lib/middleware/authenticate.js)</span></span><br><span class="line"><span class="comment">   * when it attempts to call the `oidcstrategy.authenticate` function, passport</span></span><br><span class="line"><span class="comment">   * creates an instance inherting oidcstrategy and then calls `instance.authenticate`.</span></span><br><span class="line"><span class="comment">   * Therefore, when we come here, `this` is the instance, its prototype is the</span></span><br><span class="line"><span class="comment">   * actual oidcstrategy, i.e. the `Strategy`. This means:</span></span><br><span class="line"><span class="comment">   * (1) `this._options = `, `this._verify = `, etc only adds new fields to the</span></span><br><span class="line"><span class="comment">   *      instance, it doesn't change the values in oidcstrategy, i.e. `Strategy`.</span></span><br><span class="line"><span class="comment">   * (2) `this._options`, `this._verify`, etc returns the field in the instance,</span></span><br><span class="line"><span class="comment">   *     and if there is none, returns the field in oidcstrategy, i.e. `strategy`.</span></span><br><span class="line"><span class="comment">   * (3) each time we call `authenticate`, we will get a brand new instance</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If you want to change the values in `Strategy`, use</span></span><br><span class="line"><span class="comment">   *      const oidcstrategy = Object.getPrototypeOf(self);</span></span><br><span class="line"><span class="comment">   * to get the strategy first.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note: Simply do `const self = Object.getPrototypeOf(this)` and use `self`</span></span><br><span class="line"><span class="comment">   * won't work, since the `this` instance has a couple of functions like</span></span><br><span class="line"><span class="comment">   * success/fail/error... which `authenticate` will call. The following is the</span></span><br><span class="line"><span class="comment">   * structure of `this`:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   this</span></span><br><span class="line"><span class="comment">   *   | --  success:  function(user, info)</span></span><br><span class="line"><span class="comment">   *   | --  fail:     function(challenge, status)</span></span><br><span class="line"><span class="comment">   *   | --  redirect: function(url, status)</span></span><br><span class="line"><span class="comment">   *   | --  pass:     function()</span></span><br><span class="line"><span class="comment">   *   | --  __proto__:  Strategy</span></span><br><span class="line"><span class="comment">   *                 | --  _verify</span></span><br><span class="line"><span class="comment">   *                 | --  _options</span></span><br><span class="line"><span class="comment">   *                 | --  ...</span></span><br><span class="line"><span class="comment">   *                 | --  __proto__:</span></span><br><span class="line"><span class="comment">   *                              | --  authenticate:  function(req, options)</span></span><br><span class="line"><span class="comment">   *                              | --  ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resource = options &amp;&amp; options.resourceURL;</span><br><span class="line">  <span class="keyword">var</span> customState = options &amp;&amp; options.customState;</span><br><span class="line">  <span class="keyword">var</span> tenantIdOrName = options &amp;&amp; options.tenantIdOrName;</span><br><span class="line">  <span class="keyword">var</span> login_hint = options &amp;&amp; options.login_hint;</span><br><span class="line">  <span class="keyword">var</span> domain_hint = options &amp;&amp; options.domain_hint;</span><br><span class="line">  <span class="keyword">var</span> prompt = options &amp;&amp; options.prompt;</span><br><span class="line">  <span class="keyword">var</span> extraAuthReqQueryParams = options &amp;&amp; options.extraAuthReqQueryParams;</span><br><span class="line">  <span class="keyword">var</span> extraTokenReqQueryParams = options &amp;&amp; options.extraTokenReqQueryParams;</span><br><span class="line">  <span class="keyword">var</span> response = options &amp;&amp; options.response || req.res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'params': items we get from the request or metadata, such as id_token, code, policy, metadata, cacheKey, etc</span></span><br><span class="line">  <span class="keyword">var</span> params = &#123; <span class="string">'tenantIdOrName'</span>: tenantIdOrName, <span class="string">'extraAuthReqQueryParams'</span>: extraAuthReqQueryParams, <span class="string">'extraTokenReqQueryParams'</span>: extraTokenReqQueryParams &#125;;</span><br><span class="line">  <span class="comment">// 'oauthConfig': items needed for oauth flow (like redirection, code redemption), such as token_endpoint, userinfo_endpoint, etc</span></span><br><span class="line">  <span class="keyword">var</span> oauthConfig = &#123; <span class="string">'resource'</span>: resource, <span class="string">'customState'</span>: customState, <span class="string">'domain_hint'</span>: domain_hint, <span class="string">'login_hint'</span>: login_hint, <span class="string">'prompt'</span>: prompt, <span class="string">'response'</span>: response &#125;;</span><br><span class="line">  <span class="comment">// 'optionsToValidate': items we need to validate id_token against, such as issuer, audience, etc</span></span><br><span class="line">  <span class="keyword">var</span> optionsToValidate = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>.waterfall(</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">       * Step 1. Collect information from the req and save the info into params</span></span><br><span class="line"><span class="comment">       ****************************************************************************/</span></span><br><span class="line">      (next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> self.collectInfoFromReq(params, req, next, response);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">       * Step 2. Load metadata, use the information from 'params' and 'self._options'</span></span><br><span class="line"><span class="comment">       * to configure 'oauthConfig' and 'optionsToValidate'</span></span><br><span class="line"><span class="comment">       ****************************************************************************/</span></span><br><span class="line">      (next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> self.setOptions(params, oauthConfig, optionsToValidate, next);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment">       * Step 3. Handle the flows</span></span><br><span class="line"><span class="comment">       *----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">       * (1) implicit flow (response_type = 'id_token')</span></span><br><span class="line"><span class="comment">       *     This case we get a 'id_token'</span></span><br><span class="line"><span class="comment">       * (2) hybrid flow (response_type = 'id_token code')</span></span><br><span class="line"><span class="comment">       *     This case we get both 'id_token' and 'code'</span></span><br><span class="line"><span class="comment">       * (3) authorization code flow (response_type = 'code')</span></span><br><span class="line"><span class="comment">       *     This case we get a 'code', we will use it to get 'access_token' and 'id_token'</span></span><br><span class="line"><span class="comment">       * (4) for any other request, we will ask for authorization and initialize</span></span><br><span class="line"><span class="comment">       *     the authorization process</span></span><br><span class="line"><span class="comment">       ****************************************************************************/</span></span><br><span class="line">      (next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (params.err) &#123;</span><br><span class="line">          <span class="comment">// handle the error</span></span><br><span class="line">          <span class="keyword">return</span> self._errorResponseHandler(params.err, params.err_description, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!params.id_token &amp;&amp; !params.code) &#123;</span><br><span class="line">          <span class="comment">// ask for authorization, initialize the authorization process</span></span><br><span class="line">          <span class="keyword">return</span> self._flowInitializationHandler(oauthConfig, req, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.id_token &amp;&amp; params.code) &#123;</span><br><span class="line">          <span class="comment">// handle hybrid flow</span></span><br><span class="line">          <span class="keyword">return</span> self._hybridFlowHandler(params, oauthConfig, optionsToValidate, req, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.id_token) &#123;</span><br><span class="line">          <span class="comment">// handle implicit flow</span></span><br><span class="line">          <span class="keyword">return</span> self._implicitFlowHandler(params, optionsToValidate, req, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// handle authorization code flow</span></span><br><span class="line">          <span class="keyword">return</span> self._authCodeFlowHandler(params, oauthConfig, optionsToValidate, req, next);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    (waterfallError) =&gt; &#123;</span><br><span class="line">      <span class="comment">// this code gets called after the three steps above are done</span></span><br><span class="line">      <span class="keyword">if</span> (waterfallError) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.failWithLog(<span class="string">`<span class="subst">$&#123;aadutils.getErrorMessage(waterfallError)&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们通过在这段函数中打断点就可以发现它一直都会反复调用<strong>_flowInitializationHandler</strong> 函数</p>
<p>首先我们看一下，_flowInitializationHandler函数究竟做了什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Strategy.prototype._flowInitializationHandler = <span class="function"><span class="keyword">function</span> <span class="title">flowInitializationHandler</span>(<span class="params">oauthConfig, req, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The request being authenticated is initiating OpenID Connect</span></span><br><span class="line">  <span class="comment">// authentication. Prior to redirecting to the provider, configuration will</span></span><br><span class="line">  <span class="comment">// be loaded. The configuration is typically either pre-configured or</span></span><br><span class="line">  <span class="comment">// discovered dynamically. When using dynamic discovery, a user supplies</span></span><br><span class="line">  <span class="comment">// their identifer as input.</span></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> location = aadutils.concatUrl(oauthConfig.authorization_endpoint, querystring.stringify(params));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> self.redirect(location);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么为什么会一直进入这个函数呢？</p>
<p>我们看一下他的判断条件，是因为没有id-token并且没有code（这两个参数是做什么的可以看我的上一篇文章）</p>
<p>那么为什么会没有呢？应该在哪里设置这两个参数呢？</p>
<p>其实我们向前看一下，就会发现他首先执行了一个函数叫做<strong>collectInfoFromReq</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Strategy.prototype.collectInfoFromReq = <span class="function"><span class="keyword">function</span>(<span class="params">params, req, next, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the things we will put into 'params':</span></span><br><span class="line">  <span class="comment">// err, err_description, id_token, code, policy, state, nonce, cachekey, metadata</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// we shouldn't get any access_token or refresh_token from the request</span></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">if</span> ((req.query &amp;&amp; (req.query.access_token || req.query.refresh_token)) ||</span><br><span class="line">    (req.body &amp;&amp; (req.body.access_token || req.body.refresh_token)))</span><br><span class="line">    <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: neither access token nor refresh token is expected in the incoming request'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// we might get err, id_token, code, state from the request</span></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.query &amp;&amp; (req.query.error || req.query.id_token || req.query.code))</span><br><span class="line">    source = req.query;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (req.body &amp;&amp; (req.body.error || req.body.id_token || req.body.code))</span><br><span class="line">    source = req.body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (source) &#123;</span><br><span class="line">    params.err = source.error;</span><br><span class="line">    params.err_description = source.error_description;</span><br><span class="line">    params.id_token = source.id_token;</span><br><span class="line">    params.code = source.code;</span><br><span class="line">    params.state = source.state;</span><br><span class="line">    <span class="keyword">if</span> (source.state &amp;&amp; source.state.length &gt;= <span class="number">38</span>) &#123;</span><br><span class="line">      <span class="comment">// the random generated state always has 32 characters. This state is longer than 32</span></span><br><span class="line">      <span class="comment">// so it must be a custom state. We added 'CUSTOM' prefix and a random 32 byte long</span></span><br><span class="line">      <span class="comment">// string in front of the original custom state, now we change it back.</span></span><br><span class="line">      <span class="keyword">if</span> (!source.state.startsWith(<span class="string">'CUSTOM'</span>))</span><br><span class="line">        <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`In collectInfoFromReq: invalid custom state <span class="subst">$&#123;state&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">      source.state = source.state.substring(<span class="number">38</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// If we received code, id_token or err, we must have received state, now we</span></span><br><span class="line">  <span class="comment">// find the state/nonce/policy tuple from session.</span></span><br><span class="line">  <span class="comment">// If we received none of them, find policy in query</span></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">if</span> (params.id_token || params.code || params.err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!params.state)</span><br><span class="line">      <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: missing state in the request'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tuple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!self._useCookieInsteadOfSession)</span><br><span class="line">      tuple = self._sessionContentHandler.findAndDeleteTupleByState(req, self._key, params.state);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tuple = self._cookieContentHandler.findAndDeleteTupleByState(req, response, params.state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tuple)</span><br><span class="line">      <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: invalid state received in the request'</span>));</span><br><span class="line"></span><br><span class="line">    params.nonce = tuple[<span class="string">'nonce'</span>];</span><br><span class="line">    params.policy = tuple[<span class="string">'policy'</span>];</span><br><span class="line">    params.resource = tuple[<span class="string">'resource'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user provided tenantIdOrName will be ignored for redirectUrl, since we saved the one we used in session</span></span><br><span class="line">    <span class="keyword">if</span> (params.tenantIdOrName) &#123;</span><br><span class="line">      <span class="keyword">if</span> (self._options.loggingNoPII)</span><br><span class="line">        log.info(<span class="string">'user provided tenantIdOrName is ignored for redirectUrl, we will use the one stored in session'</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        log.info(<span class="string">`user provided tenantIdOrName '<span class="subst">$&#123;params.tenantIdOrName&#125;</span>' is ignored for redirectUrl, we will use the one stored in session`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    params.tenantIdOrName = tuple[<span class="string">'tenantIdOrName'</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    params.policy = req.query.p ? req.query.p.toLowerCase() : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we are not using the common endpoint, but we have tenantIdOrName, just ignore it</span></span><br><span class="line">  <span class="keyword">if</span> (!self._options.isCommonEndpoint &amp;&amp; params.tenantIdOrName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self._options.loggingNoPII)</span><br><span class="line">      log.info(<span class="string">'identityMetadata is tenant-specific, so we ignore the tenantIdOrName provided'</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log.info(<span class="string">`identityMetadata is tenant-specific, so we ignore the tenantIdOrName '<span class="subst">$&#123;params.tenantIdOrName&#125;</span>'`</span>);</span><br><span class="line">    params.tenantIdOrName = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we are using the common endpoint and we want to validate issuer, then user has to</span></span><br><span class="line">  <span class="comment">// provide issuer in config, or provide tenant id or name using tenantIdOrName option in</span></span><br><span class="line">  <span class="comment">// passport.authenticate. Otherwise we won't know the issuer.</span></span><br><span class="line">  <span class="keyword">if</span> (self._options.isCommonEndpoint &amp;&amp; self._options.validateIssuer &amp;&amp;</span><br><span class="line">    (!self._options.issuer &amp;&amp; !params.tenantIdOrName))</span><br><span class="line">    <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: issuer or tenantIdOrName must be provided in order to validate issuer on common endpoint'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for B2C, we must have policy</span></span><br><span class="line">  <span class="keyword">if</span> (self._options.isB2C &amp;&amp; !params.policy)</span><br><span class="line">    <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: policy is missing'</span>));</span><br><span class="line">  <span class="comment">// for B2C, if we are using common endpoint, we must have tenantIdOrName provided</span></span><br><span class="line">  <span class="keyword">if</span> (self._options.isB2C &amp;&amp; self._options.isCommonEndpoint &amp;&amp; !params.tenantIdOrName)</span><br><span class="line">    <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In collectInfoFromReq: we are using common endpoint for B2C but tenantIdOrName is not provided'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// calculate metadataUrl, create a cachekey and an Metadata object instance</span></span><br><span class="line">  <span class="comment">// we will fetch the metadata, save it into the object using the cachekey</span></span><br><span class="line">  <span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">var</span> metadataUrl = self._options.identityMetadata;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we are using common endpoint and we are given the tenantIdOrName, let's replace it</span></span><br><span class="line">  <span class="keyword">if</span> (self._options.isCommonEndpoint &amp;&amp; params.tenantIdOrName) &#123;</span><br><span class="line">    metadataUrl = metadataUrl.replace(<span class="string">'/common/'</span>, <span class="string">`/<span class="subst">$&#123;params.tenantIdOrName&#125;</span>/`</span>);</span><br><span class="line">    <span class="keyword">if</span> (self._options.loggingNoPII)</span><br><span class="line">      log.info(<span class="string">`we are replacing 'common' with the tenantIdOrName provided`</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      log.info(<span class="string">`we are replacing 'common' with the tenantIdOrName <span class="subst">$&#123;params.tenantIdOrName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add policy for B2C</span></span><br><span class="line">  <span class="keyword">if</span> (self._options.isB2C)</span><br><span class="line">    metadataUrl = metadataUrl.concat(<span class="string">`&amp;p=<span class="subst">$&#123;params.policy&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we use the metadataUrl as the cachekey</span></span><br><span class="line">  params.cachekey = metadataUrl;</span><br><span class="line">  params.metadata = <span class="keyword">new</span> Metadata(metadataUrl, <span class="string">'oidc'</span>, self._options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!self._options.loggingNoPII) &#123;</span><br><span class="line">    log.info(<span class="string">`metadataUrl is: <span class="subst">$&#123;metadataUrl&#125;</span>`</span>);</span><br><span class="line">    log.info(<span class="string">`received the following items in params: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(params)&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数最开始就会去请求中获取id-token，如果这里获取不到就会导致接下来的函数无法获取，</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上所述，无限回调出现的流程就是首先去微软验证成功并返回了id-token，之后调用了我们的/auth/openid/return，也就是passport.authenciate，在这个函数中又因为无法解析body而无法获取id-token，导致重新去微软请求，再次请求成功返回，调用passport.authenciate，再次无法获取id-token，再次认证，无限循环。</p>
<h2 id="2020-02-08更新"><a href="#2020-02-08更新" class="headerlink" title="2020-02-08更新"></a>2020-02-08更新</h2><p>这个周的工作中遇到了另外一个原因会导致passport-azure-ad的登录失败，虽然不会导致无限循环，但是究其根本原因还是passport-azure-ad内部原因导致，表现的形式就是去azure登陆成功了，但是passport却偏偏认为没有登陆成功。</p>
<p>看一下log发现他会提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">params.metadata.generateOidcPEM is not a function</span><br></pre></td></tr></table></figure>

<p>那么这个 params.metadata.generateOidcPEM 是哪里来的呢？</p>
<p>仔细看一下passport-azure-ad的源码发现，如果从azure那边成功返回数据之后，passport还要去检验数据的合法性，这个函数就是用于检验合法性的，没有这个函数就会导致校验不通过，passport认为返回的数据是不合法的。</p>
<p>那么为什么会突然导致这个问题呢？</p>
<p>原因是passport-azure-ad本身又依赖了一个叫做cache-manager的包，而且这个对于这个包的版本要求是 “^2.0.0”，最近这个叫做cache-manager的包做了一次升级，2.11.0以上的版本一个深度克隆的方法从lodash的deepClone变成了deepmerge，导致了参数中的部分数据丢失。</p>
<p>所以我们只需要在package.json中指定cache-manager版本为2.10.0或者2.10.2就好。</p>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2020/06/25/preSum/</url>
    <content><![CDATA[<p>今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。</p>
<p>那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行了。</p>
<p>关键是，<strong>如何快速得到某个子数组的和呢</strong>，比如说给你一个数组 <code>nums</code>，让你实现一个接口 <code>sum(i, j)</code>，这个接口要返回 <code>nums[i..j]</code> 的和，而且会被多次调用，你怎么实现这个接口呢？</p>
<p>因为接口要被多次调用，显然不能每次都去遍历 <code>nums[i..j]</code>，有没有一种快速的方法在 O(1) 时间内算出 <code>nums[i..j]</code> 呢？这就需要<strong>前缀和</strong>技巧了。</p>
<a id="more"></a>

<h3 id="什么是前缀和"><a href="#什么是前缀和" class="headerlink" title="什么是前缀和"></a>什么是前缀和</h3><p>前缀和的思路是这样的，对于一个给定的数组 <code>nums</code>，我们额外开辟一个前缀和数组进行预处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n = nums.length;</span><br><span class="line">// 前缀和数组</span><br><span class="line">int[] preSum = new int[n + 1];</span><br><span class="line">preSum[0] = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">    preSum[i + 1] = preSum[i] + nums[i];</span><br></pre></td></tr></table></figure>

<p>这个前缀和数组 <code>preSum</code> 的含义也很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i..j]</code> 的和，只需要一步操作 <code>preSum[j+1]-preSum[i]</code> 即可，而不需要重新去遍历数组了。</p>
<p>回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    // 构造前缀和</span><br><span class="line">    int[] sum = new int[n + 1];</span><br><span class="line">    sum[0] = 0; </span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        sum[i + 1] = sum[i] + nums[i];</span><br><span class="line">    </span><br><span class="line">    int ans = 0;</span><br><span class="line">    // 穷举所有子数组</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 0; j &lt; i; j++)</span><br><span class="line">            // sum of nums[j..i-1]</span><br><span class="line">            if (sum[i] - sum[j] == k)</span><br><span class="line">                ans++;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法的时间复杂度 $O(N^2)$ 空间复杂度 $O(N)$，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。</p>
<h3 id="二、优化解法"><a href="#二、优化解法" class="headerlink" title="二、优化解法"></a>二、优化解法</h3><p>前面的解法有嵌套的 for 循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    for (int j = 0; j &lt; i; j++)</span><br><span class="line">        if (sum[i] - sum[j] == k)</span><br><span class="line">            ans++;</span><br></pre></td></tr></table></figure>

<p>第二层 for 循环在干嘛呢？翻译一下就是，<strong>在计算，有几个 <code>j</code> 能够使得 <code>sum[i]</code> 和 <code>sum[j]</code> 的差为 k。</strong>毎找到一个这样的 <code>j</code>，就把结果加一。</p>
<p>我们可以把 if 语句里的条件判断移项，这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (sum[j] == sum[i] - k)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure>

<p>优化的思路是：<strong>我直接记录下有几个 <code>sum[j]</code> 和 <code>sum[i] - k</code> 相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    // map：前缀和 -&gt; 该前缀和出现的次数</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; </span><br><span class="line">        preSum = new HashMap&lt;&gt;();</span><br><span class="line">    // base case</span><br><span class="line">    preSum.put(0, 1);</span><br><span class="line"></span><br><span class="line">    int ans = 0, sum0_i = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        sum0_i += nums[i];</span><br><span class="line">        // 这是我们想找的前缀和 nums[0..j]</span><br><span class="line">        int sum0_j = sum0_i - k;</span><br><span class="line">        // 如果前面有这个前缀和，则直接更新答案</span><br><span class="line">        if (preSum.containsKey(sum0_j))</span><br><span class="line">            ans += preSum.get(sum0_j);</span><br><span class="line">        // 把前缀和 nums[0..i] 加入并记录出现次数</span><br><span class="line">        preSum.put(sum0_i, </span><br><span class="line">            preSum.getOrDefault(sum0_i, 0) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转载自：</p>
<p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/算法思维系列/前缀和技巧.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7.md</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Promise 源码分析</title>
    <url>/2019/12/06/promise-explore/</url>
    <content><![CDATA[<p>这个周编码过程中使用了NodeJs去处理图片，因为图片处理的接口全都是Promise，就导致了我的程序中充满了Promise的嵌套返回，then的结果中有返回了另一个Promise，另一个Promise中一系列中的then中有的又会返回新的Promise，这一度让我变得混乱。</p>
<p>理清楚后，不禁对Promise为什么能够如此神奇产生了好奇，于是去阅读了它的源码，才发现有些习以为常的功能背后的设计的奇妙。</p>
<a id="more"></a>

<h2 id="Promise-使用"><a href="#Promise-使用" class="headerlink" title="Promise 使用"></a>Promise 使用</h2><p>ES6提供Promise构造函数，我们创造一个Promise实例，Promise构造函数接收一个函数作为参数，这个传入的函数有两个参数，分别是两个函数 <code>resolve</code>和<code>reject</code>作用是，<code>resolve</code>将Promise的状态由未成功变为成功，将异步操作的结果作为参数传递过去；相似的是<code>reject</code>则将状态由未失败转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。<br> 实例创建完成后，可以使用<code>then</code>方法分别指定成功或失败的回调函数，比起f1(f2(f3))的层层嵌套的回调函数写法，链式调用的写法更为美观易读</p>
<p>我们在创建一个新的Promise的时候需要传入一个函数作为参数，这个传入的函数有两个参数，分别是两个函数，resolve以及reject，函数体内部执行异步操作，然后根据操作的结果是否为需要的结果调用不同的函数，如果获得了正确的返回，就调用resolve函数，并将你需要返回的结果作为参数，如果没有获取正确的返回，就调用reject函数，并将错误信息作为参数，这样外部就可以获取错误信息了。举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> num = <span class="built_in">Math</span>.random();</span><br><span class="line">        num &gt; <span class="number">.5</span> ? resolve(<span class="string">`success:<span class="subst">$&#123;num&#125;</span>`</span>) : reject(<span class="string">`fail:<span class="subst">$&#123;num&#125;</span>`</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">resolveVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">rejectVal</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rejectVal)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个Promise，在一秒钟之后生成一个随机数，如果随机数大于0.5就返回调用resolve，如果小于0.5，如果小于0.5就调用reject。</p>
<p>当执行了resolve时，Promise的状态会变为resolved，并会执行then中传入的函数，其实就相当于then中传入的函数会被当作resolve函数执行。同理，当执行了reject时，Promise的状态会变为Rejected，这个时候会利用catch中传入的函数作为reject函数去执行。</p>
<p>总的来说，then和 catch时为Promise加载了两个resolve和reject时具体需要执行的函数。</p>
<h3 id="then的规则"><a href="#then的规则" class="headerlink" title="then的规则"></a>then的规则</h3><ul>
<li><p><code>then</code>方法下一次的输入需要上一次的输出</p>
</li>
<li><p>如果一个promise执行完后 返回的还是一个promise，会把这个promise 的执行结果，传递给下一次<code>then</code>中。也就是说如果你在PromiseA的then中返回了PromiseB，那么PromiseB的结果会作为PromiseA下一步then的入参。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promiseB = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line">promiseA.then(<span class="function">(<span class="params">resolveA</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promiseB;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">resolveB</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种情况下第二个then的参数就是promise的返回结果。</p>
</li>
<li><p>如果<code>then</code>中返回的不是Promise对象而是一个普通值，则会将这个结果作为下次then的成功的结果</p>
</li>
<li><p>如果当前<code>then</code>中失败了 会走下一个<code>then</code>的失败</p>
</li>
<li><p>如果返回的是undefined 不管当前是成功还是失败 都会走下一次的成功</p>
</li>
<li><p><code>then</code>中不写方法则值会穿透，传入下一个<code>then</code>中</p>
</li>
<li><p>then函数中的return val 与Promise resolve（val）相同</p>
</li>
</ul>
<p>举例说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example1</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'promise1'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当参数是一个非promise的时候,1秒后promise的状态立即变成resolve，并执行then里面的事件.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example2</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'promise2'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        resolve(promise2);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当参数是另一个promise的时候,这时promise1的状态由promise2来决定,什么时候promise2变化了状态,promise1的状态也会相应的变化，并且状态保持一致.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example3</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'promise2'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当回调函数里面直接return一个非promise,和上面的example1一样，当前的promise2状态变为resolve。相当于执行了(resolve(‘非promise’))</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example4</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'promise3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise3;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当回调函数里面直接return一个promise3,和上面example2一样，当前promise2的状态依赖于primise3,相当于执行了(resolve(promise3))</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example5</span></span><br><span class="line">promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise2 = promise1.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( iamnotundefined );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当回调函数里面代码报错了,并且没有被catch到的,当前promise状态变为reject.(异步的error代码catch不到,不会影响promise状 态变化)</p>
<h3 id="catch的规则"><a href="#catch的规则" class="headerlink" title="catch的规则"></a>catch的规则</h3><ul>
<li>执行reject的时候会调用catch</li>
<li>前面出现任何没有被处理的错误时会执行catch</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="https://github.com/then/promise" rel="external nofollow noopener noreferrer" target="_blank">Promise源码地址</a></p>
<p>下面的注释说明了对Promise状态的可能值：</p>
<p>0 -  等待中<br> 1 -  满足条件 (值为 _value)<br> 2 -  拒绝条件 (值为 _value)<br> 3 -  采用了另一个Promise的状态和值</p>
<blockquote>
<p>一旦状态值不为0， 那么这个Promise将不可以被修改.</p>
</blockquote>
<p>在正式声明Promise之前，为了减少对try catch在代码中显示，定义了几个工具函数，</p>
<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//空回调函数，用于then</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// States:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 0 - pending</span></span><br><span class="line"><span class="comment">// 1 - fulfilled with _value</span></span><br><span class="line"><span class="comment">// 2 - rejected with _value</span></span><br><span class="line"><span class="comment">// 3 - adopted the state of another promise, _value</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// once the state is no longer pending (0) it is immutable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// All `_` prefixed properties will be reduced to `_&#123;random number&#125;`</span></span><br><span class="line"><span class="comment">// at build time to obfuscate them and discourage their use.</span></span><br><span class="line"><span class="comment">// We don't use symbols or Object.defineProperty to fully hide them</span></span><br><span class="line"><span class="comment">// because the performance isn't good enough.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// to avoid using try/catch inside critical functions, we</span></span><br><span class="line"><span class="comment">// extract them to here.</span></span><br><span class="line"><span class="keyword">var</span> LAST_ERROR = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> IS_ERROR = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.then;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    LAST_ERROR = ex;</span><br><span class="line">    <span class="keyword">return</span> IS_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCallOne</span>(<span class="params">fn, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    LAST_ERROR = ex;</span><br><span class="line">    <span class="keyword">return</span> IS_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCallTwo</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(a, b);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    LAST_ERROR = ex;</span><br><span class="line">    <span class="keyword">return</span> IS_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promises must be constructed via new'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise constructor\'s argument is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._deferredState = <span class="number">0</span>;<span class="comment">//这个状态用于表明未来的状态会是怎么样的，只有当前的Promise状态依赖另一个Promise时才有用，也就是resolve了一个Promise</span></span><br><span class="line">  <span class="keyword">this</span>._state = <span class="number">0</span>;<span class="comment">//当前Promise的状态</span></span><br><span class="line">  <span class="keyword">this</span>._value = <span class="literal">null</span>;<span class="comment">//当前Promise的resolve的值</span></span><br><span class="line">  <span class="keyword">this</span>._deferreds = <span class="literal">null</span>;<span class="comment">//当_deferredState变为成功，也就是大于2时，执行的回调函数数组</span></span><br><span class="line">  <span class="keyword">if</span> (fn === noop) <span class="keyword">return</span>;</span><br><span class="line">  doResolve(fn, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数Promise接受一个函数作为其参数，必须通过new来创建。</p>
<p>初始化 _deferredState 和 _state为 0,  _value和_deferreds为null,<br> 如果传入函数是一个空函数，那么直接返回。<br> 正常情况下，进入 doResolve 开始流程。</p>
<h3 id="doResolve"><a href="#doResolve" class="headerlink" title="doResolve"></a>doResolve</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span>(<span class="params">fn, promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//注意，fn就是我们new Promise时传入的（resolve， reject）=&gt; &#123; if success resolve else reject&#125;,tryCallTwo会将第二个参数传给resolve,将第三个参数传给reject，这样当我们在声明的Promise中调用resolve时实际上调用的时trayCallTwo的第二个参数。</span></span><br><span class="line">  <span class="keyword">var</span> res = tryCallTwo(fn, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;<span class="comment">// 防止运行两次</span></span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    resolve(promise, value);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    reject(promise, reason);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!done &amp;&amp; res === IS_ERROR) &#123;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    reject(promise, LAST_ERROR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同步的直接调用传入的函数，讲两个函数 (即外部编写的resolve和reject)作为参数传入 , 调用完成后检查下是否是没完成的情况下出错了，如果是直接reject.<br> 针对传入的resolve函数和reject函数,等待结果后，如果尚未完成，则通过本文件中定义的resolve和reject来继续流程.</p>
<p><strong>注意tryCallTwo函数的第二个和第三个参数都是一个函数，这两个函数的参数其实就是我们new一个新的Promise的时候传入的两个函数</strong>，<strong>而这段代码中的resolve和reject则是Promise内部定义的方法</strong>。</p>
<h3 id="resolve-amp-reject"><a href="#resolve-amp-reject" class="headerlink" title="resolve &amp; reject"></a>resolve &amp; reject</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">self, newValue</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 一个Promise的解决结果不能是自己 （因为根据一开始我们提到的then的原则中，如果你返回了一个新的Promise，那么当前Promise的状态就会依赖于新的Promise，如果自己依赖自己，那么就会一直循环依赖并处于pending状态）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里的newValue其实就是我们定义的Promise实例中resolve的参数，依照前面的使用方法，它可以是字符串，数组等，也可以是另一个一个Promise</span></span><br><span class="line">  <span class="keyword">if</span> (newValue === self) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(</span><br><span class="line">      self,</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'A promise cannot be resolved with itself.'</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当新的值也就是resolve函数的参数存在并且类型是对象或者函数的时候</span></span><br><span class="line">  <span class="comment">// typeof Promised实例 === 'object'</span></span><br><span class="line">  <span class="comment">// 也就是说这个if成功的条件是resolve了一个对象，函数或者Promise实例</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    newValue &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> then = getThen(newValue);  <span class="comment">// let then = newValue.then</span></span><br><span class="line">    <span class="keyword">if</span> (then === IS_ERROR) &#123; <span class="comment">//IS_ERROR就是上面所说的工具中声明的，就是一个空对象，只有当return newValue.then发生异常时才会为IS_ERROR</span></span><br><span class="line">      <span class="keyword">return</span> reject(self, LAST_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      then === self.then &amp;&amp;</span><br><span class="line">      newValue <span class="keyword">instanceof</span> <span class="built_in">Promise</span> <span class="comment">// 如果resvole的是一个Promise,并且这个Promise的then与当前Promise的then相同时（这个then一般是相同的，都是定义在Promise的原型上的），直接就用当前Promise的结果为最终结果。</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      self._state = <span class="number">3</span>; <span class="comment">//状态3说明采用另一个Promise作为结果</span></span><br><span class="line">      self._value = newValue;</span><br><span class="line">      finale(self); <span class="comment">// 那么采用这个Promise的结果</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;<span class="comment">//走到这里就说明，resolve了一个有then方法的对象（或者一个Promise，并且和当前Promise的then不同，这种情况比较少见）</span></span><br><span class="line">      doResolve(then.bind(newValue), self); <span class="comment">// 递归调用doResolve，刚才我们也看了，doResolve的第一个参数是我们new Promise时传入的函数，第二个参数是当前的Promise实例的指针，也就是在递归中执行到这个then函数时，其内部的this指向的是这里的newValue，这里self没变</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//上面的if都没有return，才会走到这里，到了这里就说明，resolve了普通的值，比如数字，字符串，标记完成，进入结束流程</span></span><br><span class="line">  self._state = <span class="number">1</span>; <span class="comment">//状态1说明进入成功状态</span></span><br><span class="line">  self._value = newValue;</span><br><span class="line">  finale(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">self, newValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//设置reject状态和理由</span></span><br><span class="line">  self._state = <span class="number">2</span>;</span><br><span class="line">  self._value = newValue;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Promise</span>._onReject) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>._onReject(self, newValue); <span class="comment">//过程回调通知</span></span><br><span class="line">  &#125;</span><br><span class="line">  finale(self); <span class="comment">//结束 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数只有self的状态不为0的时候才会执行，这个时候执行handle就会执行传入的第二个参数，也就是_deferreds，_deferredState为1表明_deferreds是一个Handler，_deferredState为2说明_deferreds是Handler的数组，全都执行完了，再把_deferreds赋值为空</span></span><br><span class="line"><span class="comment">//也就是说finale是把所有的Handler执行一次</span></span><br><span class="line"><span class="comment">// 每个Hander都是通过then方法传入的，then方法有两个参数，分别是onFulfilled，onRejected，也就是resolve时应该执行的函数和reject时应该执行的函数</span></span><br><span class="line"><span class="comment">// 如果是_state为3的时候执行finale，其实就是先把当前Promise通过then创建的Handler挂到了它所依赖地Promise实例的_deferreds上去</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self._deferredState === <span class="number">1</span>) &#123;</span><br><span class="line">    handle(self, self._deferreds);</span><br><span class="line">    self._deferreds = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self._deferredState === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self._deferreds.length; i++) &#123;</span><br><span class="line">      handle(self, self._deferreds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    self._deferreds = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然就冒出来之前未曾触及到的_deferredState和_deferreds的使用，他们是什么用的？<br> 在回答这些之前，我们先回想下在Promise的时候中，当创建并返回了promise之后，下面的操作就是then来获取结果了 (当然也包括catch)， 那么对于这个then的实现我们先来看一下：</p>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then的参数是两个函数，onFulfilled是我们resolve时调用的回调函数，onRejected是我们reject时调用的回调函数</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.constructor !== <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> safeThen(<span class="keyword">this</span>, onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(noop);</span><br><span class="line">  handle(<span class="keyword">this</span>, <span class="keyword">new</span> Handler(onFulfilled, onRejected, res));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的safeThen和then的用法基本一致，都是创建了一个异步的空回调res，然后使用onFulfilled, onRejected和res来创建 Handler。那么核心就在handle这个函数上了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">self, deferred</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//self._state === 3说明self指向的Promise实例的状态依赖另一个Promise实例，这个实例就是self._value</span></span><br><span class="line">  <span class="comment">//也就是说通过这个循环，最终self最终会指向一个状态只依赖自己的Promise实例</span></span><br><span class="line">  <span class="comment">//也就是说假设self是p1,它依赖p2的状态，当p1调用handle的时候，并且p2还没有resolve，其实是把p1通过then创建的Handler挂到了p2的_deferreds上去，当p2 resolve的时候依次执行。</span></span><br><span class="line">  <span class="keyword">while</span> (self._state === <span class="number">3</span>) &#123;</span><br><span class="line">    self = self._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Promise</span>._onHandle) &#123; <span class="comment">// for injection - not in main loop</span></span><br><span class="line">    <span class="built_in">Promise</span>._onHandle(self);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果这个状态只依赖自己的Promise实例还没有结果，就把传入的回调函数先保存起来</span></span><br><span class="line">  <span class="comment">// _deferredState 为0表明还没有保存过回调函数，那么就把回调函数赋值给_deferreds，这个时候_deferreds只是一个回调函数</span></span><br><span class="line">  <span class="comment">// _deferredState 为1表明保存过回调函数，那么就把回调函数和原有的保存在_deferreds的回调函数构造成一个数组重新赋值给_deferreds，这个时候_deferreds只是一个回调函数的数组</span></span><br><span class="line">  <span class="comment">// _deferredState 为2表明_deferreds已经是一个回掉函数的数组了，就push就可以了</span></span><br><span class="line">  <span class="comment">// 直到某一次调用handle，self的状态不为0了，才会执行handleResolved</span></span><br><span class="line">  <span class="keyword">if</span> (self._state === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self._deferredState === <span class="number">0</span>) &#123;</span><br><span class="line">      self._deferredState = <span class="number">1</span>;</span><br><span class="line">      self._deferreds = deferred;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self._deferredState === <span class="number">1</span>) &#123;</span><br><span class="line">      self._deferredState = <span class="number">2</span>;</span><br><span class="line">      self._deferreds = [self._deferreds, deferred];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self._deferreds.push(deferred);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  handleResolved(self, deferred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的参数就是deferred， 那么说明deferred就是Handler, 结合意思，指代的就是延迟的处理。明白点说，就是完成promise之后所需要做的事情。<br> 那么具体的过程是怎么样的呢？<br> 首先判断当前状态是不是依赖于另一个promise, 是的话则通过while等待<br> 然后onHandle只是个提供给外部的进度回调，这里先无视<br> 当状态为0的时候，这里就是设置未来的处理过程了，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">如果未来状态没有设置过（<span class="number">0</span>）， 那么设置回调(<span class="keyword">deferred</span>) 为单独回调</span><br><span class="line">如果未来状态设置过了 (<span class="number">1</span>),  那么设置回调 (<span class="keyword">deferred</span>) 进入回调数组</span><br><span class="line">如果其他状态 (<span class="number">2</span> +)，那么直接进入回调数组。</span><br><span class="line">对状态<span class="number">0</span>情况下的处理这里就返回了。 因为在这个时候，是promise同步执行过来的then, 设置好未来处理的函数过程。</span><br></pre></td></tr></table></figure>

<p>当状态非0的时候， 就进入了handleResolved，这应该就是完成后处理结束的地方了。 等等，上面只是从then出发进入handle的，那时候应该promise还没有完成，处理完成的调用一定是在别的地方。 通过搜索handle的调用可以看到还有在finale函数中， 这样就和上面连接上了，我们先回顾下什么时候会调用finale呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 状态3 等待其他promise的结果时候 - 这里会进入等待</span><br><span class="line">2 状态1 完成的时候</span><br><span class="line">3 状态2 reject的时候</span><br></pre></td></tr></table></figure>

<p>可以看到只有在promise结束或者依赖其他promise的时候，才会进入finale.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self._deferredState === <span class="number">1</span>) &#123;</span><br><span class="line">    handle(self, self._deferreds);</span><br><span class="line">    self._deferreds = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self._deferredState === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self._deferreds.length; i++) &#123;</span><br><span class="line">      handle(self, self._deferreds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    self._deferreds = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finale中会将之前放入的deffereds 一一取出 调用handle, 这时state均为非0，直接进入handleResolved， 代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResolved</span>(<span class="params">self, deferred</span>) </span>&#123;</span><br><span class="line">  asap(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// self._state 为 1，就执行then函数的第一个参数，就是成功的回调函数，否则执行reject的回调函数</span></span><br><span class="line">    <span class="keyword">var</span> cb = self._state === <span class="number">1</span> ? deferred.onFulfilled : deferred.onRejected;</span><br><span class="line">    <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (self._state === <span class="number">1</span>) &#123;</span><br><span class="line">        resolve(deferred.promise, self._value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(deferred.promise, self._value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = tryCallOne(cb, self._value);</span><br><span class="line">    <span class="keyword">if</span> (ret === IS_ERROR) &#123;</span><br><span class="line">      reject(deferred.promise, LAST_ERROR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(deferred.promise, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就比较简单的，通过异步的asap调用，如果没有onFulfilled(onRejected失败情况)，则直接调用resolve(reject), 如果有则先调用onFulfilled(onRejected失败情况)，根据结果来调用resolve(reject)。</p>
<p>等等。。这里的resolve和reject不是在上面的流程中有出现了么？请注意这里resolve和 rejected的promise, 这个promise是在then的时候创建的空promise,也就是意味这什么都不会执行 （直接进入finale 无handle情况)。 所以真正影响这里流程的是 对于deferred.onFulfilled 或者 deferred.onRejected的回调执行，执行完回调 这个promise的执行过程就完成了。</p>
<p>综上, promise的执行过程是这样的</p>
<ul>
<li>创建Promise</li>
<li>设置需要执行的函数，也就是new Promise是传入的函数</li>
<li>设置完成的回调，也就是then传入的两个函数，第一个是resolve时执行的，一个是reject执行的，如果resolve了一个Promise2，那么当前then创建的Handler会挂载到Promise2上，等到Promise2 resolve了再一起执行。</li>
<li>开始执行函数</li>
<li>根据执行结果选择回调</li>
</ul>
<p>另外提一句safeThen, safeThen的作用是当调用then的时候环境this已经不是Promise的情况下能够继续安全执行then。</p>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5caf147af265da035d0c698a" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5caf147af265da035d0c698a</a></p>
<p><a href="https://juejin.im/entry/599968f6518825244630f809" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/599968f6518825244630f809</a></p>
<p><a href="https://www.jianshu.com/p/b63ec30eefdd" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b63ec30eefdd</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>PWA</title>
    <url>/2020/02/01/pwa/</url>
    <content><![CDATA[<p>这几天在学习webpack时接触到了PWA这个新的概念，于是在这里简单总结一下PWA的基本概念，用途以及如何结合webpack，vue去使用PWA。</p>
<a id="more"></a>

<h2 id="什么是PWA"><a href="#什么是PWA" class="headerlink" title="什么是PWA"></a>什么是PWA</h2><p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。</p>
<p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>
<p>PWA 的主要特点包括下面三点：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>
</ul>
<p>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 <a href="https://developers.google.cn/web/progressive-web-apps/checklist" rel="external nofollow noopener noreferrer" target="_blank">PWA Checklist</a> 查看现有的特征。</p>
<p>具体的细节可以去参考<a href="https://lavas.baidu.com/pwa/README" rel="external nofollow noopener noreferrer" target="_blank">PWA文档</a></p>
<h2 id="Service-Worker简介"><a href="#Service-Worker简介" class="headerlink" title="Service Worker简介"></a>Service Worker简介</h2><h3 id="什么是Service-Worker"><a href="#什么是Service-Worker" class="headerlink" title="什么是Service Worker"></a>什么是Service Worker</h3><p>W3C 组织早在 2014 年 5 月就提出过 Service Worker 这样的一个 HTML5 API ，主要用来做持久的离线缓存。</p>
<p>当然这个 API 不是凭空而来，至于其中的由来我们可以简单的捋一捋：</p>
<p>浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。</p>
<p>W3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫 Web Worker 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 postMessage 方法告诉主线程，而主线程通过 onMessage 方法得到 Web Worker 的结果反馈。</p>
<p>一切问题好像是解决了，但 Web Worker 是临时的，每次做的事情的结果还不能被持久存下来，如果下次有同样的复杂操作，还得费时间的重新来一遍。那我们能不能有一个Worker 是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初版本的 Service Worker ，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。当然在 Service Worker 之前也有在 HTML5 上做离线缓存的 API 叫 AppCache, 但是 AppCache 存在很多 <a href="https://alistapart.com/article/application-cache-is-a-douchebag" rel="external nofollow noopener noreferrer" target="_blank">不能忍受的缺点</a>。</p>
<p>W3C 决定 AppCache 仍然保留在 HTML 5.0 Recommendation 中，在 HTML 后续版本中移除。</p>
<p>Service Worker 有以下功能和特性：</p>
<ul>
<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>
<li>一旦被 install，就永远存在，除非被手动 unregister</li>
<li>用到的时候可以直接唤醒，不用的时候自动睡眠</li>
<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li>
<li>离线内容开发者可控</li>
<li>能向客户端推送消息</li>
<li>不能直接操作 DOM</li>
<li>必须在 HTTPS 环境下才能工作</li>
<li>异步实现，内部大都是通过 Promise 实现</li>
</ul>
<p>所以我们基本上知道了 Service Worker 的伟大使命，就是让缓存做到优雅和极致，让 Web App 相对于 Native App 的缺点更加弱化，也为开发者提供了对性能和体验的无限遐想。</p>
<h2 id="如何使用Service-Worker"><a href="#如何使用Service-Worker" class="headerlink" title="如何使用Service Worker"></a>如何使用Service Worker</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>Service Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。</p>
<ul>
<li>由于 Service Worker 要求 HTTPS 的环境，我们通常可以借助于 <a href="https://pages.github.com/" rel="external nofollow noopener noreferrer" target="_blank">github page</a> 进行学习调试。当然一般浏览器允许调试 Service Worker 的时候 host 为 <code>localhost</code> 或者 <code>127.0.0.1</code> 也是 ok 的。</li>
<li>Service Worker 的缓存机制是依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" rel="external nofollow noopener noreferrer" target="_blank">Cache API</a> 实现的</li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" rel="external nofollow noopener noreferrer" target="_blank">HTML5 fetch API</a></li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/javaScript/Reference/Global_Objects/Promise" rel="external nofollow noopener noreferrer" target="_blank">Promise</a> 实现</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>要安装 Service Worker， 我们需要通过在 js 主线程（常规的页面里的 js ）注册 Service Worker 来启动安装，这个过程将会通知浏览器我们的 Service Worker 线程的 javaScript 文件在什么地方呆着。</p>
<p>先来感受一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123456789101112131415</span><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        navigator.serviceWorker.register(<span class="string">'/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册成功</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, registration.scope);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注册失败:(</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码首先是要判断 Service Worker API 的可用情况，支持的话咱们才继续谈实现，否则免谈了。</p>
</li>
<li><p>如果支持的话，在页面 <code>onload</code> 的时候注册位于 <code>/sw.js</code> 的 Service Worker。</p>
</li>
<li><p>每次页面加载成功后，就会调用 <code>register()</code> 方法，浏览器将会判断 Service Worker 线程是否已注册并做出相应的处理。</p>
</li>
<li><p>register 方法的 scope 参数是可选的，用于指定你想让 Service Worker 控制的内容的子目录。本 demo 中服务工作线程文件位于根网域， 这意味着服务工作线程的作用域将是整个来源。</p>
<p>关于 <code>register</code> 方法的 scope 参数，需要说明一下：Service Worker 线程将接收 scope 指定网域目录上所有事项的 fetch 事件，如果我们的 Service Worker 的 javaScript 文件在 <code>/a/b/sw.js</code>， 不传 scope 值的情况下, scope 的值就是 <code>/a/b</code>。</p>
<p>scope 的值的意义在于，如果 scope 的值为 <code>/a/b</code>， 那么 Service Worker 线程只能捕获到 path 为 <code>/a/b</code> 开头的( <code>/a/b/page1</code>, <code>/a/b/page2</code>，…)页面的 fetch 事件。通过 scope 的意义我们也能看出 Service Worker 不是服务单个页面的，所以在 Service Worker 的 js 逻辑中全局变量需要慎用。</p>
</li>
<li><p><code>then()</code> 函数链式调用我们的 promise，当 promise resolve 的时候，里面的代码就会执行。</p>
</li>
<li><p>最后面我们链了一个 <code>catch()</code> 函数，当 promise rejected 才会执行。</p>
</li>
</ul>
<p>代码执行完成之后，我们这就注册了一个 Service Worker，它工作在 worker context，所以没有访问 DOM 的权限。在正常的页面之外运行 Service Worker 的代码来控制它们的加载。</p>
<h5 id="查看是否注册成功"><a href="#查看是否注册成功" class="headerlink" title="查看是否注册成功"></a>查看是否注册成功</h5><p>如果你很困惑，我的 Service Worker 到底注册成功没有呢？注册成功是什么样子呢？</p>
<p>可以在 PC 上打开我们的好伙伴 chrome 浏览器, 输入 <code>chrome://inspect/#service-workers</code></p>
<p><img src="https://gss0.bdstatic.com/9rkZbzqaKgQUohGko9WTAnF6hhy/assets/pwa/projects/1515672231576/sw-chrome-inspect.png" alt="chorme inspect-Service Worker"></p>
<p>我们还可以通过 <code>chrome://serviceworker-internals</code> 来查看服务工作线程详情。 如果只是想了解服务工作线程的生命周期，这仍很有用，但是日后其很有可能被 <code>chrome://inspect/#service-workers</code> 完全取代。</p>
<p>当然，它还可用于测试<a href="https://support.google.com/chrome/answer/95464?hl=zh-Hans" rel="external nofollow noopener noreferrer" target="_blank">隐身窗口</a>中的 Service Worker 线程，您可以关闭 Service Worker 线程并重新打开，因为之前的 Service Worker 线程不会影响新窗口。从隐身窗口创建的任何注册和缓存在该窗口关闭后均将被清除。</p>
<h5 id="注册失败的原因"><a href="#注册失败的原因" class="headerlink" title="注册失败的原因"></a>注册失败的原因</h5><p>为啥会导致 Service Worker 注册失败呢？原因基本就是以下几种情况：</p>
<ul>
<li>不是 HTTPS 环境，不是 <code>localhost</code> 或 <code>127.0.0.1</code>。</li>
<li>Service Worker 文件的地址没有写对，需要相对于 origin。</li>
<li>Service Worker 文件在不同的 origin 下而不是你的 App 的，这是不被允许的。</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在你的 Service Worker 注册成功之后呢，我们的浏览器中已经有了一个属于你自己 web App 的 worker context 啦， 在此时，浏览器就会马不停蹄的尝试为你的站点里面的页面安装并激活它，并且在这里可以把静态资源的缓存给办了。</p>
<p>install 事件我们会绑定在 Service Worker 文件中，在 Service Worker 安装成功后，install 事件被触发。</p>
<p>install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 新的标志性的存储 cache API — 一个 Service Worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>
<p><strong>localStorage 的用法和 Service Worker cache 的用法很相似，但是由于 localStorage 是同步的用法，所以不允许在 Service Worker 中使用。</strong> <strong>IndexedDB 也可以在 Service Worker 内做数据存储。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567891011121314151617</span><span class="comment">// 监听 service worker 的 install 事件</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果监听到了 service worker 已经安装成功的话，就会调用 event.waitUntil 回调函数</span></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 安装成功后操作 CacheStorage 缓存，使用之前需要先通过 caches.open() 打开对应缓存空间。</span></span><br><span class="line">        caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 cache 缓存对象的 addAll 方法添加 precache 缓存</span></span><br><span class="line">            <span class="keyword">return</span> cache.addAll([</span><br><span class="line">                <span class="string">'/'</span>,</span><br><span class="line">                <span class="string">'/index.html'</span>,</span><br><span class="line">                <span class="string">'/main.css'</span>,</span><br><span class="line">                <span class="string">'/main.js'</span>,</span><br><span class="line">                <span class="string">'/image.jpg'</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我们 新增了一个 install 事件监听器，接着在事件上接了一个 <code>ExtendableEvent.waitUntil()</code> 方法——这会确保 Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成。</li>
<li>在 <code>waitUntil()</code> 内，我们使用了 <code>caches.open()</code> 方法来创建了一个叫做 v1 的新的缓存，将会是我们的站点资源缓存的第一个版本。它返回了一个创建缓存的 promise，当它 resolved 的时候，我们接着会调用在创建的缓存实例（Cache API）上的一个方法 <code>addAll()</code>，这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表。</li>
<li>如果 promise 被 rejected，安装就会失败，这个 worker 不会做任何事情。这也是可以的，因为你可以修复你的代码，在下次注册发生的时候，又可以进行尝试。</li>
<li>当安装成功完成之后，Service Worker 就会激活。在第一次你的 Service Worker 注册／激活时，这并不会有什么不同。但是当 Service Worker 更新的时候 ，就不太一样了。</li>
</ul>
<h4 id="自定义请求响应"><a href="#自定义请求响应" class="headerlink" title="自定义请求响应"></a>自定义请求响应</h4><p>走到这一步，其实现在你已经可以将你的站点资源缓存了，你需要告诉 Service Worker 让它用这些缓存内容来做点什么。有了 fetch 事件，这是很容易做到的。</p>
<p>每次任何被 Service Worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的 html 文档，和这些 html 文档内引用的其他任何资源（比如 <code>index.html</code> 发起了一个跨域的请求来嵌入一个图片，这个也会通过 Service Worker），这下 Service Worker 代理服务器的形象开始慢慢露出来了，而这个代理服务器的钩子就是凭借 scope 和 fetch 事件两大利器就能把站点的请求管理的井井有条。</p>
<p>话扯这么多，代码怎么实现呢？你可以给 Service Worker 添加一个 fetch 的事件监听器，接着调用 event 上的 <code>respondWith()</code> 方法来劫持我们的 HTTP 响应，然后你可以用自己的魔法来更新他们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 来来来，代理可以搞一些代理的事情</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 Service Worker 有自己的返回，就直接返回，减少一次 http 请求</span></span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 service worker 没有返回，那就得直接请求真实远程服务</span></span><br><span class="line">            <span class="keyword">var</span> request = event.request.clone(); <span class="comment">// 把原始请求拷过来</span></span><br><span class="line">            <span class="keyword">return</span> fetch(request).then(<span class="function"><span class="keyword">function</span> (<span class="params">httpRes</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// http请求的返回已被抓到，可以处置了。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求失败了，直接返回失败的结果就好了。。</span></span><br><span class="line">                <span class="keyword">if</span> (!httpRes || httpRes.status !== <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> httpRes;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">                <span class="keyword">var</span> responseClone = httpRes.clone();</span><br><span class="line">                caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                    cache.put(event.request, responseClone);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> httpRes;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>install</code> 的时候进行静态资源缓存，也可以通过 <code>fetch</code> 事件处理回调来代理页面请求从而实现动态资源缓存。</p>
<p>两种方式可以比较一下：</p>
<ul>
<li>on install 的优点是第二次访问即可离线，缺点是需要将需要缓存的 URL 在编译时插入到脚本中，增加代码量和降低可维护性；</li>
<li>on fetch 的优点是无需更改编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线可用。</li>
</ul>
<p>除了静态的页面和文件之外，如果对 Ajax 数据加以适当的缓存可以实现真正的离线可用， 要达到这一步可能需要对既有的 Web App 进行一些重构以分离数据和模板。</p>
<h4 id="Service-Worker-版本更新"><a href="#Service-Worker-版本更新" class="headerlink" title="Service Worker 版本更新"></a>Service Worker 版本更新</h4><p><code>/sw.js</code> 控制着页面资源和请求的缓存，那么如果缓存策略需要更新呢？也就是如果 <code>/sw.js</code> 有更新怎么办？<code>/sw.js</code> 自身该如何更新？</p>
<p>如果 <code>/sw.js</code> 内容有更新，当访问网站页面时浏览器获取了新的文件，逐字节比对 <code>/sw.js</code> 文件发现不同时它会认为有更新启动 <a href="https://w3c.github.io/ServiceWorker/#update-algorithm" rel="external nofollow noopener noreferrer" target="_blank">更新算法</a>，于是会安装新的文件并触发 install 事件。但是此时已经处于激活状态的旧的 Service Worker 还在运行，新的 Service Worker 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的 Service Worker 自动停止，新的 Service Worker 才会在接下来重新打开的页面里生效。</p>
<h5 id="自动更新所有页面"><a href="#自动更新所有页面" class="headerlink" title="自动更新所有页面"></a>自动更新所有页面</h5><p>如果希望在有了新版本时，所有的页面都得到及时自动更新怎么办呢？可以在 install 事件中执行 <code>self.skipWaiting()</code> 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 <code>activate</code> 事件发生时，通过执行 <code>self.clients.claim()</code> 方法，更新所有客户端上的 Service Worker。</p>
<p>看一下具体实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">12345678910111213141516171819202122232425</span><span class="comment">// 安装阶段跳过等待，直接进入 active</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(self.skipWaiting());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="built_in">Promise</span>.all([</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新客户端</span></span><br><span class="line">            self.clients.claim(),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清理旧版本</span></span><br><span class="line">            caches.keys().then(<span class="function"><span class="keyword">function</span> (<span class="params">cacheList</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">                    cacheList.map(<span class="function"><span class="keyword">function</span> (<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (cacheName !== <span class="string">'my-test-cache-v1'</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        ])</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外要注意一点，<code>/sw.js</code> 文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件。这会导致更新得不到响应。如遇到该问题，可尝试这么做：在 Web Server 上添加对该文件的过滤规则，不缓存或设置较短的有效期。</p>
<h5 id="手动更新-Service-Worker"><a href="#手动更新-Service-Worker" class="headerlink" title="手动更新 Service Worker"></a>手动更新 Service Worker</h5><p>其实在页面中，也可以手动借助 <code>Registration.update()</code> 更新。</p>
<p>参考如下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123456789</span><span class="keyword">var</span> version = <span class="string">'1.0.1'</span>;</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'sw_version'</span>) !== version) &#123;</span><br><span class="line">        reg.update().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            localStorage.setItem(<span class="string">'sw_version'</span>, version)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="debug-时更新"><a href="#debug-时更新" class="headerlink" title="debug 时更新"></a>debug 时更新</h5><p><a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-debug" rel="external nofollow noopener noreferrer" target="_blank">Service Worker debug 技巧</a> 中也会提到, Service Worker 被载入后立即激活可以保证每次 <code>/sw.js</code> 为最新的。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.skipWaiting();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Service-Worker的生命周期"><a href="#Service-Worker的生命周期" class="headerlink" title="Service Worker的生命周期"></a>Service Worker的生命周期</h2><p>我们已经知道了，Service Worker 的工作原理是基于注册、安装、激活等步骤在浏览器 js 主线程中独立分担缓存任务的，那么我们如何在这些 API 自身一系列的操作中进行一些我们自己想让 worker 干的事情呢？</p>
<p>这里我们需要了解一下 Service Worker 的生命周期的概念，这有利于我们学会在各个生命周期的阶段进行有目的性的回调，让我们自定义的工作在 Service Worker 中正确有效的开展下去。MDN 给出了详细的 Service Worker 生命周期图：</p>
<p><img src="https://gss0.bdstatic.com/9rkZbzqaKgQUohGko9WTAnF6hhy/assets/pwa/projects/1515671916268/sw-lifecycle.png" alt="Service Worker 生命周期"></p>
<p>我们可以看到生命周期分为这么几个状态 <code>安装中</code>, <code>安装后</code>, <code>激活中</code>, <code>激活后</code>, <code>废弃</code></p>
<ul>
<li><strong>安装( installing )</strong>：这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。</li>
</ul>
<p><code>install</code> 事件回调中有两个方法：</p>
<ul>
<li><code>event.waitUntil()</code>：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li><code>self.skipWaiting()</code>：<code>self</code> 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>
<li><strong>安装后( installed )</strong>：Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。</li>
<li><strong>激活( activating )</strong>：在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。</li>
</ul>
<p><code>activate</code> 回调中有两个方法：</p>
<ul>
<li><code>event.waitUntil()</code>：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li><code>self.clients.claim()</code>：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。</li>
<li><strong>激活后( activated )</strong>：在这个状态会处理 <code>activate</code> 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 <code>fetch (请求)</code>、<code>sync (后台同步)</code>、<code>push (推送)</code>。</li>
<li><strong>废弃状态 ( redundant )</strong>：这个状态表示一个 Service Worker 的生命周期结束。</li>
</ul>
<p>这里特别说明一下，进入废弃 (redundant) 状态的原因可能为这几种：</p>
<ul>
<li>安装 (install) 失败</li>
<li>激活 (activating) 失败</li>
<li>新版本的 Service Worker 替换了它并成为激活状态</li>
</ul>
<h2 id="在Vue中使用"><a href="#在Vue中使用" class="headerlink" title="在Vue中使用"></a>在Vue中使用</h2><ul>
<li>npm install workbox-webpack-plugin</li>
<li>在webpack.config.js 中引入插件之后，在plugins中引入这个插件</li>
<li>运行webpack打包，会在dist目录下生成service-worker.js以及manifest</li>
<li>在index.js中通过上节示例中的代码将我们打包生成的service-worker.js进行注册安装</li>
</ul>
<p>具体详细信息可以参看<a href="https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin" rel="external nofollow noopener noreferrer" target="_blank">workbox-webpack-plugin文档</a></p>
<p>该插件其实就是根据vue项目以及打包结果生成一个用于service-worker的相关文件，最终还是需要我们在项目中自己添加service-worker的相关注册安装代码。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>基本数据结构：队列</title>
    <url>/2020/10/02/queue/</url>
    <content><![CDATA[<p>队列是我们编程时必不可少的数据结构，可以用数组实现，也可以用链表实现，但是其实队列也有一些小的地方因为长时间不用而会忘记，这次就来稍微回忆一下。</p>
<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。</p>
<p>我们知道，栈只支持两个基本操作：入栈 push()和出栈 pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p>
<a id="more"></a>

<h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>用数组方式实现的队列就是顺序队列，下面这段例子使用JavaScript语言实现的一个简单版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> <span class="built_in">Array</span>(capacity);</span><br><span class="line">        <span class="keyword">this</span>.n = capacity;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueue(item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail === <span class="keyword">this</span>.n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.items[<span class="keyword">this</span>.tail++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">this</span>.items[<span class="keyword">this</span>.head++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码其实有一个很严重问题，那就是随着不断地入队，出队，head和tail都在不断向后移动，直到tail指向了最后，即使此时head前面有空间，也无法把数据插入。</p>
<p>那我们怎么解决这个问题呢？其实有很多方案，但归结一点就是<code>数据搬移</code>，我们这里说其中一种，就是改造以下我们的入队函数，当入队时发现tail已经到了队尾的位置了，把所有的数据搬移到从头部起始，再进行插入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enqueue(item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tail === <span class="keyword">this</span>.n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.head; i &lt; <span class="keyword">this</span>.tail; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.items[i - <span class="keyword">this</span>.head] = <span class="keyword">this</span>.items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.tail -= <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.tail++] = item;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>上面的代码其实已经能够实现一个队列的基本操作了，但是如果tail指向了队列尾部，就会涉及一次数据搬移，还是比较费时的，那我们能不能想个办法把这一步也给省略呢？</p>
<p>这里就涉及到了我大学时期刚学算法课时印象最深的一个设计了，我们把这个队列给掰弯，让它变成一个首位相接的环，这样当tail指向队尾时，再插入数据，tail指针就可以重新指向队列的头部，只要head指针不在头部就行。</p>
<p>在实现代码之前，我们首先要想一想，为什么这样是可以的，有什么要注意的地方？</p>
<p>第一个问题，我们可以回过头来思考以下，head和tail的作用实际上是什么？这两个值其实标记的是[head, tail)区间内的位置是有数据的，区间之外的位置是没有数据的，我们可以把这个items想象成一段铁轨，[head, tail)就是铁轨上的火车，如果这段铁轨是一段线段，那这列火车只能从头向尾移动，一旦移动到尾部，就只能把火车搬回头部，但是如果这段铁轨是个圆，那就可以省略掉把火车搬回头部这一过程。</p>
<p>第二个问题，上面我们也说过[head. tail)区间内的是有数据，这个区间是一个前闭后开空间，也就是说head指向的节点是有数据的，tail指向的是待插入数据的，如果指向了同一个，也就是初始情况，算是没有数据的。那如果我们将这个队列变成循环的，就会出现一个问题，当head = tail时，到底是初始状态还是tail又回来了？而且tail表明接下来可以在这里插入，但其实这里head已经被插入数据了。所以反过来讲我们不能让tail再绕一圈后回到head指向的地方，于是我们需要引入一个类似哨兵的位置，放在head的前面，当tail指向这里就算满队列了。</p>
<p>明白了这两个问题，就可以知道队空的条件为head = tail，队满的条件就是(tail + 1) % n = head</p>
<p>这个时候的代码就应该是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> <span class="built_in">Array</span>(capacity);</span><br><span class="line">        <span class="keyword">this</span>.n = capacity;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueue(item) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.tail + <span class="number">1</span>) % <span class="keyword">this</span>.n === <span class="keyword">this</span>.head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.items[<span class="keyword">this</span>.tail] = item;</span><br><span class="line">        <span class="keyword">this</span>.tail = (<span class="keyword">this</span>.tail + <span class="number">1</span>) % <span class="keyword">this</span>.n;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="keyword">this</span>.tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">this</span>.items[<span class="keyword">this</span>.head];</span><br><span class="line">        <span class="keyword">this</span>.head = (<span class="keyword">this</span>.head + <span class="number">1</span>) % <span class="keyword">this</span>.n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>上面讲的顺序队列无论如何优化，其实都有一个比较大的限制。</p>
<p>这个限制是<strong>数组这种数据结构带来的，那就是必须事先定义好队列的长度，因为数组需要一块连续的内存来保证可以根据下标进行O(1)的随机访问</strong>。</p>
<p>有的人可能会问，Javascript 中的数组长度是可变的啊，其实这个要去看一下Javascript内部对于数组是怎么实现的，一种方案是当我们没有给长度的时候，会帮助我们申请一段内存使用，当发现长度不够时，会帮助我们申请一段更大的内存（一般是1.5倍），然后帮我们把数据拷贝过去。</p>
<p>那如果我们使用链表来实现队列，还会有这个问题吗？答案是没有，因为链表的内存是不连续的，所以不需要事先申请好，而且由于队列的特殊性，我们并不需要根据下标去随机访问，所以说看起来用链表来实现一个队列更好，那我们就先来试一下。</p>
<p>在尝试之前我们还是要想明白两个问题：</p>
<ul>
<li>队空的条件是什么？</li>
<li>队满的条件是什么？</li>
</ul>
<p>针对这两个问题。第一个问题答案是，head指向null，第二个问题是理论上内存还有，就不能存在队满的情况。</p>
<p>这个时候再来写代码就会简单一些，只是要注意下一些所有链表都要注意的问题，比如如何移动这个指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myQueue2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enqueue(item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(item);</span><br><span class="line">            <span class="keyword">this</span>.tail.next = newNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">this</span>.head.val;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码已经可以正常工作了，但是还有几个问题我们要思索一下：</p>
<ul>
<li>会不会有内存泄漏？比如在dequeue到最后head为null时，tail其实还保存着对最后一个节点的引用</li>
<li>哨兵节点在这里有没有用处？</li>
</ul>
<h2 id="两种使用场景"><a href="#两种使用场景" class="headerlink" title="两种使用场景"></a>两种使用场景</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<p>所谓的CAS原子操作，就是Compare and Set就是先比较队尾的数据与自己上次获取的是不是相同的，如果相同的说明队列没有被其他线程更新过，就可以set值进去，如果不相同的，说明队列已经被更新过了。</p>
<p>这个设计思想是不是有点像<a href="https://sunra.top/2019/09/21/blockchain/">区块链</a>？</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Redux的一些常见工具以及与React的联动</title>
    <url>/2021/05/18/react-and-redux/</url>
    <content><![CDATA[<p>在接触Redux的内容时，不免接触了一些它的配套工具，一时之间被这些工具搞得有些混乱，不知道哪个是哪个，他们各自的作用与联系。这篇文章就来简单记录下我的查询结果。</p>
<p>首先说一下这几个工具，redux，redux-thunk，redux-toolkit，react-redux。</p>
<a id="more"></a>

<ul>
<li><strong>Redux</strong>：是核心库，功能简单，只是一个单纯的状态机，但是蕴含的思想不简单，是传说中的“百行代码，千行文档”。</li>
<li><strong>React-Redux</strong>：是跟<code>React</code>的连接库，当<code>Redux</code>状态更新的时候通知<code>React</code>更新组件。</li>
<li><strong>Redux-Thunk</strong>：提供<code>Redux</code>的异步解决方案，弥补<code>Redux</code>功能的不足。</li>
<li><strong>Redux-Toolkit</strong>：Redux Toolkit附带了一些有用的软件包，例如Immer，Redux-Thunk和Reselect。它使React开发人员的工作变得更加轻松，允许他们直接更改状态（不处理不可变性），并应用Thunk之类的中间件（处理异步操作）。它还使用了Redux的一个简单的“选择器”库Reselect来简化reducer函数。</li>
</ul>
<p>也就是说这四者之间的关系时，redux是核心，是一个状态机，redux-thunk的作用是让这个状态机能更好地处理异步（并不是redux没法处理异步），redux-toolkit则是更进一步，让redux写起来更简洁，更可靠，它包含了redux-thunk，所以如果不与react一起，我们可以使用react+react-toolkit</p>
<p>然而单纯的状态机内部变化没法出发react的重新渲染，所以我们需要一个工具帮助我们做这件事，那就是react-redux。</p>
<p>那我们就按照redux，配合redux-thunk，配合redux-toolkit，最终配合react-redux的顺序来看看这个代码怎么写。</p>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>首先是redux的写法，这部分内容可以直接看我的上篇博客，<a href="https://sunra.top/2021/05/11/redux/">Redux入门笔记</a></p>
<h2 id="Redux-Redux-Thunk"><a href="#Redux-Redux-Thunk" class="headerlink" title="Redux + Redux-Thunk"></a>Redux + Redux-Thunk</h2><p>这是redux-thunk官方文档中的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createStore的时候传入thunk中间件</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起网络请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchSecretSauce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'https://www.baidu.com/s?wd=Secret%20Sauce'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个是普通的action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeASandwich</span>(<span class="params">forPerson, secretSauce</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'MAKE_SANDWICH'</span>,</span><br><span class="line">    forPerson,</span><br><span class="line">    secretSauce,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apologize</span>(<span class="params">fromPerson, toPerson, error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'APOLOGIZE'</span>,</span><br><span class="line">    fromPerson,</span><br><span class="line">    toPerson,</span><br><span class="line">    error,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个异步action，先请求网络，成功就makeASandwich，失败就apologize</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeASandwichWithSecretSauce</span>(<span class="params">forPerson</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetchSecretSauce().then(</span><br><span class="line">      (sauce) =&gt; dispatch(makeASandwich(forPerson, sauce)),</span><br><span class="line">      (error) =&gt; dispatch(apologize(<span class="string">'The Sandwich Shop'</span>, forPerson, error)),</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终dispatch的是异步action makeASandwichWithSecretSauce</span></span><br><span class="line">store.dispatch(makeASandwichWithSecretSauce(<span class="string">'Me'</span>));</span><br></pre></td></tr></table></figure>

<p>也就是添加了redux-thunk中间件，你就可以dispatch一个参数为dispatch的函数了，在这个函数内部你就可以做一些异步操作，然后在异步成功以后再真正地dispatch。</p>
<p>同时这个redux-thunk的源码其实非常简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>

<h2 id="Redux-Redux-Toolkit"><a href="#Redux-Redux-Toolkit" class="headerlink" title="Redux + Redux-Toolkit"></a>Redux + Redux-Toolkit</h2><p>因为Redux-Toolkit已经集成了Redux-Thunk，所以就不需要再单独使用Redux-Thunk了。</p>
<p>React和Redux被认为是大规模React应用中管理状态的最佳组合。然而，随着时间的推移，Redux的受欢迎程度下降，原因是：</p>
<ul>
<li>配置Redux Store并不简单。</li>
<li>我们需要几个软件包来使Redux与React一起工作。</li>
<li>Redux需要太多样板代码。</li>
</ul>
<p>Redux Toolkit附带了一些有用的软件包，例如Immer，Redux-Thunk和Reselect。</p>
<ul>
<li><p>Immer可以使React开发人员的工作变得更加轻松，允许他们直接更改状态（不处理不可变性）。</p>
</li>
<li><p>Thunk之类的中间件可以用来处理异步操作。</p>
</li>
<li><p>它还使用了Redux的一个简单的“选择器”库Reselect来简化reducer函数。</p>
</li>
</ul>
<h3 id="Create-a-Redux-Store"><a href="#Create-a-Redux-Store" class="headerlink" title="Create a Redux Store#"></a>Create a Redux Store<a href="https://redux-toolkit.js.org/tutorials/quick-start#create-a-redux-store" rel="external nofollow noopener noreferrer" target="_blank">#</a></h3><p>Create a file named <code>src/app/store.js</code>. Import the <code>configureStore</code> API from Redux Toolkit. We’ll start by creating an empty Redux store, and exporting it:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app/store.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore(&#123;</span><br><span class="line">  reducer: &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>This creates a Redux store, and also automatically configure the Redux DevTools extension so that you can inspect the store while developing.</p>
<h3 id="Provide-the-Redux-Store-to-React"><a href="#Provide-the-Redux-Store-to-React" class="headerlink" title="Provide the Redux Store to React#"></a>Provide the Redux Store to React<a href="https://redux-toolkit.js.org/tutorials/quick-start#provide-the-redux-store-to-react" rel="external nofollow noopener noreferrer" target="_blank">#</a></h3><p>Once the store is created, we can make it available to our React components by putting a React-Redux <code>&lt;Provider&gt;</code> around our application in <code>src/index.js</code>. Import the Redux store we just created, put a <code>&lt;Provider&gt;</code> around your <code>&lt;App&gt;</code>, and pass the store as a prop:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./app/store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="Create-a-Redux-State-Slice"><a href="#Create-a-Redux-State-Slice" class="headerlink" title="Create a Redux State Slice#"></a>Create a Redux State Slice<a href="https://redux-toolkit.js.org/tutorials/quick-start#create-a-redux-state-slice" rel="external nofollow noopener noreferrer" target="_blank">#</a></h3><p>Add a new file named <code>src/features/counter/counterSlice.js</code>. In that file, import the <code>createSlice</code> API from Redux Toolkit.</p>
<p>Creating a slice requires a string name to identify the slice, an initial state value, and one or more reducer functions to define how the state can be updated. Once a slice is created, we can export the generated Redux action creators and the reducer function for the whole slice.</p>
<p>Redux requires that <a href="https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow#immutability" rel="external nofollow noopener noreferrer" target="_blank">we write all state updates immutably, by making copies of data and updating the copies</a>. However, Redux Toolkit’s <code>createSlice</code> and <code>createReducer</code> APIs use <a href="https://immerjs.github.io/immer/" rel="external nofollow noopener noreferrer" target="_blank">Immer</a> inside to allow us to <a href="https://redux.js.org/tutorials/fundamentals/part-8-modern-redux#immutable-updates-with-immer" rel="external nofollow noopener noreferrer" target="_blank">write “mutating” update logic that becomes correct immutable updates</a>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//features/counter/counterSlice.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">'counter'</span>,</span><br><span class="line">  initialState: &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    increment: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Redux Toolkit allows us to write "mutating" logic in reducers. It</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// doesn't actually mutate the state because it uses the Immer library,</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// which detects changes to a "draft state" and produces a brand new</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// immutable state based off those changes</span></span><br><span class="line">      state.value += <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      state.value -= <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    incrementByAmount: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      state.value += action.payload</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action creators are generated for each case reducer function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.actions</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.reducer</span><br></pre></td></tr></table></figure>

<h3 id="Add-Slice-Reducers-to-the-Store"><a href="#Add-Slice-Reducers-to-the-Store" class="headerlink" title="Add Slice Reducers to the Store#"></a>Add Slice Reducers to the Store<a href="https://redux-toolkit.js.org/tutorials/quick-start#add-slice-reducers-to-the-store" rel="external nofollow noopener noreferrer" target="_blank">#</a></h3><p>Next, we need to import the reducer function from the counter slice and add it to our store. By defining a field inside the <code>reducers</code> parameter, we tell the store to use this slice reducer function to handle all updates to that state.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app/store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit'</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">'../features/counter/counterSlice'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore(&#123;</span><br><span class="line">  reducer: &#123;</span><br><span class="line">    counter: counterReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Redux-React-Toolkit-React-Redux"><a href="#Redux-React-Toolkit-React-Redux" class="headerlink" title="Redux + React-Toolkit + React-Redux"></a>Redux + React-Toolkit + React-Redux</h2><h3 id="Use-Redux-State-and-Actions-in-React-Components"><a href="#Use-Redux-State-and-Actions-in-React-Components" class="headerlink" title="Use Redux State and Actions in React Components#"></a>Use Redux State and Actions in React Components<a href="https://redux-toolkit.js.org/tutorials/quick-start#use-redux-state-and-actions-in-react-components" rel="external nofollow noopener noreferrer" target="_blank">#</a></h3><p>Now we can use the React-Redux hooks to let React components interact with the Redux store. We can read data from the store with <code>useSelector</code>, and dispatch actions using <code>useDispatch</code>. Create a <code>src/features/counter/Counter.js</code> file with a <code>&lt;Counter&gt;</code> component inside, then import that component into <code>App.js</code> and render it inside of <code>&lt;App&gt;</code>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//features/counter/Counter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment &#125; <span class="keyword">from</span> <span class="string">'./counterSlice'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter.value)</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          aria-label=<span class="string">"Increment value"</span></span><br><span class="line">          onClick=&#123;() =&gt; dispatch(increment())&#125;</span><br><span class="line">        \&gt;</span><br><span class="line">          Increment</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;count&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          aria-label=<span class="string">"Decrement value"</span></span><br><span class="line">          onClick=&#123;() =&gt; dispatch(decrement())&#125;</span><br><span class="line">        \&gt;</span><br><span class="line">          Decrement</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Connect-API"><a href="#Connect-API" class="headerlink" title="Connect API"></a>Connect API</h3><p>这种是典型的HOC将容器组件和展示组件分离的方式，在hook之前很是流行</p>
<p>具体可以看这里：<a href="https://react-redux.js.org/tutorials/connect" rel="external nofollow noopener noreferrer" target="_blank">https://react-redux.js.org/tutorials/connect</a></p>
<p>参考链接：</p>
<p><a href="https://juejin.cn/post/6869950884231675912" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.cn/post/6869950884231675912</a></p>
<p><a href="https://segmentfault.com/a/1190000039806379" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000039806379</a></p>
<p><a href="https://redux-toolkit.js.org/introduction/getting-started" rel="external nofollow noopener noreferrer" target="_blank">https://redux-toolkit.js.org/introduction/getting-started</a></p>
]]></content>
  </entry>
  <entry>
    <title>React 入门系列（三）Context</title>
    <url>/2021/03/29/react-context/</url>
    <content><![CDATA[<p>这篇博客我们继续来看React的高级指引中关于Context的部分。</p>
<p>这其中会穿插组件组合，render prop，函数式组件的部分知识。</p>
<h2 id="为什么要用到Context"><a href="#为什么要用到Context" class="headerlink" title="为什么要用到Context"></a>为什么要用到Context</h2><p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>
<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<p>就我的理解来说，<strong>如果某个属性需要多个组件公用并层层传递的时候，我们可以使用这种方式</strong>。</p>
<p>为什么要满足这两个条件呢？</p>
<ul>
<li><p>如果单纯地是多个同级组件公用，我们可以用状态提升的方法。</p>
</li>
<li><p>如果单纯地层层传递我们也可以用组件组合的方式。</p>
</li>
</ul>
<h2 id="何时使用-Context"><a href="#何时使用-Context" class="headerlink" title="何时使用 Context"></a>何时使用 Context</h2><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Toolbar theme=&quot;dark&quot; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  // Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。  </span><br><span class="line">  // 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，  </span><br><span class="line">  // 因为必须将这个值层层传递所有组件。  </span><br><span class="line">    return (    </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;  </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme=&#123;this.props.theme&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 context, 我们可以避免通过中间元素传递 props：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class="line">// 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class="line">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。    // 无论多深，任何组件都能读取这个值。    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。    </span><br><span class="line">      return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;        </span><br><span class="line">              &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line">function Toolbar() &#123;  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  // 指定 contextType 读取当前的 theme context。  </span><br><span class="line">  // React 会往上找到最近的 theme Provider，然后使用它的值。  </span><br><span class="line">  // 在这个例子中，当前的 theme 值为 “dark”。  </span><br><span class="line">  static contextType = ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme=&#123;this.context&#125; /&gt;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，要想使用<code>this.context</code>，你首先要定义<code>static contextType</code>为你想要订阅的Context才行。</p>
<p>比如上面这个例子中的<code>static contextType = ThemeContext</code></p>
</blockquote>
<h2 id="使用-Context-之前的考虑"><a href="#使用-Context-之前的考虑" class="headerlink" title="使用 Context 之前的考虑"></a>使用 Context 之前的考虑</h2><p>Context 主要应用场景在于<em>很多</em>不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p>
<p><strong>如果你只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html" rel="external nofollow noopener noreferrer" target="_blank">组件组合（component composition）</a>有时候是一个比 context 更好的解决方案。</strong></p>
<h3 id="组件组合"><a href="#组件组合" class="headerlink" title="组件组合"></a>组件组合</h3><p>比如，考虑这样一个 <code>Page</code> 组件，它层层向下传递 <code>user</code> 和 <code>avatarSize</code> 属性，从而深度嵌套的 <code>Link</code> 和 <code>Avatar</code> 组件可以读取到这些属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&lt;PageLayout user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&lt;NavigationBar user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">  &lt;Avatar user=&#123;user&#125; size=&#123;avatarSize&#125; /&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>如果在最后只有 <code>Avatar</code> 组件真的需要 <code>user</code> 和 <code>avatarSize</code>，那么层层传递这两个 props 就显得非常冗余。而且一旦 <code>Avatar</code> 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。</p>
<p>一种<strong>无需 context</strong> 的解决方案是<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html#containment" rel="external nofollow noopener noreferrer" target="_blank">将 <code>Avatar</code> 组件自身传递下去</a>，因而中间组件无需知道 <code>user</code> 或者 <code>avatarSize</code> 等 props：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Page(props) &#123;</span><br><span class="line">  const user = props.user;</span><br><span class="line">  const userLink = (</span><br><span class="line">    &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  );</span><br><span class="line">  return &lt;PageLayout userLink=&#123;userLink&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在，我们有这样的组件：</span><br><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&lt;PageLayout userLink=&#123;...&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&lt;NavigationBar userLink=&#123;...&#125; /&gt;</span><br><span class="line">// ... 渲染出 ...</span><br><span class="line">&#123;props.userLink&#125;</span><br></pre></td></tr></table></figure>

<p>这种变化下，只有最顶部的 Page 组件需要知道 <code>Link</code> 和 <code>Avatar</code> 组件是如何使用 <code>user</code> 和 <code>avatarSize</code> 的。</p>
<p>这种对组件的<strong><em>控制反转</em></strong>减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p>
<p>而且你的组件并不限制于接收单个子组件。你可能会传递多个子组件，甚至会为这些子组件（children）封装多个单独的“接口（slots）”，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html#containment" rel="external nofollow noopener noreferrer" target="_blank">正如这里的文档所列举的</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Page(props) &#123;</span><br><span class="line">  const user = props.user;</span><br><span class="line">  const content = &lt;Feed user=&#123;user&#125; /&gt;;</span><br><span class="line">  const topBar = (</span><br><span class="line">    &lt;NavigationBar&gt;</span><br><span class="line">      &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">      &lt;/Link&gt;</span><br><span class="line">    &lt;/NavigationBar&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;PageLayout</span><br><span class="line">      topBar=&#123;topBar&#125;</span><br><span class="line">      content=&#123;content&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式足够覆盖很多场景了，在这些场景下你需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流，你可以进一步使用 <a href="https://zh-hans.reactjs.org/docs/render-props.html" rel="external nofollow noopener noreferrer" target="_blank">render props</a>。</p>
<p>但是，有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。</p>
<blockquote>
<p>不知道大家看到这段文档会不会有点懵，我来简单梳理一下：</p>
<ul>
<li>如果你只是想避免属性值在组件的层层传递，那你可以直接用组件组合，也就是直接把要传递的属性直接给最终使用的组件，然后把这个组件层层传递下去。</li>
<li>这种对组件的<strong><em>控制反转</em></strong>减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂</li>
<li>如果又更加复杂的情况，比如子组件需要在渲染前和父组件进行一些交流，可以用到render prop</li>
</ul>
</blockquote>
<h3 id="render-prop"><a href="#render-prop" class="headerlink" title="render prop"></a>render prop</h3><p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>这里只是简单提下概念，具体的render prop的使用我会在以后的博客中分析。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a><code>React.createContext</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>

<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p>
<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</p>
<h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a><code>Context.Provider</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<p>Provider 接收一个 <code>value</code> 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<p>通过新旧值检测来确定变化，使用了与 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description" rel="external nofollow noopener noreferrer" target="_blank"><code>Object.is</code></a> 相同的算法。</p>
<blockquote>
<p>注意</p>
<p>当传递对象给 <code>value</code> 时，检测变化的方式会导致一些问题：详见<a href="https://zh-hans.reactjs.org/docs/context.html#caveats" rel="external nofollow noopener noreferrer" target="_blank">注意事项</a>。</p>
</blockquote>
<h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a><code>Class.contextType</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let value = this.context;</span><br><span class="line">    /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    let value = this.context;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    let value = this.context;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let value = this.context;</span><br><span class="line">    /* 基于 MyContext 组件的值进行渲染 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure>

<p>挂载在 class 上的 <code>contextType</code> 属性会被重赋值为一个由 <a href="https://zh-hans.reactjs.org/docs/context.html#reactcreatecontext" rel="external nofollow noopener noreferrer" target="_blank"><code>React.createContext()</code></a> 创建的 Context 对象。此属性能让你使用 <code>this.context</code> 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p>
<blockquote>
<p>注意：</p>
<p>你只通过该 API 订阅单一 context。如果你想订阅多个，阅读<a href="https://zh-hans.reactjs.org/docs/context.html#consuming-multiple-contexts" rel="external nofollow noopener noreferrer" target="_blank">使用多个 Context</a> 章节</p>
<p>如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="external nofollow noopener noreferrer" target="_blank">public class fields 语法</a>，你可以使用 <code>static</code> 这个类属性来初始化你的 <code>contextType</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass extends React.Component &#123;</span><br><span class="line">  static contextType = MyContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let value = this.context;</span><br><span class="line">    /* 基于这个值进行渲染工作 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a><code>Context.Consumer</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;</span><br><span class="line">&lt;/MyContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<p>一个 React 组件可以订阅 context 的变更，此组件可以让你在<a href="https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class-components" rel="external nofollow noopener noreferrer" target="_blank">函数式组件</a>中可以订阅 context。</p>
<p>这种方法需要一个<a href="https://zh-hans.reactjs.org/docs/render-props.html#using-props-other-than-render" rel="external nofollow noopener noreferrer" target="_blank">函数作为子元素（function as a child）</a>。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 <code>value</code> 值等价于组件树上方离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。</p>
<blockquote>
<p>注意</p>
<p>想要了解更多关于 “函数作为子元素（function as a child）” 模式，详见 <a href="https://zh-hans.reactjs.org/docs/render-props.html" rel="external nofollow noopener noreferrer" target="_blank">render props</a>。</p>
</blockquote>
<h3 id="Context-displayName"><a href="#Context-displayName" class="headerlink" title="Context.displayName"></a><code>Context.displayName</code></h3><p>context 对象接受一个名为 <code>displayName</code> 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p>
<p>示例，下述组件在 DevTools 中将显示为 MyDisplayName：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MyContext = React.createContext(/* some value */);</span><br><span class="line">MyContext.displayName = &apos;MyDisplayName&apos;;</span><br><span class="line">&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span><br><span class="line">&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span><br></pre></td></tr></table></figure>

<p>这里我们再总结下关于这些API的使用和注意事项：</p>
<ul>
<li>创建Context的方法有一种，就是调用<code>const MyContext = React.createContext(defaultValue);</code></li>
<li>订阅Context的方法有两种：<ul>
<li>在你要订阅的组件中<code>static contextType = MyContext;</code>但是这种方法只能订阅一个Context</li>
<li><code>Context.Consumer</code>:这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。</li>
</ul>
</li>
<li>context 对象接受一个名为 <code>displayName</code> 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="动态-Context"><a href="#动态-Context" class="headerlink" title="动态 Context"></a>动态 Context</h3><p>一个更加复杂的方案是对上面的 theme 例子使用动态值（dynamic values）：</p>
<p><strong>theme-context.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: &apos;#000000&apos;,</span><br><span class="line">    background: &apos;#eeeeee&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: &apos;#ffffff&apos;,</span><br><span class="line">    background: &apos;#222222&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const ThemeContext = React.createContext(  themes.dark // 默认值);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里声明了一个Context，默认值是theme.dark</p>
</blockquote>
<p><strong>themed-button.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ThemeContext&#125; from &apos;./theme-context&apos;;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let props = this.props;</span><br><span class="line">    let theme = this.context;    </span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        &#123;...props&#125;</span><br><span class="line">        style=&#123;&#123;backgroundColor: theme.background&#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ThemedButton.contextType = ThemeContext;</span><br><span class="line">export default ThemedButton;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里声明了一个组件，叫做<code>ThemedButton</code></p>
<p>通过<code>ThemedButton.contextType = ThemeContext;</code>的方式让组件订阅了<code>ThemeContext</code></p>
</blockquote>
<p><strong>app.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ThemeContext, themes&#125; from &apos;./theme-context&apos;;</span><br><span class="line">import ThemedButton from &apos;./themed-button&apos;;</span><br><span class="line"></span><br><span class="line">// 一个使用 ThemedButton 的中间组件</span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemedButton onClick=&#123;props.changeTheme&#125;&gt;</span><br><span class="line">      Change Theme</span><br><span class="line">    &lt;/ThemedButton&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.toggleTheme = () =&gt; &#123;</span><br><span class="line">      this.setState(state =&gt; (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme === themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 在 ThemeProvider 内部的 ThemedButton 按钮组件使用 state 中的 theme 值，    </span><br><span class="line">    // 而外部的组件使用默认的 theme 值    </span><br><span class="line">    return (</span><br><span class="line">      &lt;Page&gt;</span><br><span class="line">        &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt;</span><br><span class="line">          &lt;Toolbar changeTheme=&#123;this.toggleTheme&#125; /&gt;</span><br><span class="line">        &lt;/ThemeContext.Provider&gt;</span><br><span class="line">        &lt;Section&gt;</span><br><span class="line">          &lt;ThemedButton /&gt;</span><br><span class="line">        &lt;/Section&gt;</span><br><span class="line">      &lt;/Page&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先<code>ThemeContext.Provider</code>提供了value，所以其内部的Toolbar中使用的是value，而不是ThemeContext的默认值</p>
<p>而下面直接使用的<code>ThemedButton</code>，不在任何<code>ThemeContext.Provider</code>内部，直接使用最近的默认值。</p>
</blockquote>
<h3 id="在嵌套组件中更新-Context"><a href="#在嵌套组件中更新-Context" class="headerlink" title="在嵌套组件中更新 Context"></a>在嵌套组件中更新 Context</h3><p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context：</p>
<p><strong>theme-context.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！</span><br><span class="line">export const ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,  </span><br><span class="line">  toggleTheme: () =&gt; &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>theme-toggler-button.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ThemeContext&#125; from &apos;./theme-context&apos;;</span><br><span class="line"></span><br><span class="line">function ThemeTogglerButton() &#123;</span><br><span class="line">  // Theme Toggler 按钮不仅仅只获取 theme 值，  // 它也从 context 中获取到一个 toggleTheme 函数  </span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (        </span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ThemeTogglerButton;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据我们前面分析的，<code>ThemeContext.Consumer</code>的children是一个函数组件，当Context改变时，就会重新生成组件。</p>
<p>也就是说，当我们theme或者toggleTheme发生变化时，就会利用变化后的值创建一个新的组件出来替换旧的组件。</p>
</blockquote>
<p><strong>app.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ThemeContext, themes&#125; from &apos;./theme-context&apos;;</span><br><span class="line">import ThemeTogglerButton from &apos;./theme-toggler-button&apos;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.toggleTheme = () =&gt; &#123;</span><br><span class="line">      this.setState(state =&gt; (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme === themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // State 也包含了更新函数，因此它会被传递进 context provider。    </span><br><span class="line">    this.state = &#123;      </span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: this.toggleTheme,</span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 整个 state 都被传递进 provider    </span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt;        </span><br><span class="line">          &lt;Content /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Content() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemeTogglerButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.root);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ThemeContext.Provider</code>中渲染Content，Content中渲染<code>ThemeTogglerButton</code>。</p>
<p><code>ThemeContext.Provider</code>提供的value是自身的state。这个state中包含了theme和toggleTheme函数。</p>
<p>当我们在<code>ThemeTogglerButton</code>中触发toggleTheme后，修改的其实是最外层的state。</p>
<p>而这个state又会被<code>ThemeContext.Provider</code>当做value传递下去，从而触发<code>ThemeTogglerButton</code>的更新。</p>
</blockquote>
<p>这种方式本质上与状态提升没什么区别，可以让子组件有方法改变父组件的state，只是这个状态不用层层传递下来。</p>
<h3 id="消费多个-Context"><a href="#消费多个-Context" class="headerlink" title="消费多个 Context"></a>消费多个 Context</h3><p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Theme context，默认的 theme 是 “light” 值</span><br><span class="line">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class="line"></span><br><span class="line">// 用户登录 context</span><br><span class="line">const UserContext = React.createContext(&#123;</span><br><span class="line">  name: &apos;Guest&apos;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;signedInUser, theme&#125; = this.props;</span><br><span class="line"></span><br><span class="line">    // 提供初始 context 值的 App 组件</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;        </span><br><span class="line">        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;          </span><br><span class="line">          &lt;Layout /&gt;</span><br><span class="line">        &lt;/UserContext.Provider&gt;      </span><br><span class="line">      &lt;/ThemeContext.Provider&gt;    </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Layout() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Sidebar /&gt;</span><br><span class="line">      &lt;Content /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个组件可能会消费多个 context</span><br><span class="line">function Content() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;      </span><br><span class="line">          &#123;theme =&gt; (        </span><br><span class="line">              &lt;UserContext.Consumer&gt;          </span><br><span class="line">                  &#123;user =&gt; (            </span><br><span class="line">                      &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;          </span><br><span class="line">                  )&#125;        </span><br><span class="line">              &lt;/UserContext.Consumer&gt;      </span><br><span class="line">          )&#125;   </span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;  </span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;something: &apos;something&apos;&#125;&#125;&gt;        </span><br><span class="line">            &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/MyContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止这种情况，将 value 状态提升到父节点的 state 里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &#123;something: &apos;something&apos;&#125;,    </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider value=&#123;this.state.value&#125;&gt;        </span><br><span class="line">            &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样Provider每次重新渲染的时候，不会对value重新赋值为一个新的对象，而一直都是state.value。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React入门（五）错误边界</title>
    <url>/2021/04/01/react-error-boundary/</url>
    <content><![CDATA[<p>这篇博客我们继续看React文档的高级指引。</p>
<p>这次我们的主要内容是错误边界。</p>
<a id="more"></a>

<h2 id="什么是错误边界"><a href="#什么是错误边界" class="headerlink" title="什么是错误边界"></a>什么是错误边界</h2><p>过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时 <a href="https://github.com/facebook/react/issues/4026" rel="external nofollow noopener noreferrer" target="_blank">产生</a> <a href="https://github.com/facebook/react/issues/6895" rel="external nofollow noopener noreferrer" target="_blank">可能无法追踪的</a> <a href="https://github.com/facebook/react/issues/8579" rel="external nofollow noopener noreferrer" target="_blank">错误</a>。这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。</p>
<p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p>
<p>错误边界是一种 React 组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
<blockquote>
<p>注意</p>
<p>错误边界<strong>无法</strong>捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理（<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html#how-about-event-handlers" rel="external nofollow noopener noreferrer" target="_blank">了解更多</a>）</li>
<li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
</blockquote>
<p>如果一个 class 组件中定义了 <a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="external nofollow noopener noreferrer" target="_blank"><code>static getDerivedStateFromError()</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" rel="external nofollow noopener noreferrer" target="_blank"><code>componentDidCatch()</code></a> 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 <code>static getDerivedStateFromError()</code> 渲染备用 UI ，使用 <code>componentDidCatch()</code> 打印错误信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;    // 更新 state 使下一次渲染能够显示降级后的 UI    </span><br><span class="line">      return &#123; hasError: true &#125;;  </span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;    // 你同样可以将错误日志上报给服务器    </span><br><span class="line">      logErrorToMyService(error, errorInfo);  </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;      // 你可以自定义降级后的 UI 并渲染      </span><br><span class="line">        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    </span><br><span class="line">    &#125;</span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以将它作为一个常规组件去使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure>

<p>错误边界的工作方式类似于 JavaScript 的 <code>catch {}</code>，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p>
<p>注意<strong>错误边界仅可以捕获其子组件的错误</strong>，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p>
<h2 id="错误边界应该放置在哪？"><a href="#错误边界应该放置在哪？" class="headerlink" title="错误边界应该放置在哪？"></a>错误边界应该放置在哪？</h2><p>错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。</p>
<h2 id="未捕获错误（Uncaught-Errors）的新行为"><a href="#未捕获错误（Uncaught-Errors）的新行为" class="headerlink" title="未捕获错误（Uncaught Errors）的新行为"></a>未捕获错误（Uncaught Errors）的新行为</h2><p>这一改变具有重要意义，<strong>自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</strong></p>
<h2 id="关于-try-catch-？"><a href="#关于-try-catch-？" class="headerlink" title="关于 try/catch ？"></a>关于 try/catch ？</h2><p><code>try</code> / <code>catch</code> 很棒但它仅能用于命令式代码（imperative code）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  showButton();</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，React 组件是声明式的并且具体指出 <em>什么</em> 需要被渲染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Button /&gt;</span><br></pre></td></tr></table></figure>

<p>错误边界保留了 React 的声明性质，其行为符合你的预期。例如，即使一个错误发生在 <code>componentDidUpdate</code> 方法中，并且由某一个深层组件树的 <code>setState</code> 引起，其仍然能够冒泡到最近的错误边界。</p>
<h2 id="关于事件处理器"><a href="#关于事件处理器" class="headerlink" title="关于事件处理器"></a>关于事件处理器</h2><p>错误边界<strong>无法</strong>捕获事件处理器内部的错误。</p>
<p>React 不需要错误边界来捕获事件处理器中的错误。与 render 方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React 仍然能够知道需要在屏幕上显示什么。</p>
<p>如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript <code>try</code> / <code>catch</code> 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; error: null &#125;;</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    try &#123;      </span><br><span class="line">        // 执行操作，如有错误则会抛出    </span><br><span class="line">    &#125; catch (error) &#123;      </span><br><span class="line">        this.setState(&#123; error &#125;);    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.error) &#123;      </span><br><span class="line">        return &lt;h1&gt;Caught an error.&lt;/h1&gt;    </span><br><span class="line">    &#125;    </span><br><span class="line">    return &lt;button onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/button&gt;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意上述例子只是演示了普通的 JavaScript 行为，并没有使用错误边界。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>首先错误边界也是一个组件，只不过是实现了定义了 <a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="external nofollow noopener noreferrer" target="_blank"><code>static getDerivedStateFromError()</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" rel="external nofollow noopener noreferrer" target="_blank"><code>componentDidCatch()</code></a> 这两个生命周期方法中的任意一个（或两个）。</p>
</li>
<li><p>这个所谓的错误边界的作用类似<code>try/catch</code>，错误边界中间的内容可以类比成try中的内容，而catch到error之后，在错误边界的 <a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror" rel="external nofollow noopener noreferrer" target="_blank"><code>static getDerivedStateFromError()</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch" rel="external nofollow noopener noreferrer" target="_blank"><code>componentDidCatch()</code></a> 中去处理，前者用于渲染备用UI，后者用来打印log。</p>
</li>
<li><p>错误边界<strong>无法</strong>捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理（<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html#how-about-event-handlers" rel="external nofollow noopener noreferrer" target="_blank">了解更多</a>）</li>
<li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react-fiber</title>
    <url>/2021/06/01/react-fiber/</url>
    <content><![CDATA[<p>这几个周算是把慕课上400大洋买的关于React最佳工程实践的课程听的七七八八了，剩下的主要就是两部分，一部分是一些交互的优化，还有一点点关于性能的优化，这两部分我感觉不是很急，可以在我的工作中去慢慢体会。</p>
<p>我目前在react方面的当务之急是，我只学了实践，但是很多东西我都不知道为什么要这样写，比如为什么要setState才能更新，hook是如何生效的，react fiber是什么等等，不了解这些，我感觉自己的react还浮在半空中，没有比较好的落地，所以下一步的计划就是去了解一下原理，至于是否要去阅读源码，下一步再说。</p>
<p>这篇博客的主要内容是读了一下几位国内外大佬的博客，先对react的fiber有个大概的了解</p>
<a id="more"></a>

<h2 id="React-Fiber的诞生背景"><a href="#React-Fiber的诞生背景" class="headerlink" title="React Fiber的诞生背景"></a>React Fiber的诞生背景</h2><p>在页面元素很多，且需要频繁刷新的场景下，React 15 会出现掉帧的现象。</p>
<p>其根本原因，是大量的同步计算任务阻塞了浏览器的 UI 渲染。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中（关于这一段，可以去看我关于浏览器架构的博客：<a href="https://sunra.top/2020/12/03/browser-architecture/），他们之间是互斥的关系。如果">https://sunra.top/2020/12/03/browser-architecture/），他们之间是互斥的关系。如果</a> JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。整个过程是一气呵成，不能被打断的。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p>
<p>解决主线程长时间被 JS 运算占用这一问题的基本思路，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。</p>
<p>旧版 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。而<code>Fiber</code>实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现方式是使用了浏览器的<code>requestIdleCallback</code>这一 API。官方的解释是这样的：</p>
<blockquote>
<p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。</p>
</blockquote>
<h2 id="React-Fiber简介"><a href="#React-Fiber简介" class="headerlink" title="React Fiber简介"></a>React Fiber简介</h2><p>React 框架内部的运作可以分为 3 层：</p>
<ul>
<li>Virtual DOM 层，描述页面长什么样。</li>
<li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
<li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
</ul>
<p>这次改动最大的当属 Reconciler 层了，React 团队也给它起了个新的名字，叫<code>Fiber Reconciler</code>。这就引入另一个关键词：Fiber。</p>
<p>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示（这个只是简单版的，还有很多其他属性）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了加以区分，以前的 Reconciler 被命名为<code>Stack Reconciler</code>。Stack Reconciler 运作的过程是不能被打断的，必须一条道走到黑：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1622505912/origin-of-ray/bVboIrF_jbskrs.png" alt></p>
<p>而 Fiber Reconciler 每执行一段时间，都会将控制权交回给浏览器，可以分段执行：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1622505935/origin-of-ray/bVboJj4_drxyog.png" alt></p>
<p>为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配。任务的优先级有六种：</p>
<ul>
<li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li>
<li>task，在next tick之前执行</li>
<li>animation，下一帧之前执行</li>
<li>high，在不久的将来立即执行</li>
<li>low，稍微延迟执行也没关系</li>
<li>offscreen，下一次render时或scroll时才执行</li>
</ul>
<p>优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。</p>
<p>Fiber Reconciler 在执行过程中，会分为 2 个阶段。</p>
<ul>
<li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。</li>
<li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li>
</ul>
<p>阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</p>
<p>Fiber Reconciler 在阶段一进行 Diff 计算的时候，会生成一棵 Fiber 树。这棵树是在 Virtual DOM 树的基础上增加额外的信息来生成的，它本质来说是一个链表。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1622505970/origin-of-ray/bVboJHa_lnhgaq.png" alt></p>
<p>Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1622505995/origin-of-ray/bVboJNB_sax2xo.png" alt></p>
<p>如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。</p>
<p>在构造 Fiber 树的过程中，Fiber Reconciler 会将需要更新的节点信息保存在<code>Effect List</code>当中，在阶段二执行的时候，会批量更新相应的节点。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://segmentfault.com/a/1190000018250127" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000018250127</a></li>
<li><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React入门系列（一）语法与概念初读</title>
    <url>/2021/03/18/react-grammar/</url>
    <content><![CDATA[<p>研究了很久的Vue，突然对它的老朋友React有点感兴趣，就去初步读了一下它的文档，发现确实很多东西与Vue有相同或者不同的地方，就用这篇博客记录下，我对它文档阅读的一些笔记。</p>
<p>比较的同时，以我所理解的Vue源码思路的角度，去解读一些React背后可能的原理</p>
<a id="more"></a>

<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>React中的数据有两种存储方式，一种叫state，一种叫prop。</p>
<h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>prop就对应于Vue中的prop，prop是从父组件传给子组件的，在子组件中是不可改变的，想要改变只能通过子组件触发更新事件，父组件监听后在父组件中改变。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>state就对应于Vue中在每个组件内部定义的data，是组件内部的属性，组件对其中的每个属性都有完全的操作权。</p>
<p>不过有一点区别就是，Vue中对data的赋值操作会直接触发视图更新，因为Vue其实劫持了所有data中数据的setter方法，通过setter方法去通知视图更新。</p>
<p>而React中则通过setState去手动通知视图更新。其实这个setState我感觉是做了和Vue中setter相同的事。</p>
<p>同时React文档中多个setState会合并一起执行，也就是本来多次的视图更新会被合并到一次。</p>
<p>而Vue文档中说的是，每个setter触发的视图更新的操作会进入一个队列，叫做一个tick，每个tick会把所有队列中的数据顺序执行，其实和多个setState一起执行最终结果是相同的。</p>
<h2 id="JSX-amp-Template"><a href="#JSX-amp-Template" class="headerlink" title="JSX &amp; Template"></a>JSX &amp; Template</h2><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><p>Vue中提供了template的方式去构建组件，在解析的时候，其实是通过Vue自己改造的html-parser将template当做一个普通的html解析，对于用户自定义的组件，和Vue自定义的属性，如v-on等会加以特殊处理，然后返回render函数</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>React的JSX则是通过babel将JSX语法转换为React的createElement方法，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="函数返回JSX"><a href="#函数返回JSX" class="headerlink" title="函数返回JSX"></a>函数返回JSX</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式其实都定义了一个Welcome组件，需要注意的是，React中自定义组件的名字首字母必须大写。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>例如，传统的 HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 React 中略微不同：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span>  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code> 。例如，传统的 HTML 中阻止链接默认打开一个新页面，你可以这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 React 中，可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;    e.preventDefault();    console.log('The link was clicked.');  &#125;</span><br><span class="line">  return (</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>      Click me</span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this的绑定问题"><a href="#this的绑定问题" class="headerlink" title="this的绑定问题"></a>this的绑定问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">'ON'</span> : <span class="string">'OFF'</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Toggle /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里为什么要在构造函数中对函数内部的方法调用bind？</p>
<p>首先要理解bind的作用，他会返回一个新的函数，这个函数的this指针是确定的，就是他的参数，当我们调用这个新的函数时，其中的this不是动态的。</p>
<p>置于为什么要这样，原因在于，这个handleClick中需要用到子组件的setSstate,而这个handleClick其实是在父组件中调用的，如果不绑定，那这个this其实指向的是父组件。</p>
<p>如果觉得使用 <code>bind</code> 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="external nofollow noopener noreferrer" target="_blank">public class fields 语法</a>，你可以使用 class fields 正确的绑定回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。  // 注意: 这是 *实验性* 语法。  handleClick = () =&gt; &#123;    console.log('this is:', this);  &#125;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/facebookincubator/create-react-app" rel="external nofollow noopener noreferrer" target="_blank">Create React App</a> 默认启用此语法。</p>
<p>如果你没有使用 class fields 语法，你可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="external nofollow noopener noreferrer" target="_blank">箭头函数</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 此语法确保 `handleClick` 内的 `this` 已被绑定。    return (      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;        Click me</span></span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这两种方法能解决问题的原因在于使用了箭头函数，而箭头函数的this是静态作用域的，也就是声明箭头函数时定义好的，也不会改变，与bind是相同的作用。</p>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://react.docschina.org/docs/react-component.html#setstate" rel="external nofollow noopener noreferrer" target="_blank"><code>setState()</code></a>来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<p>例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">''</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);  &#125;</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'提交的名字: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="提交" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h2><p>这一部分直接看官方文档就好，没什么难理解的地方：<a href="https://react.docschina.org/docs/thinking-in-react.html" rel="external nofollow noopener noreferrer" target="_blank">https://react.docschina.org/docs/thinking-in-react.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React Hook的历史以及实战中的坑</title>
    <url>/2021/05/13/react-hook/</url>
    <content><![CDATA[<h2 id="Hook-的发展历程"><a href="#Hook-的发展历程" class="headerlink" title="Hook 的发展历程"></a>Hook 的发展历程</h2><p>React 团队从一开始就很注重 React 的代码复用性</p>
<p>他们对代码复用性的解决方案历经：Mixin, HOC, Render Prop，直到现在的 Custom Hook</p>
<p>所以 Custom Hook 并不是一拍脑门横空出世的产物，即使是很多对 Custom Hook 有丰富开发经验的开发者，也不了解 Hook 到底是怎么来的，以及在 React 里扮演什么角色</p>
<p>不理解这段设计思路是无法深刻的理解 Custom Hook 的，今天我们就一起来学习一下</p>
<a id="more"></a>

<h3 id="1-Mixin"><a href="#1-Mixin" class="headerlink" title="1. Mixin"></a>1. Mixin</h3><p>这种方式在Vue2中很常见，也是其源码中的重要组成部分，比如父子组件生命周期函数的merge</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SetIntervalMixin = &#123;</span><br><span class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  setInterval: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals.push(setInterval.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intervals.forEach(clearInterval);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createReactClass = <span class="built_in">require</span>(<span class="string">'create-react-class'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TickTock = createReactClass(&#123;</span><br><span class="line">  mixins: [SetIntervalMixin], <span class="comment">// 使用 mixin</span></span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">seconds</span>: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>); <span class="comment">// 调用 mixin 上的方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">seconds</span>: <span class="keyword">this</span>.state.seconds + <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        React has been running <span class="keyword">for</span> &#123;<span class="keyword">this</span>.state.seconds&#125; seconds.</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;TickTock /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>确实起到了重用代码的作用</li>
</ol>
<p>缺点：</p>
<ol>
<li>它是隐式依赖，隐式依赖被认为在 React 中是不好的</li>
<li>名字冲突问题</li>
<li>只能在 <code>React.createClass</code>里工作，不支持 ES6 的 Class Component</li>
<li>实践下来发现：难以维护</li>
</ol>
<p>在 React 官网中已经被标记为 ‘不推荐使用’，官方吐槽点<a href="https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" rel="external nofollow noopener noreferrer" target="_blank">这里</a></p>
<h3 id="2-HOC"><a href="#2-HOC" class="headerlink" title="2. HOC"></a>2. HOC</h3><p>2015 年开始，React 团队宣布不推荐使用 Mixin，推荐大家使用 HOC 模式</p>
<p>HOC 采用了 ‘装饰器模式’ 来复用代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withWindowWidth</span>(<span class="params">BaseComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      windowWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        windowWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.onResize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.onResize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">BaseComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DerivedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Window width is: &#123;props.windowWidth&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经典的 容器组件与展示组件分离 (separation of container presidential) 就是从这里开始的</p>
<p>下面是最最经典的 HOC 容器组件与展示组件分离 案例 - Redux中的connect 的实例代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createInfoScreen = <span class="function">(<span class="params">ChildComponent, fetchData, dataName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HOComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line">    handleIncrementCounter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.setState(&#123; <span class="attr">counter</span>: <span class="keyword">this</span>.state.counter + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.fetchData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data = &#123;&#125;, isFetching, error &#125; = <span class="keyword">this</span>.props[dataName]; </span><br><span class="line">      <span class="keyword">if</span> (isFetching) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;Loading&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      if (error) &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">          &lt;div&gt;Something is wrong. Please try again!&lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;div&gt;No Data!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      return (</span></span><br><span class="line"><span class="regexp">        &lt;ChildComponent </span></span><br><span class="line"><span class="regexp">          counter=&#123;this.state.counter&#125;</span></span><br><span class="line"><span class="regexp">          onIncrementCounterClick=&#123;this.handleIncrementCounter&#125;</span></span><br><span class="line"><span class="regexp">          &#123;...this.props&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dataSelector = <span class="function"><span class="params">state</span> =&gt;</span> state[dataName];</span><br><span class="line">  <span class="keyword">const</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> createSelector(dataSelector, data =&gt; data);</span><br><span class="line">  <span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = getData();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      [dataName]: data(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HOComponent.propTypes = &#123;</span><br><span class="line">    fetchData: PropTypes.func.isRequired,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HOComponent.displayName = <span class="string">`createInfoScreen(<span class="subst">$&#123;getDisplayName(HOComponent)&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    &#123; fetchData &#125;,</span><br><span class="line">  )(HOComponent);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>可以在任何组件包括 Class Component 中工作</li>
<li>它所倡导的 容器组件与展示组件分离 原则做到了：关注点分离</li>
</ol>
<p>缺点：</p>
<ol>
<li>不直观，难以阅读</li>
<li>名字冲突</li>
<li>组件层层层层层层嵌套</li>
</ol>
<h3 id="3-Render-Prop"><a href="#3-Render-Prop" class="headerlink" title="3. Render Prop"></a>3. Render Prop</h3><p>2017 年开始，Render Prop 流行了起来</p>
<p>Render Prop 采用了 ‘代理模式’ 来复用代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWidth</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  propTypes = &#123;</span><br><span class="line">    children: PropTypes.func.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    windowWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      windowWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.onResize)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.onResize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.windowWidth);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;WindowWidth&gt;</span><br><span class="line">      &#123;width =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Window width is: &#123;width&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/WindowWidth&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>React Router 也采用了这样的API设计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path = &quot;/about&quot; render= &#123; (props) =&gt; &lt;About &#123;...props&#125; /&gt;&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>灵活</li>
</ol>
<p>缺点：</p>
<ol>
<li>难以阅读，难以理解</li>
</ol>
<h3 id="4-Hook"><a href="#4-Hook" class="headerlink" title="4. Hook"></a>4. Hook</h3><p>2018 年，React 团队宣布推出一种全新的重用代码的方式 - React Hook</p>
<p>它的核心改变是：允许函数式组件存储自己的状态，在这之前函数式组件是不能有自己的状态的</p>
<p>这个改变使我们可以像抽象一个普通函数一样抽象React组件中的逻辑</p>
<p>实现的原理：闭包</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useWindowsWidth = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isScreenSmall, setIsScreenSmall] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> checkScreenSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setIsScreenSmall(<span class="built_in">window</span>.innerWidth &lt; <span class="number">600</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    checkScreenSize();</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, checkScreenSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">"resize"</span>, checkScreenSize);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isScreenSmall;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWindowsWidth;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> useWindowWidth <span class="keyword">from</span> <span class="string">'./useWindowWidth.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> onSmallScreen = useWindowWidth();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Return some elements</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>提取逻辑出来非常容易</li>
<li>非常易于组合</li>
<li>可读性非常强</li>
<li>没有名字冲突问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>Hook有自身的用法限制: 只能在组件顶层使用，只能在组件中使用</li>
<li>由于原理为闭包，所以极少数情况下会出现难以理解的问题</li>
</ol>
<h2 id="Hook使用过程中需要注意的几个点"><a href="#Hook使用过程中需要注意的几个点" class="headerlink" title="Hook使用过程中需要注意的几个点"></a>Hook使用过程中需要注意的几个点</h2><h3 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WatchCount() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(function() &#123;</span><br><span class="line">    setInterval(function log() &#123;</span><br><span class="line">      console.log(`Count is: $&#123;count&#125;`);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1) &#125;&gt;</span><br><span class="line">        加1</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码大家认为会打印什么？<br>没错，每次打印出来的都是“Count is 0”</p>
<p>因为我们设置定时器的时候传入的是个函数闭包，这个闭包中已经缓存了count的值，所以每次调用的是同一个log函数。</p>
<p>解决方式也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WatchCount() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(function() &#123;</span><br><span class="line">    const id = setInterval(function log() &#123;</span><br><span class="line">      console.log(`Count is: $&#123;count&#125;`);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">    return function() &#123;</span><br><span class="line">      clearInterval(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]); // 看这里，这行是重点</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1) &#125;&gt;</span><br><span class="line">        Increase</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就告诉useEffect，每当count变化是，重新创建副作用函数。</p>
<p>闭包问题不仅仅是useEffect的问题，而是所有可能用到函数闭包的hook的通用问题。</p>
<h3 id="useState第二个修改state的参数是异步的，需要在下一次渲染才生效"><a href="#useState第二个修改state的参数是异步的，需要在下一次渲染才生效" class="headerlink" title="useState第二个修改state的参数是异步的，需要在下一次渲染才生效"></a>useState第二个修改state的参数是异步的，需要在下一次渲染才生效</h3><h3 id="Hook的无限循环渲染问题"><a href="#Hook的无限循环渲染问题" class="headerlink" title="Hook的无限循环渲染问题"></a>Hook的无限循环渲染问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  // 当obj是基本类型的时候，就不会无限循环</span><br><span class="line">  // 当 obj是对象的时候，就会无限循环</span><br><span class="line">  // 当 obj 是对象的state时，不会无限循环</span><br><span class="line">  const [obj, setObj] = useState(&#123; name: &quot;Jack&quot; &#125;);</span><br><span class="line">  // const obj = 1;</span><br><span class="line">  // const obj = &#123;name: &apos;Jack&apos;&#125;</span><br><span class="line">  const [num, setNum] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;effect&quot;);</span><br><span class="line">    setNum(num + 1);</span><br><span class="line">  &#125;, [obj]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &#123;num&#125;</span><br><span class="line">      &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们分析下为什么obj是普通对象时会触发无限渲染</p>
<p>第一次渲染时，执行useEffect的副作用，也就是会调用setNum去更新num</p>
<p>调用了setNum会更新num，导致组件重新渲染，这个时候obj已经是另一个对象了（虽然属性和值完全相同，但是地址已经变了，而react比较useEffect的方式很粗暴，应该也是为了性能的原因，只是简单的判等），所以又会重新执行setNum，又会出发重新渲染，所以进入了无限循环。</p>
<p>明白了obj是对象的时候为什么会无限渲染，我们就可以理解obj是基础类型的时候为什么不会进入无限循环了。</p>
<p><strong>而当obj是个state时，除非手动调用对应的setState，react不会认为state发生了改变</strong></p>
<h3 id="useState惰性初始化"><a href="#useState惰性初始化" class="headerlink" title="useState惰性初始化"></a>useState惰性初始化</h3><p>useState如果第一个参数传入一个函数，作用并不是以这个函数作为state的初始值，而是这个函数的返回值作为初始值，这叫做惰性初始化。所以尽量不要用useState保存函数。</p>
<h3 id="useRef返回值并不是组件状态，所以它的改变不会触发重新渲染，而且它每次渲染会返回同一个值"><a href="#useRef返回值并不是组件状态，所以它的改变不会触发重新渲染，而且它每次渲染会返回同一个值" class="headerlink" title="useRef返回值并不是组件状态，所以它的改变不会触发重新渲染，而且它每次渲染会返回同一个值"></a>useRef返回值并不是组件状态，所以它的改变不会触发重新渲染，而且它每次渲染会返回同一个值</h3><p>本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。</p>
<p>你应该熟悉 ref 这一种<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">访问 DOM</a> 的主要方式。如果你将 ref 对象以 <code>&lt;div ref={myRef} /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 <code>.current</code> 属性设置为相应的 DOM 节点。</p>
<p>然而，<code>useRef()</code> 比 <code>ref</code> 属性更有用。它可以<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="external nofollow noopener noreferrer" target="_blank">很方便地保存任何可变值</a>，其类似于在 class 中使用实例字段的方式。</p>
<p>这是因为它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>
<p>请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node" rel="external nofollow noopener noreferrer" target="_blank">回调 ref</a> 来实现。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1620866482/origin-of-ray/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210513084055_cx2rak.jpg" alt><code></code></p>
<p>也就是说这段代码即使你点击了setCallback也不会触发重新渲染，所以点击call callback调用的还是一开始的callback</p>
<p>可以将call callback的onClick改为 () =&gt; callbackRef.current()</p>
<blockquote>
<p>注意，改成onclick={callbackRef.current}无效，这个和图上的形式没什么区别</p>
</blockquote>
<h3 id="自定义hook中如果要返回函数，可以用useCallback包裹"><a href="#自定义hook中如果要返回函数，可以用useCallback包裹" class="headerlink" title="自定义hook中如果要返回函数，可以用useCallback包裹"></a>自定义hook中如果要返回函数，可以用useCallback包裹</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization" rel="external nofollow noopener noreferrer" target="_blank">memoized</a> 回调函数。</p>
<p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p>
<blockquote>
<p>注意</p>
<p>依赖项数组不会作为参数传给回调函数。虽然从概念上来说它表现为：所有回调函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p>
<p>我们推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" rel="external nofollow noopener noreferrer" target="_blank"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920" rel="external nofollow noopener noreferrer" target="_blank"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p>
</blockquote>
<p>参考链接：<a href="https://www.notion.so/10-7-React-Hook-14e8a28e607f45e2a4787ad9cebbbe66" rel="external nofollow noopener noreferrer" target="_blank">https://www.notion.so/10-7-React-Hook-14e8a28e607f45e2a4787ad9cebbbe66</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React Hook实战总结 - 如何用React Hook写出没那么复杂的项目</title>
    <url>/2021/07/17/react-hook2/</url>
    <content><![CDATA[<p>使用React也有两个月了，总结下这两个月在实战中以及自己买的课程中的关于React Hook的一些收获。</p>
<a id="more"></a>

<h2 id="React为什么要发明Hooks"><a href="#React为什么要发明Hooks" class="headerlink" title="React为什么要发明Hooks"></a>React为什么要发明Hooks</h2><h3 id="React-组件的本质：一个状态到视图的函数"><a href="#React-组件的本质：一个状态到视图的函数" class="headerlink" title="React 组件的本质：一个状态到视图的函数"></a>React 组件的本质：一个状态到视图的函数</h3><p>React 组件的模型其实很直观，就是从 Model 到 View 的映射，这里的 Model 对应到 React 中就是 state 和 props。如下图所示：</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUwNDJlODhmMGY1MjlkZTc2ZGM2NDg4YTliMjJlYmVfcEY0cHhxMDIwRFNNUExrWGlrNHJGUGlxMXhWNkZjMTBfVG9rZW46Ym94Y244enZJQkI5Nmg2SXlLSUt0TXRtc0RmXzE2MjY0Nzk5OTk6MTYyNjQ4MzU5OV9WNA" alt="img"></p>
<p>在过去，我们需要处理当 Model 变化时，DOM 节点应该如何变化的细节问题。而现在，我们只需要通过 JSX，根据 Model 的数据用声明的方式去描述 UI 的最终展现就可以了，因为 React 会帮助你处理所有 DOM 变化的细节。而且，当 Model 中的状态发生变化时，UI 会自动变化，即所谓的数据绑定。</p>
<p>所以呢，我们可以把 UI 的展现看成一个函数的执行过程。其中，Model 是输入参数，函数的执行结果是 DOM 树，也就是 View。而 React 要保证的，就是每当 Model 发生变化时，函数会重新执行，并且生成新的 DOM 树，然后 React 再把新的 DOM 树以最优的方式更新到浏览器。</p>
<p>既然如此，使用 Class 作为组件是否真的合适呢？Class 在作为 React 组件的载体时，是否用了它所有的功能呢？如果你仔细思考，会发现使用 Class 其实是有点牵强的，主要有两方面的原因。</p>
<p>一方面，React 组件之间是不会互相继承的。比如说，你不会创建一个 Button 组件，然后再创建一个 DropdownButton 来继承 Button。所以说，React 中其实是没有利用到 Class 的继承特性的。</p>
<p>另一方面，因为所有 UI 都是由状态驱动的，因此很少会在外部去调用一个类实例（即组件）的方法。要知道，组件的所有方法都是在内部调用，或者作为生命周期方法被自动调用的。</p>
<p>这也是为什么 React 很早就提供了函数组件的机制。只是当时有一个局限是，函数组件无法存在内部状态，必须是纯函数，而且也无法提供完整的生命周期机制。这就极大限制了函数组件的大规模使用。</p>
<h3 id="Hook的诞生：把任何数据源想办法钩进任何函数组件"><a href="#Hook的诞生：把任何数据源想办法钩进任何函数组件" class="headerlink" title="Hook的诞生：把任何数据源想办法钩进任何函数组件"></a>Hook的诞生：把任何数据源想办法钩进任何函数组件</h3><p>其实顺着函数组件的思路继续思考，就会发现，如果我们想要让函数组件更有用，目标就是给函数组件加上状态。这看上去似乎并不是难事。</p>
<p>简单想一下，函数和对象不同，并没有一个实例的对象能够在多次执行之间保存状态，那势必需要一个函数之外的空间来保存这个状态，而且要能够检测其变化，从而能够触发函数组件的重新渲染。</p>
<p>再进一步想，那我们是不是就是需要这样一个机制，能够把一个外部的数据绑定到函数的执行。当数据变化时，函数能够自动重新执行。这样的话，任何会影响 UI 展现的外部数据，都可以通过这个机制绑定到 React 的函数组件。在 React 中，这个机制就是 Hooks。</p>
<p>所以我们现在也能够理解这个机制为什么叫 Hooks 了。顾名思义，Hook 就是“钩子”的意思。在 React 中，Hooks 就是把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。</p>
<p>对于函数组件，这个结果是最终的 DOM 树；所以 Hooks 的结构可以如下图所示：Hooks的作用就是将所有的数据都当作数据源，钩进任何函数组件中，并且可以触发函数组件的更新</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q5MGIyODJiYmEzNDc1MzJkMDgyZjBhNjFlOGRhYTNfMG14ajU4UDFFR0ZrbUpWT2lNSnhTNXR0bFNtV0ZLTm5fVG9rZW46Ym94Y25NOFRnbDl4UjB3cDNhSGJRZDBRR0c1XzE2MjY0Nzk5OTk6MTYyNjQ4MzU5OV9WNA" alt="img"></p>
<h3 id="Hooks带来的好处"><a href="#Hooks带来的好处" class="headerlink" title="Hooks带来的好处"></a>Hooks带来的好处</h3><ul>
<li><blockquote>
<p>逻辑分离</p>
</blockquote>
</li>
<li><blockquote>
<p>关注点分离</p>
</blockquote>
</li>
</ul>
<h4 id="逻辑分离"><a href="#逻辑分离" class="headerlink" title="逻辑分离"></a>逻辑分离</h4><p>就以刚才我们提到的绑定窗口大小的场景为例。如果有多个组件需要在用户调整浏览器窗口大小时，重新调整布局，那么我们需要把这样的逻辑提取成一个公共的模块供多个组件使用。以 React 思想，在 JSX 中我们会根据 Size 大小来渲染不同的组件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size === <span class="string">"small"</span>) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SmallComponent</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LargeComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Class 组件的场景下，我们首先需要定义一个高阶组件，负责监听窗口大小变化，并将变化后的值作为 props 传给下一个组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> withWindowSize = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 产生一个高阶组件 WrappedComponent，只包含监听窗口大小的逻辑</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        size: <span class="keyword">this</span>.getSize()</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, <span class="keyword">this</span>.handleResize); </span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">"resize"</span>, <span class="keyword">this</span>.handleResize);</span><br><span class="line">    &#125;</span><br><span class="line">    getSize() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.innerWidth &gt; <span class="number">1000</span> ? <span class="string">"large"</span> ：<span class="string">"small"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handleResize = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> currentSize = <span class="keyword">this</span>.getSize();</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        size: <span class="keyword">this</span>.getSize()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 将窗口大小传递给真正的业务逻辑组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">size</span>=<span class="string">&#123;this.state.size&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; size &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (size === <span class="string">"small"</span>) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SmallComponent</span> /&gt;</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LargeComponent</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 withWindowSize 产生高阶组件，用于产生 size 属性传递给真正的业务组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withWindowSize(MyComponent);</span><br></pre></td></tr></table></figure>

<p>同样的逻辑如果用 Hooks 和函数组件该如何实现。首先我们需要实现一个 Hooks：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.innerWidth &gt; <span class="number">1000</span> ? <span class="string">"large"</span> : <span class="string">"small"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> useWindowSize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [size, setSize] = useState(getSize());</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setSize(getSize())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> size = useWindowSize();</span><br><span class="line">  <span class="keyword">if</span> (size === <span class="string">"small"</span>) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SmallComponent</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LargeComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="关注分离"><a href="#关注分离" class="headerlink" title="关注分离"></a>关注分离</h4><p>Hooks 的另一大好处：有助于关注分离除了逻辑复用之外，Hooks 能够带来的另外一大好处就是有助于关注分离，意思是说 Hooks 能够让针对同一个业务逻辑的代码尽可能聚合在一块儿。</p>
<p>这是过去在 Class 组件中很难做到的。因为在 Class 组件中，你不得不把同一个业务逻辑的代码分散在类组件的不同生命周期的方法中。所以通过 Hooks 的方式，把业务逻辑清晰地隔离开，能够让代码更加容易理解和维护。</p>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>逻辑分离是可以让逻辑从函数组件中脱离出来，减少函数组件的长度，</p>
<p>关注分离是可以让相关的逻辑在一起，比如同一个自定义Hook中，而不是散落在函数组件内部的各处。</p>
<p>突然发现，之前喜欢把各种useState，useEffect都塞进函数组件中不是很好，这就导致了函数组件会很长，而且又让所有逻辑都在一个函数中混杂了，完全没用到逻辑分离和关注分离的好处。</p>
<h2 id="几个内置Hooks的作用以及使用思考"><a href="#几个内置Hooks的作用以及使用思考" class="headerlink" title="几个内置Hooks的作用以及使用思考"></a>几个内置Hooks的作用以及使用思考</h2><h3 id="useState：让函数组件具有维持状态的能力"><a href="#useState：让函数组件具有维持状态的能力" class="headerlink" title="useState：让函数组件具有维持状态的能力"></a>useState：让函数组件具有维持状态的能力</h3><p>useState 这个 Hook 就是用来管理 state 的，它可以让函数组件具有维持状态的能力。也就是说，在一个函数组件的多次渲染之间，这个 state 是共享的。下面这个例子就显示了 useState 的用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个保存 count 的 state，并给初始值 0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        +</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>useState 这个 Hook 的用法总结出来就是这样的：</p>
<ol>
<li>useState(initialState) 的参数 initialState 是创建 state 的初始值，它可以是任意类型，比如数字、对象、数组等等（如果你想要缓存一个函数，应该使用useCallback，如果useState的initialState是个函数，则会缓存函数的返回结果）。</li>
<li>useState() 的返回值是一个有着两个元素的数组。第一个数组元素用来读取 state 的值，第二个则是用来设置这个 state 的值。在这里要注意的是，state 的变量（例子中的 count）是只读的，所以我们必须通过第二个数组元素 setCount 来设置它的值。</li>
<li>如果要创建多个 state，那么我们就需要多次调用 useState。</li>
</ol>
<blockquote>
<p>通常来说，我们要遵循的一个原则就是：state 中不要保存可以通过计算得到的值。</p>
</blockquote>
<ul>
<li><blockquote>
<p>从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。</p>
</blockquote>
</li>
<li><blockquote>
<p>从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。</p>
</blockquote>
</li>
<li><blockquote>
<p>从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。</p>
</blockquote>
</li>
</ul>
<h3 id="useEffect：执行副作用"><a href="#useEffect：执行副作用" class="headerlink" title="useEffect：执行副作用"></a>useEffect：执行副作用</h3><p>useEffect ，顾名思义，用于执行一段副作用。什么是副作用呢？</p>
<p>通常来说，副作用是指一段和当前执行结果无关的代码。比如说要修改函数外部的某个变量，要发起一个请求，等等。</p>
<p>也就是说，在函数组件的当次执行过程中，useEffect 中代码的执行是不影响渲染出来的 UI 的。</p>
<p>对应到 Class 组件，那么 useEffect 就涵盖了 ComponentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期方法。不过如果你习惯了使用 Class 组件，那千万不要按照把 useEffect 对应到某个或者某几个生命周期的方法。你只要记住，useEffect 是每次组件 render 完后判断依赖并执行就可以了。</p>
<p>useEffect 还有两个特殊的用法：没有依赖项，以及依赖项作为空数组。我们来具体分析下。</p>
<ul>
<li>没有依赖项，则每次 render 后都会重新执行。</li>
<li>空数组作为依赖项，则只在首次执行时触发。</li>
</ul>
<p>除了这些机制之外，useEffect 还允许你返回一个函数，用于在组件销毁的时候做一些清理的操作。比如移除事件的监听。</p>
<p>那么在定义依赖项时，我们需要注意以下三点：</p>
<ul>
<li>依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。</li>
<li>依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。</li>
<li>React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks 时很容易导致 Bug 的地方</li>
</ul>
<h3 id="useCallback：缓存回调函数"><a href="#useCallback：缓存回调函数" class="headerlink" title="useCallback：缓存回调函数"></a>useCallback：缓存回调函数</h3><p>在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p>
<p>比如下面的代码中，我们在加号按钮上定义了一个事件处理函数，用来让计数器加 1。但是因为定义是在函数组件内部，因此在多次渲染之间，是无法重用 handleIncrement 这个函数的，而是每次都需要创建一个新的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> handleIncrement = <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncrement&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次组件状态发生变化的时候，函数组件实际上都会重新执行一遍。在每次执行的时候，实际上都会创建一个新的事件处理函数 handleIncrement。这个事件处理函数中呢，包含了 count 这个变量的闭包，以确保每次能够得到正确的结果。</p>
<p>这也意味着，即使 count 没有发生变化，但是函数组件因为其它状态发生变化而重新渲染时，这种写法也会每次创建一个新的函数。创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。因为这样做不仅增加了系统的开销，更重要的是：每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染。</p>
<h3 id="useMemo：缓存计算的结果"><a href="#useMemo：缓存计算的结果" class="headerlink" title="useMemo：缓存计算的结果"></a>useMemo：缓存计算的结果</h3><p>useMemo 的 API 签名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(fn, deps);</span><br></pre></td></tr></table></figure>

<p>这里的 fn 是产生所需数据的一个计算函数。通常来说，fn 会使用 deps 中声明的一些变量来生成一个结果，用来渲染出最终的 UI。这个场景应该很容易理解：如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算。</p>
<p>举个例子，对于一个显示用户信息的列表，现在需要对用户名进行搜索，且 UI 上需要根据搜索关键字显示过滤后的用户，那么这样一个功能需要有两个状态：</p>
<ul>
<li>用户列表数据本身：来自某个请求。</li>
<li>搜索关键字：用户在搜索框输入的数据。</li>
</ul>
<p>在这个例子中，无论组件为何要进行一次重新渲染，实际上都需要进行一次过滤的操作。但其实你只需要在 users 或者 searchKey 这两个状态中的某一个发生变化时，重新计算获得需要展示的数据就行了。那么，这个时候，我们就可以用 useMemo 这个 Hook 来实现这个逻辑，缓存计算的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 使用 userMemo 缓存计算的结果</span></span><br><span class="line"><span class="keyword">const</span> usersToShow = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!users) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> users.data.filter(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> user.first_name.includes(searchKey));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [users, searchKey]);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>这个时候，如果我们结合 useMemo 和 useCallback 这两个 Hooks 一起看，会发现一个有趣的特性，那就是 useCallback 的功能其实是可以用 useMemo 来实现的。比如下面的代码就是利用 useMemo 实现了 useCallback 的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myEventHandler = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 返回一个函数作为缓存结果</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 在这里进行事件处理</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;, [dep1, dep2]);</span><br></pre></td></tr></table></figure>

<h3 id="useRef：在多次渲染之间共享数据"><a href="#useRef：在多次渲染之间共享数据" class="headerlink" title="useRef：在多次渲染之间共享数据"></a>useRef：在多次渲染之间共享数据</h3><p>在类组件中，我们可以定义类的成员变量，以便能在对象上通过成员属性去保存一些数据。但是在函数组件中，是没有这样一个空间去保存数据的。因此，React 让 useRef 这样一个 Hook 来提供这样的功能。useRef 的 API 签名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myRefContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>

<p>假设你要去做一个计时器组件，这个组件有开始和暂停两个功能。很显然，你需要用 window.setInterval 来提供计时功能；而为了能够暂停，你就需要在某个地方保存这个 window.setInterval 返回的计数器的引用，确保在点击暂停按钮的同时，也能用 window.clearInterval 停止计时器。那么，这个保存计数器引用的最合适的地方，就是 useRef，因为它可以存储跨渲染的数据。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 time state 用于保存计时的累积时间</span></span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量</span></span><br><span class="line">  <span class="keyword">const</span> timer = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始计时的事件处理函数</span></span><br><span class="line">  <span class="keyword">const</span> handleStart = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 current 属性设置 ref 的值</span></span><br><span class="line">    timer.current = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="function">(<span class="params">time</span>) =&gt;</span> time + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂停计时的事件处理函数</span></span><br><span class="line">  <span class="keyword">const</span> handlePause = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 clearInterval 来停止计时</span></span><br><span class="line">    <span class="built_in">window</span>.clearInterval(timer.current);</span><br><span class="line">    timer.current = <span class="literal">null</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;time / <span class="number">10</span>&#125; seconds.</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleStart&#125;&gt;Start&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handlePause&#125;&gt;Pause&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用 useRef 保存的数据一般是和 UI 的渲染无关的，因此当 ref 的值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。</p>
<p>除了存储跨渲染的数据之外，useRef 还有一个重要的功能，就是保存某个 DOM 节点的引用。我们知道，在 React 中，几乎不需要关心真实的 DOM 节点是如何渲染和修改的。但是在某些场景中，我们必须要获得真实 DOM 节点的引用，所以结合 React 的 ref 属</p>
<h3 id="useContext：定义全局状态"><a href="#useContext：定义全局状态" class="headerlink" title="useContext：定义全局状态"></a>useContext：定义全局状态</h3><p>React 提供了 Context 这样一个机制，能够让所有在某个组件开始的组件树上创建一个 Context。这样这个组件树上的所有组件，就都能访问和修改这个 Context 了。那么在函数组件里，我们就可以使用 useContext 这样一个 Hook 来管理 Context。</p>
<p>useContext 的 API 签名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>

<p>正如刚才提到的，一个 Context 是从某个组件为根组件的组件树上可用的，所以我们需要有 API 能够创建一个 Context，这就是 React.createContext API，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(initialValue);</span><br></pre></td></tr></table></figure>

<p>这里的 MyContext 具有一个 Provider 的属性，一般是作为组件树的根组件。这里我仍然以 React 官方文档的例子来讲解，即：一个主题的切换机制。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个 Theme 的 Context</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 整个应用使用 ThemeContext.Provider 作为根组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 使用 themes.dark 作为当前 Context </span></span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在 Toolbar 组件中使用一个会使用 Theme 的 Button</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在 Theme Button 中使用 useContext 来获取当前的主题</span></span><br><span class="line"><span class="regexp">function ThemedButton() &#123;</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">      background: theme.background,</span></span><br><span class="line"><span class="regexp">      color: theme.foreground</span></span><br><span class="line"><span class="regexp">    &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里你也许会有点好奇，Context 看上去就是一个全局的数据，为什么要设计这样一个复杂的机制，而不是直接用一个全局的变量去保存数据呢？</p>
<p>答案其实很简单，就是为了能够进行数据的绑定。当这个 Context 的数据发生变化时，使用这个数据的组件就能够自动刷新。但如果没有 Context，而是使用一个简单的全局变量，就很难去实现了。</p>
<p>不过刚才我们看到的其实是一个静态的使用 Context 的例子，直接用了 thems.dark 作为 Context 的值。那么如何让它变得动态呢？比如说常见的切换黑暗或者明亮模式的按钮，用来切换整个页面的主题。事实上，动态 Context 并不需要我们学习任何新的 API，而是利用 React 本身的机制，通过这么一行代码就可以实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，themes.dark 是作为一个属性值传给 Provider 这个组件的，如果要让它变得动态，其实只要用一个 state 来保存，通过修改 state，就能实现动态的切换 Context 的值了。而且这么做，所有用到这个 Context 的地方都会自动刷新。比如这样的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 state 来保存 theme 从而可以动态修改</span></span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换 theme 的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> toggleTheme = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTheme(<span class="function">(<span class="params">theme</span>) =&gt;</span> (theme === <span class="string">"light"</span> ? <span class="string">"dark"</span> : <span class="string">"light"</span>));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 使用 theme state 作为当前 Context</span></span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes[theme]&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;toggleTheme&#125;&gt;Toggle Theme&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Toolbar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Hooks与生命周期的比较"><a href="#Hooks与生命周期的比较" class="headerlink" title="Hooks与生命周期的比较"></a>Hooks与生命周期的比较</h2><p>生命周期的方式是把组件的创建更新看作一条流水线，你可以在这个流水线上做些什么。而Hooks的方式则是，当状态变化了，要做什么。</p>
<h2 id="如何组织React项目结构"><a href="#如何组织React项目结构" class="headerlink" title="如何组织React项目结构"></a>如何组织React项目结构</h2><p>软件复杂度的根源：复杂的依赖关系</p>
<p>我们经常会说，某个项目看上去好复杂。那么这个“复杂”，到底该怎么定义呢？如果仔细思考就会发现，当某个功能需要层层嵌套的模块依赖，那么即使开发时觉得思路很顺，但是自己再回头去看，或者要让别人理解某个功能实现，就不得不去翻阅很深的调用链。这就是让你觉得复杂的直接原因。那么我们可以这么说，软件复杂度的根源完全来自复杂的依赖关系。</p>
<p>在 components、actions、Hooks 等文件夹下，再按照功能进行分类。而这个分类的做法呢，经常是按照技术功能进行进一步划分，比如 table、modals、pages 等。这种做法其实会增加项目结构的复杂度，开发起来也很不方便，主要体现在两个方面。</p>
<p>一方面，对于一个功能，我们无法直观地知道它相关的代码散落在哪些文件夹中。比如内容管理系统中的分类功能，可能有列表、下拉框、对话框、异步请求逻辑等，它们都在不同的文件夹中。</p>
<p>另一方面，开发一个功能时，切换源代码会非常不方便。比如你在写分类列表功能时，就需要在组件、样式文件、action、reducer 等文件之间频繁地来回切换。而且，如果项目很大，那么你就需要展开很长的树结构，才能找到相应的文件，或者借助文件搜索去导航。不过，文件搜索导航的前提是，你还需要对整个功能的逻辑非常了解，知道有哪些文件。</p>
<p>产生这种开发难度的本质就在于，源代码没有按照业务功能组织在一起，而是从技术角度进行了拆分。所以呢，对于文件夹的组织，我们一定要按领域去组织源代码。一个与领域相关的文件夹，就类似于刚才讲的第一个场景，自身包含了自己需要的所有技术模块，这样无论是理解代码实现，还是开发时切换导航，都会非常方便。</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFkZmZjOGMxOTA4YTlhZjA2ZGVjMzk2YzdhY2E0ODJfcXhuTVplRkxKbzZvVGRJcmFiTGZLSks2WlhjWjBIWTZfVG9rZW46Ym94Y25lcFE2SzRKcXk4cENjYjZGRlFqWDRkXzE2MjY0Nzk5OTk6MTYyNjQ4MzU5OV9WNA" alt="img"></p>
<p>可以看到，整个应用至少包含了文章管理、评论、分类、用户等模块。首先我们知道，一个 React 应用，一定是由一些技术部件组成的，比如 components、routing、actions、store 等，图中我用不同的颜色对这些部件进行了区分。但是呢，如果我们将这些技术部件分散到不同的领域文件夹中，而每个领域文件夹都有自己的 compoents、routing、actions、store 等。这样的话，每一个文件夹就相当于一个小型的项目，包含了与自己相关的所有源代码，就便于理解和开发。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React入门（六）深入JSX</title>
    <url>/2021/04/01/react-jsx/</url>
    <content><![CDATA[<p>这次博客的主要内容是来自React文档高级指引部分的深入JSX相关内容。</p>
<h2 id="JSX是什么"><a href="#JSX是什么" class="headerlink" title="JSX是什么"></a>JSX是什么</h2><p>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖。如下 JSX 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br></pre></td></tr></table></figure>

<p>会编译为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: &apos;blue&apos;, shadowSize: 2&#125;,</span><br><span class="line">  &apos;Click Me&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果没有子节点，你还可以使用自闭合的标签形式，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;sidebar&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>会编译为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  &apos;div&apos;,</span><br><span class="line">  &#123;className: &apos;sidebar&apos;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是说，其实所谓的JSX是需要经过编译生成React的代码的，这一点和Vue的template有点类似，Vue的template也会经过编译生成render函数，在这个函数中，对于每一个标签，都会调用其自身的API来创建vnode。</p>
</blockquote>
<h2 id="指定-React-元素类型"><a href="#指定-React-元素类型" class="headerlink" title="指定 React 元素类型"></a>指定 React 元素类型</h2><p>JSX 标签的第一部分指定了 React 元素的类型。</p>
<p>大写字母开头的 JSX 标签意味着它们是 React 组件。这些标签会被编译为对命名变量的直接引用，所以，当你使用 JSX <code>&lt;Foo /&gt;</code> 表达式时，<code>Foo</code> 必须包含在作用域内。</p>
<h3 id="React-必须在作用域内"><a href="#React-必须在作用域内" class="headerlink" title="React 必须在作用域内"></a>React 必须在作用域内</h3><p>由于 JSX 会编译为 <code>React.createElement</code> 调用形式，所以 <code>React</code> 库也必须包含在 JSX 代码作用域内。</p>
<p>例如，在如下代码中，虽然 <code>React</code> 和 <code>CustomButton</code> 并没有被直接使用，但还是需要导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;import CustomButton from &apos;./CustomButton&apos;;</span><br><span class="line">function WarningButton() &#123;</span><br><span class="line">  // return React.createElement(CustomButton, &#123;color: &apos;red&apos;&#125;, null);  </span><br><span class="line">  return &lt;CustomButton color=&quot;red&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不使用 JavaScript 打包工具而是直接通过 <code>&lt;script&gt;</code> 标签加载 React，则必须将 <code>React</code> 挂载到全局变量中。</p>
<h3 id="在-JSX-类型中使用点语法"><a href="#在-JSX-类型中使用点语法" class="headerlink" title="在 JSX 类型中使用点语法"></a>在 JSX 类型中使用点语法</h3><p>在 JSX 中，你也可以使用点语法来引用一个 React 组件。当你在一个模块中导出许多 React 组件时，这会非常方便。例如，如果 <code>MyComponents.DatePicker</code> 是一个组件，你可以在 JSX 中直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const MyComponents = &#123;</span><br><span class="line">  DatePicker: function DatePicker(props) &#123;</span><br><span class="line">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function BlueDatePicker() &#123;</span><br><span class="line">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户定义的组件必须以大写字母开头"><a href="#用户定义的组件必须以大写字母开头" class="headerlink" title="用户定义的组件必须以大写字母开头"></a>用户定义的组件必须以大写字母开头</h3><p>以小写字母开头的元素代表一个 HTML 内置组件，比如 <code>&lt;div&gt;</code> 或者 <code>&lt;span&gt;</code> 会生成相应的字符串 <code>&#39;div&#39;</code> 或者 <code>&#39;span&#39;</code> 传递给 <code>React.createElement</code>（作为参数）。大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如 <code>&lt;Foo /&gt;</code> 会编译为 <code>React.createElement(Foo)</code>。</p>
<p>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在 JSX 中使用它之前，必须将它赋值给一个大写字母开头的变量。</p>
<p>例如，以下的代码将无法按照预期运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 错误！组件应该以大写字母开头：</span><br><span class="line">function hello(props) &#123; </span><br><span class="line">  // 正确！这种 &lt;div&gt; 的使用是合法的，因为 div 是一个有效的 HTML 标签</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloWorld() &#123;</span><br><span class="line">  // 错误！React 会认为 &lt;hello /&gt; 是一个 HTML 标签，因为它没有以大写字母开头：  </span><br><span class="line">    return &lt;hello toWhat=&quot;World&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，我们需要重命名 <code>hello</code> 为 <code>Hello</code>，同时在 JSX 中使用 <code>&lt;Hello /&gt;</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 正确！组件需要以大写字母开头：</span><br><span class="line">function Hello(props) &#123;  </span><br><span class="line">  // 正确！ 这种 &lt;div&gt; 的使用是合法的，因为 div 是一个有效的 HTML 标签：</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloWorld() &#123;</span><br><span class="line">  // 正确！React 知道 &lt;Hello /&gt; 是一个组件，因为它是大写字母开头的： </span><br><span class="line">    return &lt;Hello toWhat=&quot;World&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在运行时选择类型"><a href="#在运行时选择类型" class="headerlink" title="在运行时选择类型"></a>在运行时选择类型</h3><p>你不能将通用表达式作为 React 元素类型。如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给大写字母开头的变量。这通常用于根据 prop 来渲染不同组件的情况下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // 错误！JSX 类型不能是一个表达式。  </span><br><span class="line">    return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题, 需要首先将类型赋值给一个大写字母开头的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // 正确！JSX 类型可以是大写字母开头的变量。  </span><br><span class="line">    const SpecificStory = components[props.storyType];  </span><br><span class="line">    return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSX-中的-Props"><a href="#JSX-中的-Props" class="headerlink" title="JSX 中的 Props"></a>JSX 中的 Props</h2><p>有多种方式可以在 JSX 中指定 props。</p>
<h3 id="JavaScript-表达式作为-Props"><a href="#JavaScript-表达式作为-Props" class="headerlink" title="JavaScript 表达式作为 Props"></a>JavaScript 表达式作为 Props</h3><p>你可以把包裹在 <code>{}</code> 中的 JavaScript 表达式作为一个 prop 传递给 JSX 元素。例如，如下的 JSX：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>MyComponent</code> 中，<code>props.foo</code> 的值等于 <code>1 + 2 + 3 + 4</code> 的执行结果 <code>10</code>。</p>
<p><code>if</code> 语句以及 <code>for</code> 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function NumberDescriber(props) &#123;</span><br><span class="line">  let description;</span><br><span class="line">  if (props.number % 2 == 0) &#123;    </span><br><span class="line">      description = &lt;strong&gt;even&lt;/strong&gt;;  </span><br><span class="line">  &#125; else &#123;    </span><br><span class="line">      description = &lt;i&gt;odd&lt;/i&gt;;  </span><br><span class="line">  &#125;  </span><br><span class="line">  return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在对应的章节中学习更多关于<a href="https://zh-hans.reactjs.org/docs/conditional-rendering.html" rel="external nofollow noopener noreferrer" target="_blank">条件渲染</a>和<a href="https://zh-hans.reactjs.org/docs/lists-and-keys.html" rel="external nofollow noopener noreferrer" target="_blank">循环</a>的内容。</p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>你可以将字符串字面量赋值给 prop. 如下两个 JSX 表达式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent message=&quot;hello world&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;&apos;hello world&apos;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>当你将字符串字面量赋值给 prop 时，它的值是未转义的。所以，以下两个 JSX 表达式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;&apos;&lt;3&apos;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>这种行为通常是不重要的，这里只是提醒有这个用法。</p>
<h3 id="Props-默认值为-“True”"><a href="#Props-默认值为-“True”" class="headerlink" title="Props 默认值为 “True”"></a>Props 默认值为 “True”</h3><p>如果你没给 prop 赋值，它的默认值是 <code>true</code>。以下两个 JSX 表达式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>通常，我们不建议不传递 value 给 prop，因为这可能与 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015" rel="external nofollow noopener noreferrer" target="_blank">ES6 对象简写</a>混淆，<code>{foo}</code> 是 <code>{foo: foo}</code> 的简写，而不是 <code>{foo: true}</code>。这样实现只是为了保持和 HTML 中标签属性的行为一致。</p>
<h3 id="属性展开"><a href="#属性展开" class="headerlink" title="属性展开"></a>属性展开</h3><p>如果你已经有了一个 props 对象，你可以使用展开运算符 <code>...</code> 来在 JSX 中传递整个 props 对象。以下两个组件是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App1() &#123;</span><br><span class="line">  return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App2() &#123;</span><br><span class="line">  const props = &#123;firstName: &apos;Ben&apos;, lastName: &apos;Hector&apos;&#125;;</span><br><span class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Button = props =&gt; &#123;</span><br><span class="line">  const &#123; kind, ...other &#125; = props;  </span><br><span class="line">  const className = kind === &quot;primary&quot; ? &quot;PrimaryButton&quot; : &quot;SecondaryButton&quot;;</span><br><span class="line">  return &lt;button className=&#123;className&#125; &#123;...other&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button kind=&quot;primary&quot; onClick=&#123;() =&gt; console.log(&quot;clicked!&quot;)&#125;&gt;</span><br><span class="line">        Hello World!</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>kind</code> 的 prop 会被安全的保留，它将<em>不会</em>被传递给 DOM 中的 <code>&lt;button&gt;</code> 元素。 所有其他的 props 会通过 <code>...other</code> 对象传递，使得这个组件的应用可以非常灵活。你可以看到它传递了一个 <code>onClick</code> 和 <code>children</code> 属性。</p>
<p>属性展开在某些情况下很有用，但是也很容易将不必要的 props 传递给不相关的组件，或者将无效的 HTML 属性传递给 DOM。我们建议谨慎的使用该语法。</p>
<h2 id="JSX-中的子元素"><a href="#JSX-中的子元素" class="headerlink" title="JSX 中的子元素"></a>JSX 中的子元素</h2><p>包含在开始和结束标签之间的 JSX 表达式内容将作为特定属性 <code>props.children</code> 传递给外层组件。有几种不同的方法来传递子元素：</p>
<h3 id="字符串字面量-1"><a href="#字符串字面量-1" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>你可以将字符串放在开始和结束标签之间，此时 <code>props.children</code> 就只是该字符串。这对于很多内置的 HTML 元素很有用。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个合法的 JSX，<code>MyComponent</code> 中的 <code>props.children</code> 是一个简单的未转义字符串 <code>&quot;Hello world!&quot;</code>。因此你可以采用编写 HTML 的方式来编写 JSX。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JSX 会移除行首尾的空格以及空行。与标签相邻的空行均会被删除，文本字符串之间的新行会被压缩为一个空格。因此以下的几种方式都是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  Hello World</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JSX-子元素"><a href="#JSX-子元素" class="headerlink" title="JSX 子元素"></a>JSX 子元素</h3><p>子元素允许由多个 JSX 元素组成。这对于嵌套组件非常有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line">  &lt;MyFirstComponent /&gt;</span><br><span class="line">  &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;/MyContainer&gt;</span><br></pre></td></tr></table></figure>

<p>你可以将不同类型的子元素混合在一起，因此你可以将字符串字面量与 JSX 子元素一起使用。这也是 JSX 类似 HTML 的一种表现，所以如下代码是合法的 JSX 并且也是合法的 HTML：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  Here is a list:</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>React 组件也能够返回存储在数组中的一组元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 不需要用额外的元素包裹列表元素！</span><br><span class="line">  return [</span><br><span class="line">    // 不要忘记设置 key :)</span><br><span class="line">    &lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;,</span><br><span class="line">    &lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;,</span><br><span class="line">    &lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-表达式作为子元素"><a href="#JavaScript-表达式作为子元素" class="headerlink" title="JavaScript 表达式作为子元素"></a>JavaScript 表达式作为子元素</h3><p>JavaScript 表达式可以被包裹在 <code>{}</code> 中作为子元素。例如，以下表达式是等价的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent&gt;foo&lt;/MyComponent&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&gt;&#123;&apos;foo&apos;&#125;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>

<p>这对于展示任意长度的列表非常有用。例如，渲染 HTML 列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Item(props) &#123;</span><br><span class="line">  return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;</span><br><span class="line"></span><br><span class="line">function TodoList() &#123;</span><br><span class="line">  const todos = [&apos;finish doc&apos;, &apos;submit pr&apos;, &apos;nag dan to review&apos;];</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125;    </span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 表达式也可以和其他类型的子元素组合。这种做法可以方便地替代模板字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Hello(props) &#123;</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数作为子元素"><a href="#函数作为子元素" class="headerlink" title="函数作为子元素"></a>函数作为子元素</h3><p>通常，JSX 中的 JavaScript 表达式将会被计算为字符串、React 元素或者是列表。不过，<code>props.children</code> 和其他 prop 一样，它可以传递任意类型的数据，而不仅仅是 React 已知的可渲染类型。例如，如果你有一个自定义组件，你可以把回调函数作为 <code>props.children</code> 进行传递：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 调用子元素回调 numTimes 次，来重复生成组件</span><br><span class="line">function Repeat(props) &#123;</span><br><span class="line">  let items = [];</span><br><span class="line">  for (let i = 0; i &lt; props.numTimes; i++) &#123;    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ListOfTenThings() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Repeat numTimes=&#123;10&#125;&gt;</span><br><span class="line">      &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125;    &lt;/Repeat&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以将任何东西作为子元素传递给自定义组件，只要确保在该组件渲染之前能够被转换成 React 理解的对象。这种用法并不常见，但可以用于扩展 JSX。</p>
<h3 id="布尔类型、Null-以及-Undefined-将会忽略"><a href="#布尔类型、Null-以及-Undefined-将会忽略" class="headerlink" title="布尔类型、Null 以及 Undefined 将会忽略"></a>布尔类型、Null 以及 Undefined 将会忽略</h3><p><code>false</code>, <code>null</code>, <code>undefined</code>, and <code>true</code> 是合法的子元素。但它们并不会被渲染。以下的 JSX 表达式渲染结果相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;false&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;null&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;true&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这有助于依据特定条件来渲染其他的 React 元素。例如，在以下 JSX 中，仅当 <code>showHeader</code> 为 <code>true</code> 时，才会渲染 <code>&lt;Header /&gt;</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125;  &lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>值得注意的是有一些 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="external nofollow noopener noreferrer" target="_blank">“falsy” 值</a>，如数字 <code>0</code>，仍然会被 React 渲染。例如，以下代码并不会像你预期那样工作，因为当 <code>props.messages</code> 是空数组时，<code>0</code> 仍然会被渲染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &amp;&amp;    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，确保 <code>&amp;&amp;</code> 之前的表达式总是布尔值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &gt; 0 &amp;&amp;    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>反之，如果你想渲染 <code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code> 等值，你需要先将它们<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion" rel="external nofollow noopener noreferrer" target="_blank">转换为字符串</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分的内容没有什么需要理解的，都是语法问题，只不过有几个地方需要注意：</p>
<ul>
<li>React组件必须在作用域内。</li>
<li>React组件的名称必须以大写开头。</li>
<li>组件标签之间的内容会作为prop.children，它可以是表达式，函数，字符串等等。</li>
<li>值得注意的是有一些 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="external nofollow noopener noreferrer" target="_blank">“falsy” 值</a>，如数字 <code>0</code>，仍然会被 React 渲染。例如，以下代码并不会像你预期那样工作，因为当 <code>props.messages</code> 是空数组时，<code>0</code> 仍然会被渲染：要解决这个问题，确保 <code>&amp;&amp;</code> 之前的表达式总是布尔值：</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React 入门系列（二）Ref</title>
    <url>/2021/03/25/react-ref/</url>
    <content><![CDATA[<p>上一篇博客我大概记录了一下react官方文档中关于核心概念的一些内容和想法，很多内容都是我基于对Vue的理解基础上的猜测。</p>
<p>从这篇博客开始继续去阅读高级指引，本次博客的主题就是React中的Ref。</p>
<a id="more"></a>

<h2 id="Ref的作用"><a href="#Ref的作用" class="headerlink" title="Ref的作用"></a>Ref的作用</h2><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>
<p>在典型的 React 数据流中，<a href="https://zh-hans.reactjs.org/docs/components-and-props.html" rel="external nofollow noopener noreferrer" target="_blank">props</a> 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p>
<p>上面这段话摘自官方文档，简单来说，就是正常情况下，我们只能通过修改state或者prop来触发组件的重新渲染，但是，Ref提供了一种新的方式，可以让你直接去修改自定义组件或者DOM。</p>
<h2 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h2><p>下面是几个适合使用 refs 的情况：</p>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p>避免使用 refs 来做任何可以通过声明式实现来完成的事情。</p>
<p>举个例子，避免在 <code>Dialog</code> 组件里暴露 <code>open()</code> 和 <code>close()</code> 方法，最好传递 <code>isOpen</code> 属性。</p>
<h3 id="什么是声明式"><a href="#什么是声明式" class="headerlink" title="什么是声明式"></a>什么是声明式</h3><p>上面这段话里面提到了声明式，那么什么是声明式呢？</p>
<p>简单来说，就是一种编程范式，它和命令式变成，函数式编程，面向对象编程是同级的概念。</p>
<p>所谓的声明式，就是表明目的，但是不具体指定怎么做。</p>
<p>就像文档中的这个例子，<code>open()</code>是声明式的编程范式，它只说明了目的，而不具体指定怎么做，如果是<code>isOpen=true</code>，那就是命令式的，就是告诉怎么做了，做法就是把isOpen置为true。</p>
<p>具体的可以去看一下：<a href="https://segmentfault.com/a/1190000015924762" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000015924762</a></p>
<h2 id="勿过度使用-Refs"><a href="#勿过度使用-Refs" class="headerlink" title="勿过度使用 Refs"></a>勿过度使用 Refs</h2><p>你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 <a href="https://zh-hans.reactjs.org/docs/lifting-state-up.html" rel="external nofollow noopener noreferrer" target="_blank">状态提升</a> 以获取更多有关示例。</p>
<h2 id="如何使用Ref"><a href="#如何使用Ref" class="headerlink" title="如何使用Ref"></a>如何使用Ref</h2><h3 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h3><p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();  </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h3><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure>

<p>ref 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li>
</ul>
<h4 id="为-DOM-元素添加-ref"><a href="#为-DOM-元素添加-ref" class="headerlink" title="为 DOM 元素添加 ref"></a>为 DOM 元素添加 ref</h4><p>以下代码使用 <code>ref</code> 去存储 DOM 节点的引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    // 创建一个 ref 来存储 textInput 的 DOM 元素</span><br><span class="line">    this.textInput = React.createRef();    </span><br><span class="line">    this.focusTextInput = this.focusTextInput.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    // 直接使用原生 API 使 text 输入框获得焦点</span><br><span class="line">    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br><span class="line">    this.textInput.current.focus();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br><span class="line">    // 构造器里创建的 `textInput` 上</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.textInput&#125; /&gt;        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<blockquote>
<p>通过这句话，我们可以大致猜测一下：</p>
<ul>
<li>在react的源码中，当通过html-parser解析到这里的时候，应该是有一段判断当前组件是否是原生DOM的逻辑，如果是，那么就把这个DOM赋值给<code>this.textInput.current</code></li>
<li>在react的组件生命周期执行序列之间，应该有一段逻辑是去更新ref的。这样才能保证<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</li>
</ul>
</blockquote>
<h4 id="为-class-组件添加-Ref"><a href="#为-class-组件添加-Ref" class="headerlink" title="为 class 组件添加 Ref"></a>为 class 组件添加 Ref</h4><p>如果我们想包装上面的 <code>CustomTextInput</code>，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 <code>focusTextInput</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AutoFocusTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.textInput.current.focusTextInput();  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt;    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这仅在 <code>CustomTextInput</code> 声明为 class 时才有效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过这个例子，我们可以回头理解刚才我们说的：当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</p>
<p>也就是说在这个<code>AutoFocusTextInput</code>组件中，我们又创建了一个新的ref，虽然还叫作<code>textInput</code>，但是这个时候的<code>textInput.current</code>指向的就是<code>CustomTextInput</code>真正挂载的实例，也就是new CustomTestInput()这个实例（这里我们可以大胆猜测下，<customtextinput>背后对应的逻辑，应该是new一个实例出来），那么好，当前我们的<code>textInput.current</code>就是我们刚创建的这个实例，我们就可以调用这个实例上的方法，也就是<code>focusTextInput()</code></customtextinput></p>
</blockquote>
<h4 id="Refs-与函数组件"><a href="#Refs-与函数组件" class="headerlink" title="Refs 与函数组件"></a>Refs 与函数组件</h4><p>默认情况下，<strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyFunctionComponent() &#123;  return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = React.createRef();  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // This will *not* work!</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt;    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从这段来看，上面所说的自定义组件其实是调用了new的说法可能是有问题的。</p>
<p>以为，如果是直接调用的new，那么只有两种解释：</p>
<ul>
<li>第一，new Class和new Function不同，这一点我过一段时间回去看看class的源码再回来填坑。</li>
<li>第二，那就是react源码对于Class和Function做了不同的处理，所以Function的声明方式没有创建实例出来。</li>
</ul>
</blockquote>
<p>如果要在函数组件中使用 <code>ref</code>，你可以使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" rel="external nofollow noopener noreferrer" target="_blank"><code>forwardRef</code></a>（可与 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="external nofollow noopener noreferrer" target="_blank"><code>useImperativeHandle</code></a> 结合使用），或者可以将该组件转化为 class 组件。</p>
<p>不管怎样，你可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  // 这里必须声明 textInput，这样 ref 才可以引用它  const textInput = useRef(null);</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    textInput.current.focus();  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;text&quot;</span><br><span class="line">        ref=&#123;textInput&#125; /&gt;      &lt;input</span><br><span class="line">        type=&quot;button&quot;</span><br><span class="line">        value=&quot;Focus the text input&quot;</span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的forwardRef等会讲Ref转发的时候再说。</p>
</blockquote>
<h3 id="将-DOM-Refs-暴露给父组件"><a href="#将-DOM-Refs-暴露给父组件" class="headerlink" title="将 DOM Refs 暴露给父组件"></a>将 DOM Refs 暴露给父组件</h3><p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。</p>
<p>虽然你可以<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-class-component" rel="external nofollow noopener noreferrer" target="_blank">向子组件添加 ref</a>，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数组件上无效。</p>
<p>如果你使用 16.3 或更高版本的 React, 这种情况下我们推荐使用 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" rel="external nofollow noopener noreferrer" target="_blank">ref 转发</a>。<strong>Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref</strong>。关于怎样对父组件暴露子组件的 DOM 节点，在 <a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components" rel="external nofollow noopener noreferrer" target="_blank">ref 转发文档</a>中有一个详细的例子。</p>
<p>如果你使用 16.2 或更低版本的 React，或者你需要比 ref 转发更高的灵活性，你可以使用<a href="https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509" rel="external nofollow noopener noreferrer" target="_blank">这个替代方案</a>将 ref 作为特殊名字的 prop 直接传递。</p>
<p>可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这个方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 <a href="https://zh-hans.reactjs.org/docs/react-dom.html#finddomnode" rel="external nofollow noopener noreferrer" target="_blank"><code>findDOMNode()</code></a>，但在<a href="https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage" rel="external nofollow noopener noreferrer" target="_blank"><code>严格模式</code></a> 下已被废弃且不推荐使用。</p>
<h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><p>React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。</p>
<p>不同于传递 <code>createRef()</code> 创建的 <code>ref</code> 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。</p>
<p>下面的例子描述了一个通用的范例：使用 <code>ref</code> 回调函数，在实例的属性中存储对 DOM 节点的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput = null;</span><br><span class="line">    this.setTextInputRef = element =&gt; &#123;      this.textInput = element;    &#125;;</span><br><span class="line">    this.focusTextInput = () =&gt; &#123;      // 使用原生 DOM API 使 text 输入框获得焦点      </span><br><span class="line">    	if (this.textInput) this.textInput.focus();    </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 组件挂载后，让文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span><br><span class="line">    // 实例上（比如 this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.setTextInputRef&#125;        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React 将在组件挂载时，会调用 <code>ref</code> 回调函数并传入 DOM 元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 refs 一定是最新的。</p>
<blockquote>
<p>这里有小伙伴可能会钻牛角尖，凭什么传入一个函数，就会被调用啊。</p>
<p>答案很简单，React源码中对于ref属性肯定是有特殊处理的，如果它的值是一个函数，回去调用它。</p>
<p>如果这样猜想，那你其实传进去任何函数，他都会执行，不一定要在函数中设置ref，在ref属性传入的函数中设置一个ref，应该只是约定而已。</p>
</blockquote>
<p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 <code>React.createRef()</code> 创建的对象 refs 一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Parent</code> 把它的 refs 回调函数当作 <code>inputRef</code> props 传递给了 <code>CustomTextInput</code>，而且 <code>CustomTextInput</code> 把相同的函数作为特殊的 <code>ref</code> 属性传递给了 <code>&lt;input&gt;</code>。结果是，在 <code>Parent</code> 中的 <code>this.inputElement</code> 会被设置为与 <code>CustomTextInput</code> 中的 <code>input</code> 元素相对应的 DOM 节点。</p>
<h4 id="关于回调-refs-的说明"><a href="#关于回调-refs-的说明" class="headerlink" title="关于回调 refs 的说明"></a>关于回调 refs 的说明</h4><p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<h2 id="Ref转发"><a href="#Ref转发" class="headerlink" title="Ref转发"></a>Ref转发</h2><p>Ref 转发是一项将 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">ref</a> 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。最常见的案例如下所述。</p>
<h3 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h3><p>考虑这个渲染原生 DOM 元素 <code>button</code> 的 <code>FancyButton</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FancyButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className=&quot;FancyButton&quot;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React 组件隐藏其实现细节，包括其渲染结果。其他使用 <code>FancyButton</code> 的组件<strong>通常不需要</strong>获取内部的 DOM 元素 <code>button</code> 的 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">ref</a>。这很好，因为这防止组件过度依赖其他组件的 DOM 结构。</p>
<p>虽然这种封装对类似 <code>FeedStory</code> 或 <code>Comment</code> 这样的应用级组件是理想的，但其对 <code>FancyButton</code> 或 <code>MyTextInput</code> 这样的高可复用“叶”组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规 DOM <code>button</code> 和 <code>input</code> 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。</p>
<p><strong>Ref 转发是一个可选特性，其允许某些组件接收 <code>ref</code>，并将其向下传递（换句话说，“转发”它）给子组件。</strong></p>
<p>在下面的示例中，<code>FancyButton</code> 使用 <code>React.forwardRef</code> 来获取传递给它的 <code>ref</code>，然后转发到它渲染的 DOM <code>button</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (  </span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;    </span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 你可以直接获取 DOM button 的 ref：</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>

<p>这样，使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 ref ，并在必要时访问，就像其直接使用 DOM <code>button</code> 一样。</p>
<p>以下是对上述示例发生情况的逐步解释：</p>
<ol>
<li>我们通过调用 <code>React.createRef</code> 创建了一个 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" rel="external nofollow noopener noreferrer" target="_blank">React ref</a> 并将其赋值给 <code>ref</code> 变量。</li>
<li>我们通过指定 <code>ref</code> 为 JSX 属性，将其向下传递给 <code>&lt;FancyButton ref={ref}&gt;</code>。</li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code>，作为其第二个参数。</li>
<li>我们向下转发该 <code>ref</code> 参数到 <code>&lt;button ref={ref}&gt;</code>，将其指定为 JSX 属性。</li>
<li>当 ref 挂载完成，<code>ref.current</code> 将指向 <code>&lt;button&gt;</code> DOM 节点。</li>
</ol>
<blockquote>
<p>注意</p>
<p>第二个参数 <code>ref</code> 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 <code>ref</code> 参数，且 props 中也不存在 <code>ref</code>。</p>
<p>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>React入门（四）Render Prop 与 HOC</title>
    <url>/2021/04/01/react-render-prop-and-hoc/</url>
    <content><![CDATA[<p>这篇博客继续来看高级指引。</p>
<p>这次的主题是Render Prop以及高阶组件。</p>
<h2 id="Render-Prop"><a href="#Render-Prop" class="headerlink" title="Render Prop"></a>Render Prop</h2><h3 id="什么是Render-Prop"><a href="#什么是Render-Prop" class="headerlink" title="什么是Render Prop"></a>什么是Render Prop</h3><p>术语 <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="external nofollow noopener noreferrer" target="_blank">“render prop”</a> 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
<p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这段描述，看起来这个<strong>render prop和普通的prop并没有什么区别</strong>，react并不会对一个叫做render的prop做什么特殊处理，你需要自己在组件内部去调用</p>
</blockquote>
<h3 id="使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）"><a href="#使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）" class="headerlink" title="使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）"></a>使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）</h3><p>组件是 React 代码复用的主要单元，但如何将一个组件封装的状态或行为共享给其他需要相同状态的组件并不总是显而易见。</p>
<p>例如，以下组件跟踪 Web 应用程序中的鼠标位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &apos;100vh&apos; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;当前的鼠标位置是 (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当光标在屏幕上移动时，组件在 <code>&lt;p&gt;</code> 中显示其（x，y）坐标。</p>
<p>现在的问题是：我们如何在另一个组件中复用这个行为？换个说法，若另一个组件需要知道鼠标位置，我们能否封装这一行为，以便轻松地与其他组件共享它？？</p>
<p>由于组件是 React 中最基础的代码复用单元，现在尝试重构一部分代码使其能够在 <code>&lt;Mouse&gt;</code> 组件中封装我们需要共享的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &lt;Mouse&gt; 组件封装了我们需要的行为...</span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &apos;100vh&apos; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/* ...但我们如何渲染 &lt;p&gt; 以外的东西? */&#125;</span><br><span class="line">        &lt;p&gt;The current mouse position is (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>&lt;Mouse&gt;</code> 组件封装了所有关于监听 <code>mousemove</code> 事件和存储鼠标 (x, y) 位置的行为，但其仍不是真正的可复用。</p>
<p>举个例子，假设我们有一个 <code>&lt;Cat&gt;</code> 组件，它可以呈现一张在屏幕上追逐鼠标的猫的图片。我们或许会使用 <code>&lt;Cat mouse={ { x, y }}</code> prop 来告诉组件鼠标的坐标以让它知道图片应该在屏幕哪个位置。</p>
<p>首先, 你或许会像这样，尝试在 <code>&lt;Mouse&gt;</code> 内部的渲染方法渲染 <code>&lt;Cat&gt;</code> 组件：:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &apos;absolute&apos;, left: mouse.x, top: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseWithCat extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &apos;100vh&apos; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          我们可以在这里换掉 &lt;p&gt; 的 &lt;Cat&gt;   ......</span><br><span class="line">          但是接着我们需要创建一个单独的 &lt;MouseWithSomethingElse&gt;</span><br><span class="line">          每次我们需要使用它时，&lt;MouseWithCat&gt; 是不是真的可以重复使用.</span><br><span class="line">        */&#125;</span><br><span class="line">        &lt;Cat mouse=&#123;this.state&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;MouseWithCat /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法适用于我们的特定用例，但我们还没有达到以可复用的方式真正封装行为的目标。现在，每当我们想要鼠标位置用于不同的用例时，我们必须创建一个新的组件（本质上是另一个 <code>&lt;MouseWithCat&gt;</code> ），它专门为该用例呈现一些东西.</p>
<blockquote>
<p>这段话的意思是，其实Cat这个组件还是写死在了<code>&lt;MouseWithCat&gt;</code>组件中，以后你可能还需要<code>&lt;MouseWithDog&gt;</code>，<code>&lt;MouseWithMonkey&gt;</code></p>
</blockquote>
<p>这也是 render prop 的来历：相比于直接将 <code>&lt;Cat&gt;</code> 写死在 <code>&lt;Mouse&gt;</code> 组件中，并且有效地更改渲染的结果，我们可以为 <code>&lt;Mouse&gt;</code> 提供一个函数 prop 来动态的确定要渲染什么 —— 一个 render prop。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;img src=&quot;/cat.jpg&quot; style=&#123; &#123; position: &apos;absolute&apos;, left: mouse.x, top: mouse.y &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleMouseMove = this.handleMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123; &#123; height: &apos;100vh&apos; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          使用 `render`prop 动态决定要渲染的内容，</span><br><span class="line">          而不是给出一个 &lt;Mouse&gt; 渲染结果的静态表示</span><br><span class="line">        */&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们提供了一个 <code>render</code> 方法 让 <code>&lt;Mouse&gt;</code> 能够动态决定什么需要渲染，而不是克隆 <code>&lt;Mouse&gt;</code> 组件然后硬编码来解决特定的用例。</p>
<p>更具体地说，<strong>render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</strong></p>
<p>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有 <code>render</code> prop 的 <code>&lt;Mouse&gt;</code> 组件就能够告诉它当前鼠标坐标 (x, y) 要渲染什么。</p>
<p>关于 render prop 一个有趣的事情是你可以使用带有 render prop 的常规组件来实现大多数<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" rel="external nofollow noopener noreferrer" target="_blank">高阶组件</a> (HOC)。 例如，如果你更喜欢使用 <code>withMouse</code> HOC而不是 <code>&lt;Mouse&gt;</code> 组件，你可以使用带有 render prop 的常规 <code>&lt;Mouse&gt;</code> 轻松创建一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果你出于某种原因真的想要 HOC，那么你可以轻松实现</span><br><span class="line">// 使用具有 render prop 的普通组件创建一个！</span><br><span class="line">function withMouse(Component) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，你可以将任一模式与 render prop 一起使用。</p>
<h3 id="使用-Props-而非-render"><a href="#使用-Props-而非-render" class="headerlink" title="使用 Props 而非 render"></a>使用 Props 而非 <code>render</code></h3><p>重要的是要记住，render prop 是因为模式才被称为 <em>render</em> prop ，你不一定要用名为 <code>render</code> 的 prop 来使用这种模式。事实上， <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="external nofollow noopener noreferrer" target="_blank"><em>任何</em>被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”</a>.</p>
<p>尽管之前的例子使用了 <code>render</code>，我们也可以简单地使用 <code>children</code> prop！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Mouse children=&#123;mouse =&gt; (</span><br><span class="line">  &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>记住，<code>children</code> prop 并不真正需要添加到 JSX 元素的 “attributes” 列表中。相反，你可以直接放置到元素的<em>内部</em>！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Mouse&gt;</span><br><span class="line">  &#123;mouse =&gt; (</span><br><span class="line">    &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Mouse&gt;</span><br></pre></td></tr></table></figure>

<p>你将在 <a href="https://github.com/chenglou/react-motion" rel="external nofollow noopener noreferrer" target="_blank">react-motion</a> 的 API 中看到此技术。</p>
<p>由于这一技术的特殊性，当你在设计一个类似的 API 时，你或许会要直接地在你的 propTypes 里声明 children 的类型应为一个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mouse.propTypes = &#123;</span><br><span class="line">  children: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="将-Render-Props-与-React-PureComponent-一起使用时要小心"><a href="#将-Render-Props-与-React-PureComponent-一起使用时要小心" class="headerlink" title="将 Render Props 与 React.PureComponent 一起使用时要小心"></a>将 Render Props 与 React.PureComponent 一起使用时要小心</h4><p>如果你在 render 方法里创建函数，那么使用 render prop 会抵消使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" rel="external nofollow noopener noreferrer" target="_blank"><code>React.PureComponent</code></a> 带来的优势。因为浅比较 props 的时候总会得到 false，并且在这种情况下每一个 <code>render</code> 对于 render prop 将会生成一个新的值。</p>
<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" rel="external nofollow noopener noreferrer" target="_blank"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" rel="external nofollow noopener noreferrer" target="_blank"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="external nofollow noopener noreferrer" target="_blank"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数，也就是说<code>React.PureComponent</code>更新之前会调用自己实现的shouldComponentUpdate方法，该方法会浅层比较state和prop，如果相同，就不更新。</p>
</blockquote>
<p>例如，继续我们之前使用的 <code>&lt;Mouse&gt;</code> 组件，如果 <code>Mouse</code> 继承自 <code>React.PureComponent</code> 而不是 <code>React.Component</code>，我们的例子看起来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Mouse extends React.PureComponent &#123;</span><br><span class="line">  // 与上面相同的代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">        &#123;/*</span><br><span class="line">          这是不好的！</span><br><span class="line">          每个渲染的 `render` prop的值将会是不同的。</span><br><span class="line">        */&#125;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Cat mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这样例子中，每次 <code>&lt;MouseTracker&gt;</code> 渲染，它会生成一个新的函数作为 <code>&lt;Mouse render&gt;</code> 的 prop，因而在同时也抵消了继承自 <code>React.PureComponent</code> 的 <code>&lt;Mouse&gt;</code> 组件的效果！</p>
<blockquote>
<p>每次重新渲染<code>&lt;MouseTracker&gt;</code>都会重新生成一个新的函数赋值给render，所以虽然函数功能是相同的，但是已经是另一个函数了，浅比较的时候，比较的是内存内置，所以一定是false，但其实要做的事没有变化。</p>
</blockquote>
<p>为了绕过这一问题，有时你可以定义一个 prop 作为实例方法，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  // 定义为实例方法，`this.renderTheCat`始终</span><br><span class="line">  // 当我们在渲染中使用它时，它指的是相同的函数</span><br><span class="line">  renderTheCat(mouse) &#123;</span><br><span class="line">    return &lt;Cat mouse=&#123;mouse&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;this.renderTheCat&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你无法静态定义 prop（例如，因为你需要关闭组件的 props 和/或 state），则 <code>&lt;Mouse&gt;</code> 应该继承自 <code>React.Component</code>。</p>
<h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>

<p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
<h3 id="使用-HOC-解决横切关注点问题"><a href="#使用-HOC-解决横切关注点问题" class="headerlink" title="使用 HOC 解决横切关注点问题"></a>使用 HOC 解决横切关注点问题</h3><p>组件是 React 中代码复用的基本单元。但你会发现某些模式并不适合传统组件。</p>
<p>例如，假设有一个 <code>CommentList</code> 组件，它订阅外部数据源，用以渲染评论列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CommentList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      // 假设 &quot;DataSource&quot; 是个全局范围内的数据源变量</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 订阅更改</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    // 清除订阅</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    // 当数据源更新时，更新组件状态</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.comments.map((comment) =&gt; (</span><br><span class="line">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍后，编写了一个用于订阅单个博客帖子的组件，该帖子遵循类似的模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BlogPost extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    DataSource.addChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(this.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;TextBlock text=&#123;this.state.blogPost&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CommentList</code> 和 <code>BlogPost</code> 不同 - 它们在 <code>DataSource</code> 上调用不同的方法，且渲染不同的结果。但它们的大部分实现都是一样的：</p>
<ul>
<li>在挂载时，向 <code>DataSource</code> 添加一个更改侦听器。</li>
<li>在侦听器内部，当数据源发生变化时，调用 <code>setState</code>。</li>
<li>在卸载时，删除侦听器。</li>
</ul>
<p>你可以想象，在一个大型应用程序中，这种订阅 <code>DataSource</code> 和调用 <code>setState</code> 的模式将一次又一次地发生。我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p>
<p>对于订阅了 <code>DataSource</code> 的组件，比如 <code>CommentList</code> 和 <code>BlogPost</code>，我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。让我们调用函数 <code>withSubscription</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const BlogPostWithSubscription = withSubscription(</span><br><span class="line">  BlogPost,</span><br><span class="line">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第一个参数是被包装组件。第二个参数通过 <code>DataSource</code> 和当前的 props 返回我们需要的数据。</p>
<p>当渲染 <code>CommentListWithSubscription</code> 和 <code>BlogPostWithSubscription</code> 时， <code>CommentList</code> 和 <code>BlogPost</code> 将传递一个 <code>data</code> prop，其中包含从 <code>DataSource</code> 检索到的最新数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 此函数接收一个组件...</span><br><span class="line">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  // ...并返回另一个组件...</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.handleChange = this.handleChange.bind(this);</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      // ...负责订阅相关的操作...</span><br><span class="line">      DataSource.addChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      // ... 并使用新数据渲染被包装的组件!</span><br><span class="line">      // 请注意，我们可能还会传递其他属性</span><br><span class="line">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，<strong>HOC 通过将组件<em>包装</em>在容器组件中来<em>组成</em>新组件。HOC 是纯函数，没有副作用</strong>。</p>
<p>被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 <code>data</code> prop。<strong>HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的</strong>。</p>
<p>因为 <code>withSubscription</code> 是一个普通函数，你可以根据需要对参数进行增添或者删除。例如，您可能希望使 <code>data</code> prop 的名称可配置，以进一步将 HOC 与包装组件隔离开来。或者你可以接受一个配置 <code>shouldComponentUpdate</code> 的参数，或者一个配置数据源的参数。因为 HOC 可以控制组件的定义方式，这一切都变得有可能。</p>
<p>与组件一样，<code>withSubscription</code> 和包装组件之间的契约完全基于之间传递的 props。这种依赖方式使得替换 HOC 变得容易，只要它们为包装的组件提供相同的 prop 即可。例如你需要改用其他库来获取数据的时候，这一点就很有用。</p>
<h3 id="不要改变原始组件。使用组合。"><a href="#不要改变原始组件。使用组合。" class="headerlink" title="不要改变原始组件。使用组合。"></a>不要改变原始组件。使用组合。</h3><p>不要试图在 HOC 中修改组件原型（或以其他方式改变它）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(InputComponent) &#123;</span><br><span class="line">  InputComponent.prototype.componentDidUpdate = function(prevProps) &#123;</span><br><span class="line">    console.log(&apos;Current props: &apos;, this.props);</span><br><span class="line">    console.log(&apos;Previous props: &apos;, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 返回原始的 input 组件，暗示它已经被修改。</span><br><span class="line">  return InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每次调用 logProps 时，增强组件都会有 log 输出。</span><br><span class="line">const EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>

<p>这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 <code>componentDidUpdate</code> 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。</p>
<p>修改传入组件的 HOC 是一种糟糕的抽象方式。调用者必须知道他们是如何实现的，以避免与其他 HOC 发生冲突。</p>
<p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&apos;Current props: &apos;, this.props);</span><br><span class="line">      console.log(&apos;Previous props: &apos;, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      // 将 input 组件包装在容器中，而不对其进行修改。Good!</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 HOC 与上文中修改传入组件的 HOC 功能相同，同时避免了出现冲突的情况。它同样适用于 class 组件和函数组件。而且因为它是一个纯函数，它可以与其他 HOC 组合，甚至可以与其自身组合。</p>
<h3 id="约定：将不相关的-props-传递给被包裹的组件"><a href="#约定：将不相关的-props-传递给被包裹的组件" class="headerlink" title="约定：将不相关的 props 传递给被包裹的组件"></a>约定：将不相关的 props 传递给被包裹的组件</h3><p>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。</p>
<p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 过滤掉非此 HOC 额外的 props，且不要进行透传</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; = this.props;</span><br><span class="line"></span><br><span class="line">  // 将 props 注入到被包装的组件中。</span><br><span class="line">  // 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  // 将 props 传递给被包装组件</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种约定保证了 HOC 的灵活性以及可复用性。</p>
<h3 id="约定：最大化可组合性"><a href="#约定：最大化可组合性" class="headerlink" title="约定：最大化可组合性"></a>约定：最大化可组合性</h3><p>并不是所有的 HOC 都一样。有时候它仅接受一个参数，也就是被包裹的组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure>

<p>HOC 通常可以接收多个参数。比如在 Relay 中，HOC 额外接收了一个配置对象用于指定组件的数据依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>

<p>最常见的 HOC 签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// React Redux 的 `connect` 函数</span><br><span class="line">const ConnectedComment = connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure>

<p><em>刚刚发生了什么？！</em>如果你把它分开，就会更容易看出发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// connect 是一个函数，它的返回值为另外一个函数。</span><br><span class="line">const enhance = connect(commentListSelector, commentListActions);</span><br><span class="line">// 返回值为 HOC，它会返回已经连接 Redux store 的组件</span><br><span class="line">const ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure>

<p>换句话说，<code>connect</code> 是一个返回高阶组件的高阶函数！</p>
<p>这种形式可能看起来令人困惑或不必要，但它有一个有用的属性。 像 <code>connect</code> 函数返回的单参数 HOC 具有签名 <code>Component =&gt; Component</code>。 输出类型与输入类型相同的函数很容易组合在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 而不是这样...</span><br><span class="line">const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))</span><br><span class="line"></span><br><span class="line">// ... 你可以编写组合工具函数</span><br><span class="line">// compose(f, g, h) 等同于 (...args) =&gt; f(g(h(...args)))</span><br><span class="line">const enhance = compose(</span><br><span class="line">  // 这些都是单参数的 HOC</span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line">const EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>

<p>（同样的属性也允许 <code>connect</code> 和其他 HOC 承担装饰器的角色，装饰器是一个实验性的 JavaScript 提案。）</p>
<p>许多第三方库都提供了 <code>compose</code> 工具函数，包括 lodash （比如 <a href="https://lodash.com/docs/#flowRight" rel="external nofollow noopener noreferrer" target="_blank"><code>lodash.flowRight</code></a>）， <a href="https://redux.js.org/api/compose" rel="external nofollow noopener noreferrer" target="_blank">Redux</a> 和 <a href="https://ramdajs.com/docs/#compose" rel="external nofollow noopener noreferrer" target="_blank">Ramda</a>。</p>
<h3 id="约定：包装显示名称以便轻松调试"><a href="#约定：包装显示名称以便轻松调试" class="headerlink" title="约定：包装显示名称以便轻松调试"></a>约定：包装显示名称以便轻松调试</h3><p>HOC 创建的容器组件会与任何其他组件一样，会显示在 <a href="https://github.com/facebook/react-devtools" rel="external nofollow noopener noreferrer" target="_blank">React Developer Tools</a> 中。为了方便调试，请选择一个显示名称，以表明它是 HOC 的产物。</p>
<p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 <code>withSubscription</code>，并且被包装组件的显示名称为 <code>CommentList</code>，显示名称应该为 <code>WithSubscription(CommentList)</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function withSubscription(WrappedComponent) &#123;</span><br><span class="line">  class WithSubscription extends React.Component &#123;/* ... */&#125;</span><br><span class="line">  WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`;</span><br><span class="line">  return WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDisplayName(WrappedComponent) &#123;</span><br><span class="line">  return WrappedComponent.displayName || WrappedComponent.name || &apos;Component&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>高阶组件有一些需要注意的地方，对于 React 新手来说可能并不容易发现。</p>
<h4 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h4><p>React 的 diff 算法（称为<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" rel="external nofollow noopener noreferrer" target="_blank">协调</a>）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 <code>render</code> 返回的组件与前一个渲染中的组件相同（<code>===</code>），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>
<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 每次调用 render 函数都会创建一个新的 EnhancedComponent</span><br><span class="line">  // EnhancedComponent1 !== EnhancedComponent2</span><br><span class="line">  const EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！</span><br><span class="line">  return &lt;EnhancedComponent /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>
<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>
<p>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p>
<h4 id="务必复制静态方法"><a href="#务必复制静态方法" class="headerlink" title="务必复制静态方法"></a>务必复制静态方法</h4><p>有时在 React 组件上定义静态方法很有用。例如，Relay 容器暴露了一个静态方法 <code>getFragment</code> 以方便组合 GraphQL 片段。</p>
<p>但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义静态函数</span><br><span class="line">WrappedComponent.staticMethod = function() &#123;/*...*/&#125;</span><br><span class="line">// 现在使用 HOC</span><br><span class="line">const EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line">// 增强组件没有 staticMethod</span><br><span class="line">typeof EnhancedComponent.staticMethod === &apos;undefined&apos; // true</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  // 必须准确知道应该拷贝哪些方法 :(</span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 <a href="https://github.com/mridgway/hoist-non-react-statics" rel="external nofollow noopener noreferrer" target="_blank">hoist-non-react-statics</a> 自动拷贝所有非 React 静态方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hoistNonReactStatic from &apos;hoist-non-react-statics&apos;;</span><br><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;/*...*/&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用这种方式代替...</span><br><span class="line">MyComponent.someFunction = someFunction;</span><br><span class="line">export default MyComponent;</span><br><span class="line"></span><br><span class="line">// ...单独导出该方法...</span><br><span class="line">export &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line">// ...并在要使用的组件中，import 它们</span><br><span class="line">import MyComponent, &#123; someFunction &#125; from &apos;./MyComponent.js&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="Refs-不会被传递"><a href="#Refs-不会被传递" class="headerlink" title="Refs 不会被传递"></a>Refs 不会被传递</h4><p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 <code>ref</code> 实际上并不是一个 prop - 就像 <code>key</code> 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 <code>React.forwardRef</code> API</p>
<h2 id="在高阶组件中转发-refs"><a href="#在高阶组件中转发-refs" class="headerlink" title="在高阶组件中转发 refs"></a>在高阶组件中转发 refs</h2><p>这个技巧对<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" rel="external nofollow noopener noreferrer" target="_blank">高阶组件</a>（也被称为 HOC）特别有用。让我们从一个输出组件 props 到控制台的 HOC 示例开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(WrappedComponent) &#123;  class LogProps extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&apos;old props:&apos;, prevProps);</span><br><span class="line">      console.log(&apos;new props:&apos;, this.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return LogProps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“logProps” HOC 透传（pass through）所有 <code>props</code> 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FancyButton extends React.Component &#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们导出 LogProps，而不是 FancyButton。</span><br><span class="line">// 虽然它也会渲染一个 FancyButton。</span><br><span class="line">export default logProps(FancyButton);</span><br></pre></td></tr></table></figure>

<p>下面的示例有一点需要注意：<strong>refs 将不会透传下去。这是因为 <code>ref</code> 不是 prop 属性</strong>。就像 <code>key</code> 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</p>
<p>这意味着用于我们 <code>FancyButton</code> 组件的 refs 实际上将被挂载到 <code>LogProps</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import FancyButton from &apos;./FancyButton&apos;;</span><br><span class="line"></span><br><span class="line">const ref = React.createRef();</span><br><span class="line">// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。</span><br><span class="line">// 尽管渲染结果将是一样的，</span><br><span class="line">// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！</span><br><span class="line">// 这意味着我们不能调用例如 ref.current.focus() 这样的方法</span><br><span class="line">&lt;FancyButton</span><br><span class="line">  label=&quot;Click Me&quot;</span><br><span class="line">  handleClick=&#123;handleClick&#125;</span><br><span class="line">  ref=&#123;ref&#125;/&gt;;</span><br></pre></td></tr></table></figure>

<p>幸运的是，我们可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到内部的 <code>FancyButton</code> 组件。<code>React.forwardRef</code> 接受一个渲染函数，其接收 <code>props</code> 和 <code>ref</code> 参数并返回一个 React 节点。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logProps(Component) &#123;</span><br><span class="line">  class LogProps extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&apos;old props:&apos;, prevProps);</span><br><span class="line">      console.log(&apos;new props:&apos;, this.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123;forwardedRef, ...rest&#125; = this.props;</span><br><span class="line">      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span><br><span class="line">      return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;;    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注意 React.forwardRef 回调的第二个参数 “ref”。</span><br><span class="line">  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span><br><span class="line">  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span><br><span class="line">  return React.forwardRef((props, ref) =&gt; &#123;    </span><br><span class="line">      return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;·</span><br></pre></td></tr></table></figure>

<p><code>logProps</code>组件是<code>React.forwardRef</code>返回的Ref转发组件，传入它的ref属性会一层层传递到一个它被传入到ref属性的组件中。</p>
<p>这样说比较绕，就说是，我们创建一个refA，赋值给<code>logProps</code>，但因为它是转发组件，所以这个时候并不会给refA赋值，而是直接透传到<code>forwardedRef</code>属性，再透传到<code>Component</code>组件的<code>ref</code>属性，如果这个组件不是转发组件，那这个时候才会对这个refA真正赋值。</p>
<h2 id="总结和比较"><a href="#总结和比较" class="headerlink" title="总结和比较"></a>总结和比较</h2><p>无论是Render Prop还是HOC，都是为了解决横切关注点问题。</p>
<p>那么首先，我们要理解下什么是横切关注点</p>
<blockquote>
<p>部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点（Cross-cutting concerns, Horizontal concerns）」。</p>
</blockquote>
<p>这样说好像还是特别抽象？那我们举个例子。</p>
<p><strong>日志功能</strong>就是<strong>横切关注点</strong>的一个典型案例。日志功能往往横跨系统中的每个业务模块，即“<strong>横切</strong>”所有需要日志功能的类和方法体。所以我们说日志成为了<strong>横切</strong>整个系统对象结构的<strong>关注点</strong> —— 也就叫做<strong>横切关注点</strong>啦。</p>
<blockquote>
<p>说的实际一点，就是说这两个东西都是为了解决重复代码问题的。</p>
<p>对于重复的代码部分，我们把它抽取成一个组件，并给不同的部分预留好位置：</p>
<ul>
<li>对于HOC来讲，它是利用函数的入参（至少有一个是公共组件）去通过函数逻辑构造新的组件</li>
<li>对于Render Prop来讲，它是在公共组件中预留一个地方去调用未来传入的Render Prop。</li>
</ul>
<p>对于不同的部分：</p>
<ul>
<li>对于HOC来讲，我们可以通过HOC来利用一个函数去利用重复的部分去去生成一个新的组件。</li>
<li>对于Render Prop来讲，可以通过Render Prop直接传入生成我们要渲染的组件的函数，然后在公共部分中调用这个函数去渲染不同的组件部分。</li>
</ul>
</blockquote>
<p>这二者都不是什么React的特殊语法糖，也就是这两个并不是React的源码会做特殊处理的，都只是React基本语法的使用方式，Render Prop就是个普通的prop，只要你传入的prop是个返回组件的函数（设为A），并且在该组件（设为B）的某个地方调用并渲染了这个组件A，那这个prop就是Render Prop。</p>
<p>而HOC就是个函数而已，只不过这个函数的入参和返回都是组件，你可以利用入参的组件去创建一个新的组件，但是请不要去改变入参的组件。</p>
<p>区别的话，HOC更加灵活，函数中可以有很多逻辑，Render Prop就只能传入一个Render函数给Prop。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>redux入门笔记</title>
    <url>/2021/05/11/redux/</url>
    <content><![CDATA[<p>最近开始看一些关于react的知识，不可避免的接触到了redux。</p>
<p>去看了看他的文档，就来简单总结下。</p>
<p>注意，原大部分内容已经过时了，因为react更新了hook，我接下来回去研究下react-redux针对hook做了哪些改进，再来重新解释，不过本博客大部分内容是讲的原生的redux，还可以放心食用。</p>
<a id="more"></a>

<h2 id="Redux是什么"><a href="#Redux是什么" class="headerlink" title="Redux是什么"></a>Redux是什么</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 <a href="https://reduxframework.com/" rel="external nofollow noopener noreferrer" target="_blank">Redux Framework</a>。)</p>
<p>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个<a href="https://github.com/gaearon/redux-devtools" rel="external nofollow noopener noreferrer" target="_blank">时间旅行调试器可以编辑后实时预览</a>。</p>
<p><strong>Redux 除了和 <a href="https://facebook.github.io/react/" rel="external nofollow noopener noreferrer" target="_blank">React</a> 一起用外，还支持其它界面库</strong>。 它体小精悍（只有2kB，包括依赖）。</p>
<h2 id="Redux简述"><a href="#Redux简述" class="headerlink" title="Redux简述"></a>Redux简述</h2><p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 <em>store</em> 中。 惟一改变 state 的办法是触发 <em>action</em>，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 <em>reducers</em>。</p>
<p>就是这样！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。</span></span><br><span class="line"><span class="comment"> * 描述了 action 如何把 state 转变成下一个 state。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * state 的形式取决于你，可以是基本类型、数组、对象、</span></span><br><span class="line"><span class="comment"> * 甚至是 Immutable.js 生成的数据结构。惟一的要点是</span></span><br><span class="line"><span class="comment"> * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper)</span></span><br><span class="line"><span class="comment"> * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">    <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">    <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Redux store 来存放应用的状态。</span></span><br><span class="line"><span class="comment">// API 是 &#123; subscribe, dispatch, getState &#125;。</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动订阅更新，也可以事件绑定到视图层。</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变内部 state 惟一方法是 dispatch 一个 action。</span></span><br><span class="line"><span class="comment">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>你应该把要做的修改变成一个普通对象，这个对象被叫做 <em>action</em>，而不是直接修改 state。然后编写专门的函数来决定每个 action 如何改变应用的 state，这个函数被叫做 <em>reducer</em>。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Redux 本身很简单。</p>
<p>当使用普通对象来描述应用的 state 时。例如，todo 应用的 state 可能长这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos: [&#123;</span><br><span class="line">    text: <span class="string">'Eat food'</span>,</span><br><span class="line">    completed: <span class="literal">true</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    text: <span class="string">'Exercise'</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">  &#125;],</span><br><span class="line">  visibilityFilter: <span class="string">'SHOW_COMPLETED'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个对象就像 “Model”，区别是它并没有 setter（修改器方法）。因此其它的代码不能随意修改它，造成难以复现的 bug。</p>
<p>要想更新 state 中的数据，你需要发起一个 action。Action 就是一个普通 JavaScript 对象（注意到没，这儿没有任何魔法）用来描述发生了什么。下面是一些 action 的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">text</span>: <span class="string">'Go to swimming pool'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'TOGGLE_TODO'</span>, <span class="attr">index</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>, <span class="attr">filter</span>: <span class="string">'SHOW_ALL'</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>强制使用 action 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么</strong>。如果一些东西改变了，就可以知道为什么变。action 就像是描述发生了什么的指示器。最终，<strong>为了把 action 和 state 串起来，开发一些函数，这就是 reducer</strong>。</p>
<p>再次地，没有任何魔法，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 对于大的应用来说，不大可能仅仅只写一个这样的函数，所以我们编写很多小函数来分别管理 state 的一部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = <span class="string">'SHOW_ALL'</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'SET_VISIBILITY_FILTER'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.filter;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">    <span class="keyword">return</span> state.concat([&#123; <span class="attr">text</span>: action.text, <span class="attr">completed</span>: <span class="literal">false</span> &#125;]);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">    <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></span><br><span class="line">      action.index === index ?</span><br><span class="line">        &#123; <span class="attr">text</span>: todo.text, <span class="attr">completed</span>: !todo.completed &#125; :</span><br><span class="line">        todo</span><br><span class="line">   )</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再开发一个 reducer 调用这两个 reducer，进而来管理整个应用的 state：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: todos(state.todos, action),</span><br><span class="line">    visibilityFilter: visibilityFilter(state.visibilityFilter, action)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ul>
<li>单一数据源，即只有一个state</li>
<li>state是只读的，你不能直接对state赋值，唯一能够修改state的方法就是触发action</li>
<li>使用纯函数来执行修改，当触发了一个action，具体执行的reducer需要时一个纯函数，也就是不能直接对state进行修改，而是要返回一个新的state对象。</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>首先，让我们来给 action 下个定义。</p>
<p><strong>Action</strong> 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。一般来说你会通过 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch" rel="external nofollow noopener noreferrer" target="_blank"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>添加新 todo 任务的 action 是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: <span class="string">'Build my first Redux app'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Action 本质上是 JavaScript 普通对象</strong>。我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<h4 id="Action-创建函数"><a href="#Action-创建函数" class="headerlink" title="Action 创建函数"></a>Action 创建函数</h4><p><strong>Action 创建函数</strong> 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>在 Redux 中的 action 创建函数只是简单的返回一个 action:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做将使 action 创建函数更容易被移植和测试。</p>
<p>Redux 中只需把 action 创建函数的结果传给 <code>dispatch()</code> 方法即可发起一次 dispatch 过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dispatch(addTodo(text))</span><br><span class="line">dispatch(completeTodo(index))</span><br></pre></td></tr></table></figure>

<p>或者创建一个 <strong>被绑定的 action 创建函数</strong> 来自动 dispatch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boundAddTodo = <span class="function"><span class="params">text</span> =&gt;</span> dispatch(addTodo(text))</span><br><span class="line"><span class="keyword">const</span> boundCompleteTodo = <span class="function"><span class="params">index</span> =&gt;</span> dispatch(completeTodo(index))</span><br></pre></td></tr></table></figure>

<p>然后直接调用它们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">boundAddTodo(text);</span><br><span class="line">boundCompleteTodo(index);</span><br></pre></td></tr></table></figure>

<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a href="https://www.redux.org.cn/docs/basics/Actions.html" rel="external nofollow noopener noreferrer" target="_blank">actions</a> 并发送到 store 的，记住 <strong>actions 只是描述了<em>有事情发生了</em>这一事实，并没有描述应用如何更新 state</strong>。</p>
<h4 id="Action-处理"><a href="#Action-处理" class="headerlink" title="Action 处理"></a>Action 处理</h4><p>现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>

<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li>
</ul>
<p>谨记 reducer 一定要保持纯净。<strong>只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>
<h4 id="Reducer的拆分与合成"><a href="#Reducer的拆分与合成" class="headerlink" title="Reducer的拆分与合成"></a>Reducer的拆分与合成</h4><p>随着状态越来越复杂，我们的reducer必定会越来越带，所以我们就要想办法把reducer拆分，最后再像办法再合起来，因为我们只能由一个state。</p>
<p>针对我们一开始核心概念那一节的例子，Redux 提供了 <a href="https://www.redux.org.cn/docs/api/combineReducers.html" rel="external nofollow noopener noreferrer" target="_blank"><code>combineReducers()</code></a> 工具类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  visibilityFilter,</span><br><span class="line">  todos</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp</span><br></pre></td></tr></table></figure>

<p>注意上面的写法和下面完全等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visibilityFilter: visibilityFilter(state.visibilityFilter, action),</span><br><span class="line">    todos: todos(state.todos, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以给它们设置不同的 key，或者调用不同的函数。下面两种合成 reducer 方法完全等价：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: doSomethingWithA(state.a, action),</span><br><span class="line">    b: processB(state.b, action),</span><br><span class="line">    c: c(state.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.redux.org.cn/docs/api/combineReducers.html" rel="external nofollow noopener noreferrer" target="_blank"><code>combineReducers()</code></a> 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer <strong>根据它们的 key 来筛选出 state 中的一部分数据并处理</strong>，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><strong>Store</strong> 就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#getState" rel="external nofollow noopener noreferrer" target="_blank"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch" rel="external nofollow noopener noreferrer" target="_blank"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" rel="external nofollow noopener noreferrer" target="_blank"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" rel="external nofollow noopener noreferrer" target="_blank"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<p>再次强调一下 <strong>Redux 应用只有一个单一的 store</strong>。当需要拆分数据处理逻辑时，你应该使用 <a href="https://www.redux.org.cn/docs/basics/Reducers.html#splitting-reducers" rel="external nofollow noopener noreferrer" target="_blank">reducer 组合</a> 而不是创建多个 store。</p>
<p>根据已有的 reducer 来创建 store 是非常容易的。在<a href="https://www.redux.org.cn/docs/basics/Reducers.html" rel="external nofollow noopener noreferrer" target="_blank">前一个章节</a>中，我们使用 <a href="https://www.redux.org.cn/docs/api/combineReducers.html" rel="external nofollow noopener noreferrer" target="_blank"><code>combineReducers()</code></a> 将多个 reducer 合并成为一个。现在我们将其导入，并传递 <a href="https://www.redux.org.cn/docs/api/createStore.html" rel="external nofollow noopener noreferrer" target="_blank"><code>createStore()</code></a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.redux.org.cn/docs/api/createStore.html" rel="external nofollow noopener noreferrer" target="_blank"><code>createStore()</code></a> 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = createStore(todoApp, <span class="built_in">window</span>.STATE_FROM_SERVER)</span><br></pre></td></tr></table></figure>

<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>到现在，Redux的基础概念和用法讲完了，我们还是存在几个问题</p>
<ul>
<li>到目前为止，好像React和Redux并没有任何联动，不存在什么关系，最起码用法上没有什么特殊照顾。</li>
<li>Redux看起来只是个状态管理，并不是全局状态管理，那么react中为什么可以做到全局状态管理呢？</li>
<li>如何实现异步的Action，如果我就想在触发Action之后的Reducer中执行一些副作用怎么办？</li>
</ul>
<p>我们一个个解决</p>
<h3 id="搭配React"><a href="#搭配React" class="headerlink" title="搭配React"></a>搭配React</h3><p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
<p>Redux 默认并不包含 <a href="https://github.com/reactjs/react-redux" rel="external nofollow noopener noreferrer" target="_blank">React 绑定库</a>，需要单独安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure>

<p>如果你不使用npm，你也可以从unpkg获取最新的UMD包（包括<a href="https://unpkg.com/react-redux@latest/dist/react-redux.js" rel="external nofollow noopener noreferrer" target="_blank">开发环境包</a>和<a href="https://unpkg.com/react-redux@latest/dist/react-redux.min.js" rel="external nofollow noopener noreferrer" target="_blank">生产环境包</a>）。如果你用 <code>&lt;script&gt;</code> 标签的方式引入UMD包，那么它会在全局抛出<code>window.ReactRedux</code>对象。</p>
<h4 id="容器组件（Smart-Container-Components）和展示组件（Dumb-Presentational-Components）"><a href="#容器组件（Smart-Container-Components）和展示组件（Dumb-Presentational-Components）" class="headerlink" title="容器组件（Smart/Container Components）和展示组件（Dumb/Presentational Components）"></a>容器组件（Smart/Container Components）和展示组件（Dumb/Presentational Components）</h4><p>Redux 的 React 绑定库是基于 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="external nofollow noopener noreferrer" target="_blank">容器组件和展示组件相分离</a> 的开发思想。所以建议先读完这篇文章再回来继续学习。这个思想非常重要。</p>
<blockquote>
<p>这篇文章是在hook出现之前出现的，也是class时代最为流行的开发方式，但是当hook出现后，作者承认hook是一种更好的实践，但是如果你的版本不支持hook，这种思想仍然十分重要。</p>
</blockquote>
<p>那让我们再总结一下不同点：</p>
<table>
<thead>
<tr>
<th align="right"></th>
<th align="left">展示组件</th>
<th align="left">容器组件</th>
</tr>
</thead>
<tbody><tr>
<td align="right">作用</td>
<td align="left">描述如何展现（骨架、样式）</td>
<td align="left">描述如何运行（数据获取、状态更新）</td>
</tr>
<tr>
<td align="right">直接使用 Redux</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="right">数据来源</td>
<td align="left">props</td>
<td align="left">监听 Redux state</td>
</tr>
<tr>
<td align="right">数据修改</td>
<td align="left">从 props 调用回调函数</td>
<td align="left">向 Redux 派发 actions</td>
</tr>
<tr>
<td align="right">调用方式</td>
<td align="left">手动</td>
<td align="left">通常由 React Redux 生成</td>
</tr>
</tbody></table>
<p>大部分的组件都应该是展示型的，但一般需要少数的几个容器组件把它们和 Redux store 连接起来。这和下面的设计简介并不意味着容器组件必须位于组件树的最顶层。如果一个容器组件变得太复杂（例如，它有大量的嵌套组件以及传递数不尽的回调函数），那么在组件树中引入另一个容器，就像<a href="https://www.redux.org.cn/docs/faq/ReactRedux.html#react-multiple-components" rel="external nofollow noopener noreferrer" target="_blank">FAQ</a>中提到的那样</p>
<p>技术上讲你可以直接使用 <code>store.subscribe()</code> 来编写容器组件。但不建议这么做的原因是无法使用 React Redux 带来的性能优化。也因此，<strong>不要手写容器组件，而使用 React Redux 的 <code>connect()</code> 方法来生成</strong>，后面会详细介绍。</p>
<h3 id="为什么所有组件都可以访问到redux的state"><a href="#为什么所有组件都可以访问到redux的state" class="headerlink" title="为什么所有组件都可以访问到redux的state"></a>为什么所有组件都可以访问到redux的state</h3><p>所有容器组件都可以访问 Redux store，所以可以手动监听它。一种方式是把它以 props 的形式传入到所有容器组件中。但这太麻烦了，因为必须要用 <code>store</code> 把展示组件包裹一层，仅仅是因为恰好在组件树中渲染了一个容器组件。</p>
<p>建议的方式是使用指定的 React Redux 组件 <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store" rel="external nofollow noopener noreferrer" target="_blank">``</a> 来 <a href="https://facebook.github.io/react/docs/context.html" rel="external nofollow noopener noreferrer" target="_blank">魔法般的</a> 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。</p>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><code>index.js</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h3 id="middleware创建异步action，有副作用的reducer"><a href="#middleware创建异步action，有副作用的reducer" class="headerlink" title="middleware创建异步action，有副作用的reducer"></a>middleware创建异步action，有副作用的reducer</h3><p>标准的做法是使用 <a href="https://github.com/gaearon/redux-thunk" rel="external nofollow noopener noreferrer" target="_blank">Redux Thunk 中间件</a>。要引入 <code>redux-thunk</code> 这个专门的库才能使用。我们 <a href="https://www.redux.org.cn/docs/advanced/Middleware.html" rel="external nofollow noopener noreferrer" target="_blank">后面</a> 会介绍 middleware 大体上是如何工作的；目前，你只需要知道一个要点：通过使用指定的 middleware，action 创建函数除了返回 action 对象外还可以返回函数。这时，这个 action 创建函数就成为了 <a href="https://en.wikipedia.org/wiki/Thunk" rel="external nofollow noopener noreferrer" target="_blank">thunk</a>。</p>
<p>当 action 创建函数返回函数时，这个函数会被 Redux Thunk middleware 执行。这个函数并不需要保持纯净；它还可以带有副作用，包括执行异步 API 请求。这个函数还可以 dispatch action，就像 dispatch 前面定义的同步 action 一样。</p>
<p>我们仍可以在 <code>actions.js</code> 里定义这些特殊的 thunk action 创建函数。</p>
<h4 id="actions-js"><a href="#actions-js" class="headerlink" title="actions.js"></a><code>actions.js</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'cross-fetch'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_POSTS = <span class="string">'REQUEST_POSTS'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestPosts</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: REQUEST_POSTS,</span><br><span class="line">    subreddit</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POSTS = <span class="string">'RECEIVE_POSTS'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receivePosts</span>(<span class="params">subreddit, json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    subreddit,</span><br><span class="line">    posts: json.data.children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.data),</span><br><span class="line">    receivedAt: <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> INVALIDATE_SUBREDDIT = ‘INVALIDATE_SUBREDDIT’</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invalidateSubreddit</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     type: INVALIDATE_SUBREDDIT,</span><br><span class="line">     subreddit</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来看一下我们写的第一个 thunk action 创建函数！</span></span><br><span class="line"><span class="comment">// 虽然内部操作不同，你可以像其它 action 创建函数 一样使用它：</span></span><br><span class="line"><span class="comment">// store.dispatch(fetchPosts('reactjs'))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchPosts</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thunk middleware 知道如何处理函数。</span></span><br><span class="line">  <span class="comment">// 这里把 dispatch 方法通过参数的形式传给函数，</span></span><br><span class="line">  <span class="comment">// 以此来让它自己也能 dispatch action。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次 dispatch：更新应用的 state 来通知</span></span><br><span class="line">    <span class="comment">// API 请求发起了。</span></span><br><span class="line"></span><br><span class="line">    dispatch(requestPosts(subreddit))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thunk middleware 调用的函数可以有返回值，</span></span><br><span class="line">    <span class="comment">// 它会被当作 dispatch 方法的返回值传递。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个案例中，我们返回一个等待处理的 promise。</span></span><br><span class="line">    <span class="comment">// 这并不是 redux middleware 所必须的，但这对于我们而言很方便。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`http://www.subreddit.com/r/<span class="subst">$&#123;subreddit&#125;</span>.json`</span>)</span><br><span class="line">      .then(</span><br><span class="line">        response =&gt; response.json(),</span><br><span class="line">        <span class="comment">// 不要使用 catch，因为会捕获</span></span><br><span class="line">        <span class="comment">// 在 dispatch 和渲染中出现的任何错误，</span></span><br><span class="line">        <span class="comment">// 导致 'Unexpected batch number' 错误。</span></span><br><span class="line">        <span class="comment">// https://github.com/facebook/react/issues/6895</span></span><br><span class="line">         error =&gt; <span class="built_in">console</span>.log(<span class="string">'An error occurred.'</span>, error)</span><br><span class="line">      )</span><br><span class="line">      .then(<span class="function"><span class="params">json</span> =&gt;</span></span><br><span class="line">        <span class="comment">// 可以多次 dispatch！</span></span><br><span class="line">        <span class="comment">// 这里，使用 API 请求结果来更新应用的 state。</span></span><br><span class="line"></span><br><span class="line">        dispatch(receivePosts(subreddit, json))</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们是如何在 dispatch 机制中引入 Redux Thunk middleware 的呢？我们使用了 <a href="https://www.redux.org.cn/docs/api/applyMiddleware.html" rel="external nofollow noopener noreferrer" target="_blank"><code>applyMiddleware()</code></a>，如下：</p>
<h4 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a><code>index.js</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">'redux-logger'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; selectSubreddit, fetchPosts &#125; <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = createLogger()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(</span><br><span class="line">    thunkMiddleware, <span class="comment">// 允许我们 dispatch() 函数</span></span><br><span class="line">    loggerMiddleware <span class="comment">// 一个很便捷的 middleware，用来打印 action 日志</span></span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.dispatch(selectSubreddit(<span class="string">'reactjs'</span>))</span><br><span class="line">store</span><br><span class="line">  .dispatch(fetchPosts(<span class="string">'reactjs'</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>thunk 的一个优点是它的结果可以再次被 dispatch：</p>
<h4 id="actions-js-1"><a href="#actions-js-1" class="headerlink" title="actions.js"></a><code>actions.js</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'cross-fetch'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_POSTS = <span class="string">'REQUEST_POSTS'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestPosts</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: REQUEST_POSTS,</span><br><span class="line">    subreddit</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POSTS = <span class="string">'RECEIVE_POSTS'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receivePosts</span>(<span class="params">subreddit, json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    subreddit,</span><br><span class="line">    posts: json.data.children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.data),</span><br><span class="line">    receivedAt: <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INVALIDATE_SUBREDDIT = <span class="string">'INVALIDATE_SUBREDDIT'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">invalidateSubreddit</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: INVALIDATE_SUBREDDIT,</span><br><span class="line">    subreddit</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchPosts</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(requestPosts(subreddit))</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`http://www.reddit.com/r/<span class="subst">$&#123;subreddit&#125;</span>.json`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(receivePosts(subreddit, json)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldFetchPosts</span>(<span class="params">state, subreddit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = state.postsBySubreddit[subreddit]</span><br><span class="line">  <span class="keyword">if</span> (!posts) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (posts.isFetching) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> posts.didInvalidate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchPostsIfNeeded</span>(<span class="params">subreddit</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这个函数也接收了 getState() 方法</span></span><br><span class="line">  <span class="comment">// 它让你选择接下来 dispatch 什么。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当缓存的值是可用时，</span></span><br><span class="line">  <span class="comment">// 减少网络请求很有用。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldFetchPosts(getState(), subreddit)) &#123;</span><br><span class="line">      <span class="comment">// 在 thunk 里 dispatch 另一个 thunk！</span></span><br><span class="line">      <span class="keyword">return</span> dispatch(fetchPosts(subreddit))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 告诉调用代码不需要再等待。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可以让我们逐步开发复杂的异步控制流，同时保持代码整洁如初：</p>
<h4 id="index-js-2"><a href="#index-js-2" class="headerlink" title="index.js"></a><code>index.js</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store</span><br><span class="line">  .dispatch(fetchPostsIfNeeded(<span class="string">'reactjs'</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>浏览器渲染流程</title>
    <url>/2020/11/26/rendering-process/</url>
    <content><![CDATA[<p>最近看了几篇关于浏览器原理的文章，对浏览器的渲染流程有了个比较系统的了解，在这里简单总结下并顺便讲下老生常谈的重排和重绘是怎么回事。</p>
<a id="more"></a>

<p>首先上一张完整的渲染流程图</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1606480548/Blog/975fcbf7f83cc20d216f3d68a85d0f37_aiymmq.png" alt></p>
<p>结合上图，一个完整的渲染流程大致可总结为如下：</p>
<ul>
<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。</li>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li>
</ul>
<p>对于前面几个过程，其实从作用上讲没什么好说的，大家也都明白，但是如果具体说如何实现的，又可以开一篇新的博客，比如html-parser是如何把html文档转化为DOM树的等。</p>
<p>所以对于前面几个过程，我们只简单提一下。</p>
<h2 id="渲染流程各步骤作用"><a href="#渲染流程各步骤作用" class="headerlink" title="渲染流程各步骤作用"></a>渲染流程各步骤作用</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>为什么要构建 DOM 树呢？</p>
<p>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p>
<p>但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p>
<h3 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h3><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p>
<h4 id="把-CSS-转换为浏览器能够理解的结构"><a href="#把-CSS-转换为浏览器能够理解的结构" class="headerlink" title="把 CSS 转换为浏览器能够理解的结构"></a>把 CSS 转换为浏览器能够理解的结构</h4><p>CSS 样式来源主要有三种：</p>
<ul>
<li><p>通过 link 引用的外部 CSS 文件</p>
</li>
<li><p><code>&lt;style&gt;</code>标记内的css。</p>
</li>
<li><p>元素style属性内嵌的css</p>
</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</p>
<h4 id="转换样式表中的属性值，使其标准化"><a href="#转换样式表中的属性值，使其标准化" class="headerlink" title="转换样式表中的属性值，使其标准化"></a>转换样式表中的属性值，使其标准化</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">2em</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"><span class="selector-tag">span</span>  &#123;<span class="attribute">display</span>: none&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">font-weight</span>: bold&#125;</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">color</span>:red; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>
<h4 id="计算出-DOM-树中每个节点的具体样式"><a href="#计算出-DOM-树中每个节点的具体样式" class="headerlink" title="计算出 DOM 树中每个节点的具体样式"></a>计算出 DOM 树中每个节点的具体样式</h4><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>
<h4 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h4><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p>
<ul>
<li><p>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</p>
</li>
<li><p>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</p>
</li>
</ul>
<h4 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h4><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？答案依然是否定的。</p>
<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>
<p><strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong></p>
<p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</p>
<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>
<ul>
<li><p>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</p>
</li>
<li><p>第二点，需要剪裁（clip）的地方也会被创建为图层。</p>
</li>
</ul>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>
<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>
<p>通常，你会把你的绘制操作分解为三步：</p>
<ul>
<li><p>绘制蓝色背景；</p>
</li>
<li><p>在中间绘制一个红色的圆；</p>
</li>
<li><p>再在圆上绘制绿色三角形。</p>
</li>
</ul>
<p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p>
<h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</p>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>
<p>那我们得先来看看什么是视口</p>
<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。</p>
<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile</strong>），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>
<p>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。<strong>所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位</strong>。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>
<h2 id="重排，重绘，合成"><a href="#重排，重绘，合成" class="headerlink" title="重排，重绘，合成"></a>重排，重绘，合成</h2><h3 id="更新了元素的几何属性（重排）"><a href="#更新了元素的几何属性（重排）" class="headerlink" title="更新了元素的几何属性（重排）"></a>更新了元素的几何属性（重排）</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1606481480/Blog/b3ed565230fe4f5c1886304a8ff754e5_ensz6f.png" alt></p>
<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</p>
<h3 id="更新元素的绘制属性（重绘）"><a href="#更新元素的绘制属性（重绘）" class="headerlink" title="更新元素的绘制属性（重绘）"></a>更新元素的绘制属性（重绘）</h3><p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1606481522/Blog/3c1b7310648cccbf6aa4a42ad0202b03_nikkto.png" alt></p>
<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>
<h3 id="直接合成阶段"><a href="#直接合成阶段" class="headerlink" title="直接合成阶段"></a>直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1606481570/Blog/024bf6c83b8146d267f476555d953a2c_whdgtc.png" alt></p>
<p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>
<p>注：</p>
<p>本文图片均来自于极客时间《浏览器工作原理与实践》</p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>require-from-string</title>
    <url>/2020/03/07/require-from-string/</url>
    <content><![CDATA[<p>最近几天遇到了一个需求，就是在项目启动的时候，需要动态生成一些代码并将这些生成的代码进行引入，一开始我的做法是把生成的代码写入文件，再require这些文件，成功之后再将文件删除。做完之后才发现，这些文件其实没必要去创建，可不可以直接从内存中引入，这样就减少了两次的文件io，而且require其实也是将文件读入内存再进行解析，那么从内存中直接引入也是存在理论上的可能性的。</p>
<a id="more"></a>

<p>在这里记录一下具体的做法以及背后的原理分析。</p>
<h2 id="require-from-string"><a href="#require-from-string" class="headerlink" title="require-from-string"></a>require-from-string</h2><p>其实这个功能很久之前就被开发出来了，只需要从npm仓库中下载“require-from-string”这个包就可以了，然后就可以直接将代码字符串传入函数中就可以了。</p>
<p>这里有一点要注意的就是，<strong>如果你通过require-from-string引入的代码中还通过require引入了其他的module，那么这些module的相对路径要相对你调用require-from-string的地方</strong>。</p>
<p>下面是简单的官方示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requireFromString = <span class="built_in">require</span>(<span class="string">'require-from-string'</span>);</span><br><span class="line"> </span><br><span class="line">requireFromString(<span class="string">'module.exports = 1'</span>);</span><br><span class="line"><span class="comment">//=&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h3 id="requireFromString-code-filename-options"><a href="#requireFromString-code-filename-options" class="headerlink" title="requireFromString(code, [filename], [options])"></a>requireFromString(code, [filename], [options])</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p><em>Required</em><br>Type: <code>string</code></p>
<p>Module code.</p>
<h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>Type: <code>string</code><br>Default: <code>&#39;&#39;</code></p>
<p>Optional filename.</p>
<h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>Type: <code>object</code></p>
<h5 id="appendPaths"><a href="#appendPaths" class="headerlink" title="appendPaths"></a>appendPaths</h5><p>Type: <code>Array</code></p>
<p>List of <code>paths</code>, that will be appended to module <code>paths</code>. Useful, when you want to be able require modules from these paths.</p>
<h5 id="prependPaths"><a href="#prependPaths" class="headerlink" title="prependPaths"></a>prependPaths</h5><p>Type: <code>Array</code></p>
<p>Same as <code>appendPaths</code>, but paths will be prepended.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个包使用起来非常简单，在使用之后，我们再去看一下他的<a href="https://github.com/floatdrop/require-from-string#readme" rel="external nofollow noopener noreferrer" target="_blank">源码</a>。</p>
<p>源码也非常简单，只有一个index.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">requireFromString</span>(<span class="params">code, filename, opts</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> filename === <span class="string">'object'</span>) &#123;</span><br><span class="line">		opts = filename;</span><br><span class="line">		filename = <span class="literal">undefined</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	opts = opts || &#123;&#125;;</span><br><span class="line">	filename = filename || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">	opts.appendPaths = opts.appendPaths || [];</span><br><span class="line">	opts.prependPaths = opts.prependPaths || [];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> code !== <span class="string">'string'</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'code must be a string, not '</span> + <span class="keyword">typeof</span> code);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> parent = <span class="built_in">module</span>.parent;</span><br><span class="line">	<span class="keyword">var</span> m = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line">	m.filename = filename;</span><br><span class="line">	m.paths = [].concat(opts.prependPaths).concat(paths).concat(opts.appendPaths);</span><br><span class="line">	m._compile(code, filename);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> exports = m.exports;</span><br><span class="line">	parent &amp;&amp; parent.children &amp;&amp; parent.children.splice(parent.children.indexOf(m), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码里面最关键的就是引用的Nodejs的module核心模块。</p>
<p>这里面用到了Module模块的几个变量和方法。</p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>module.children</td>
<td>就是这个module require的那些module</td>
</tr>
<tr>
<td>module.exports</td>
<td>就是module 暴露给引用者的内容</td>
</tr>
<tr>
<td>module.filename</td>
<td>文件名</td>
</tr>
<tr>
<td>module.loaded</td>
<td>load完成没，比如前面的循环引用的例子中，就会出现load没完成的时候</td>
</tr>
<tr>
<td>module.parent</td>
<td>第一个require 这个module的module</td>
</tr>
<tr>
<td>module.require(id)</td>
<td>就是require的真身，没怎么用过，貌似可以在load完成后再让其require，但是在其他module中只能看到exports，所以module本身需要被export。</td>
</tr>
</tbody></table>
<h3 id="Module-contructor"><a href="#Module-contructor" class="headerlink" title="Module contructor"></a>Module contructor</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Module;</span><br></pre></td></tr></table></figure>

<h3 id="module-compile"><a href="#module-compile" class="headerlink" title="module._compile"></a>module._compile</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run the file contents in the correct scope or sandbox. Expose</span></span><br><span class="line"><span class="comment">// the correct helper variables (require, module, exports) to</span></span><br><span class="line"><span class="comment">// the file.</span></span><br><span class="line"><span class="comment">// Returns exception, if any.</span></span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  ...(omit here)...</span><br><span class="line">  <span class="comment">// create wrapper function</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> compiledWrapper = vm.runInThisContext(wrapper, &#123;</span><br><span class="line">    filename: filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process._debugWaitConnect &amp;&amp; process._eval == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!resolvedArgv) &#123;</span><br><span class="line">      <span class="comment">// we enter the repl if we're not given a filename argument.</span></span><br><span class="line">      <span class="keyword">if</span> (process.argv[<span class="number">1</span>]) &#123;</span><br><span class="line">        resolvedArgv = Module._resolveFilename(process.argv[<span class="number">1</span>], <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolvedArgv = <span class="string">'repl'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set breakpoint on module start</span></span><br><span class="line">    <span class="keyword">if</span> (filename === resolvedArgv) &#123;</span><br><span class="line">      <span class="keyword">delete</span> process._debugWaitConnect;</span><br><span class="line">      <span class="keyword">const</span> Debug = vm.runInDebugContext(<span class="string">'Debug'</span>);</span><br><span class="line">      Debug.setBreakPoint(compiledWrapper, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> dirname = path.dirname(filename);</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> args = [<span class="keyword">this</span>.exports, <span class="built_in">require</span>, <span class="keyword">this</span>, filename, dirname];</span><br><span class="line">  <span class="keyword">var</span> depth = internalModule.requireDepth;</span><br><span class="line">  <span class="keyword">if</span> (depth === <span class="number">0</span>) stat.cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">var</span> result = compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</span><br><span class="line">  <span class="keyword">if</span> (depth === <span class="number">0</span>) stat.cache = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="require原理"><a href="#require原理" class="headerlink" title="require原理"></a>require原理</h2><p>如果对上述代码的理解还不够，可以看一下require的源码，其实require-from-string就是截取了require源码中对于js文件的处理，并且省略了一些细节的结果，省了文件类型判断，模块的cache，paths的生成等。</p>
<p>具体的原理解析可以看<a href="http://tech.colla.me/zh/show/further_reading_on_node.js_modules" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p>
<p>总结得讲，就是</p>
<ul>
<li><p>require其实是调用了module的_load方法，该方法首先会根据入参生成文件的绝对路径，然后用这个绝对路径作为键去查cache（其实就是个对象），如果找到，直接返回，如果找不到继续编译。</p>
</li>
<li><p>编译首先会找是不是核心模块，如果是则返回核心模块的require结果，如果不是，继续。</p>
</li>
<li><p>接下来就是require-from-string中的步骤，new Module（filename，parent）。</p>
</li>
<li><p>在接下来就是一些变量的赋值，比如isMain，如果是node命令运行这个文件，那他就是入口文件，process.mainModule就是当前module。</p>
</li>
<li><p>接下来就是将这个module存到cache。</p>
</li>
<li><p>调用tryModuleLoad（module，filename），该方法会调用module.load，如果调用失败，则从cache中删除当前模块。</p>
</li>
<li><p>那么module.load做了什么？Module._nodeModulePaths(path.dirname(filename))方法生成路径，再根据路径获取扩展名，然后对于不同的文件类型调用不同的方法，json就用JSON.parse，js就调用了module._compile方法</p>
</li>
<li><p>这个_compile会对模块进行解析</p>
</li>
<li><p>最终就是调用NativeModule.wrapper去将打包好的模块放进闭包中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  NativeModule.wrapper = [</span><br><span class="line">    <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">    <span class="string">'\n&#125;);'</span></span><br><span class="line">  ];</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>路由协议</title>
    <url>/2020/03/27/routing-protocol/</url>
    <content><![CDATA[<p>有了IP地址以及路由表的设计之后，我们就要继续考虑如何去获取路由信息，也就是路由器之间如何去交换信息，如如何表达自己对其他路由器的可达性，获取路由信息之后，我们还要想办法构造路由表。</p>
<a id="more"></a>

<h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>为了有效地转发IP数据包并提高成功交付的机会，在网际层使用了网际控制报文协议，但是ICMP并不是高层协议（看起来是高层协议，因为ICMP是装在IP数据报中，作为其中数据部分），其格式如下：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1585353884/computer_network/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200328080347_h3omwf.png" alt="ICMP"></p>
<p>ICMP报文分为两个类型，<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>，ICMP报文的前四个字节的格式是统一的，共有三个字段，分别为类型，代码，检验和，接下来4个字节的内容与ICMP类型有关，最后的是数据字段，其长度取决于ICMP的类型。</p>
<p>常见的ICMP报文类型有：</p>
<table>
<thead>
<tr>
<th>ICMP报文种类</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody><tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达</td>
</tr>
<tr>
<td></td>
<td>11</td>
<td>时间超过</td>
</tr>
<tr>
<td></td>
<td>12</td>
<td>参数问题</td>
</tr>
<tr>
<td></td>
<td>5</td>
<td>改变路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>请求或回答</td>
</tr>
<tr>
<td></td>
<td>13或14</td>
<td>时间戳请求或回答</td>
</tr>
</tbody></table>
<p>ICMP报文的代码字段是为了进一步区分某种类型中的几种不同情况，检验和字段用来检验整个ICMP报文，因为IP数据报首部的检验和并不检验IP数据包的内容。</p>
<h3 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h3><p>上表中的差错报文共有四种：</p>
<ul>
<li>终点不可达：当路由器或者主机不能交付数据报时就向源点发送终点不可达报文。</li>
<li>时间超过：当路由器收到生存时间为0的数据报时，丢弃该数据报的同时，向远点发送时间超过报文。同时当中点在预先规定的时间不能收到一个数据报的全部数据报片时，就把已收到的全部数据报片丢弃，并向源点发送时间超过报文。</li>
<li>参数问题：当主机或路由器收到的数据报首部中有的字段不正确时，就会丢弃该数据报，并向源点发送参数问题报文。</li>
<li>改变路由（重定向）：路由器把改变路由的报文发送给主机，让主机知道瑕疵的数据报发送给另外的路由器。</li>
</ul>
<p>当主机刚开始工作的时候，一般都在路由表中设置一个默认路由器的IP地址，不管数据报要发送到那个目的地址，都一律先把数据报发送到默认路由器。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过当前网络上的另一个路由器时，就用改变路由报文把这个情况告诉主机。</p>
<p>所有的ICMP差错报告报文中的数据字段都具有相同的样式，把收到的<strong>需要进行差错报告的IP数据包的首部和数据字段的前8个字节提取出来</strong>，作为ICMP数据报的数据字段，再加上ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文，之所起提取需要进行差错报告的IP数据报前8个字段是为了获得运输层 的端口号</p>
<p>以下几种情况不应该发送ICMP差错报告报文：</p>
<ul>
<li>对ICMP差错报告报文，不再发送ICMP差错报告报文。</li>
<li>对于第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文。</li>
<li>对具有多播地址的数据包，都不发送差错报文。</li>
<li>对特殊地址（如127.0.0.1），不发送差错报文。</li>
</ul>
<h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><p>常用的询问报文有两种：</p>
<ul>
<li>回送请求和回答：ICMP回送请求报文是主机或路由器向一个特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文，这种询问报文用来测试目的站是否可达以及其有关状态。</li>
<li>时间戳请求和回答：请求某台主机回答它当前的日期和时间。</li>
</ul>
<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><p>PING命令其实就是使用了ICMP的回送请求与回答报文。</p>
<h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>Traceroute其实就是源主机向目的主机发送的一连串的IP数据报，数据报中封装的是<strong>无法交付的UDP数据报</strong>，第一个数据报P1的TTL设置为1，当P1到达路径上的第一个路由器R1时，R1手下它，然后把TTL减1，由于TTL等于0了，R1就把P1丢弃，并向源主机发送一个<strong>ICMP时间超过</strong>差错报文。</p>
<p>接下来一次发送第n个数据报Pn，TTL设置为n，最终某个数据报到达目的主机，由于是无法交付的UDP数据报，目的主机向源主机发送<strong>ICMP终点不可达差错报文</strong>。 </p>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><p>路由选择协议的核心就是路由算法，即需要何种算法来获取路由表中的各项目。</p>
<p>一个理想的路由算法应该具有：</p>
<ul>
<li>算法必须是<strong>正确和完整</strong>的。这里“正确”的含义是，通过各路由表所指出的路径，分组最终一定能够到达目的网络和目的主机。</li>
<li>算法在计算上必须<strong>简单</strong>。不能在网络通信上增加太多的开销。</li>
<li>算法应该能够适应通信量和网络拓扑的变化，也就是要有<strong>自适应</strong>能力。</li>
<li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定时，算法应该收敛到一个可以接受的解。</li>
<li>算法应该是<strong>公平</strong>的。路由选择算法应对所有的门户都是平等的。</li>
<li>算法应该是<strong>最佳</strong>的。所谓的最佳，只是相对于与某一种特定要求下得出较为合理的选择而已。</li>
</ul>
<h3 id="分层次路由选择协议"><a href="#分层次路由选择协议" class="headerlink" title="分层次路由选择协议"></a>分层次路由选择协议</h3><p>如果从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，可以分为两类，非别为<strong>静态路由选择策略</strong>和<strong>动态路由选择策略</strong>。</p>
<p>静态路由选择策略也叫作非自适应路由选择，其特点是简单和开销小，但不能及时适应网络状态的的变化，对于很简单地小网络，我们可以采用静态路由选择。</p>
<p><strong>互联网采用的路由选择协议主要是动态的，分布式的路由选择协议</strong>：</p>
<ul>
<li>互联网规模非常大，如果让所有路由器知道所有网络应该怎样到达，路由表将非常大，路由处理时间也会变得非常长。</li>
<li>许多单位不愿意外界了解自己单位网络的的布局细节和本部门采用的路由选择协议。</li>
</ul>
<p>为此我们可以把互联网划分为许多小的<strong>自治系统（autonomous system, AS）</strong>，AS指的是在<strong>单一技术管理下的一组路由器</strong>，一个AS对另一个AS所表现出的就是一个单一和一致的路由选择策略。</p>
<p>一个大的ISP就是一个大的自治系统，互联网就把路由选择协议分为两大类：</p>
<ul>
<li><strong>内部网关协议IGP</strong>，即在一个自治系统内部使用的路由选择协议，这与互联网中其他自治系统选择什么路由选择协议没有关系。</li>
<li><strong>外部网关协议EGP</strong>，当源主机和目的主机不在同一个自治系统中时，如果一个数据报传送到自治系统边界时，就需要一种协议将路由选择信息传送到另外一个自治系统中。</li>
</ul>
<h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3><p>RIP是一种<strong>分布式的基于距离向量的路由选择协议</strong>，是互联网的标准协议，它要求网络中的每一个路由器都要维护从自己到其他每一个目的网络的距离记录。</p>
<p>RIP将<strong>”距离“</strong>定义如下：</p>
<p>从一个路由器到直接连接的网络的距离定义为1，从路由器到非直接连接的网络距离定义为未经过的路由器数加1。</p>
<p>RIP协议的距离，也成为<strong>“跳数”</strong>，因为每经过一个路由器，跳数就加一，<strong>RIP认为最好的陆幽就是它通过的路由器数目少</strong>，即距离短。RIP允许一条路径最多包含15个路由器，因此距离等于16时就相当于不可到达，可见RIP只适用于小型网络。</p>
<p>RIP不能再两个网络之间同时使用多条路由。<strong>RIP选择一条具有最少路由器的路由，哪怕还存在一条高速低时延但是路由器较多的路由</strong></p>
<p>RIP协议的<strong>特点</strong>如下：</p>
<ul>
<li>仅和相邻的路由器交换信息。</li>
<li>路由器交换的信息是当前本路由器知道的所有信息，也就是自己现在的路由表。</li>
<li>按照固定的时间交换路由信息。</li>
</ul>
<p>路由器在刚开始工作的时候，它的路由表是空的，然后路由器就只能得出自身和相邻的几个网络的距离为1。每个路由器也只能和<strong>数目有限</strong>的相邻路由器交换并更新路由信息，但是经过若干次交换后，所有路由器最终都会得知到达自治系统中任何一个网络的最短距离和下一跳路由器的地址。这个过程叫做<strong>“收敛”</strong>。</p>
<p>RIP协议的路由表中最主要的信息就是：到达某个网络的距离，以及经过的下一跳地址。</p>
<h4 id="距离向量算法："><a href="#距离向量算法：" class="headerlink" title="距离向量算法："></a>距离向量算法：</h4><ol>
<li>对于地址为X的相邻路由器发送来的RIP报文，先修改此报文中的所有项目，把下一跳地址字段中的地址都改为X，并把所有的距离字段加1.每一个项目都有三个关键数据：到目的网络N，距离是d，下一跳路由地址是X。</li>
<li>对修改后的RIP的报文中的每一个项目，进行以下步骤：<ul>
<li>若原来的路由表中没有目的网络N，则把该项目添加到路由表中。</li>
<li>如果路由表中有目的网络N，再查看下一跳路由地址，若下一跳路由地址是X，则把收到的项目替换进原项目中。如果下一跳地址不是X，查看收到的项目中的d是否小于路由表中的距离，如果小，则更新，否则什么也不做。</li>
</ul>
</li>
<li>若三分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器标记为不可到达。</li>
</ol>
<h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3><p><strong>开发最短路由优先OSPF（Open Shortest Path First）</strong>是为了克服RIP的缺点而开放出来了。“开放”表明OSPF协议并不是受某一家厂商控制，“最短路径优先”是因为采用了Dijkstra提出的最短路径算法SPF。</p>
<p>OSPF协议最主要的特征就是采用了分布式的<strong>链路状态协议（link state protocol）</strong>，而不是RIP的距离向量，与RIP相比，OSPF的<strong>三个特点</strong>与RIP都不一样：</p>
<ul>
<li>向本自治系统的所有路由器发送信息，这里使用的方法是洪泛法，也就是路由器向所有输出端口向<strong>所有相邻的路由器</strong>发送信息，而每一个相邻路由器又再将此信息发送给其所有相邻的路由器（不再发送给刚刚发来信息的那个路由器）。</li>
<li>发送的<strong>信息是本路由器与所有相邻路由器的链路状态</strong>，但这是只该路由器知道的部分信息，所谓的“链路状态”就是说明本路由器和那些路由器相邻，以及该链路的“度量”。OSPF将这个度量用于表示费用，距离，时延，带宽等，由网络管理人员决定。</li>
<li>只有当链路状态发生变化时，路由器才想所有路由器用洪泛法发送信息。</li>
</ul>
<p>由于各路由器之间频繁地交换信息，因此所有的路由器最终都会建立一个链路状态数据库，这个数据库其实就是全网的拓扑结构图。</p>
<p>OSPF将一个自治系统再划分为若干个更小的范围，叫做区域（area），每个区域都有一个32位的区域标识符。</p>
<p>划分区域的好处就是把利用洪泛法交换的链路状态信息的范围局限在每一个区域而不是整个自治系统。OSPF使用层次结构的区域划分，在上层的区域叫做主干区域，主干区域的标识符默认为0.0.0.0 ，主干区域的作用是用来连通其他在下层的区域，从其他区域来的信息都由区域边界路由器进行概括。</p>
<h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><p>首先要搞清楚，为什么在不同的自治系统之间不能使用前面讨论的内部网关协议，这主要有两个原因：</p>
<ul>
<li>互联网规模过大，是的自治系统AS之间的路由选择非常困难。连接在互联网主干网上的路由器，必须对任何有效的IP地址都能在路由表中找到匹配的目的网络。而目前在互联网主干网路由器上，一个路由表的项目早就找过5w的网络前缀。，使用OSPF计算路径花费时间太长。而且由于每个AS内部协议不同，当一条路径通过多个AS时，再想计算出有意义的路径代价不太可能。</li>
<li>AS之间的路由选择必须考虑相关的策略，包括政治经济等因素，例如我国国内的站点在相互传递数据报的时候不能去国外兜圈子。</li>
</ul>
<p>BGP只能是力求寻找一条能够到达目的网络且比较好的路由，<strong>并非要找一条最佳路由</strong>。BGP采用路径向量路由选择协议。在配置BGP，每一个自治系统的管理员至少要选择一个路由器作为该自治系统的<strong>”BGP发言人“</strong>。而BGP发言人往往就是BGP的边界路由器。</p>
<p>一个BGP发言人与其他AS的BGP发言人交换信息，就要先建立TCP连接（port：179），然后在此连接上建立BGP session。。</p>
<p>每个BGP发言人除了必须运行BGP之外，还必须运行该AS的内部网关协议。。</p>
<p>BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列自治系统。当BGP发言人交换了网络可达性后，各BGP发言人就根据所采用的的策略从收到的路由信息中找到到达各AS的较好路由。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>RPC 概念简介</title>
    <url>/2020/08/17/rpc/</url>
    <content><![CDATA[<h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。</p>
<p>RPC （Remote Procedure Call）的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，<strong>RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用</strong>。　　<br> RPC采用C/S模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，计算结果发送答复信息，然后等待下一个调用信息。最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>单独看上面的概念可能还是有点模糊</p>
<p>我们看一下Python自带的RPC demo</p>
<p>Server.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_add</span><span class="params">(a,b)</span>:</span>     </span><br><span class="line">    totle = a + b      </span><br><span class="line">    <span class="keyword">return</span> totle </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:     </span><br><span class="line">    s = SimpleXMLRPCServer((<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>))   <span class="comment">#开启xmlrpcserver     </span></span><br><span class="line">    s.register_function(fun_add)                <span class="comment">#注册函数fun_add     </span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"server is online..."</span>     s.serve_forever()                           <span class="comment">#开启循环等待</span></span><br></pre></td></tr></table></figure>

<p>Client.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpclib <span class="keyword">import</span> ServerProxy            <span class="comment">#导入xmlrpclib的包 </span></span><br><span class="line">s = ServerProxy(<span class="string">"http://172.171.5.205:8080"</span>) <span class="comment">#定义xmlrpc客户端 </span></span><br><span class="line"><span class="keyword">print</span> s.fun_add(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h2><p>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1597670692/Blog/fd5b5686336b0a1212398d8ea8fe6f66.jpg-wh_651x-s_3461264051_xmwq0x.jpg" alt></p>
<h3 id="RPC核心功能（RPC协议）"><a href="#RPC核心功能（RPC协议）" class="headerlink" title="RPC核心功能（RPC协议）"></a>RPC核心功能（RPC协议）</h3><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1597670948/Blog/2730356-e239aeb499d61162.png_ejj0qe.webp" alt></p>
<ul>
<li>客户端(Client)：服务调用方。</li>
<li>客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li>服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li>服务端(Server)：服务的真正提供者。</li>
<li>Network Service：底层传输，可以是 TCP 或 HTTP。</li>
</ul>
<h3 id="RPC-调用流程如下"><a href="#RPC-调用流程如下" class="headerlink" title="RPC 调用流程如下"></a>RPC 调用流程如下</h3><ul>
<li>服务消费者(Client 客户端)通过本地调用的方式调用服务。</li>
<li>客户端存根(Client Stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体。</li>
<li>客户端存根(Client Stub)找到远程的服务地址，并且将消息通过网络发送给服务端。</li>
<li>服务端存根(Server Stub)收到消息后进行解码(反序列化操作)。</li>
<li>服务端存根(Server Stub)根据解码结果调用本地的服务进行相关处理</li>
<li>服务端(Server)本地服务业务处理。</li>
<li>处理结果返回给服务端存根(Server Stub)。</li>
<li>服务端存根(Server Stub)序列化结果。</li>
<li>服务端存根(Server Stub)将结果通过网络发送至消费方。</li>
<li>客户端存根(Client Stub)接收到消息，并进行解码(反序列化)。</li>
<li>服务消费方得到最终结果。</li>
</ul>
<h2 id="RPC协议实现"><a href="#RPC协议实现" class="headerlink" title="RPC协议实现"></a>RPC协议实现</h2><p>RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：</p>
<ul>
<li>服务寻址</li>
<li>数据流的序列化和反序列化</li>
<li>网络传输</li>
</ul>
<h3 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a><strong>服务寻址</strong></h3><p>服务寻址可以使用 Call ID 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>所以在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。</p>
<p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个函数和Call ID的对应表。</p>
<p>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<p>实现方式：服务注册中心。</p>
<p>要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例。</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h3><p>客户端怎么把参数值传给远程的函数呢?在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</p>
<p>但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。</p>
<p>这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。</p>
<p>只有二进制数据才能在网络中传输，序列化和反序列化的定义是：</p>
<ul>
<li>将对象转换成二进制流的过程叫做序列化</li>
<li>将二进制流转换成对象的过程叫做反序列化</li>
</ul>
<p>这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h3><p>网络传输：远程调用往往用在网络上，客户端和服务端是通过网络连接的。</p>
<p>所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</p>
<p>只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。</p>
<p>尽管大部分 RPC 框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。</p>
<p>TCP 的连接是最常见的，简要分析基于 TCP 的连接：通常 TCP 连接可以是按需连接(需要调用的时候就先建立连接，调用结束后就立马断掉)，也可以是长连接(客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效)，多个远程过程调用共享同一个连接。</p>
<p>在 RPC 中可选的网络传输方式有多种，可以选择 TCP 协议、UDP 协议、HTTP 协议。</p>
<p>每一种协议对整体的性能和效率都有不同的影响，如何选择一个正确的网络传输协议呢?首先要搞明白各种传输协议在 RPC 中的工作方式。</p>
<h4 id="基于-TCP-协议的-RPC-调用"><a href="#基于-TCP-协议的-RPC-调用" class="headerlink" title="基于 TCP 协议的 RPC 调用"></a><strong>基于 TCP 协议的 RPC 调用</strong></h4><p>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法。</p>
<p>***将结果返回给服务的调用方，整个基于 TCP 协议的 RPC 调用大致如此。</p>
<p>但是在实例应用中则会进行一系列的封装，如 RMI 便是在 TCP 协议上传递可序列化的 Java 对象。</p>
<h4 id="基于-HTTP-协议的-RPC-调用"><a href="#基于-HTTP-协议的-RPC-调用" class="headerlink" title="基于 HTTP 协议的 RPC 调用"></a><strong>基于 HTTP 协议的 RPC 调用</strong></h4><p>该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p>
<p>其大致流程为：由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 GET、POST、PUT、DELETE 等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p>
<p>而调用的具体方法则是根据 URL 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 XML 数据或者 JSON 数据解析后的结果，***返回 JOSN 或者 XML 的数据结果。</p>
<p>由于目前有很多开源的 Web 服务器，如 Tomcat，所以其实现起来更加容易，就像做 Web 项目一样。</p>
<h4 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a><strong>两种方式对比</strong></h4><p>基于 TCP 的协议实现的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。</p>
<p>但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p>
<p>基于 HTTP 协议实现的 RPC 则可以使用 JSON 和 XML 格式的请求或响应数据。</p>
<p>而 JSON 和 XML 作为通用的格式标准(使用 HTTP 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 Web 程序已经做好了序列化内容)，开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p>
<p>但是由于 HTTP 协议是上层协议，发送包含同等内容的信息，使用 HTTP 协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p>
<p>因此在同等网络下，通过 HTTP 协议传输相同内容，效率会比基于 TCP 协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距。</p>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>使用 RabbitMQ 的好处：</p>
<ul>
<li>同步变异步：可以使用线程池将同步变成异步，但是缺点是要自己实现线程池，并且强耦合。使用消息队列可以轻松将同步请求变成异步请求。</li>
<li>低内聚高耦合：解耦，减少强依赖。</li>
<li>流量削峰：通过消息队列设置请求***值，超过阀值的抛弃或者转到错误界面。</li>
<li>网络通信性能提高：TCP 的创建和销毁开销大，创建 3 次握手，销毁 4 次分手，高峰时成千上万条的链接会造成资源的巨大浪费，而且操作系统每秒处理 TCP 的数量也是有数量限制的，必定造成性能瓶颈。</li>
</ul>
<h2 id="RPC服务注册与发现"><a href="#RPC服务注册与发现" class="headerlink" title="RPC服务注册与发现"></a>RPC服务注册与发现</h2><p>RPC远程过程调用中，存在2个角色，一个服务提供者、另一个服务消费者。那如何让调用者知道，存在哪些服务可以调用呢？即如何让别人使用我们的服务呢？</p>
<p>有同学说很简单嘛，告诉使用者服务的IP以及端口就可以了啊。确实是这样，这里问题的关键在于是自动告知还是人肉告知。</p>
<p>人肉告知的方式：如果你发现你的服务一台机器不够，要再添加一台，这个时候就要告诉调用者我现在有两个ip了，你们要轮询调用来实现负载均衡；调用者咬咬牙改了，结果某天一台机器挂了，调用者发现服务有一半不可用，他又只能手动修改代码来删除挂掉那台机器的ip。现实生产环境当然不会使用人肉方式。</p>
<p>有没有一种方法能实现自动告知，即机器的增添、剔除对调用方透明，调用者不再需要写死服务提供方地址？当然可以，现如今zookeeper被广泛用于实现服务自动注册与发现功能！</p>
<p>成熟的服务治理框架中不止存在这两个角色，一般还会有一个 Registry（注册中心）的角色。一张图就可以解释注册中心的主要职责。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1597672620/Blog/9033085-334724946c50139e.png_i6remn.webp" alt></p>
<ul>
<li>注册中心，用于服务端注册远程服务以及客户端发现服务</li>
<li>服务端，对外提供后台服务，将自己的服务信息注册到注册中心</li>
<li>客户端，从注册中心获取远程服务的注册信息，然后进行远程过程调用</li>
</ul>
<p>目前主要的注册中心可以借由 zookeeper，eureka，consul，etcd 等开源框架实现。互联网公司也会因为自身业务的特性自研，如美团点评自研的 MNS，新浪微博自研的 vintage。</p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>显然，要让别人发现自己的服务，首先需要把服务注册到服务中心。</p>
<p>把服务注册到服务中心，其实就是在注册中心进行一个登记，注册中心存储了该服务的IP、端口、调用方式(协议、序列化方式)等。在zookeeper中，进行服务注册，实际上就是在zookeeper中创建了一个znode节点，该节点存储了上面所说的服务信息。该节点承担着最重要的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正网络拓扑位置以及得知如何调用。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务消费者在第一次调用服务时，会通过注册中心找到相应的服务的IP地址列表，并缓存到本地，以供后续使用。当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。</p>
<h3 id="感知服务的下线"><a href="#感知服务的下线" class="headerlink" title="感知服务的下线"></a>感知服务的下线</h3><p>服务上线时自然要注册到注册中心，但下线时也得从注册中心中摘除。注册是一个主动的行为，这没有特别要注意的地方，但服务下线却是一个值得思考的问题。服务下线包含了主动下线和系统宕机等异常方式的下线。</p>
<h2 id="RPC与RESTful"><a href="#RPC与RESTful" class="headerlink" title="RPC与RESTful"></a>RPC与RESTful</h2><h3 id="所属类别不同"><a href="#所属类别不同" class="headerlink" title="所属类别不同"></a>所属类别不同</h3><p>REST，是Representational State Transfer 的简写，中文描述表述性状态传递（是指某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式(XML、JSON)等信息。）</p>
<p>REST 是一种软件架构风格。这种风格的典型应用，就是HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p>
<p>而RPC 呢，是 Remote Procedure Call Protocol 的简写，中文描述是远程过程调用，它可以实现客户端像调用本地服务(方法)一样调用服务器的服务(方法)。</p>
<p>而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的，按理说它和REST不是一个层面意义上的东西，不应该放在一起讨论，但是谁让REST这么流行呢，它是目前最流行的一套互联网应用程序的API设计标准，某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p>
<h3 id="使用方式不同"><a href="#使用方式不同" class="headerlink" title="使用方式不同"></a>使用方式不同</h3><p>从使用上来看，HTTP 接口只关注服务提供方，对于客户端怎么调用并不关心。接口只要保证有客户端调用时，返回对应的数据就行了。而RPC则要求客户端接口保持和服务端的一致。</p>
<p>REST 是服务端把方法写好，客户端并不知道具体方法。客户端只想获取资源，所以发起HTTP请求，而服务端接收到请求后根据URI经过一系列的路由才定位到方法上面去RPC是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。</p>
<h3 id="面向对象不同"><a href="#面向对象不同" class="headerlink" title="面向对象不同"></a>面向对象不同</h3><p>从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ，REST：所谓的 Representational state transfer ，是面向资源的，除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的，这个接触不多，就不多说了。</p>
<h3 id="序列化协议不同"><a href="#序列化协议不同" class="headerlink" title="序列化协议不同"></a>序列化协议不同</h3><p>接口调用通常包含两个部分，序列化和通信协议。</p>
<p>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。</p>
<p>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes等，REST 通常使用的是 JSON或者XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>REST和RPC都常用于微服务架构中。</p>
<p>1、HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</p>
<p>RPC在微服务中的利用</p>
<p>2、 RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</p>
<p>参考链接：</p>
<p><a href="https://www.zhihu.com/question/25536695" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/25536695</a></p>
<p><a href="https://www.jianshu.com/p/027a6ec9c44e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/027a6ec9c44e</a></p>
<p><a href="https://developer.51cto.com/art/201906/597963.htm" rel="external nofollow noopener noreferrer" target="_blank">https://developer.51cto.com/art/201906/597963.htm</a></p>
<p><a href="https://www.jianshu.com/p/4213069067ae" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4213069067ae</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>同源策略与跨域方法的思考</title>
    <url>/2019/08/10/same_orgin_and_cors/</url>
    <content><![CDATA[<h2 id="同源策略概述"><a href="#同源策略概述" class="headerlink" title="同源策略概述"></a>同源策略概述</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。<br>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。协议相同，域名相同，端口相同。</p>
<a id="more"></a>

<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3><h4 id="窃取cookie"><a href="#窃取cookie" class="headerlink" title="窃取cookie"></a>窃取cookie</h4><p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？<br>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<h4 id="窃取页面"><a href="#窃取页面" class="headerlink" title="窃取页面"></a>窃取页面</h4><p>1.有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进<a href="http://www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。" rel="external nofollow noopener noreferrer" target="_blank">www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。</a><br>2.睡眼朦胧的你没看清楚，平时访问的银行网站是<a href="http://www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？" rel="external nofollow noopener noreferrer" target="_blank">www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;iframe name=&quot;yinhang&quot; src=&quot;www.yinhang.com&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">// JS</span><br><span class="line">// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom</span><br><span class="line">const iframe = window.frames[&apos;yinhang&apos;]</span><br><span class="line">const node = iframe.document.getElementById(&apos;你输入账号密码的Input&apos;)</span><br><span class="line">console.log(`拿到了这个$&#123;node&#125;，我还拿不到你刚刚输入的账号密码吗`)</span><br></pre></td></tr></table></figure>

<p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h3 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h3><ol>
<li>Cookie，LocalStorage和IndexDB。</li>
<li>DOM 无法获取。</li>
<li>AJAX请求无法发送</li>
</ol>
<h2 id="AJAX跨域的两种常用方式"><a href="#AJAX跨域的两种常用方式" class="headerlink" title="AJAX跨域的两种常用方式"></a>AJAX跨域的两种常用方式</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h4 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h4><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：<br>HEAD<br>GET<br>POST<br>（2）HTTP的头信息不超出以下几种字段：</p>
<p>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
</blockquote>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Credentials: true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&gt; xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; xhr.withCredentials = <span class="literal">false</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><ol>
<li>预检请求</li>
</ol>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line">&gt; <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&gt; xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">&gt; xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">&gt; xhr.send();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; OPTIONS /cors HTTP/1.1</span><br><span class="line">&gt; Origin: http://api.bob.com</span><br><span class="line">&gt; Access-Control-Request-Method: PUT</span><br><span class="line">&gt; Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">&gt; Host: api.alice.com</span><br><span class="line">&gt; Accept-Language: en-US</span><br><span class="line">&gt; Connection: keep-alive</span><br><span class="line">&gt; User-Agent: Mozilla/5.0...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，”预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<ol start="2">
<li>预检请求的返回</li>
</ol>
<p>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; HTTP/1.1 200 OK</span><br><span class="line">&gt; Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">&gt; Server: Apache/2.0.61 (Unix)</span><br><span class="line">&gt; Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">&gt; Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">&gt; Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">&gt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&gt; Content-Encoding: gzip</span><br><span class="line">&gt; Content-Length: 0</span><br><span class="line">&gt; Keep-Alive: timeout=2, max=100</span><br><span class="line">&gt; Connection: Keep-Alive</span><br><span class="line">&gt; Content-Type: text/plain</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Origin: *</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">&gt; Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>服务器回应的其他CORS相关字段如下。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">&gt; Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">&gt; Access-Control-Allow-Credentials: true</span><br><span class="line">&gt; Access-Control-Max-Age: 1728000</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<ol start="3">
<li>预检请求成功之后的正常请求、</li>
</ol>
<p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; PUT /cors HTTP/1.1</span><br><span class="line">&gt; Origin: http://api.bob.com</span><br><span class="line">&gt; Host: api.alice.com</span><br><span class="line">&gt; X-Custom-Header: value</span><br><span class="line">&gt; Accept-Language: en-US</span><br><span class="line">&gt; Connection: keep-alive</span><br><span class="line">&gt; User-Agent: Mozilla/5.0...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">&gt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><p>想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 监听9099端口</span><br><span class="line">    listen 9099;</span><br><span class="line">    # 域名是localhost</span><br><span class="line">    server_name localhost;</span><br><span class="line">    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 </span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">    proxy_pass http://localhost:9871;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="由重定向请求引发的同源策略思考"><a href="#由重定向请求引发的同源策略思考" class="headerlink" title="由重定向请求引发的同源策略思考"></a>由重定向请求引发的同源策略思考</h2><p>今天遇到这样一个情况，前端是用vue写的，首页的路由守卫中会通过修改当前url的方式去call后台的express接口。</p>
<p>在这个接口中的处理中间键中会去调用passport-azure的认证接口，这个流程可以顺利执行。</p>
<p>但是如果我在ajax的请求处理中间键中如果发现session过期之后自动帮助用户重新去Azure，但是这个时候就会抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间键</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loginMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  passport.authenticate(<span class="string">'azuread-openidconnect'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      response: res, <span class="comment">// required</span></span><br><span class="line">      customState: <span class="string">'my_state'</span>, <span class="comment">// optional. Provide a value if you want to provide custom state value.</span></span><br><span class="line">      failureRedirect: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  )(req, res, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过url调用</span></span><br><span class="line">app.route(<span class="string">'/api/auth/user/login'</span>).get(aadController.loginMiddleware);</span><br><span class="line"><span class="comment">// ajax请求  </span></span><br><span class="line">app.all(<span class="string">'/api/*'</span>, aadController.ensureAuthenticatedWithSkipPath);</span><br></pre></td></tr></table></figure>

<p>上述代码在第一个路由，也就是url调用方式时可以正常运行，但是如果走第二个路由，就会抛出一个错误。</p>
<p>假设我的请求是A，如果身份校验是过的，那就正常执行，如果不过，我自动帮用户调用一次passport-azure的认证请求，假设是B。这个时候控制台会报一个错，说我重定向自A的请求B跨域。</p>
<p>这里面就涉及到了两个问题</p>
<ul>
<li><p>为什么请求B是后端代码发送的，却会被浏览器的同源策略限制。</p>
</li>
<li><p>为什么说我的请求B是从A重定向过来的。</p>
</li>
<li><p>为什么B请求这个时候会跨域，而我通过url的方式去调用这个B却不会跨域。</p>
</li>
</ul>
<p>首先说一下前两个问题的答案，前两个问题其实可以一并解释，因为，全程passport中用到的req其实是前端传过来的，所以一直都是一个请求，只不过passport对这个请求重定向了而已。</p>
<p>第二个问题，为什么通过url的方式不会跨域，而ajax会。这个问题可以有两种理解方式，你可以认为浏览器的同源策略对url的方式没有限制，也可以认为通过url的方式去直接call一个请求，从头到尾都在一个域中，也就是你这个请求所在的域，所以没有跨域。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先同源策略的主要目的就是为了限制不同网站之间资源的随意调用，保证网络的安全。他的识别依靠的是请求头中的origin字段，origin字段是在请求页面时就决定的，比如你请求的是 <a href="http://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com</a> ，那么从该页面发出的任何请求的origin字段都是 <a href="http://www.baidu.com" rel="external nofollow noopener noreferrer" target="_blank">www.baidu.com</a> ，百度的服务器检测这些请求的origin字段与自己是相同的就不会触发跨域，如果不同就会触发跨域问题从而拒绝请求。</p>
<p>但是由于同源策略过于严格，当我的后台是由很多服务器共同组成的时候，就不可避免地会遇到跨域问题，所以就需要一些跨域方式来让我的后台服务器之间可以相互访问。</p>
<p>参考文章：</p>
<p><a href="https://segmentfault.com/a/1190000015597029" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000015597029</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Session Fixation 原理与防御</title>
    <url>/2019/11/09/sessionFixation/</url>
    <content><![CDATA[<h3 id="Session-与登录机制"><a href="#Session-与登录机制" class="headerlink" title="Session 与登录机制"></a>Session 与登录机制</h3><h4 id="Session-概念"><a href="#Session-概念" class="headerlink" title="Session 概念"></a>Session 概念</h4><p>指一类用来在客户端和服务器之间保持状态的方案的存储结构</p>
<a id="more"></a>

<h4 id="Session-特点"><a href="#Session-特点" class="headerlink" title="Session 特点"></a>Session 特点</h4><p>由于Session是以文本文件形式存储在服务器端，所以不怕客户端修改内容，可以直接存储在内存中，也可以存储在redis这种内存数据库中，当然存储到其他数据库中也是可以的。</p>
<p>Session是有生命周期的</p>
<p>Session实例时轻量级的，所谓的轻量级，指的是它的创建和删除不需要消耗太多的资源</p>
<p>Session对象内部有一个缓存</p>
<h4 id="Session-用法"><a href="#Session-用法" class="headerlink" title="Session 用法"></a>Session 用法</h4><p>用于存储特定用户会话的属性以及配置信息，比如用户的身份信息等，这些信息在web页面跳转的时候信息将不会丢失。</p>
<p>通常用于以下操作：</p>
<ul>
<li>存储整个会话过程中保持用户状态的信息，比如登录信息或者用户浏览时产生的其他信息</li>
<li>存储只需要页面新加载过程中，或者一组功能页之间保持状态的对象</li>
<li>在web服务器上保持用户的状态信息，供在任何时间从任何设备上的页面进行访问</li>
</ul>
<p>限制：</p>
<ul>
<li>用户登陆越多，session需要的内存越大</li>
<li>每个session对象的持续时间是用户访问时间加上不活动时间</li>
</ul>
<h4 id="为何需要Session"><a href="#为何需要Session" class="headerlink" title="为何需要Session"></a>为何需要Session</h4><p>因为HTTP协议本身是无状态的，没有办法用户登陆之后能够在一段时间之内记住登录状态，那就需要另外一种工具来讲登录状态记录下来，并为这个记录生成一个id返回给客户端，客户端保存下来之后，接下来的每个请求都会带上这个id自动去认证这个登录态。</p>
<p>举个喝咖啡的例子：</p>
<p>1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。</p>
<p>2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。</p>
<p>3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。</p>
<h4 id="具体机制"><a href="#具体机制" class="headerlink" title="具体机制"></a>具体机制</h4><ol>
<li><p>当程序需要为某个客户端的请求创建一个<code>session</code>（一般是登陆信息验证成功之后为这些信息创建一个session）的时候，服务器首先检查这个客户端的请求里是否已包含了一个  <strong>session标识</strong>   - 称为<code>session id</code>，如果已包含一个<code>session id</code>则说明以前已经为此客户端创建过session，服务器就按照<code>session id</code>把这个<code>session</code>检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含<code>session id</code>，则为此客户端创建一个<code>session</code>并且生成一个与此<code>session</code>相关联的<code>session id</code>，<code>session id</code>的值应该是一个 <strong>既不会重复，又不容易被找到规律以仿造的字符串</strong> ，这个<code>session id</code>将被在本次响应中返回给客户端保存（一般通过返回头中的set-cookie头将这个sessionid设置到cookie中，下次的请求就会通过cookie自动将这个sessionid发送到后台）。</p>
</li>
<li><p>由于<code>cookie</code>可以被人为的禁止，必须有其他机制以便在<code>cookie</code>被禁止时仍然能够把<code>session id</code>传递回服务器。经常被使用的一种技术叫做<code>URL</code>重写</p>
<p>两种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 作为url附加路径</span><br><span class="line">&apos;http://..../xxx;jsessionid=abcdefjijeoijoifjioe&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 作为查询字符串</span><br><span class="line">&apos;http://..../xxx?jsessionid=abcdefjijeoijoifjioe&apos;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>较老的技术，<strong>表单隐藏字段</strong>，此方法在防止csrf中有用</p>
</li>
</ol>
<h3 id="Session-Fixation-漏洞"><a href="#Session-Fixation-漏洞" class="headerlink" title="Session Fixation 漏洞"></a>Session Fixation 漏洞</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>会话固定攻击（session fixation attack）是利用应用系统在服务器的会话ID固定不变机制，借助他人用相同的会话ID获取认证和授权，然后利用该会话ID劫持他人的会话以成功冒充他人，造成会话固定攻击</p>
<h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p>1、攻击者Attacker能正常访问该应用网站；</p>
<p>2、应用网站服务器返回一个会话ID(attackSessionID)给他；</p>
<p>3、攻击者Attacker用该会话ID构造一个该网站链接（<a href="http://website.kom/login.php?sessionid=attackerSessionID）发给受害者Victim；" rel="external nofollow noopener noreferrer" target="_blank">http://website.kom/login.php?sessionid=attackerSessionID）发给受害者Victim；</a></p>
<p>4、受害者Victim点击该链接，携带攻击者的会话ID和用户名密码正常登录了该网站，会话成功建立；这个时候如果再用attackerSessionID去访问服务器，服务器就会认为攻击者是受害者。</p>
<p>5、攻击者Attacker用该会话ID成功冒充并劫持了受害者Victim的会话。</p>
<h4 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h4><p>整个攻击过程的根本原因就是直接利用了链接发送过来的sessionID生成session，并直接将这个sessionID返回。</p>
<p>解决方式也很简单，类似登陆这种有敏感信息的接口需要重新生成一个新的sessionID</p>
<h3 id="Express-session-防御-Session-Fixation-举例"><a href="#Express-session-防御-Session-Fixation-举例" class="headerlink" title="Express-session 防御 Session Fixation 举例"></a>Express-session 防御 Session Fixation 举例</h3><p>express-session是node服务器框架express的一个插件，具体如何使用可以参考一下<a href="https://github.com/expressjs/session" rel="external nofollow noopener noreferrer" target="_blank">express-session文档</a>，如果想要了解原理，也可以去看一下源码，其实原理都很简单，只不过是被封装了起来，就是请求头部的cookie和set-cookie的生成，session的CRUD的封装。</p>
<p>值得注意的是它的store选项，也就是存储位置，如果不传值会默认存储到内存中，我们可以自己实现一个插件，只要这个插件实现了上面文档中提到的get，set，touch等接口就可以，置于你的这几个接口是把数据存储到redis，MongoDB还是其他什么地方都无所谓。</p>
<p>如果只是使用express-session来进行session的管理，是没有办法防御session fixation的，而且也没有必要对每一个请求都重新生成sessionID，我们只需要对某些敏感操作，如登陆进行重新生成sessionID的操作就好。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fixation = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    req.resetSessionID = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> session = req.session;</span><br><span class="line">        req.session.regenerate(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> session) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!req.session[i]) &#123;</span><br><span class="line">                req.session[i] = session[i];</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(req.session);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (options.everyRequest &amp;&amp; req.headers[<span class="string">'X-Requested-With'</span>] !== <span class="string">'XMLHttpRequest'</span> &amp;&amp; !req.xhr) &#123;</span><br><span class="line">      req.resetSessionID().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        next(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码通过express-session自带regenerate方法重新生成一个id，并将原有的session内容设置给新生成的session。</p>
<p>我们只需要在需要重置id的请求中调用该方法即可。</p>
<p>参考文章：</p>
<p> <a href="https://juejin.im/post/5af828e96fb9a07ab83e1f10" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af828e96fb9a07ab83e1f10</a> </p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>How to use sinon mock function</title>
    <url>/2019/10/12/sinon_mock_function/</url>
    <content><![CDATA[<h2 id="Point1"><a href="#Point1" class="headerlink" title="Point1"></a>Point1</h2><p>今天在写测试的时候干了一件非常蠢的事情，记录一下，提醒自己：sinon.stub可以mock测试类中的方法，但是如果A方法被同一个类中的B方法调用，当B执行的时候，调用的还是原来的A方法</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testForSinon1.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    test1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//testForSinon2.js</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="built_in">require</span>(<span class="string">'./testForSinon1'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'_test2Inner'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    test1.test1();</span><br><span class="line">    test2Inner();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    test2,</span><br><span class="line">    test2Inner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sinon.js</span></span><br><span class="line"><span class="keyword">const</span> sinon = <span class="built_in">require</span>(<span class="string">'sinon'</span>);</span><br><span class="line"><span class="keyword">const</span> test1 = <span class="built_in">require</span>(<span class="string">'./lib/testForSinon1'</span>);</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="built_in">require</span>(<span class="string">'./lib/testForSinon2'</span>);</span><br><span class="line"></span><br><span class="line">sinon.stub(test1, <span class="string">'test1'</span>).callsFake(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1-stub'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sinon.stub(test2, <span class="string">'test2Inner'</span>).callsFake(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test2Inner-stub'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2.test2Inner();</span><br><span class="line"><span class="comment">//test2Inner-stub</span></span><br><span class="line"></span><br><span class="line">test2.test2();</span><br><span class="line"><span class="comment">//test1-stub</span></span><br><span class="line"><span class="comment">//_test2Inner</span></span><br><span class="line"><span class="comment">//test2</span></span><br></pre></td></tr></table></figure>

<h2 id="Point2"><a href="#Point2" class="headerlink" title="Point2"></a>Point2</h2><p>如果你在A中通过如下方法引入一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; b &#125; = <span class="built_in">require</span>(<span class="string">'./B.js'</span>);</span><br></pre></td></tr></table></figure>

<p>然后在测试中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'./B.js'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sinon.stub(B, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>这样其实是没有用的，调用的还是b方法的本身</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/04/04/sliding-window/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>滑动窗口算法的思路是这样：</p>
<p>1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。</p>
<p>2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p>
<p>3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p>
<a id="more"></a>

<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。</strong>左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>题目链接： <a href="https://leetcode-cn.com/problems/minimum-window-substring/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">string s, t;</span><br><span class="line"><span class="comment">// 在 s 中寻找 t 的「最小覆盖子串」</span></span><br><span class="line">int left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">string res = s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="built_in">window</span>.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 如果符合要求，移动 left 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">window</span> 符合要求) &#123;</span><br><span class="line">        <span class="comment">// 如果这个窗口的子串更短，则更新 res</span></span><br><span class="line">        res = minLen(res, <span class="built_in">window</span>);</span><br><span class="line">        <span class="built_in">window</span>.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>, minLength = s.length + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> needs = &#123;&#125;, where = &#123;&#125;;</span><br><span class="line">    t.split(<span class="string">''</span>).forEach(<span class="function">(<span class="params">t1</span>) =&gt;</span> &#123;</span><br><span class="line">        needs[t1] = needs[t1] ? needs[t1] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> match = <span class="number">0</span>, needMatch = <span class="built_in">Object</span>.keys(needs).length;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> s0 = s[right];</span><br><span class="line">        <span class="keyword">if</span> (!!needs[s0]) &#123;</span><br><span class="line">            where[s0] = where[s0] ? where[s0] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (where[s0] == needs[s0]) &#123;</span><br><span class="line">                match++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(match === needMatch) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; minLength) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                minLength = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> s1 = s[left];</span><br><span class="line">            <span class="keyword">if</span> (!!needs[s1]) &#123;</span><br><span class="line">                where[s1]--;</span><br><span class="line">                <span class="keyword">if</span> (where[s1] &lt; needs[s1]) &#123;</span><br><span class="line">                    match--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength === s.length + <span class="number">10</span> ? <span class="string">''</span> : s.substr(start, minLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不符合条件的最大值（2021-02-19更新）"><a href="#不符合条件的最大值（2021-02-19更新）" class="headerlink" title="不符合条件的最大值（2021/02/19更新）"></a>不符合条件的最大值（2021/02/19更新）</h2><p>上面的滑动窗口算法求取的是符合条件的最短长度。</p>
<p>但是有的时候我们求取的是不符合条件的最大长度。</p>
<p>举个例子，今天的leetcode每日一题</p>
<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/max-consecutive-ones-iii/</a></p>
<p><strong>题意转换。把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」</strong></p>
<p>那么在这个题目中，条件就是：<strong>子数组中包含K个及以上个0</strong>。</p>
<p>这种情况下，我们的解题模板就变了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">string s, t;</span><br><span class="line"><span class="comment">// 在 s 中寻找 t 的「最小覆盖子串」</span></span><br><span class="line">int left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">string res = s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">    <span class="built_in">window</span>.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    <span class="comment">// 如果符合要求，移动 left 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">window</span> 符合要求) &#123;</span><br><span class="line">        <span class="built_in">window</span>.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个窗口的子串更长，则更新 res</span></span><br><span class="line">    res = maxLen(res, <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<p>仔细观察可以发现，其实模板变化并不大，最重要的变化就是求结果的地方变了，从内层循环移动到了外层循环。</p>
<p>为什么会有这个变化呢？</p>
<p>要理解这个我们就要真正明白内外层的循环在做什么？</p>
<ul>
<li><p>外层循环在不断扩张子数组的长度，直到满足条件。<strong>换句话说，外层循环会遍历所有不符合条件的情况。</strong></p>
</li>
<li><p>内层循环在不断缩短子数组的长度，直到不满足条件。<strong>换句话说，就是内层循环会遍历所有符合条件的情况。</strong></p>
</li>
</ul>
<p>理解了这个，我们再来解决这个问题就不难了，直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestOnes = <span class="function"><span class="keyword">function</span>(<span class="params">A, K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> left = right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(right &lt; A.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[right] !== <span class="number">1</span>) &#123;</span><br><span class="line">      zeroCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">    <span class="keyword">while</span>(zeroCount &gt; K) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[left] === <span class="number">0</span>) &#123;</span><br><span class="line">        zeroCount--;</span><br><span class="line">      &#125;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">Math</span>.max(result, right - left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里可能会有人问，你只说了符合条件的最短和不符合条件的最长，那还有符合条件的最长和不符合条件的最短呢？</p>
<p>关于这个问题，大家可以思考一下，后面两个有没有意义，符合条件的最长，直接去判断整个数组是否符合条件就可以了，因为符合条件的最长只可能是整个数组，整个数组都不符合条件，子数组更不可能。而不符合条件的最短也是挨个遍历就行了，用数组中的每一项去判断是否符合条件就可以。</p>
<p>这两种情况根本用不到滑动窗口。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>智能合约概述</title>
    <url>/2019/12/05/smart-contract/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在大致搞清楚比特币的基本概念之后，再来理解以太坊的概念就容易很多，其中最主要的就是搞清楚什么是智能合约。</p>
<p>只是合约其实就是存储在区块链上并运行在矿工机上的一段代码，由于以太坊的限制，这段代码并不能过大，也不能过于复杂。</p>
<a id="more"></a>

<p>那么智能合约大致是怎么工作的呢？</p>
<p>目前的理解是以太坊存在两种账户，一种是外部账户，一种是合约账户，二者都有自己的地址和余额，唯一的区别就是合约账户上存储着智能合约合约的codehash，实际的合约代码已经通过一笔交易被矿工存储到了区块链上，所以发布合约实际上也是一笔交易。可以通过向全零地址发送一笔交易来创建合约，然后根据合约内容生成合约的地址用于标识合约账户，这个过程与创建外部账户不同，外部账户地址的生成是有公钥生成私钥，再由私钥计算出地址，这个过程不可逆，这也是为什么只有掌握了私钥就等于掌握了地址；但是合约账户的地址生成依赖的主要是合约代码的hash。</p>
<p>当我们在dapp上通过界面发出一条指令时，可能就是向某个指定的合约账户发起了一场交易，矿工收到交易消息后通过codehash找到合约代码并运行，当然这笔交易也可以向合约账户转账。矿工运行合约之后在交易的基础上收取一定的费用，之后通过挖矿将这笔交易确认后就可以获取这笔费用。</p>
<p>并不是说每一笔交易都必须发向某一个合约账户，也可以直接发向某个外部账户，那收到这个交易信息的矿工只需要确认这比交易是否可以成立，比如发送者简单的余额是否足够就可以，不需要去运行合约代码。</p>
<p>我们可以简单的吧DApp理解为一个前后端分离的项目，前端就是我们平时见过的正常的前端，但是他的后台代码是智能合约，而且二者之间的通信也不是平时我们用到的类似Axios这种工具，而是通过web3.js来进行通信。</p>
<h2 id="详细文档摘要"><a href="#详细文档摘要" class="headerlink" title="详细文档摘要"></a>详细文档摘要</h2><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><p>以太坊是一个可编程的区块链应用，像比特币一样，以太坊基于分布式计算机组成的点对点网络协议。但是以太坊不像比特币一样，提供某种特定的功能，事实上，以太坊没有提供任何现成的功能，包括交易，反而是让用户在它的基础上自行编程开发功能，然后将开发好的代码存储在区块链上并提供给所有人使用，这些程序运行在以太坊虚拟机上，也就是所有以太坊的节点组成的网络上，由整个以太坊的网络提供算力，并向最终实际提供算力的节点支付费用，这些运行在以太坊虚拟机上的程序就是智能合约。</p>
<p>比特币网络中有大量计算机节点负责维护和更新区块链，在ETH中同样存在，被称为EVM（Eth虚拟机）。可以把EVM看作一台超级计算机，拥有网络中所有节点的计算能力，该计算能力用于在区块链上运行智能合约。EVM向用户收取非常小的ETH代币维护费作为回报，以提供智能合约需要使用的计算能力，这个费用被称为“gas”。所以ETH代币的核心意义不是作为一般等价物的货币，而是类似于石油一样作为动力驱动ETH网络。</p>
<h3 id="简单的智能合约"><a href="#简单的智能合约" class="headerlink" title="简单的智能合约"></a>简单的智能合约</h3><p>我们通过官网的示例来进行解释</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">uint x</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行就是告诉大家源代码使用Solidity版本0.4.0写的，并且使用0.4.0以上版本运行也没问题（最高到0.5.0，但是不包含0.5.0）。这是为了确保合约不会在新的编译器版本中突然行为异常。关键字 pragma 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的（例如， <a href="https://en.wikipedia.org/wiki/Pragma_once" rel="external nofollow noopener noreferrer" target="_blank">pragma once</a> ）。</p>
<p>Solidity中合约的含义就是一组代码（它的 <em>函数</em> )和数据（它的 <em>状态</em> ），它们位于以太坊区块链的一个特定地址上。 代码行 uint storedData; 声明一个类型为 uint (256位无符号整数）的状态变量，叫做 storedData 。 你可以认为它是数据库里的一个位置，可以通过调用管理数据库代码的函数进行查询和变更。对于以太坊来说，上述的合约就是拥有合约（owning contract）。在这种情况下，函数 set 和 get 可以用来变更或取出变量的值。</p>
<p>要访问一个状态变量，并不需要像 this. 这样的前缀，虽然这是其他语言常见的做法。</p>
<p>该合约能完成的事情并不多（由于以太坊构建的基础架构的原因）：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 set ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。随后，我们会看到怎样施加访问限制，以确保只有你才能改变这个数字。</p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a><strong>注解</strong></h5><p>所有的标识符（合约名称，函数名称和变量名称）都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储。</p>
<h5 id="警告"><a href="#警告" class="headerlink" title="警告"></a><strong>警告</strong></h5><p>小心使用Unicode文本，因为有些字符虽然长得相像（甚至一样），但其字符码是不同的，其编码后的字符数组也会不一样。</p>
<h4 id="子货币（Subcurrency）例子"><a href="#子货币（Subcurrency）例子" class="headerlink" title="子货币（Subcurrency）例子"></a><strong>子货币（Subcurrency）例子</strong></h4><p>下面的合约实现了一个最简单的加密货币。这里，币确实可以无中生有地产生，但是只有创建合约的人才能做到（实现一个不同的发行计划也不难）。而且，任何人都可以给其他人转币，不需要注册用户名和密码 —— 所需要的只是以太坊密钥对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// 关键字“public”让这些变量可以从外部读取</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轻客户端可以通过事件针对变化作出高效的反应</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是构造函数，只有当合约创建时运行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Coin</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != minter) <span class="keyword">return</span>;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balances[msg.sender] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约引入了一些新的概念，让我们逐一解读。</p>
<p>address public minter; 这一行声明了一个可以被公开访问的 address 类型的状态变量。 address 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。关键字 public 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。由编译器生成的函数的代码大致如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minter</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">address</span>) </span>&#123; <span class="keyword">return</span> minter; &#125;</span><br></pre></td></tr></table></figure>

<p>当然，加一个和上面完全一样的函数是行不通的，因为我们会有同名的一个函数和一个变量，这里，主要是希望你能明白——编译器已经帮你实现了。</p>
<p>下一行， mapping (address =&gt; uint) public balances; 也创建一个公共状态变量，但它是一个更复杂的数据类型。 该类型将address映射为无符号整数。 Mappings 可以看作是一个 <a href="https://en.wikipedia.org/wiki/Hash_table" rel="external nofollow noopener noreferrer" target="_blank">哈希表</a> 它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。 但是，这种类比并不太恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。 因此，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它，就如本例。 而由 public 关键字创建的getter函数 <a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#getter-functions" rel="external nofollow noopener noreferrer" target="_blank">getter function</a> 则是更复杂一些的情况， 它大致如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">balances</span>(<span class="params">address _account</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balances[_account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，你可以通过该函数轻松地查询到账户的余额。</p>
<p>event Sent(address from, address to, uint amount); 这行声明了一个所谓的“事件（event）”，它会在 send 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 from ， to 和 amount 三个参数，可方便追踪事务。 为了监听这个事件，你可以使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Coin.Sent().watch(&#123;&#125;, <span class="string">''</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Coin transfer: "</span> + result.args.amount +</span><br><span class="line">            <span class="string">" coins were sent from "</span> + result.args.from +</span><br><span class="line">            <span class="string">" to "</span> + result.args.to + <span class="string">"."</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Balances now:\n"</span> +</span><br><span class="line">            <span class="string">"Sender: "</span> + Coin.balances.call(result.args.from) +</span><br><span class="line">            <span class="string">"Receiver: "</span> + Coin.balances.call(result.args.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里请注意自动生成的 balances 函数是如何从用户界面调用的。</p>
<p>特殊函数 Coin 是在创建合约期间运行的构造函数，不能在事后调用。 它永久存储创建合约的人的地址: msg (以及 tx 和 block ) 是一个神奇的全局变量，其中包含一些允许访问区块链的属性。 msg.sender 始终是当前（外部）函数调用的来源地址。</p>
<p>最后，真正被用户或其他合约所调用的，以完成本合约功能的方法是 mint 和 send。 如果 mint 被合约创建者外的其他人调用则什么也不会发生。 另一方面， send 函数可被任何人用于向他人发送币 (当然，前提是发送者拥有这些币)。记住，如果你使用合约发送币给一个地址，当你在区块链浏览器上查看该地址时是看不到任何相关信息的。因为，实际上你发送币和更改余额的信息仅仅存储在特定合约的数据存储器中。通过使用事件，你可以非常简单地为你的新币创建一个“区块链浏览器”来追踪交易和余额。</p>
<h3 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h3><p><strong>概述</strong></p>
<p>以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。</p>
<p><strong>账户</strong></p>
<p>以太坊中有两类账户（它们共用同一个地址空间）： <strong>外部账户</strong> 由公钥-私钥对（也就是人）控制； <strong>合约账户</strong> 由和账户一起存储的代码控制.</p>
<p>外部账户的地址是由公钥决定的，而合约账户的地址是在创建该合约时确定的（这个地址通过合约创建者的地址和从该地址发出过的交易数量计算得到的，也就是所谓的“nonce”）</p>
<p>无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。</p>
<p>每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 <strong>存储</strong> 。</p>
<p>此外，每个账户有一个以太币余额（ <strong>balance</strong> ）（单位是“Wei”），余额会因为发送包含以太币的交易而改变。</p>
<p><strong>交易</strong></p>
<p>交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。</p>
<p>如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。</p>
<p>如果目标账户是零账户（账户地址为 0 )，此交易将创建一个 <strong>新合约</strong> 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p>
<p><strong>注解</strong></p>
<p>在合约创建的过程中，它的代码还是空的。所以直到构造函数执行结束，你都不应该在其中调用合约自己函数。</p>
<p><strong>Gas</strong></p>
<p>一经创建，每笔交易都收取一定数量的 <strong>gas</strong> ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。</p>
<p><strong>gas price</strong> 是交易发送者设置的一个值，发送者账户需要预付的手续费= gas_price * gas 。如果交易执行后还有剩余， gas 会原路返还。</p>
<p>无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。</p>
<p>那么可能就会有一个问题，如果gas price是交易发送者自己制定的，那不是越低越省钱？每个人都不想多付钱。要解决这个问题首先要搞明白三个概念：</p>
<p>Gas</p>
<p>Gas对应于一个交易(Transaction)中以太坊虚拟机(EVM)的实际运算步数。 越简单的交易，例如单纯的</p>
<p>以太币转帐交易，需要的运算步数越少， Gas亦会需要的少一点。 反之，如果要计算一些复杂运算，Gas的消耗</p>
<p>量就会大。 所以你提交的交易需要EVM进行的计算量越大，所需的Gas消耗量就越高了。</p>
<p>Gas Price</p>
<p>Gas Price就是你愿意为一个单位的Gas出多少Eth，一般用Gwei作单位。 所以Gas Price 越高，</p>
<p>就表示交易中每运算一步，会支付更多的Eth。</p>
<p>大家可能对Gwei 这个单位感到陌生，Gwei 其实就是10 ^ -9 Eth，也就是说1 Gwei = 0.000000001 Eth。</p>
<p>所以，当你设定Gas price = 20 Gwei ，就意味着你愿意为单步运算支付0.00000002 Eth。</p>
<p>说到这里，聪明如你就会意识到以太坊的手续费计算公式很简单：</p>
<p>交易手续费(Tx Fee) = 实际运行步数(Actual Gas Used) * 单步价格(Gas Price)</p>
<p>例如你的交易需要以太坊执行50步完成运算，假设你设定的Gas Price是2 Gwei ，那么整个交易的手续费</p>
<p>就是50 * 2 = 100 Gwei 了。</p>
<p>Gas Limit</p>
<p>Gas Limit就是一次交易中Gas的可用上限，也就是你的交易中最多会执行多少步运算。 由于交易复杂程度各有不同，</p>
<p>确切的Gas消耗量是在完成交易后才会知道，因此在你提交交易之前，需要为交易设定一个Gas用量的上限。</p>
<p>如果说你提交的交易尚未完成，消耗的Gas就已经超过你设定的Gas Limit，那么这次交易就会被取消，而</p>
<p>已经消耗的手续费同样被扣取 —— 因为要奖励已经付出劳动的矿工。 而如果交易已经完成，消耗的Gas未达到Gas Limit，</p>
<p>那么只会按实际消耗的Gas 收取交易服务费。 换句话说，一个交易可能被收取的最高服务费就是Gas Limit * Gas Price 了。</p>
<p>最后值得一提的是Gas Price 越高，你提交的交易会越快被矿工接纳。 但通常人们都不愿多支付手续费</p>
<p><strong>委托调用/代码调用和库</strong></p>
<p>有一种特殊类型的消息调用，被称为 <strong>委托调用(delegatecall)</strong> 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。</p>
<p><strong>日志</strong></p>
<p>有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为 <strong>日志(logs)</strong> ，Solidity用它来实现 <strong>事件(events)</strong> 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" rel="external nofollow noopener noreferrer" target="_blank">布隆过滤器（Bloom filter)</a> 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。</p>
<p><strong>创建</strong></p>
<p>合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。创建合约的调用 <strong>create calls</strong> 和普通消息调用的唯一区别在于，负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。</p>
<p><strong>自毁</strong></p>
<p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。</p>
<h3 id="重点概念再次解释"><a href="#重点概念再次解释" class="headerlink" title="重点概念再次解释"></a>重点概念再次解释</h3><p><strong>账户</strong></p>
<p>以太坊引入了账户的概念取代比特币UTXO模型。以太坊中有两类账户，外部账户和合约账户，两类账户对于EVM来说没有区别。每个账户都有一个与之关联的账户状态和一个20字节地址，都可以存储以太币。</p>
<p>外部账户：由私钥控制，没有代码与之关联，地址由公钥决定。私钥可用于对交易签名从而主动向其他账户发起交易（transaction）进行消息传递，</p>
<p>合约账户：由合约代码控制，有代码与之关联，其地址由合约创建者的地址和该地址发出过的交易数量nonce共同决定。不可以主动向其他账户发起交易，但可以“响应”其他账户进行消息调用（message call）。</p>
<p>外部账户之间的消息传递是价值转移的过程，外部账户到合约账户的交易或合约账户到合约账户的消息会激发合约账户代码的执行，允许它执行如转移代币，写入内部存储，执行运算，创建合约等各种操作。</p>
<p>账户状态</p>
<p>不论账户类型，账户状态都包含以下四个字段：</p>
<p>nonce：随机数，账户发出的交易数及创建的合约数量之和。</p>
<p>Balance：余额，账户拥有以太币数量，单位为Wei，1Ether=10^18Wei。</p>
<p>storageRoot：存储根节点，账户内容的MerklePatricia 树根节点的哈希编码。</p>
<p>codeHash：代码哈希，与账户关联的EVM代码的哈希值，外部账户的codeHash为一个空字符串的哈希，创建后不可更改。状态数据库中包含所有代码片段哈希, 以便后续使用。</p>
<p><img src="D:%5Cdocument%5Cstudy%5CYNote%5Cqq063B60F6CBD116FB4E7479117DADDDEF%5Cc84218cfc20e4f21be8e4befbd9157c4%5C4660_image3.jpeg" alt="img"></p>
<p><strong>交易（Transaction）</strong></p>
<p>外部账户向其他账户发送签名数据包。每一笔交易都会改变以太坊的状态，都将被序列化，经矿工验证广播后记入区块链，因此，交易是异步的，可以即时返回的值只有transaction hash。交易可以分为创建合约和传递消息两类。一个交易的完成可能会需要触发多条消息及消息调用。</p>
<p>交易包含：</p>
<p>∙交易的接收者</p>
<p>∙可识别交易发送者、证明这是一笔发送者通过区块链发送到接收者的交易的签名</p>
<p>∙ VALUE，需转移的以太币数量（wei）</p>
<p>∙ Gas Limit(有时被称为StartGas)，允许交易执行时消耗的最大gas数量</p>
<p>∙ Gas Price，交易发送者指定的单位gas的价格（用以太币计算）</p>
<p><strong>消息（Message）</strong></p>
<p>两个账户间传递的数据和值（以太币）。不一定会改变以太坊的状态，只存在于以太坊执行环境的虚拟对象，不会被序列化也不会被记入区块链，消息是同步的，可以即时得到返回值。</p>
<p>消息调用（Message Call）</p>
<p>将消息从一个帐户传递到另一个帐户的行为，调用形式类似Transaction，但是只存在于以太坊执行环境的虚拟对象不会被记入区块链，可以类比函数调用。如果目标账户是合约账户，则合约账户的EVM代码被激发执行，如果两个账户都是合约账户，则调用中可以传递所有虚拟机的返回值。</p>
<p>消息包含：</p>
<p>∙消息的发送者（隐式的）</p>
<p>∙消息的接收者</p>
<p>∙ VALUE，随消息传递到合约地址的以太币数量（wei）</p>
<p>∙可选数据字段，作为合约的输入</p>
<p>∙ STARTGAS，用来限制这个消息触发的代码执行能消耗的最大gas数量</p>
<p>消息调用和消息通常同义，没有必要严格区分。</p>
<p>交易和消息不是包含关系，而是部分重合关系：交易发送者不经过合约直接发送交易到以太坊指定地址创建合约的操作，没有消息调用的过程，只属于交易；交易发送者通过调用合约从一个账户向另一个账户转账的操作，既属于交易又属于消息调用；合约账户受到外部账户激发而进行创建合约的操作，只属于消息调用不属于交易。</p>
<p>交易一定是由外部账户发起，一个交易可能会引发一系列“消息调用”，合约账户为“响应”来自其他账户的“消息调用”而执行代码继而激发新的“消息调用”，因此，本质上所有“消息调用”及以太坊的状态改变都是由外部账户激发，即，以太坊在整体上可以看作一个基于交易的状态机：起始于一个创世块（Genesis）状态，然后随着交易的执行状态逐步改变一直到最终状态, 这个最终状态是以太坊世界的权威版本。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="全零地址"><a href="#全零地址" class="headerlink" title="全零地址"></a>全零地址</h3><p>以太坊中有个地址拥有非常多的以太币，这个地址就是全零地址，那么这个地址为什么会有这么多的以太币呢？</p>
<p>这就要从以太坊的创世区块讲起。</p>
<p>ETH最主要的来源并不是挖矿，而是当年众筹时发行的。</p>
<p>即使在以太坊正式发布近三年后的今天，创世区块中发行的7200w个ETH依然占到73.4%。</p>
<p>那么，这个全零地址中的ETH，是不是来自创世区块中发行的ETH呢？</p>
<p>实际上并不是的。</p>
<p>然而，解析下创世区块，可以发现，挖出创世区块的miner，居然是这个全零的地址。</p>
<p>创世区块不是被挖出来的，它是被人为创建出来，并作为整条区块链的起点。</p>
<p>既然不是被挖出来的，使用全零的地址作为占位符也是合理的。</p>
<p>创世区块因为不是挖矿所得，无人为此消耗算力，自然也不会有任何区块奖励。</p>
<p>转了一圈，这个全零地址中的ETH和创世区块并无关系。</p>
<p>除了创世区块中发行的ETH，新的ETH只有一种产生途径，那就是挖矿。</p>
<p>为了更加精确的计算，以下单位均使用ETH的最小单位Wei，关于单位问题，可以参看这里《<a href="https://zhuanlan.zhihu.com/p/28994731" rel="external nofollow noopener noreferrer" target="_blank">以太币(Ether)的单位</a>》。</p>
<p>搜索下miner为这个全零地址的区块，还真不少呢。</p>
<p>这个全零地址共挖出主链区块94个：</p>
<p>那么问题来了，为什么有人会用全零地址挖矿，这样自己消耗了电力，最终获益的却是全零地址。</p>
<p>全零地址最早挖出的一个区块是5305，难度值仅有199,485,740,316，不到0.2T，还是1060显卡为例，仅需要不到3小时即可发现一个区块。</p>
<p>那时候，区块是如此容易挖掘，几乎任何一台有独立显卡的中端PC，都可以挖到区块。</p>
<p>于是，很多人本着试试看的心态，使用自家的普通PC尝试挖掘，几乎0成本。</p>
<p>这群人中，有相当一部分是仅会复制粘贴的小白，悲催的事儿来了，他们忘记设置收款地址。有些专业矿工在调试机器稳定性时，也会出于方便，没有对挖矿软件进行配置。</p>
<p>部分钱包软件在solo挖矿时，如果不设置收款地址，就会默认使用全零地址挖矿。</p>
<p><strong>这也就解释了，为什么会有如此多的区块是全零地址挖到的。</strong></p>
<p>而且要注意的是，全零地址是一个黑洞地址，没有一个人手中掌握了全零地址的私钥，我们也无法通过全零来反向推算出全零地址的私钥，所以理论上来说，进入了黑洞地址的以太币再也无法转出了。</p>
<h3 id="智能合约如何运行"><a href="#智能合约如何运行" class="headerlink" title="智能合约如何运行"></a>智能合约如何运行</h3><p>比特币交易非常简单。你可以只做一件事。一种类型的交易。略过一些细节，一切都可以归结为<strong>TO （付给，谁在收钱），FROM （来自于，谁在付钱）和 AMOUNT</strong>（数量，多少钱）。这使得比特币成为一种价值储存手段，能够在网络参与者之间传递价值。</p>
<p>以太坊的不同之处在于交易还有一个「<strong>DATA」</strong>（数据）字段。该「<strong>DATA</strong>」字段支持三种类型的交易：</p>
<p><strong>价值转移（和比特币一样）</strong></p>
<ul>
<li><strong>TO</strong>接收地址；</li>
<li><strong>DATA</strong>字段为空或包含要附加的任何消息；</li>
<li><strong>FROM</strong>你</li>
<li><strong>AMOUNT 是</strong>你要发送的以太坊数量</li>
</ul>
<p><strong>创建智能合约</strong></p>
<ul>
<li>TO 字段为空（它触发智能合约的创建）</li>
<li>DATA 字段包含编译为字节代码的智能合约代码（所以实际上我们编写的代码是用来创建合约代码的，而不是真正存储到链上的合约代码）</li>
<li>FROM 你</li>
<li>AMOUNT 可以是 0 或者任意你想放在合约里的以太币数量</li>
</ul>
<p><strong>调用智能合约</strong></p>
<ul>
<li>TO 字段是智能合约账户地址</li>
<li>DATA 字段包含函数名称和参数 —— 如何调用智能合约</li>
<li>FROM 你</li>
<li>AMOUNT 可以是 0 或者任何数量的以太币，比如你需要为一项服务合约支付的数目</li>
</ul>
<h3 id="合约与合约账户"><a href="#合约与合约账户" class="headerlink" title="合约与合约账户"></a>合约与合约账户</h3><p>合约是代码与账户当前状态的一个集合，每次交易之后，当前的合约都会</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/sportshark/article/details/52249607" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/sportshark/article/details/52249607</a></p>
<p><a href="https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html" rel="external nofollow noopener noreferrer" target="_blank">https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html</a></p>
<p><a href="https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/" rel="external nofollow noopener noreferrer" target="_blank">https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/</a></p>
<p><a href="https://blog.csdn.net/jiang_xinxing/article/details/80289694" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/jiang_xinxing/article/details/80289694</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34363341" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/34363341</a></p>
<p><a href="https://www.chainnews.com/articles/891681682372.htm" rel="external nofollow noopener noreferrer" target="_blank">https://www.chainnews.com/articles/891681682372.htm</a></p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>Solace Endpoints</title>
    <url>/2020/02/15/solace_endpoint/</url>
    <content><![CDATA[<p>这个周刚接触了一点关于Solace的知识，对其中几个基础的概念查阅了一下官方文档，在这里总结一下，主要就是Endpoints，Queue，Topic，Subscription之间的关系。</p>
<a id="more"></a>

<p>首先总结一下，Endpoint是Solace中用于发送和接收消息的端，它分为两种类型，一种是Queue Endpoint，另一种是Topic Endpoint，这两种Endpoint都可以有自己的Subscription，也可以称为Topic Subscription，每个Queue Endpoint可以有多个Topic Subscription，而每个Topic Endpoint只能有自身的一个Topic Subscription，我们可以把消息推送到Topic中，也可以推送到Queue中，但是推送到Topic中的消息不仅会被发送到Topic Endpoint中，还会发送到订阅它的Queue Endpoint中。（目前作者不成熟的理解是每个Topic Endpoint都一定有一个和它Match的Topic Subscription，所以给某个Topic推送，最少会有一个Topic Endpoint收到，同时订阅这个Topic的Queue也会收到，但是如果直接向Queue推送，就只有该Queue会受到消息）</p>
<p>接下来详细解释一下具体的概念，这部分内容来自于Solace的官方解释。</p>
<h2 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h2><p>Solace PubSub+事件代理支持两种类型的端点，用于接收、存储和交付保证消息。</p>
<p>Endpoint仅具有本地事件代理的意义，并且在使用者必须连接到具有该端点的事件代理时，它不是一个网络范围的概念。不存在通过事件代理到事件代理控制/路由协议的端点存在的传播。因此，事件代理在整个网络中不强制端点名称唯一性（看这个意思是说每个Endpoint仅在本地有效，是不会直接同网络进行信息交换的，所以就不会要求在整个网络中有唯一的名字）。</p>
<h2 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h2><p>Queue既是客户端可以向其发布消息的目的地，也是客户端可以绑定使用者并使用消息的Endpoint。Queue通常用于点对点(PTP)消息传递环境。</p>
<p>尽管许多Consumer可以绑定到一个Queue，但仅能由单个Consumer使用连接到Queue的单个消息。</p>
<p>还可以将主题订阅添加到队列，以便将发布到匹配主题的消息传递到队列。因此，也可以在发布和订阅(Pub/Sub)模型中使用队列。</p>
<p>Queue比Topic Endpoint灵活得多，是大多数应用程序推荐的方法。Topic Endpoint的使用应该仅限于JMS应用程序。</p>
<h3 id="Queue-Access-Types"><a href="#Queue-Access-Types" class="headerlink" title="Queue Access Types"></a>Queue Access Types</h3><p>队列具有访问类型，该类型决定了在多个使用者流绑定到队列时如何传递消息。可以为队列分配以下一种访问类型:</p>
<ul>
<li><p>Exclusive（独占）:任何时候只有一个消费者可以接收消息，而其他消费者可以作为备用连接。也就是说，只有一个流是活动的。只有第一个绑定的使用者才能接收消息。如果第一个使用者断开连接，第二个使用者将接收数据，依此类推。独占队列总是按照接收消息的顺序传递消息。</p>
</li>
<li><p>Non-exclusive（非独占）:多个消费者可以绑定到一个非独占队列。每个消费者都以循环的方式得到服务。这提供了负载平衡;但是，如果连接失败，则未确认的消息将被发送给另一个设置了重新发送标志的使用者。通过这种方式，可以不按顺序将消息发送给使用者</p>
</li>
</ul>
<p>可以更改持久队列的访问类型，但仅在禁用了对队列的客户端访问之后。</p>
<p>此外，队列的访问类型不会影响客户机使用队列浏览器在队列上浏览消息的能力。</p>
<h3 id="Adding-Topic-Subscriptions-to-Queues"><a href="#Adding-Topic-Subscriptions-to-Queues" class="headerlink" title="Adding Topic Subscriptions to Queues"></a>Adding Topic Subscriptions to Queues</h3><p>这一段建议直接看<a href="https://docs.solace.com/PubSub-Basics/Endpoints.htm#add-topics-to-queues" rel="external nofollow noopener noreferrer" target="_blank">Adding Topic Subscriptions to Queues</a></p>
<p>同时还有<a href="https://docs.solace.com/PubSub-Basics/Topic-Matching-and-Delivery-Modes.htm" rel="external nofollow noopener noreferrer" target="_blank">Delivery Modes</a></p>
<h2 id="Topic-Endpoint"><a href="#Topic-Endpoint" class="headerlink" title="Topic Endpoint"></a>Topic Endpoint</h2><p>主题端点吸引发布到主题的消息，主题端点对该主题具有匹配的主题订阅。主题端点的主题订阅在客户端请求中指定，以便将流绑定到该主题端点。</p>
<p>主题端点可以在发布/订阅模型中使用。它们相当于Java消息服务(JMS)中的持久主题订阅。</p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>基本排序算法的重新解读</title>
    <url>/2020/10/02/sort-algorithm/</url>
    <content><![CDATA[<p>我们在上大学的时候会接触很多基本的排序算法，到了工作后其实我们很多时候用的都是语言自带的一些排序方法，所以就会有些生疏，这次重看《数据结构与算法之美》，对这些基本的排序算法又有了一点进一步的理解，索性就重新回顾一遍这些基本的排序算法，并从几个新的角度去理解和使用它们，本文所有的排序都是从小到大排序，并且是从王争老师的课程中提取了一点关于基本排序的知识按照自己的思维方式重新组织并实现了一次，加入了一点自己的联想，比如计数排序与前缀和的关系，从一个新的角度理解归并排序与快速排序的区别，但还是强烈建议大家去购买王争老师的正版课程，真正的由浅入深，这样每个人的知识树不一样，构建起来的知识体系也不同。</p>
<a id="more"></a>

<h1 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个排序算法</h1><h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p>
<ol>
<li>最好情况、最坏情况、平均情况时间复杂度我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</li>
<li>时间复杂度的系数、常数 、低阶我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</li>
<li>比较次数和交换（或移动）次数。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</li>
</ol>
<h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。</p>
<h1 id="基于比较的排序算法列举"><a href="#基于比较的排序算法列举" class="headerlink" title="基于比较的排序算法列举"></a>基于比较的排序算法列举</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> needToSort = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">                needToSort = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needToSort) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>冒泡排序算法的思想比较简单，我们可以想象一下，把数组竖起来看，头在下，尾在上。</p>
<p>整个数组可以分成未排序区间和排序区间，未排序区间在前，排序区间在后，一开始排序区间是空的，每完成一次对排序区间完整的比较和交换，就有一个未排序区间的最大值被加入到排序区间的头部。</p>
<p>就是从头开始依次比较相邻的两个数据的大小，如果前面的大于后面的数，就交换两个位置，<strong>这样每次交换的结果就能保证后面的数字比前面的大，最终比较到最后一位的时候就可以保证最后一位已经是最大的了</strong>。</p>
<p>因为已经保证了最后一位已经是最大的了，所以下一次比较的时候就不需要再比较最后一位了，依次类推，直到最后一次比较只需要比较前两位就好。</p>
<p>又因为整个过程像是一个气泡上升的过程，所以叫做冒泡排序。</p>
<p>上面算法实现做了一点小优化，如果某次对未排序区间的比较没有做过任何一次交换，说明未排序区间其实已经是有序的了，就可以结束冒泡排序了。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>冒泡排序是原地排序算法吗？</strong></p>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<strong>原地排序算法</strong>。</p>
<p><strong>冒泡排序是稳定的排序算法吗？</strong></p>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是<strong>稳定的排序算法</strong>。</p>
<p><strong>冒泡排序的时间复杂度是多少？</strong></p>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p>
<p>平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。这里还有一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。有序度是数组中具有有序关系的元素对的个数。</p>
<blockquote>
<p>有序元素对：a[i] &lt;= a[j], 如果i &lt; j。</p>
</blockquote>
<p>对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n<em>(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作*</em>满有序度**。逆序度的定义正好跟有序度相反</p>
<p>我们还可以得到一个公式：<strong>逆序度 = 满有序度 - 有序度</strong>。</p>
<p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n<em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n</em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n<em>(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n</em>(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = nums[i];</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; value) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>插入排序的思路也比较容易理解，和冒泡排序一样，也分为排序区间和未排序区间，只不过插入排序的排序区间在前。</p>
<p>核心思路就是每次从未排序区间中拿出第一个来，假设为a，从后向前依次与排序区间内的值（假设为b）比较，a &lt; b，说明a应该插入到b前面，就把b向后挪一位，知道找到第一个a &gt;b 的位置，不再挪动位置，因为a就应该在这里了，所以将第一个小于a的位置的数据置为a。</p>
<p>这样说起来可能有点晦涩，大家可以想象一下我们平时打牌，手里的牌就是排好序的，牌堆里就是没有排好序的，每次我们摸到一张牌，就开始从我们手牌从后向前找，一直找到第一个小于摸到的牌的位置，把这张牌插入到这里，后面的牌就依次向后挪一个位置。</p>
<p>插入排序模仿的就是这个过程，不过是在我们从后向前找的过程中预先把大于摸到的牌值的牌向后挪一个位置。</p>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p><strong>插入排序是原地排序算法吗？</strong></p>
<p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p>
<p><strong>插入排序是稳定的排序算法吗？</strong></p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<p><strong>插入排序的时间复杂度是多少？</strong></p>
<p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> min = nums[i], minPos = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">                min = nums[j];</span><br><span class="line">                minPos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minPos !== i) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[minPos];</span><br><span class="line">            nums[minPos] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p>也就是说插入排序是每次从未排序区间拿出第一个，然后再排序区间找到它的合适位置，而选择排序是每次从未排序区间找到最小的那个，它的位置就应该是排序区间后紧跟着的那个位置。</p>
<h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><p><strong>插入排序是原地排序算法吗？</strong></p>
<p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p>
<p><strong>插入排序是稳定的排序算法吗？</strong></p>
<p>选择排序是一种不稳定的排序算法。可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<p><strong>插入排序的时间复杂度是多少？</strong></p>
<p>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge_sort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    merge_sort_c(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge_sort_c = <span class="function">(<span class="params">nums, p, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="built_in">Math</span>.floor((p + r) / <span class="number">2</span>);</span><br><span class="line">    merge_sort_c(nums, p, q);</span><br><span class="line">    merge_sort_c(nums, q + <span class="number">1</span>, r);</span><br><span class="line">    merge(nums, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">nums, p, q, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = p, j = q + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = [];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            temp[k++] = nums[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = nums[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> start = i, end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">        start = j;</span><br><span class="line">        end = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        temp[k++] = nums[start++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">0</span>; m &lt;= r - p; m++) &#123;</span><br><span class="line">        nums[p + m] = temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</p>
<p>写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p>
<p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p>
<h3 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h3><p><strong>归并排序是稳定的排序算法吗？</strong></p>
<p>结合我前面画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<p><strong>归并排序的时间复杂度是多少？</strong></p>
<p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。在递归那一节我们讲过，递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我们就可以得到这样的递推关系式：T(a) = T(b) + T(c) + K其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，我们来分析一下归并排序的时间复杂度。我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = 2<em>T(n/2) + n； n&gt;1通过这个公式，如何来求解 T(n) 呢？还不够直观？那我们再进一步分解一下计算过程。T(n) = 2*T(n/2) + n = 2</em>(2<em>T(n/4) + n/2) + n = 4<em>T(n/4) + 2</em>n = 4</em>(2<em>T(n/8) + n/4) + 2<em>n = 8</em>T(n/8) + 3*n = 8</em>(2<em>T(n/16) + n/8) + 3</em>n = 16<em>T(n/16) + 4</em>n …… = 2^k，通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p><strong>归并排序的空间复杂度是多少？</strong></p>
<p>归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？<strong>因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间</strong>。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是 O(n)，还是 O(nlogn)，应该如何分析呢？如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quick_sort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    quick_sort_c(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quick_sort_c = <span class="function">(<span class="params">nums, p, r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> q = partition(nums, p ,r);</span><br><span class="line">    quick_sort_c(nums, p, q - <span class="number">1</span>);</span><br><span class="line">    quick_sort_c(nums, q + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">nums, p , r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = nums[r];</span><br><span class="line">    <span class="keyword">let</span> i = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = p; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">            swap(nums, i++, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">nums, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。如果我们用递推公式来将上面的过程写出来的话，就是这样：</p>
<blockquote>
<p>递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</p>
<p>终止条件：p &gt;= r</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 快速排序，A是数组，n表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">  quick_sort_c(A, p, q<span class="number">-1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序中有一个 merge() 合并函数，我们这里有一个 partition() 分区函数。partition() 分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p>
<p>如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]。</p>
<p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。</p>
<p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot := A[r]</span><br><span class="line">  i := p</span><br><span class="line">  <span class="keyword">for</span> j := p to r<span class="number">-1</span> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] <span class="keyword">with</span> A[j]</span><br><span class="line">      i := i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] <span class="keyword">with</span> A[r]</span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<p>这里的处理有点类似选择排序。我们通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。</p>
<h3 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h3><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并<strong>不是一个稳定的排序算法</strong>。</p>
<p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)</p>
<p>但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
<p><strong>归并排序与快速排序的区别：</strong></p>
<p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>
<p>我们通过代码也可以看出，归并排序最终的排序是在递归函数最后merge操作中进行的，而快排是递归函数最开始通过partition函数中执行的，也就是说<strong>归并排序是在递归回归的过程中完成的排序，是从下到上的，而快排是在递归下递的过程中完成的排序，是从上到下的</strong>。</p>
<h1 id="其他基本排序简介"><a href="#其他基本排序简介" class="headerlink" title="其他基本排序简介"></a>其他基本排序简介</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</p>
<p>桶排序的时间复杂度为什么是 O(n) 呢？我们一块儿来分析一下。如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</p>
<p>答案当然是否定的。实际上，<strong>桶排序对要排序数据的要求是非常苛刻的</strong>。首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。</p>
<p>根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<p>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</p>
<p>想弄明白这个问题，我们就要来看计数排序算法的实现方法。我还拿考生那个例子来解释。为了方便说明，我对数据规模做了简化。假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6]的值。</p>
<blockquote>
<p>如果大家对于前缀和有印象，那么就很好理解这个基数排序了，其原理与前缀和非常的相似。</p>
</blockquote>
<p>这里我们举个<a href="https://leetcode-cn.com/problems/sort-colors/" rel="external nofollow noopener noreferrer" target="_blank">leetcode上的实际例子</a>：</p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        count[n]++;</span><br><span class="line">    &#125;);</span><br><span class="line">    count[<span class="number">1</span>] += count[<span class="number">0</span>];</span><br><span class="line">    count[<span class="number">2</span>] += count[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = count[nums[i]]--;</span><br><span class="line">        res[c - <span class="number">1</span>] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res.forEach(<span class="function">(<span class="params">r, i</span>) =&gt;</span> &#123;</span><br><span class="line">        nums[i] = r;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>我们之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢？</p>
<p>现在我就来介绍一种新的排序算法，基数排序。刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。借助稳定排序算法，这里有一个巧妙的实现思路。还记得我们第 11 节中，在阐述排序算法的稳定性的时候举的订单的例子吗？我们这里也可以借助相同的处理思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>spring-boot-mongodb-transaction</title>
    <url>/2020/02/29/spring-boot-mongodb-transaction/</url>
    <content><![CDATA[<p>今天在工作中需要使用到mongodb的tansaction，于是查阅了各种资料，也踩了不少的坑，在这里总结一下。</p>
<a id="more"></a>

<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>MongoDB的版本必须是4.0版本以上</li>
<li>引入spring-data</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages = <span class="string">"com.baeldung.repository"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoTransactionConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MongoTransactionManager <span class="title">transactionManager</span><span class="params">(MongoDbFactory dbFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoTransactionManager(dbFactory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoClient <span class="title">mongoClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(<span class="string">"127.0.0.1"</span>, <span class="number">27017</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After we finished the configuration, all we need to do to use native MongoDB transactions – is to <strong>annotate our method with</strong> <strong>*@Transactional</strong>.*</p>
<p>Everything inside the annotated method will be executed in one transaction:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenPerformMongoTransaction_thenSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="number">30</span>));</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"Ringo"</span>, <span class="number">35</span>));</span><br><span class="line">    Query query = <span class="keyword">new</span> Query().addCriteria(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"John"</span>));</span><br><span class="line">    List&lt;User&gt; users = mongoTemplate.find(query, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    assertThat(users.size(), is(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we can’t use <em>listCollections</em> command inside a multi-document transaction – for example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = MongoTransactionException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Transactional</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">whenListCollectionDuringMongoTransaction_thenException</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mongoTemplate.collectionExists(User<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        mongoTemplate.save(<span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="number">30</span>));</span><br><span class="line">        mongoTemplate.save(<span class="keyword">new</span> User(<span class="string">"Ringo"</span>, <span class="number">35</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This example throws a <em>MongoTransactionException</em> as we used the <em>collectionExists()</em> method.</p>
<p>We also can’t run <em>count</em> inside a multi-document transaction:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = MongoCommandException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Transactional</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">whenCountDuringMongoTransaction_thenException</span>() </span>&#123;</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="number">30</span>));</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"Ringo"</span>, <span class="number">35</span>));</span><br><span class="line">    userRepository.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But, we can work around this one with a simple query and then get the size of the resulting list:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenQueryDuringMongoTransaction_thenSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"Jane"</span>, <span class="number">20</span>));</span><br><span class="line">    userRepository.save(<span class="keyword">new</span> User(<span class="string">"Nick"</span>, <span class="number">33</span>));</span><br><span class="line">    List&lt;User&gt; users = mongoTemplate.find(<span class="keyword">new</span> Query(), User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    assertTrue(users.size() &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>注解必须是@Transactional(rollbackFor = { Exception.class })，不能仅仅是@Transactional</p>
</li>
<li><p>必须在properties文件中配置replica-set，否则报错”Sessions are not supported by the MongoDB cluster to which this client is connected”。配置方式是spring.data.mongodb.uri=<a href="mongodb://host1:port1,host2:port2,host3:port3/" rel="external nofollow noopener noreferrer" target="_blank">mongodb://host1:port1,host2:port2,host3:port3/</a>数据库名称?replicaSet=复制集名称</p>
<p>这一点是因为事务必须基于副本集才能实现</p>
</li>
<li><p>如果有捕获异常，则必须加一行代码，否则发生异常时还是能insert到数据库；加了后才能回滚insert操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly</span><br></pre></td></tr></table></figure>
</li>
<li><p>不必引入spring-data-mongodb包，只需要spring-boot-starter-data-mongodb、spring-data-commons和mongo-java-driver即可。</p>
</li>
<li><p>@Transactional 只能应用到 public 方法才有效</p>
</li>
</ul>
<h2 id="Transactional配置项"><a href="#Transactional配置项" class="headerlink" title="@Transactional配置项"></a>@Transactional配置项</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td>
</tr>
<tr>
<td align="left">propagation</td>
<td align="left">事务的传播行为，默认值为 REQUIRED。</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">事务的隔离度，默认值采用 DEFAULT。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td align="left">read-only</td>
<td align="left">指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td>
</tr>
<tr>
<td align="left">rollback-for</td>
<td align="left">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>
</tr>
<tr>
<td align="left">no-rollback- for</td>
<td align="left">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>
</tr>
</tbody></table>
<p>除此以外，@Transactional 注解也可以添加到类级别上。当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。</p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot 注解简单总结（持续补充中）</title>
    <url>/2019/08/11/spring-boot-simple/</url>
    <content><![CDATA[<p>Spring Boot 最大的特点就是无需XML配置文件，能够自动扫描包路径装载并注入对象，并能够根据classpath下的jar包自动配置。</p>
<a id="more"></a>

<h2 id="Spring-Boot-三个核心注解"><a href="#Spring-Boot-三个核心注解" class="headerlink" title="Spring Boot 三个核心注解"></a>Spring Boot 三个核心注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>这是 Spring Boot 最最最核心的注解，用在 Spring Boot 主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。</p>
<p>其实这个注解就是 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 这三个注解的组合，也可以用这三个注解来代替 @SpringBootApplication 注解。</p>
<h3 id="1-EnableAutoConfiguration"><a href="#1-EnableAutoConfiguration" class="headerlink" title="1. @EnableAutoConfiguration"></a>1. @EnableAutoConfiguration</h3><p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p>
<h3 id="2-Configuration"><a href="#2-Configuration" class="headerlink" title="2. @Configuration"></a>2. @Configuration</h3><p>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。它的几个相关的注解也比较重要：</p>
<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>用于替代XML配置文件中的&lt;bean …&gt;配置。</p>
<h4 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h4><p>如果有些通过类的注册方式无法配置的，可以通过这个注解引入额外的XML配置文件，有些老的配置文件无法通过@Configuration方式配置的很有效</p>
<p>@Import</p>
<p>用来引入额外一个或者多个@Configuration修饰的配置类文件</p>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>就是@Configuration在Spring Boot中的另一种叫法</p>
<h3 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3. @ComponentScan"></a>3. @ComponentScan</h3><p>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 component-scan 配置，开启组件扫描，即自动扫描包路径下的 @Component 注解进行注册 bean 实例到 context 中。</p>
<h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong>@ConfigurationProperties</strong></h3><p>用来加载额外的配置（如 .properties 文件），可用在 <code>@Configuration</code> 注解类，或者 <code>@Bean</code> 注解方法上面。</p>
<h4 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a><strong>@EnableConfigurationProperties</strong></h4><p>一般要配合 <code>@ConfigurationProperties</code> 注解使用，用来开启对 <code>@ConfigurationProperties</code> 注解配置 Bean 的支持。</p>
<h3 id="AutoConfigureAfter"><a href="#AutoConfigureAfter" class="headerlink" title="@AutoConfigureAfter"></a><strong>@AutoConfigureAfter</strong></h3><p>用在自动配置类上面，表示该自动配置类需要在另外指定的自动配置类配置完之后。</p>
<p>如 Mybatis 的自动配置类，需要在数据源自动配置类之后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><br><span class="line">public class MybatisAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<h3 id="AutoConfigureBefore"><a href="#AutoConfigureBefore" class="headerlink" title="@AutoConfigureBefore"></a><strong>@AutoConfigureBefore</strong></h3><p>这个和 <code>@AutoConfigureAfter</code> 注解使用相反，表示该自动配置类需要在另外指定的自动配置类配置之前。</p>
<h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>自动导入。</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>获取参数。</p>
<h3 id="JsonBackReference"><a href="#JsonBackReference" class="headerlink" title="@JsonBackReference"></a>@JsonBackReference</h3><p>  jackson中的@JsonBackReference和@JsonManagedReference，以及@JsonIgnore均是为了解决对象中存在双向引用导致的无限递归（infinite recursion）问题。这些标注均可用在属性或对应的get、set方法中。  </p>
<p>@JsonBackReference和@JsonManagedReference：这两个标注通常配对使用，通常用在父子关系中。@JsonBackReference标注的属性在序列化（serialization，即将对象转换为json数据）时，会被忽略（即结果中的json数据不包含该属性的内容）。@JsonManagedReference标注的属性则会被序列化。在序列化时，@JsonBackReference的作用相当于@JsonIgnore，此时可以没有@JsonManagedReference。但在反序列化（deserialization，即json数据转换为对象）时，如果没有@JsonManagedReference，则不会自动注入@JsonBackReference标注的属性（被忽略的父或子）；如果有@JsonManagedReference，则会自动注入自动注入@JsonBackReference标注的属性。    </p>
<h3 id="RepositoryRestResourcepublic"><a href="#RepositoryRestResourcepublic" class="headerlink" title="@RepositoryRestResourcepublic"></a>@RepositoryRestResourcepublic</h3><p>配合spring-boot-starter-data-rest使用。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p>
<h3 id="RestController-1"><a href="#RestController-1" class="headerlink" title="@RestController"></a>@RestController</h3><p>用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>提供路由信息，负责URL到Controller中的具体函数的映射。</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>注入Spring boot application.properties配置的属性的值。示例代码： </p>
<p>@Value(value = “#{message}”)<br>private String message;</p>
<h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p>等价于默认的@Autowired，只是没有required属性；</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<h3 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h3><p>自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：<br>@Autowired<br>@Qualifier(value = “demoInfoService”)<br>private DemoInfoService demoInfoService;</p>
<h3 id="RequestMapping-1"><a href="#RequestMapping-1" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。<br>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p>
<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p>
<h3 id="PathVariable-1"><a href="#PathVariable-1" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>路径变量。如<br>RequestMapping(“user/get/mac/{macAddress}”)<br>public String getByMacAddress(@PathVariable String macAddress){<br>//do something; </p>
<h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>包含@Component。可以被扫描到。统一处理异常。</p>
<h3 id="ExceptionHandler（Exception-class）"><a href="#ExceptionHandler（Exception-class）" class="headerlink" title="@ExceptionHandler（Exception.class）"></a>@ExceptionHandler（Exception.class）</h3><p>用在方法上面表示遇到这个异常就执行以下方法。</p>
<h3 id="Resource-name-”name”-type-”type”"><a href="#Resource-name-”name”-type-”type”" class="headerlink" title="@Resource(name=”name”,type=”type”)"></a>@Resource(name=”name”,type=”type”)</h3><p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>描述的是Spring容器如何创建Bean的实例的，它有几种不同可能的取值：</p>
<ol>
<li>Singleton：一个Spring容器只能有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例</li>
<li>Prototype：每次调用新建一个Bean的实例</li>
<li>Request：Web项目中，给每一个http request新建一个Bean实例</li>
<li>Session：Web项目中，给每一个http Session新建一个Bean实例</li>
<li>GlobalSesion：这个只在portal应用中有用，给每一个global http session 新建一个Bean实例。</li>
</ol>
<h3 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h3><p>增加JSR250支持后，该注解修饰的方法会在构造函数执行完成之后执行</p>
<h3 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h3><p>增加JSR250支持后，该注解修饰的方法会在Bean销毁之前执行</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是注解的注解，包括@Retention，@Target，@Document，@Inherited</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>@Retention（RetentionPolicy.SOURCE）：注解仅存在于源码中，在class字节码文件中不包含</p>
<p>@Retention（RetentionPolicy.CLASS）：默认的保留策略，注解会在class字节码文件中存在，但运行时无法获取</p>
<p>@Retention（RetentionPolicy.RUNTIME）：注解会在class字节码文件中存在，运行时可以通过反射获得</p>
<h3 id="Target：定义注解的目标"><a href="#Target：定义注解的目标" class="headerlink" title="@Target：定义注解的目标"></a>@Target：定义注解的目标</h3><p>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法<br>@Target(ElementType.PARAMETER) //方法参数<br>@Target(ElementType.CONSTRUCTOR)  //构造函数<br>@Target(ElementType.LOCAL_VARIABLE)//局部变量<br>@Target(ElementType.ANNOTATION_TYPE)//注解<br>@Target(ElementType.PACKAGE) ///包  </p>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>表明该注解会被包含在javadoc中</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>子类可以继承父类中的该注解</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们可以通过上述几个注解定义一个新的注解，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Action &#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就定义了一个叫做Action的新注解，它有一个叫做name的属性</p>
<h2 id="Spring多线程相关"><a href="#Spring多线程相关" class="headerlink" title="Spring多线程相关"></a>Spring多线程相关</h2><p>spring通过任务执行器（TaskExecutor）来实现多线程和并发编程。使用ThreadPoolTaskExecutor可实现一个基于线程池的TaskExecutor。而实际开发中任务一般是非阻碍的，即异步的，所以我们要在配置类中通过@EnableAsync开启对异步任务的支持，并通过在实际执行的Bean的方法中使用@Async注解来声明其是一个异步任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.wisely.highlight"</span>)</span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutorConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        taskExecutor.setQueueCapcity(<span class="number">25</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述配置类，则在”com.wisely.highlight”包下的所有被@Async修饰的类或者方法都是异步的。</p>
<h2 id="Spring计划任务"><a href="#Spring计划任务" class="headerlink" title="Spring计划任务"></a>Spring计划任务</h2><p>首先在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务。</p>
<p>通过@Scheduled支持的计划任务分为多种，包括corn，fixDelay，fixRate等</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wisely.highlight</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">5000</span>) <span class="comment">//每隔五秒执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled</span>(corn = <span class="string">"0 25 11 ? * *"</span>) <span class="comment">//定时任务，每条11点28分执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixTimeExecution</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过@EnableScheduling来开启对计划任务的支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.wisely.highlight"</span>)</span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskSchedulerConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样所有com.wisely.highlight包下面所有的类都会开启对于计划任务的支持</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigAoolicationContext (TaskSchedulerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>参考文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/57689422" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/57689422</a></p>
<p><a href="https://blog.csdn.net/zsq520520/article/details/55261359" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zsq520520/article/details/55261359</a></p>
<p><a href="https://blog.csdn.net/qq_35357001/article/details/55505659" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_35357001/article/details/55505659</a></p>
<p><a href="https://www.jianshu.com/p/12e1a752974d" rel="external nofollow noopener noreferrer" target="_blank">ExceptionHandler使用法简介</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Springboot + Spring Security + redis + rabbitmq 配置</title>
    <url>/2019/08/17/spring_boot_and_security/</url>
    <content><![CDATA[<p>本文讲述的是基于springboot项目来整合spring Security，mysql，redis，rabbitmq的配置过程。</p>
<a id="more"></a>

<h2 id="引入项目依赖"><a href="#引入项目依赖" class="headerlink" title="引入项目依赖"></a>引入项目依赖</h2><p>首先利用 IntelliJ 编辑器新建一个 gradle 项目，然后将build.gradle文件改为以下内容，重新导入依赖</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123; url <span class="string">"https://plugins.gradle.org/m2/"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'org.junit.platform:junit-platform-gradle-plugin:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line">apply plugin: <span class="string">'idea'</span></span><br><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br><span class="line">apply plugin: <span class="string">'org.junit.platform.gradle.plugin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="string">'com.ray.parctice'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-thymeleaf"</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'mysql'</span>, name: <span class="string">'mysql-connector-java'</span>, version: <span class="string">'8.0.15'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'org.flywaydb'</span>, name: <span class="string">'flyway-core'</span>, version: <span class="string">'5.2.4'</span></span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-security"</span>)</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-data-redis"</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'redis.clients'</span>, name: <span class="string">'jedis'</span>, version: <span class="string">'3.0.1'</span></span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-amqp"</span>)</span><br><span class="line">    </span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">    testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.0.0'</span></span><br><span class="line"></span><br><span class="line">    testCompile(<span class="string">'org.junit.jupiter:junit-jupiter-params:5.0.0'</span>)</span><br><span class="line">    testCompile(<span class="string">"org.springframework.security:spring-security-test"</span>)</span><br><span class="line"></span><br><span class="line">    testRuntime(<span class="string">'org.junit.jupiter:junit-jupiter-engine:5.0.0'</span>)</span><br><span class="line">    </span><br><span class="line">    testRuntime <span class="string">"com.h2database:h2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Springboot-mysql-配置"><a href="#Springboot-mysql-配置" class="headerlink" title="Springboot + mysql 配置"></a>Springboot + mysql 配置</h2><p>这里就搭建一个最基本的Springboot项目，大概分为以下几步：</p>
<h3 id="在application-yml中添加mysql的配置项"><a href="#在application-yml中添加mysql的配置项" class="headerlink" title="在application.yml中添加mysql的配置项"></a>在application.yml中添加mysql的配置项</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/myblob?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">validate</span></span><br></pre></td></tr></table></figure>

<h3 id="新建User-Entity-以及对应的-Respository"><a href="#新建User-Entity-以及对应的-Respository" class="headerlink" title="新建User Entity 以及对应的 Respository"></a>新建User Entity 以及对应的 Respository</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUser.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"my_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String feeling;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUserRepository</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyUserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">MyUser</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新建-MyUser-的-Service-和-Controller"><a href="#新建-MyUser-的-Service-和-Controller" class="headerlink" title="新建 MyUser 的 Service 和 Controller"></a>新建 MyUser 的 Service 和 Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyUserService</span> </span>&#123;</span><br><span class="line">    <span class="function">MyUser <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">MyUser <span class="title">updateUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUserSeiviceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.jimmy.myBlob.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jimmy.myBlob.model.MyUser;</span><br><span class="line"><span class="keyword">import</span> com.jimmy.myBlob.repository.MyUserRepository;</span><br><span class="line"><span class="keyword">import</span> com.jimmy.myBlob.service.MyUserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserRepository myUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        myUserRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyUser <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myUserRepository.findById(id).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyUser <span class="title">updateUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myUserRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        myUserRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUserController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserService myUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; registerUser(<span class="meta">@RequestBody</span> MyUser user) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        myUserService.registerUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getUserById(<span class="meta">@PathVariable</span> <span class="keyword">int</span> userId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(myUserService.getUserById(userId), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; updateUser(<span class="meta">@RequestBody</span> MyUser user) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(myUserService.updateUser(user), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; deleteUserById(<span class="meta">@PathVariable</span> <span class="keyword">int</span> userId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        myUserService.deleteUserById(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止就完成了一个最基础的Springboot + mysql 项目的基本配置，这个项目采用的是Restful风格的请求，可以处理User的CRUD。</p>
<h2 id="配置-redis-作为缓存"><a href="#配置-redis-作为缓存" class="headerlink" title="配置 redis 作为缓存"></a>配置 redis 作为缓存</h2><p>在我们的某些项目中会存在大量的数据，当数据量变大的时候，我们的数据库的效率就会变成我们项目的一个瓶颈，这一点是无法避免的，所以我们只能改变一种方式来避开大量数据在数据库中查询慢的情况。</p>
<p>虽然项目中可能会存在大量数据，但是有的数据使用频率比较高或者说是对于速度要求比较高，比如某个热点视频的数据，它会被大量请求同时又要求速度够快，而有的数据则正好相反，前者叫做热数据，后者叫做冷数据，对于热数据我们可以将它们放到缓存中来提高效率。</p>
<p>所以我们需要一种方式来帮助我们管理缓存的数据，redis 作为一种存储在内存中的 nosql 型数据库可以很好地帮助我们解决这些问题。redis 是单线程的，但是因为它是内存数据库，所以读写速度非常快，同时由于它是单线程的所以避免了多线程带来的进程切换和加锁等机制带来的消耗；redis 也存在快照机制，帮助我们在突然断电的情况下保护我们的数据。</p>
<p>虽然redis 很强大，但是整合到我们的spring项目中非常简单。</p>
<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>和其他数据库一样，首先你需要在自己的系统上安装redis并将其运行</p>
<h3 id="修改application-yml配置文件"><a href="#修改application-yml配置文件" class="headerlink" title="修改application.yml配置文件"></a>修改application.yml配置文件</h3><p>将application.yml文件改为以下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/myblob?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">validate</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">1000000</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h4 id="修改Service文件，在每个请求上面添加cache注解"><a href="#修改Service文件，在每个请求上面添加cache注解" class="headerlink" title="修改Service文件，在每个请求上面添加cache注解"></a>修改Service文件，在每个请求上面添加cache注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CachePut</span>(cacheNames=<span class="string">"myUser"</span>, key=<span class="string">"#user.id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    myUserRepository.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span>(cacheNames=<span class="string">"myUser"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MyUser <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    simulateSlowService();</span><br><span class="line">    <span class="keyword">return</span> myUserRepository.findById(id).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CachePut</span>(cacheNames=<span class="string">"myUser"</span>, key=<span class="string">"#user.id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyUser <span class="title">updateUser</span><span class="params">(MyUser user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myUserRepository.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheEvict</span>(cacheNames=<span class="string">"myUser"</span>, key=<span class="string">"#id"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    myUserRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两点需要注意</p>
<ol>
<li>key的值需要与传入的参数对应，比如第一个请求的key就是user中的id属性，那就需要写成#user.id，这里不能写成#myUser.id（cacheNames.id）或者#my_user.id（tableName.id），一旦填错就会发现你的请求报了500但是数据库写入成功。</li>
<li>CRUD用到的注解不同，在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。 @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</li>
</ol>
<h3 id="在项目入口添加-EnableCaching"><a href="#在项目入口添加-EnableCaching" class="headerlink" title="在项目入口添加@EnableCaching"></a>在项目入口添加@EnableCaching</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Security-配置"><a href="#Spring-Security-配置" class="headerlink" title="Spring Security 配置"></a>Spring Security 配置</h2><p>添加 WebSecurityConfig.java 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiWebSecurityConfigurationAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                    .httpBasic().and()</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .antMatchers(<span class="string">"/users"</span>, <span class="string">"/users/**"</span>).permitAll().anyRequest().authenticated()</span><br><span class="line">                    .and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-配置"><a href="#RabbitMQ-配置" class="headerlink" title="RabbitMQ 配置"></a>RabbitMQ 配置</h2><h3 id="安装并启动-RabbitMQ"><a href="#安装并启动-RabbitMQ" class="headerlink" title="安装并启动 RabbitMQ"></a>安装并启动 RabbitMQ</h3><p>这一步可以去网上搜索一下，有很多教程</p>
<h3 id="修改application-yml配置"><a href="#修改application-yml配置" class="headerlink" title="修改application.yml配置"></a>修改application.yml配置</h3><p>在spring 配置下添加rabbitmq的配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">15672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template.mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="添加RabbitConstants类去获取配置文件中的配置信息"><a href="#添加RabbitConstants类去获取配置文件中的配置信息" class="headerlink" title="添加RabbitConstants类去获取配置文件中的配置信息"></a>添加RabbitConstants类去获取配置文件中的配置信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RabbitConstants.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.rabbitmq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String uhost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = uhost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供了两种方式去获取配置，第一种是直接在类上方加@ConfigurationProperties(prefix = “spring.rabbitmq”)注解，那么类中与配置文件中名字相同的属性会被自动匹配过来；第二种方式是直接在属性上加@Value注解，但是这种方式就需要完全指定。</p>
<h3 id="添加RabbitmqConfig文件"><a href="#添加RabbitmqConfig文件" class="headerlink" title="添加RabbitmqConfig文件"></a>添加RabbitmqConfig文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">"spring-boot-exchange2"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTINGKEY = <span class="string">"spring-boot-routingKey2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitConstants rabbitConstants;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        connectionFactory.setAddresses(rabbitConstants.getHost());</span><br><span class="line">        connectionFactory.setUsername(rabbitConstants.getUsername());</span><br><span class="line">        connectionFactory.setPassword(rabbitConstants.getPassword());</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 这里需要显示调用才能进行消息的回调  必须要设置</span></span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">defaultExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> org.springframework.amqp.core.<span class="function">Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"spring-boot-queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue()).to(defaultExchange()).with(RabbitmqConfig.ROUTINGKEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory());</span><br><span class="line">        container.setQueues(queue());</span><br><span class="line">        container.setExposeListenerChannel(<span class="keyword">true</span>);</span><br><span class="line">        container.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        container.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置确认模式手工确认</span></span><br><span class="line">        container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">        container.setMessageListener(<span class="keyword">new</span> ChannelAwareMessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">                System.out.println(<span class="string">"receive msg : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="comment">//确认消息成功消费</span></span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加RabbitMQ消息发送器"><a href="#添加RabbitMQ消息发送器" class="headerlink" title="添加RabbitMQ消息发送器"></a>添加RabbitMQ消息发送器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqSendMessage</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabbitmqSendMessage</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="comment">//这是是设置回调能收到发送到响应，confirm()在下面解释</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationId = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//convertAndSend(exchange:交换机名称,routingKey:路由关键字,object:发送的消息内容,correlationData:消息ID)</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE, RabbitmqConfig.ROUTINGKEY, content, correlationId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 回调id:"</span> + correlationData);</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息成功消费"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息消费失败:"</span> + cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改Controller文件，添加rabbitmq"><a href="#修改Controller文件，添加rabbitmq" class="headerlink" title="修改Controller文件，添加rabbitmq"></a>修改Controller文件，添加rabbitmq</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyUserController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserService myUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitmqSendMessage rabbitmqSendMessage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; registerUser(<span class="meta">@RequestBody</span> MyUser user) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        myUserService.registerUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; getUserById(<span class="meta">@PathVariable</span> <span class="keyword">int</span> userId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        rabbitmqSendMessage.sendMsg(<span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(myUserService.getUserById(userId), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; updateUser(<span class="meta">@RequestBody</span> MyUser user) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(myUserService.updateUser(user), HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; deleteUserById(<span class="meta">@PathVariable</span> <span class="keyword">int</span> userId) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        myUserService.deleteUserById(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>SQL注入学习笔记</title>
    <url>/2021/08/22/sql-injection-advanced/</url>
    <content><![CDATA[<p>SQL注入学习笔记</p>
<a id="more"></a>

<h2 id="宏观视角的注入：5种不同类型的注入"><a href="#宏观视角的注入：5种不同类型的注入" class="headerlink" title="宏观视角的注入：5种不同类型的注入"></a>宏观视角的注入：5种不同类型的注入</h2><p>这五种不同类型注入的分类，是通过注入是否成功回显方式不同判断标准来分类的</p>
<ul>
<li>布尔型注入</li>
<li>联合查询：使用union字段</li>
<li>时间盲注：基于时间延迟的注入</li>
<li>报错型注入</li>
<li>可多语句查询注入</li>
</ul>
<p>举例说明</p>
<p><strong>布尔型注入</strong></p>
<p>页面只返回True和False两种类型页面。利用页面返回不同，逐个猜数据</p>
<p><a href="http://test.com?id=1" rel="external nofollow noopener noreferrer" target="_blank">http://test.com?id=1</a> and substring(version(), 1, 1) = 5</p>
<p>如果数据库版本是5.x那么就可以正常返回页面</p>
<p><strong>联合查询注入</strong></p>
<p>判断是否入住成功的标准就是是否查询了其他的信息出来。这个是最快捷的获取任何想要的数据的方法，但是有一个前提，就是该请求能返回sql查询的结果</p>
<p><a href="http://test.com?id=1" rel="external nofollow noopener noreferrer" target="_blank">http://test.com?id=1</a> UNION select 1,2,3,4 from INFORMATION_SCHEMA</p>
<p><strong>基于时间的盲注</strong></p>
<p>如果一个请求没有任何的返回，或者说，是否成功结果都是相同的，那我们就没法用布尔或者联合查询来判断这里是否能够注入，于是我们就需要时间盲注</p>
<p>Select * from user where id = 1 and sleep(3)</p>
<p>这条语句如果成功执行，会在3秒后执行查询，如果我们在前端感知到确实有时间上的延迟，说明sql注入成功了</p>
<p><strong>报错型注入</strong></p>
<p>这类注入比较少见，需要前端能够显示部分sql的报错信息，而这需要后端直接就把报错结果返回给前端</p>
<p>典型的就是group by的duplicate key的报错</p>
<p><strong>多语句查询注入</strong></p>
<p>最危险的注入类型，能够执行多条语句，这意味着我们也可以执行更新数据库的操作</p>
<p><a href="http://test.com?id=1" rel="external nofollow noopener noreferrer" target="_blank">http://test.com?id=1</a>; update set name = ‘1’ where id = 1</p>
<h2 id="SQL注入最关键的两个步骤"><a href="#SQL注入最关键的两个步骤" class="headerlink" title="SQL注入最关键的两个步骤"></a>SQL注入最关键的两个步骤</h2><ul>
<li>发现可以注入的点。如报错型，如果我们输入1可以正常查询，输入1‘则会报错，说明这里有sql注入问题</li>
<li>构造原始的注入语句。通过猜测后端的sql语句，尝试闭合原有语句并执行自己的内容</li>
</ul>
<h2 id="利用时间盲注绕过无报错（布尔）无回显（联合）场景"><a href="#利用时间盲注绕过无报错（布尔）无回显（联合）场景" class="headerlink" title="利用时间盲注绕过无报错（布尔）无回显（联合）场景"></a>利用时间盲注绕过无报错（布尔）无回显（联合）场景</h2><p>定义：通过注入特定语句，通过页面对请求的物理反馈，来判断注入是否成功，如注入sleep语句来观察页面的加载时间来判断注入点。</p>
<p>适用于无法从页面上获取注入结果，甚至连注入语句是否成功执行都不知道的情景</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629850956/origin-of-ray/asynccode_blqzax.png" alt="img"></p>
<p>也就是说我们可以在sleep之前拼接我们真正想要判断的信息，如果时间延迟了，说明前面的判断是正确的，如果没有延迟，说明sleep之前的判断是失败的</p>
<p>时间盲注的常用函数：substr，count，ascii，length，left，sleep</p>
<ul>
<li>一般的步骤，首先需要判断这里存在时间盲注，所以一般一开始不是and sleep（3），而是or sleep（3），如果确实感到有时间上的延迟，确认有时间盲注。(或者你确定前面的条件一定为真，也可以直接中and sleep（3）)</li>
<li>如果有时间盲注，则在sleep之前加入自己想要判断的条件，如搜索是否有个叫user的数据库</li>
</ul>
<p><strong>举例：</strong></p>
<p>获取数据库长度</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629850986/origin-of-ray/asynccode_enm7jy.png" alt="img"></p>
<p>获取数据库名称</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629851008/origin-of-ray/asynccode_wyqrgr.png" alt="img"></p>
<h2 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h2><p>针对HTTP请求的头部信息，如果不加以过滤或者转义，在直接与数据库交互的过程中，就容易发生SQL注入。如有的webapp会从头部信息中获取用户的访问记录，IP，hostname等信息</p>
<p>比如server会从头部中获取user-agent信息插入数据库。</p>
<p>我们猜测，后端的注入语句是”insert into user values(“ + use-agent + “)”</p>
<p>那我们可以尝试修改user-agent头部，将x替换成 1); sleep(3)#</p>
<p>如果有时间延迟，则说明注入成功</p>
<blockquote>
<p>如果语句是”insert into user values(“ + use-agent + “,” + ip_address + “)”，还能成功注入吗？</p>
</blockquote>
<blockquote>
<p>如果语句是”insert into user values(“ + ip_address  + “,” + use-agent + “)”，还能成功注入吗？</p>
</blockquote>
<h2 id="报错型注入"><a href="#报错型注入" class="headerlink" title="报错型注入"></a>报错型注入</h2><p>MySql的报错注入主要是利用MySql的一些逻辑漏洞，如BigInt大整数溢出等。</p>
<p>可以将MySql的报错注入划分为以下类型：</p>
<ul>
<li>BigInt等数据类型溢出</li>
<li>Xpath语法错误</li>
<li>count() + rand() + group_by()导致重复</li>
<li>空间数据类型函数错误</li>
</ul>
<h3 id="前置知识：预备函数"><a href="#前置知识：预备函数" class="headerlink" title="前置知识：预备函数"></a>前置知识：预备函数</h3><ul>
<li>rand(N)：返回一个随机数，如果传入参数，则N相同时，产生的随机序列也想通</li>
<li>floor(x)：返回一个不大于x的整数</li>
<li>count：返回数据集的数量</li>
</ul>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629851039/origin-of-ray/asynccode_zd8hgo.png" alt="img"></p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1629851061/origin-of-ray/asynccode_h2yczf.png" alt="img"></p>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>Sql注入 入门笔记</title>
    <url>/2020/06/20/sql-injection/</url>
    <content><![CDATA[<h2 id="什么是sql注入"><a href="#什么是sql注入" class="headerlink" title="什么是sql注入"></a>什么是sql注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​    sql注入的原理是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。</p>
<a id="more"></a>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>​    比如我们使用的登录接口：在登录界面包括用户名和密码输入框，以及提交按钮，输入用户名和密码，提交。</p>
<p>​    登录时调用接口/user/login/ 加上参数username、password，首先连接数据库，然后后台对请求参数中携带的用户名、密码进行参数校验，即sql的查询过程。假设正确的用户名和密码为ls和123456，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">'ls'</span> <span class="keyword">AND</span> <span class="keyword">password</span> = <span class="string">'123456'</span></span><br></pre></td></tr></table></figure>

<p>​    sql中会将#及–以后的字符串当做注释处理，如果我们使用“’ or 1=1 #” 作为用户名参数，那么服务端构建的sql语句就如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span><span class="comment">#' and password='123456'</span></span><br></pre></td></tr></table></figure>

<p>​    而#会忽略后面的语句，因此上面的sql也等价于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=<span class="string">''</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>​    而1=1属于常等型条件，因此这个sql便成为了如下，查询出所有的登陆用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span></span><br></pre></td></tr></table></figure>

<p>​    其实上面的sql注入只是在参数层面做了些手脚，如果是引入了一些功能性的sql那就更危险了，比如上面的登陆接口，如果用户名使用这个“’ or 1=1;delete * from users; #”，那么在”;”之后相当于是另外一条新的sql，这个sql是删除全表，是非常危险的操作，因此sql注入这种还是需要特别注意的。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常见的sql注入按照参数类型可分为两种：数字型和字符型。</p>
<p>当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。</p>
<p>也可以根据数据库返回的结果，分为回显注入、报错注入、盲注。</p>
<ul>
<li><p>回显注入：可以直接在存在注入点的当前页面中获取返回结果。</p>
</li>
<li><p>报错注入（布尔型注入）：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。</p>
</li>
<li><p>盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。</p>
</li>
</ul>
<p>按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入，无论此种分类如何多，都可以归纳为以上两种形式。</p>
<h3 id="注入测试"><a href="#注入测试" class="headerlink" title="注入测试"></a>注入测试</h3><h4 id="数字型："><a href="#数字型：" class="headerlink" title="数字型："></a>数字型：</h4><p>猜测SQL语句：</p>
<p>select 字段名 from 表名 where id = 1；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.sql.com/xxx.php?id=1              假设ID为存在注入的参数</span><br><span class="line">http://www.sql.com/xxx.php?id=1‘             语句报错</span><br><span class="line">http://www.sql.com/xxx.php?id=1 and 1=1      页面正常返回结果</span><br><span class="line">http://www.sql.com/xxx.php?id=1 and 1=2      页面返回错误</span><br></pre></td></tr></table></figure>

<p>  如果以上几个测试步骤结果全部满足，就可能存在sql注入漏洞。</p>
<p>  数字型注入一般出现在asp php等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=1，PHP会自动把ID的数据类型推导为int类型，若是 id=1 and 1=1，则把ID推导为string类型。但是对于Java、c#这类强类型语言，如果把一个字符串转换为int类型，则会抛出异常，无法运行，所以数字型注入一般出现在弱类型的语言当中，强类型语言很少存在。</p>
<h4 id="字符型："><a href="#字符型：" class="headerlink" title="字符型："></a>字符型：</h4><p>猜测SQL语句：</p>
<p>select 字段名 from 表名 where id =‘；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.sql.com/xxx.php?id=1                      假设ID为存在注入的参数</span><br><span class="line">http://www.sql.com/xxx.php?id=1‘                     语句报错</span><br><span class="line">http://www.sql.com/xxx.php?id=1&apos; and 1=1 and &apos;1&apos;=&apos;1  页面正常返回结果</span><br><span class="line">http://www.sql.com/xxx.php?id=1&apos; and 1=2 and &apos;1&apos;=&apos;1  页面返回错误</span><br></pre></td></tr></table></figure>

<h4 id="搜索型："><a href="#搜索型：" class="headerlink" title="搜索型："></a>搜索型：</h4><p>猜测SQL语句：</p>
<p>select 字段 from 表名 where username like ‘%k%’;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.sql.com/xxx.php?search=test                  假设search为存在注入的参数</span><br><span class="line">http://www.sql.com/xxx.php?search=test&apos;                 语句报错</span><br><span class="line">http://www.sql.com/xxx.php?search=test%&apos; and 1=1 and &apos;%&apos;=&apos;   页面正常返回结果</span><br><span class="line">http://www.sql.com/xxx.php?search=test%&apos; and 1=2 and &apos;%&apos;=&apos;   页面返回错误</span><br></pre></td></tr></table></figure>

<h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>如果我们认为一个输入框可能会有sql注入的情况，我们可以使用sqlmap来帮助我们去进行扫描。</p>
<p>比如我在本地搭建了一个网站，可以搜索站内的文章，它能够根据我输入不同的key去给我一个真或者假的判断，那这里可能就会存在布尔型注入。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620081821696_iytob2.png" alt="image-20200620082754120"></p>
<p>这个时候我们可以通过控制台找到这个搜索的请求：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615446/sql_injection/image-20200620081912352_gm4sc3.png" alt="image-20200620081912352"></p>
<p>找到了这个请求之后，我们就可以利用sqlmap去检查我们的这个请求是否有sql注入问题。</p>
<p>我们可以通过在控制台输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u http://localhost:8080/article/search?key=123 -dbs</span><br></pre></td></tr></table></figure>

<p>去尝试获取后台的数据库的table，如果获取成功会显示以下效果：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620082740546_yzowgw.png" alt="image-20200620082552344"></p>
<p>可以看出这里确实有sql注入问题，我们已经成功获取到了后台的数据库名。</p>
<p>获得了数据库名称之后我们可以进一步获取其中的表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">py -3 sqlmap.py -u http://localhost:8080/article/search?key=123 -D insecurity <span class="comment">--tables</span></span><br></pre></td></tr></table></figure>

<p>通过这个命令，我们可以获取insecurity这个数据库中有什么表</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615757/sql_injection/image-20200620084424782_uqyhrq.png" alt="image-20200620084424782"></p>
<p>我们可以看到整个db中有三个表，分别是user，atricle和flyway_schema_history</p>
<p>进一步我们可以获取表中的列名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">py -3 sqlmap.py -u http://localhost:8080/article/search?key=123 -D insecurity -T insecurity <span class="comment">--columns</span></span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620085249277_yc3nh4.png" alt="image-20200620085249277"></p>
<p>它会详细列出每一列的名字和类型，最终我们可以得知以下结果。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620085054277_jxns66.png" alt="image-20200620085054277"></p>
<p>得到这个表结构有什么用呢？</p>
<p>我们可以利用union语句把任何我想知道的信息union到atricle的返回结果中，比如我在搜索栏中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos; union select uid, uid, &apos;123&apos;, username, password, &apos;123&apos;, create_time, update_time, del  from user;%23&apos;</span><br></pre></td></tr></table></figure>

<p>username和password就会分别通过作者名和图片链接返回到前端</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620085634320_w8oblo.png" alt="image-20200620085634320"></p>
<p>这样我们就可以获取到admin的密码了。</p>
<p>甚至如果我们发现它的登录界面都有注入问题，我们都不需要密码</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1592615447/sql_injection/image-20200620090420970_yvyxb5.png" alt="image-20200620090420970"></p>
<p>只要password是这个，任何人的账号我都可以进去。</p>
<p>sqlmap还有很多强大的功能，建议大家去看文档，我也是刚刚接触。</p>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5d56b641f265da03f12e565c" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5d56b641f265da03f12e565c</a></p>
<p><a href="https://www.kanxue.com/book-6-110.htm" rel="external nofollow noopener noreferrer" target="_blank">https://www.kanxue.com/book-6-110.htm</a></p>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>SSRF漏洞的原理以及防御方案</title>
    <url>/2021/05/06/ssrf/</url>
    <content><![CDATA[<p>最近在看一些安全知识的时候，发现了一个新的漏洞，叫做SSRF，这个漏洞原理其实并不复杂，但是由于是第一次遇到，还是简单记录一下。</p>
<a id="more"></a>

<h2 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF"></a>什么是SSRF</h2><p>服务端请求伪造(Server-Side Request Forgery),指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。</strong></p>
<p>假设某公司的网站部署在A服务器上，为了让用户能够访问到，所以A服务器有自己的I公网P地址（或者经过NAT网关配置，有了自己的公网IP+PORT），同时公司还有一台B服务器，存放着一些重要的数据，这台B服务器部署在在内网，没有公网的IP，所以正常情况下，外网是无法访问的。</p>
<p>而这个时候，A服务器上的网站有的服务需要用到B上的数据，所以会向B发送请求，由于A知道B在哪里，所以A可以访问。</p>
<p>这个时候<strong>A就相当于B的一个反向代理</strong>了，只不过这个代理只能发出A网站上的指定的几个请求。</p>
<p>如果这个时候，A所能发出的请求没有经过严格的限制，可以随便拼凑参数，那A就相当于为黑客开了一扇大门，可以直通B服务器。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>很多web应用都提供了从其他的服务器上获取数据的功能。使用指定的URL，web应用便可以获取图片，下载文件，读取文件内容等。SSRF的实质是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。一般情况下， SSRF攻击的目标是外网无法访问的内部系统，黑客可以利用SSRF漏洞获取内部系统的一些信息（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p>
<h2 id="SSRF危害"><a href="#SSRF危害" class="headerlink" title="SSRF危害"></a>SSRF危害</h2><h3 id="探测内部主机的任意端口"><a href="#探测内部主机的任意端口" class="headerlink" title="探测内部主机的任意端口"></a><strong>探测内部主机的任意端口</strong></h3><p>这种情况比较极端，基本不会出现，就是说A会通过请求参数中的ip和端口号去找B，也就是说，B的具体信息是A解析了请求中的IP和Port得出来的</p>
<p>不过这种情况一旦出现，攻击者就可以伪造各种IP和PORT去访问，根据返回结果不同，得到内网中的网络结果和每个服务器的端口开发情况。</p>
<h3 id="利用ssrf获取内网敏感文件信息"><a href="#利用ssrf获取内网敏感文件信息" class="headerlink" title="利用ssrf获取内网敏感文件信息"></a><strong>利用ssrf获取内网敏感文件信息</strong></h3><p>在服务器上有一个ssrf.php的页面，该页面的功能是获取URL参数，然后将URL的内容显示到网页页面上。</p>
<p>我们访问该链接：<a href="http://127.0.0.1/ssrf.php?url=http://127.0.0.1/test.php" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1/ssrf.php?url=http://127.0.0.1/test.php</a> ，它会将test.php页面显示</p>
<p>我们可以将URL参数换成内网的地址，则会泄露服务器内网的信息。将URL换成file://的形式，就可以读取本地文件。</p>
<h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><p>1、过滤返回的信息，如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>2、统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。</p>
<p>3、限制请求的端口，比如80,443,8080,8090。</p>
<p>4、禁止不常用的协议，仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp://等引起的问题。</p>
<p>5、使用DNS缓存或者Host白名单的方式。</p>
<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/91819069" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/91819069</a></p>
<p><a href="https://www.jianshu.com/p/612c010e588e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/612c010e588e</a></p>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>字符串匹配算法学习笔记</title>
    <url>/2020/10/24/string-matching-algorithm/</url>
    <content><![CDATA[<p>我们平时工作中会经常使用SringA.indexOf(StringB)这种子串查找函数，如果让我们自己实现，我们会怎么实现？</p>
<p>这次就记录下我们常说的四种字符串匹配算法，分别是BF，RK，BM和KMP算法。</p>
<p>前两种容易想到，也很简单，后面两种了解原理即可，这两种算是算法中比较难理解的两种，就算理解也很难写出没有bug的程序。</p>
<a id="more"></a>

<h2 id="BF（暴力匹配）算法"><a href="#BF（暴力匹配）算法" class="headerlink" title="BF（暴力匹配）算法"></a>BF（暴力匹配）算法</h2><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p>
<p>在开始讲解这个算法之前，我先定义两个概念，方便我后面讲解。它们分别是主串和模式串。这俩概念很好理解，我举个例子你就懂了。比方说，我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p>
<p>作为最简单、最暴力的字符串匹配算法，<strong>BF 算法的思想可以用一句话来概括，那就是，我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</strong>。</p>
<p>举个例子：</p>
<p><img src="https://static001.geekbang.org/resource/image/f3/a2/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt></p>
<p>从上面的算法思想和例子，我们可以看出，在极端情况下，比如主串是“aaaaa…aaaaaa”（省略号表示有很多重复的字符 a），模式串是“aaaaab”。我们每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的最坏情况时间复杂度是 O(n * m)。</p>
<p>尽管理论上，BF 算法的时间复杂度很高，是 O(n * m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。</p>
<p>为什么这么说呢？原因有两点。第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p>
<p>所以说这种算法虽然时间复杂度很高，但是<strong>如果我们的数据并不复杂的时候，完全可以用这种算法，因为这种算法思路简单，不容易出错</strong></p>
<h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。这个算法理解起来也不是很难。我个人觉得，它其实就是刚刚讲的 BF 算法的升级版。</p>
<p>我在讲 BF 算法的时候讲过，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n-m+1 个长度为 m 的子串，我们只需要暴力地对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。</p>
<p>但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。</p>
<p>RK 算法的思路是这样的：<strong>我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了</strong>（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>
<h3 id="如何巧妙地设计哈希函数"><a href="#如何巧妙地设计哈希函数" class="headerlink" title="如何巧妙地设计哈希函数"></a>如何巧妙地设计哈希函数</h3><p>通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？</p>
<p>这里就要用到一个比较常见但也比较实用的思想，<strong>如果你后面的结果可以通过前面的计算结果推算出来，那就可以大大简化计算量，比如我们动态规划中的递推公式，前缀和等等都是用到这个思想。</strong></p>
<p>由于我们依次计算子串哈希值的时候前一个和后一个子串有很大的重合部分，如果我们的哈希函数可以利用到这些重合的部分的计算结果，就可以避免很多的重复计算。</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设字符串中只包含 a～z 这 26 个小写字符，我们用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。</p>
<p><img src="https://static001.geekbang.org/resource/image/c4/9c/c47b092408ebfddfa96268037d53aa9c.jpg" alt></p>
<h3 id="改进哈希函数"><a href="#改进哈希函数" class="headerlink" title="改进哈希函数"></a>改进哈希函数</h3><ul>
<li>如果还想提高效率，可以进一步空间花时间，那就是 26^(m-1) 这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</li>
<li>上面这种哈希函数固然不会出现哈希冲突，但是十分占用空间，甚至可能会出现超过数字变量存储上限的情况。这种情况下我们可以牺牲一部分性能，采用简单的哈希算法，比如简单的ascii码相加，这样比较的时候如果hash值相同，我们再去具体比较一次，这个思想很想布隆过滤器。</li>
</ul>
<h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p>
<p><img src="https://static001.geekbang.org/resource/image/43/f9/4316dd98eac500a01a0fd632bb5e77f9.jpg" alt="4316dd98eac500a01a0fd632bb5e77f9"></p>
<p>在这个例子里，主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。</p>
<p><img src="https://static001.geekbang.org/resource/image/cf/15/cf362f9e59c01aaf40a34d2f10e1ef15.jpg" alt="cf362f9e59c01aaf40a34d2f10e1ef15"></p>
<p>由现象找规律，你可以思考一下，<strong>当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢</strong>？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？我们今天要讲的 BM 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）。我们下面依次来看，这两个规则分别都是怎么工作的。</p>
<h4 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h4><p>前面两个算法，在匹配的过程中，我们都是按模式串的下标从小到大的顺序，依次与主串中的字符进行匹配的。这种匹配顺序比较符合我们的思维习惯，而 BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。我画了一张图，你可以看下。</p>
<p><img src="https://static001.geekbang.org/resource/image/29/e1/29521f541dd45e13162013b3364fece1.jpg" alt="29521f541dd45e13162013b3364fece1"></p>
<p><img src="https://static001.geekbang.org/resource/image/54/9e/540809418354024206d9989cb6cdd89e.jpg" alt="540809418354024206d9989cb6cdd89e"></p>
<blockquote>
<p>这里有个问题，为什么这里需要从后往前找？</p>
</blockquote>
<p>我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</p>
<p><img src="https://static001.geekbang.org/resource/image/22/da/220daef736418df84367215647bca5da.jpg" alt></p>
<p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>
<p><img src="https://static001.geekbang.org/resource/image/4e/64/4e36c4d48d1b6c3b499fb021f03c7f64.jpg" alt></p>
<p>这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/ca/a8d229aa217a67051fbb31b8aeb2edca.jpg" alt></p>
<p>第一次不匹配的时候，我们滑动了三位，第二次不匹配的时候，我们将模式串后移两位，那具体滑动多少位，到底有没有规律呢？</p>
<p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，我这里说的下标，都是字符在模式串的下标）。</p>
<p><img src="https://static001.geekbang.org/resource/image/8f/2e/8f520fb9d9cec0f6ea641d4181eb432e.jpg" alt></p>
<p>这里我要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p>
<p>利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p>
<p>不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。</p>
<blockquote>
<p>到这里为止，其实只要我们限制计算出来的移动位数不能为负，BM算法就可以正常工作了。</p>
</blockquote>
<h4 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h4><p>好后缀规则实际上跟坏字符规则的思路很类似。你看我下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/d7/8a/d78990dbcb794d1aa2cf4a3c646ae58a.jpg" alt></p>
<p>这个时候该如何滑动模式串呢？当然，我们还可以利用坏字符规则来计算模式串的滑动位数，不过，我们也可以使用好后缀处理规则。两种规则到底如何选择，我稍后会讲。抛开这个问题，现在我们来看，好后缀规则是怎么工作的？</p>
<p>我们把已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u<em>}，那我们就将模式串滑动到子串{u</em>}与主串中{u}对齐的位置。</p>
<p><img src="https://static001.geekbang.org/resource/image/b9/63/b9785be3e91e34bbc23961f67c234b63.jpg" alt></p>
<p>如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/de/cd/de97c461b9b9dbc42d35768db59908cd.jpg" alt></p>
<p>不过，当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/9b/70/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg" alt></p>
<p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/05/23/0544d2997d8bb57c10e13ccac4015e23.jpg" alt></p>
<p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p>
<p>所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/f9/6caa0f61387fd2b3109fe03d803192f9.jpg" alt></p>
<p>坏字符和好后缀的基本原理都讲完了，当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则计算得到的往后滑动的位数，有可能是负数的情况。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h4><p>“坏字符规则”本身不难理解。当遇到坏字符时，要计算往后移动的位数 si-xi，其中 xi 的计算是重点，我们如何求得 xi 呢？或者说，如何查找坏字符在模式串中出现的位置呢？</p>
<p>如果我们拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。有没有更加高效的方式呢？我们之前学的散列表，这里可以派上用场了。我们可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>
<p>关于这个散列表，我们只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。</p>
<p>数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。如果将上面的过程翻译成代码，就是下面这个样子。其中，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = <span class="number">-1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>掌握了坏字符规则之后，我们先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public int bm(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] bc = <span class="keyword">new</span> int[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  int i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(int)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h4><p>我们先简单回顾一下，前面讲过好后缀的处理规则中最核心的内容：</p>
<ul>
<li><p>在模式串中，查找跟好后缀匹配的另一个子串；</p>
</li>
<li><p>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</p>
</li>
</ul>
<p>在不考虑效率的情况下，这两个操作都可以用很“暴力”的匹配查找方式解决。但是，如果想要 BM 算法的效率很高，这部分就不能太低效。如何来做呢？</p>
<p><strong>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过预处理模式串</strong>，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。</p>
<p>如何表示模式串中不同的后缀子串呢？因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，我们只需要记录长度就可以了。通过长度，我们可以确定一个唯一的后缀子串。</p>
<p><img src="https://static001.geekbang.org/resource/image/77/c8/7742f1d02d0940a1ef3760faf4929ec8.jpg" alt></p>
<p>现在，我们要引入最关键的变量 suffix 数组。suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值。</p>
<p><img src="https://static001.geekbang.org/resource/image/99/c2/99a6cfadf2f9a713401ba8feac2484c2.jpg" alt></p>
<p>如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，那 suffix 数组中该存储哪一个子串的起始位置呢？为了避免模式串往后滑动得过头了，我们肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。不过，这样处理就足够了吗？</p>
<p>实际上，仅仅是选最靠后的子串片段来存储是不够的。我们再回忆一下好后缀规则。我们不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。</p>
<p>如果我们只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串</p>
<p><img src="https://static001.geekbang.org/resource/image/27/83/279be7d64e6254dac1a32d2f6d1a2383.jpg" alt></p>
<p>现在，我们来看下，如何来计算并填充这两个数组的值？</p>
<p>这个计算过程非常巧妙。我们拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p>
<p><img src="https://static001.geekbang.org/resource/image/57/7c/5723be3c77cdbddb64b1f8d6473cea7c.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, boolean[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = <span class="number">-1</span>;</span><br><span class="line">    prefix[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m<span class="number">-1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span>) prefix[k] = <span class="literal">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这两个数组之后，我们现在来看，在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</p>
<p>假设好后缀的长度是 k。我们先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段。我们可以用下面这条规则来处理</p>
<p><img src="https://static001.geekbang.org/resource/image/1d/72/1d046df5cc40bc57d3f92ff7c51afb72.jpg" alt></p>
<p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p>
<p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  boolean[] prefix = <span class="keyword">new</span> boolean[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m<span class="number">-1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, boolean[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != <span class="number">-1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m<span class="number">-1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> generateBC = <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = b.length;</span><br><span class="line">    <span class="keyword">let</span> bc = <span class="keyword">new</span> <span class="built_in">Array</span>(SIZE).fill(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ascii = b[i].charCodeAt();</span><br><span class="line">        bc[ascii] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generateGS = <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> m = b.length;</span><br><span class="line">    <span class="keyword">let</span> suffix = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">let</span> prefix = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m - <span class="number">1</span> - k]) &#123;</span><br><span class="line">            suffix[++k] = j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === <span class="number">-1</span>) &#123;</span><br><span class="line">            prefix[k] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        suffix,</span><br><span class="line">        prefix</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moveByGS = <span class="function">(<span class="params">j, suffix, prefix</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> m = suffix.length;</span><br><span class="line">    <span class="keyword">let</span> k = m - j - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (suffix[k] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> j - suffix[k] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r = j + <span class="number">2</span>; r &lt; m; r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix[m - r]) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bm = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bc = generateBC(b);</span><br><span class="line">    <span class="keyword">const</span> &#123; suffix, prefix &#125; = generateGS(b);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, n = a.length, m = b.length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n - m) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + j] != b[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> x = j - bc[a[i + j].charCodeAt()];</span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">            y = moveByGS(j, suffix, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="built_in">Math</span>.max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://sunra.top/2020/08/30/think_of_shortest_palindrome/">https://sunra.top/2020/08/30/think_of_shortest_palindrome/</a></p>
<p>注：</p>
<p>本文图片均来自于极客时间《数据结构与算法之美》</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>TamperMonkey 对于内容的保护</title>
    <url>/2020/07/31/tamper-monkey-security/</url>
    <content><![CDATA[<p>前段时间做了个油猴插件，把项目组常用的项目在不同环境的url给整理一下，方便使用。<br>最近又被各个项目在各个环境的db配置搞得有点烦，就想着把db的配置也放进脚本里，但是这些db配置中还有些敏感的信息，贸然放进去可能会有安全的问题，为了研究一下TamperMonkey的安全性，就研究了下TamperMonkey的文档以及它的一点原理。</p>
<a id="more"></a>

<h2 id="独立的运行环境"><a href="#独立的运行环境" class="headerlink" title="独立的运行环境"></a>独立的运行环境</h2><p>首先粘一段国外论坛上的结论：</p>
<p>See <a href="https://stackoverflow.com/q/6617361/331508" rel="external nofollow noopener noreferrer" target="_blank">“Are Chrome user-scripts separated from the global namespace like Greasemonkey scripts?”</a>. Both Chrome userscripts/content-scripts and Greasemonkey scripts are isolated from the page’s javascript. This is done to help keep you from being hacked, but it also reduces conflicts and unexpected side-effects.</p>
<p>However, the methods are different for each browser…</p>
<p><strong>Firefox:</strong></p>
<ol>
<li>Runs scripts in <a href="https://developer.mozilla.org/en/XPCNativeWrapper" rel="external nofollow noopener noreferrer" target="_blank">an XPCNativeWrapper sandbox</a>, unless <a href="http://wiki.greasespot.net/@grant" rel="external nofollow noopener noreferrer" target="_blank">@grant none</a> is in effect (as of GM 1.0).</li>
<li>Wraps the script in an anonymous function by default.</li>
<li>Provides unsafeWindow to access the target page’s javascript. But beware that it is <em>possible</em> for hostile webmasters to follow unsafeWindow usage back to the script’s context and thus gain elevated privileges to pwn you with.</li>
</ol>
<p><strong>Chrome:</strong></p>
<ol>
<li><p>Runs scripts in <a href="https://developer.chrome.com/extensions/content_scripts.html#execution-environment" rel="external nofollow noopener noreferrer" target="_blank">an “isolated world”</a>.</p>
</li>
<li><p>Wraps the script in an anonymous function.</p>
</li>
<li><p><strong>Strictly</strong> blocks any access to the page’s JS by the script and vice-versa.</p>
<p>Recent versions of Chrome now provide an object named unsafeWindow, for very-limited compatibility, but this object does not provide any access to the target page’s JS. It is the same as window in the script scope (which is not window in the page scope).</p>
</li>
</ol>
<p>上面这段结论大致可以总结为，TamperMonkey的运行环境与页面的JS脚本不是一个，TamperMonkey中的脚本运行在一个沙箱环境中，但是二者都可以操作页面。</p>
<p>沙箱的环境也是有所不同的，如果你的@grant的值是none，那么如果你向window对象上挂载了一些属性，其他脚本理论上也是可以访问到的。</p>
<p>但如果你的@grant不是none，那么就连window对象都是分开的，你在脚本中挂载的属性在其他脚本中是无法访问的。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我们看一下TamperMonkey脚本的基本格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>我们可以一眼就看出，这是个闭包，而且是个立即执行函数，所以定义在其中所有变量，除非我们有意识地挂载到window上，否则在外部是无法访问地。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，TamperMonkey中的脚本是运行在完全独立于page的JS的另一个环境中，各个脚本之间不会相互影响，同时由于脚本的实际内容都是在一个闭包中，只有在grant是none且我们有意识地向window对象上挂载一个属性，不然这个属性是不会被外部访问到的。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Chrome-Xray"><a href="#Chrome-Xray" class="headerlink" title="Chrome Xray"></a>Chrome Xray</h3><p>Gecko从各种不同的来源并以各种不同的特权级别运行JavaScript：</p>
<ul>
<li><p>与C ++核心一起实现浏览器本身的JavaScript代码称为chrome代码，并使用系统特权运行。 如果chrome特权代码遭到破坏，则攻击者可以接管用户的计算机。</p>
</li>
<li><p>从普通网页加载的JavaScript称为内容代码。 因为此代码是从任意网页加载的，所以对于其他网站和用户而言，它均被视为不受信任且可能具有敌意。</p>
</li>
<li><p>除了这两个特权级别，chrome代码还可以创建沙箱。 为沙箱定义的安全主体确定其特权级别。 如果使用扩展主体，则沙箱将获得对内容代码的某些特权，并且受到内容代码的直接访问保护。</p>
</li>
</ul>
<p>Gecko中的安全机制可确保不同特权级别的代码之间存在非对称访问：例如，内容代码无法访问由chrome代码创建的对象，但是chrome代码可以访问由内容创建的对象。</p>
<p>但是，即使访问内容对象的能力也可能会对chrome代码造成安全风险。 JavaScript是一种高度可扩展的语言。 在网页中运行的脚本可以为DOM对象添加额外的属性（也称为expando属性），甚至可以重新定义标准的DOM对象以执行意外的操作。 如果chrome代码依赖于此类修改后的对象，则可以欺骗它做不应做的事情。</p>
<p>例如：window.confirm（）是一个DOM API，应该让用户确认一个动作，并根据他们单击“确定”还是“取消”返回一个布尔值。 网页可以重新定义它以返回true：</p>
<p>任何调用此函数并期望其结果代表用户确认的特权代码都会被欺骗。 当然，这是非常幼稚的，但是从chrome访问内容对象会导致安全问题的方法更细微。</p>
<p>这是Xray旨在解决的问题。 当脚本使用Xray访问对象时，它只会看到该对象的本机版本。 任何expandos都是不可见的，并且如果已重新定义对象的任何属性，它将看到原始的实现，而不是重新定义的版本。</p>
<p>因此，在上面的示例中，调用内容的window.confirm（）的chrome代码将获得Confirm（）的原始版本，而不是重新定义的版本。</p>
<p>特权代码在访问属于特权较少的代码的对象时自动获得Xray。 因此，当chrome代码访问内容对象时，它会通过Xray看到它们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome code</span></span><br><span class="line"><span class="keyword">var</span> transfer = gBrowser.contentWindow.confirm(<span class="string">"Transfer all my money?"</span>);</span><br><span class="line"><span class="comment">// calls the native implementation</span></span><br></pre></td></tr></table></figure>

<h4 id="禁止Xray"><a href="#禁止Xray" class="headerlink" title="禁止Xray"></a>禁止Xray</h4><p>Xray是一种安全启发式设计，旨在使对不受信任的对象的最常见操作变得简单和安全。 但是，有些操作对它们的限制过于严格：例如，如果需要查看DOM对象上的expandos。 在这种情况下，您可以放弃Xray防护，但随后您将不再依赖于正在或正在执行的任何属性或功能。 其中的任何一个，甚至是setter和getter，都可能已被不受信任的代码重新定义。</p>
<p>要放弃对象的Xray，可以使用Components.utils.waiveXrays（object），也可以使用对象的wrappedJSObject属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chrome code</span></span><br><span class="line"><span class="keyword">var</span> waivedWindow = Components.utils.waiveXrays(gBrowser.contentWindow);</span><br><span class="line"><span class="keyword">var</span> transfer = waivedWindow.confirm(<span class="string">"Transfer all my money?"</span>);</span><br><span class="line"><span class="comment">// calls the redefined implementation</span></span><br><span class="line"><span class="comment">// chrome code</span></span><br><span class="line"><span class="keyword">var</span> waivedWindow = gBrowser.contentWindow.wrappedJSObject;</span><br><span class="line"><span class="keyword">var</span> transfer = waivedWindow.confirm(<span class="string">"Transfer all my money?"</span>);</span><br><span class="line"><span class="comment">// calls the redefined implementation</span></span><br></pre></td></tr></table></figure>

<p>豁免是可传递的：因此，如果您放弃某个对象的Xray，则将自动放弃其所有对象属性。 例如，window.wrappedJSObject.document可让您放弃文档版本。</p>
<p>要再次撤消放弃，请调用Components.utils.unwaiveXrays（waivedObject）：</p>
<h4 id="Xray-For-DOM"><a href="#Xray-For-DOM" class="headerlink" title="Xray For DOM"></a>Xray For DOM</h4><p>Xray的主要用途是用于DOM对象：即代表网页各部分的对象。</p>
<p>在Gecko中，DOM对象具有双重表示形式：规范表示形式采用C ++，并且为了体现JavaScript代码的优势，这被反映到JavaScript中。 对这些对象的任何修改（例如添加expandos或重新定义标准属性）都保留在JavaScript反射中，并且不影响C ++表示形式。</p>
<p>双重表示形式实现了Xrays的优雅实现：Xray只是直接访问原始对象的C ++表示形式，而根本不涉及内容的JavaScript反射。 Xray不会完全过滤出内容所做的修改，而是将内容完全短路。</p>
<p>这也使Xrays对DOM对象的语义更加清晰：它们与DOM规范相同，因为它是使用WebIDL定义的，并且WebIDL还定义了C ++表示形式。</p>
<h4 id="Xray-For-JavaScript-Object"><a href="#Xray-For-JavaScript-Object" class="headerlink" title="Xray For JavaScript Object"></a>Xray For JavaScript Object</h4><p>直到最近，通过特权更高的代码访问时，不属于DOM的内置JavaScript对象（例如Date，Error和Object）都无法获得Xray。</p>
<p>在大多数情况下，这不是问题：Xrays解决的主要问题是处理不受信任的Web内容操纵对象，并且Web内容通常与DOM对象一起工作。 例如，如果内容代码创建一个新的Date对象，则通常将其创建为DOM对象的属性，然后由DOM Xray过滤掉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redefine Date.getFullYear()</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.getFullYear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// chrome code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// contentWindow is an Xray, and date is an expando on contentWindow</span></span><br><span class="line"><span class="comment">// so date is filtered out</span></span><br><span class="line">gBrowser.contentWindow.date.getFullYear()</span><br><span class="line"><span class="comment">// -&gt; TypeError: gBrowser.contentWindow.date is undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>Extensions are made of different, but cohesive, components. Components can include <a href="https://developer.chrome.com/background_pages.html" rel="external nofollow noopener noreferrer" target="_blank">background scripts</a>, <a href="https://developer.chrome.com/content_scripts.html" rel="external nofollow noopener noreferrer" target="_blank">content scripts</a>, an <a href="https://developer.chrome.com/options" rel="external nofollow noopener noreferrer" target="_blank">options page</a>, <a href="https://developer.chrome.com/user_interface.html" rel="external nofollow noopener noreferrer" target="_blank">UI elements</a> and various logic files. Extension components are created with web development technologies: HTML, CSS, and JavaScript. An extension’s components will depend on its functionality and may not require every option</p>
<h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p>An extension’s architecture will depend on its functionality, but many robust extensions will include multiple components:</p>
<ul>
<li><a href="https://developer.chrome.com/extensions/extensions/manifest" rel="external nofollow noopener noreferrer" target="_blank">Manifest</a></li>
<li><a href="https://developer.chrome.com/extensions/overview#background_script" rel="external nofollow noopener noreferrer" target="_blank">Background Script</a></li>
<li><a href="https://developer.chrome.com/extensions/overview#pages" rel="external nofollow noopener noreferrer" target="_blank">UI Elements</a></li>
<li><a href="https://developer.chrome.com/extensions/overview#contentScripts" rel="external nofollow noopener noreferrer" target="_blank">Content Script</a></li>
<li><a href="https://developer.chrome.com/extensions/overview#optionsPage" rel="external nofollow noopener noreferrer" target="_blank">Options Page</a></li>
</ul>
<h4 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h4><p><a href="https://developer.chrome.com/extensions/manifest" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/extensions/manifest</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Getting Started Example"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Build an Extension!"</span>,</span><br><span class="line">  <span class="attr">"permissions"</span>: [<span class="string">"activeTab"</span>, <span class="string">"declarativeContent"</span>, <span class="string">"storage"</span>],</span><br><span class="line">  <span class="attr">"options_page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">  <span class="attr">"background"</span>: &#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: [<span class="string">"background.js"</span>],</span><br><span class="line">    <span class="attr">"persistent"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"content_scripts"</span>: [],</span><br><span class="line">  <span class="attr">"page_action"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span>,</span><br><span class="line">    <span class="attr">"default_icon"</span>: &#123;</span><br><span class="line">      <span class="attr">"16"</span>: <span class="string">"images/get_started16.png"</span>,</span><br><span class="line">      <span class="attr">"32"</span>: <span class="string">"images/get_started32.png"</span>,</span><br><span class="line">      <span class="attr">"48"</span>: <span class="string">"images/get_started48.png"</span>,</span><br><span class="line">      <span class="attr">"128"</span>: <span class="string">"images/get_started128.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"icons"</span>: &#123;</span><br><span class="line">    <span class="attr">"16"</span>: <span class="string">"images/get_started16.png"</span>,</span><br><span class="line">    <span class="attr">"32"</span>: <span class="string">"images/get_started32.png"</span>,</span><br><span class="line">    <span class="attr">"48"</span>: <span class="string">"images/get_started48.png"</span>,</span><br><span class="line">    <span class="attr">"128"</span>: <span class="string">"images/get_started128.png"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Content-Script"><a href="#Content-Script" class="headerlink" title="Content Script"></a>Content Script</h4><p><strong>Content script</strong> 是你扩展的一部分，运行于一个特定的网页环境（而<strong>并不是后台脚本</strong>，后台脚本是扩展的一部分，也不是该网页利用<code>&lt;script&gt;</code>加载的一个脚本，<code>&lt;script&gt;</code> 加载的脚本是网页的一部分）。</p>
<p><strong>后台脚本可以访问所有WebExtension JavaScript APIS，但是他们不能直接访问网页的内容</strong>，所以如果你需要Content Scripts来做到这点。</p>
<p>就像通常的网页加载的脚本一样，<strong>Content Scripts 可以使用standard DOM APIS 读取和修改页面内容</strong>。</p>
<p>Content Script 只能访问WebExtension APIS 的一个小的子集，但是它们可以使用通信系统与后台脚本进行通信，从而间接的访问WebExtension APIS。</p>
<h5 id="DOM访问"><a href="#DOM访问" class="headerlink" title="DOM访问"></a>DOM访问</h5><p>Content scripts 可以访问和修改页面的DOM，就像普通的页面脚本一样。他们也可以察觉页面脚本对页面做出的任何修改。</p>
<p>不过，content scripts 得到的是一个“<strong>干净的DOM视图</strong>”，这意味着：</p>
<ul>
<li>content scripts 不能看见页面脚本定义的javascript 变量。</li>
<li>如果一个页面脚本重定义了一个DOM内置属性，content scripts将获取到这个属性的原始版本，而不是重定义版本。</li>
</ul>
<p>在 Gecko, 这种行为被称为<strong>射线视觉(Xray)</strong>。</p>
<p>举个例子，考虑一个网页如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"page-scripts/page-script.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>脚本文件“page-script.js”如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// page-script.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add a new element to the DOM</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">p.textContent = <span class="string">"This paragraph was added by a page script."</span>;</span><br><span class="line">p.setAttribute(<span class="string">"id"</span>, <span class="string">"page-script-para"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a new property on the window</span></span><br><span class="line"><span class="built_in">window</span>.foo = <span class="string">"This global variable was added by a page script"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redefine the built-in window.confirm() function</span></span><br><span class="line"><span class="built_in">window</span>.confirm = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"The page script has also redefined 'confirm'"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在一个扩展插入一个content script 如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// content-script.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// can access and modify the DOM</span></span><br><span class="line"><span class="keyword">var</span> pageScriptPara = <span class="built_in">document</span>.getElementById(<span class="string">"page-script-para"</span>);</span><br><span class="line">pageScriptPara.style.backgroundColor = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can't see page-script-added properties</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sees the original form of redefined properties</span></span><br><span class="line"><span class="built_in">window</span>.confirm(<span class="string">"Are you sure?"</span>); <span class="comment">// calls the original window.confirm()</span></span><br></pre></td></tr></table></figure>

<p>相反的情况也是成立的：<strong>页面脚本不能察觉到通过content scripts 添加的JavaScript 属性</strong>。</p>
<p>这意味着content script 可以<strong>依靠DOM属性获取可预期的行为</strong></p>
<p>这种行为造成的一个结果是content script<strong>不能获取任何通过页面加载的Javascript 库</strong>。所以，如果这个页面包含JQuery，content script 将不会在意它。</p>
<p>如果一个content script 想要使用Javascript库，这个库本身就必须像一个content script一样在这个content script旁被插入:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"content_scripts": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"matches"</span>: [<span class="string">"*://*.mozilla.org/*"</span>],</span><br><span class="line">    <span class="attr">"js"</span>: [<span class="string">"jquery.js"</span>, <span class="string">"content-script.js"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="WebExtensions-APIs"><a href="#WebExtensions-APIs" class="headerlink" title="WebExtensions APIs"></a>WebExtensions APIs</h5><p>除了standard DOM APIS，content script还能使用以下WebExtension APIS:</p>
<p>From <code>extension</code>:</p>
<ul>
<li><code>getURL()</code></li>
<li><code>inIncognitoContext</code></li>
</ul>
<p>From <code>runtime</code>:</p>
<ul>
<li><code>connect()</code></li>
<li><code>getManifest()</code></li>
<li><code>getURL()</code></li>
<li><code>onConnect</code></li>
<li><code>onMessage</code></li>
<li><code>sendMessage()</code></li>
</ul>
<p>From <code>i18n</code>:</p>
<ul>
<li><code>getMessage()</code></li>
<li><code>getAcceptLanguages()</code></li>
<li><code>getUILanguage()</code></li>
<li><code>detectLanguage()</code></li>
</ul>
<p>所有 <code>storage</code>.</p>
<p>参考链接：</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Xray_vision</a></p>
<p><a href="https://stackoverflow.com/questions/10824697/why-is-window-and-unsafewindow-not-the-same-from-a-userscript-as-from-a-scrip" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/10824697/why-is-window-and-unsafewindow-not-the-same-from-a-userscript-as-from-a-scrip</a></p>
<p><a href="https://developer.chrome.com/extensions/content_scripts#execution-environment" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/extensions/content_scripts#execution-environment</a></p>
<p><a href="https://developer.chrome.com/extensions" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/extensions</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Content_scripts" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Content_scripts</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>由一道困难leetcode引发的思考</title>
    <url>/2020/08/30/think_of_shortest_palindrome/</url>
    <content><![CDATA[<p>前几天leetcode的一道困难级别的每日一题再次让我感受到真正的聪明人擅长的是把困难的问题转换成简单的问题，而不是死磕难题。</p>
<p>这道题目的链接：<a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/shortest-palindrome/solution/</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aacecaaa&quot;</span><br><span class="line">输出: &quot;aaacecaaa&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcd&quot;</span><br><span class="line">输出: &quot;dcbabcd&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我不知道有没有小伙伴会和我一样，bfs，dfs，dp之类的用多了，就会往那个方向考虑，但是思考了半天好像也没有什么好的方法，于是去看了眼题解，恍然大悟。</p>
<h3 id="要学会把问题转化"><a href="#要学会把问题转化" class="headerlink" title="要学会把问题转化"></a>要学会把问题转化</h3><p>简单一句话来说，就是找到现有字符串s的最长回文前缀s‘，那么把剩下的s - s’倒序放到s的开头，就是最短的回文串了。</p>
<p>这是具体的官方证明逻辑：<a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/</a></p>
<p>这样一来，一个寻找最短回文串的问题就变成了简单的寻找最长回文前缀，看到这里的时候我是真的绝的有种茅塞顿开的感觉。</p>
<p>接下来就简单了，怎么找回文前缀。</p>
<h3 id="寻找最长回文前缀"><a href="#寻找最长回文前缀" class="headerlink" title="寻找最长回文前缀"></a>寻找最长回文前缀</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>最简单的暴力解法，可以依次判断从从 0 开始到 i 的子串是不是回文的，i 从 s.length - 1 到 0.</p>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>KMP算法是用来计算两个字符串之间重叠的部分的。</p>
<p>假设字符串s的倒叙是s‘，那么通过KMP算法得到的重叠部分就应该是s的最长回文前缀。</p>
<h2 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>对于KMP算法的解释，<a href="[http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)">阮一峰老师的这篇博客</a>讲的比较清晰</p>
<p>如果还有什么地方会有疑惑的话，可能就是为什么：移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
<p>那么我们就要搞懂：</p>
<h3 id="部分匹配值代表了什么"><a href="#部分匹配值代表了什么" class="headerlink" title="部分匹配值代表了什么"></a>部分匹配值代表了什么</h3><ul>
<li>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，</li>
</ul>
<blockquote>
<p>　　－　“A”的前缀和后缀都为空集，共有元素的长度为0；</p>
<p>　　－　“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p>
<p>　　－　“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</p>
<p>　　－　“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</p>
<p>　　－　“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</p>
<p>　　－　“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>　　－　“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
</blockquote>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<ul>
<li>假设已匹配字符位数是m，就代表模式串的前m位与匹配串的【i, i + m - 1】是相同的， i是本次匹配开始的位置。</li>
<li>而此时的部分匹配值是n，那就代表模式串的前n位与【i, i + m - 1】的后n位是相同的。</li>
</ul>
<p>所以移动m - n位可以跳过去匹配那些不可能相同的位。</p>
<p>参考链接：</p>
<p><a href="https://leetcode-cn.com/problems/shortest-palindrome/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/shortest-palindrome/</a></p>
<p><a href="https://www.cxyxiaowu.com/2665.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cxyxiaowu.com/2665.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>缓存系统的三个问题</title>
    <url>/2019/12/27/three_cache_issues/</url>
    <content><![CDATA[<p>随着互联网系统发展的逐步完善，提高系统的qps，目前的绝大部分系统都增加了缓存机制从而避免请求过多的直接与数据库操作从而造成系统瓶颈，极大的提升了用户体验和系统稳定性。</p>
<p>缓存在带来性能提升的同时，本身也是存在一些问题的。</p>
<a id="more"></a>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>缓存雪崩指缓存服务器重启或者大量缓存集中在某一个时间段内失效，给后端数据库造成瞬时的负载升高的压力，甚至压垮数据库的情况。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><p>只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps。</p>
<h4 id="交错失效时间"><a href="#交错失效时间" class="headerlink" title="交错失效时间"></a>交错失效时间</h4><p>这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。</p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>针对于整体服务，整体负荷超出整体负载承受能力时，延迟或暂停非重要服务，例如日志收集服务，保证重要服务正常运行。</p>
<h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><p>针对于单个服务，当某一服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施。直接关闭该服务（比较暴力）或者保证部分请求成功，另一部分直接返回失败（不占用服务资源），eg.如果5秒钟之内连续请求失败次数达到20次，那么触发熔断机制，过滤60%的请求。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>限流可以认为服务降级的一种，限流就是限制系统的访问量已达到保护系统的目的。</p>
<p>常见的限流算法有：计数器、漏桶和令牌桶算法。</p>
<p><strong>计数器：</strong></p>
<p>一个典型的应用场景就是规定在固定的时间内，只允许通过固定数量的请求，如规定在一分钟内只允许处理100个请求。</p>
<ul>
<li><p><strong>基本思想</strong>：有一个counter。当一个请求到来的时候，首先判断现在是否是处于新的时间段里。如果是在新的时间段了，就可以把counter清0，然后对当前这个请求进行计数加一操作。假如没有处于新的时间段，则判断当前的counter的数量是否超过规定的数量，如100。超过了就丢弃请求，否则对计数器加一，允许该请求通过。</p>
</li>
<li><p><strong>存在问题</strong>：精度不够，请求分布不平均。当在时间的临界区的时候，可能会出现问题。例如，规定一分钟处理100个请求，第一秒就有100个请求，也会造成系统压力，后面59秒系统空闲。</p>
</li>
</ul>
<p><strong>漏筒算法：</strong></p>
<ul>
<li>一个固定容量的漏桶，按照常量固定速率流出水滴；</li>
<li>如果桶是空的，则不需流出水滴；</li>
<li>可以以任意速率流入水滴到漏桶；</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li>
</ul>
<p><strong>令牌桶算法：</strong></p>
<p>一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。</p>
<ul>
<li>令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。</li>
<li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>
<li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。</li>
<li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>缓存穿透指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要穿透到后端数据库系统进行查询，使数据库压力过大，甚至使数据库服务被压死。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>我们通常将空值缓存起来，再次接收到同样的查询请求时，若命中缓存并且值为空，就会直接返回，不会透传到数据库，避免缓存穿透。当然，有时恶意袭击者可以猜到我们使用了这种方案，每次都会使用不同的参数来查询，这就需要我们对输入的参数进行过滤，例如，如果我们使用ID进行查询，则可以对ID的格式进行分析，如果不符合产生ID的规则，就直接拒绝，或者在ID上放入时间信息，根据时间信息判断ID是否合法，或者是否是我们曾经生成的ID，这样可以拦截一定的无效请求。</p>
<p>当然还有一种更常见的解决方案就是使用布隆过滤器</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
<p>假设我们现在获得了一个size=10000的布隆过滤器,分配给我们的其实是10000个二进制位,假设<code>k=8</code>,那么当新添加<code>huyanshi</code>这个元素时,通过8个不同的<code>hash函数</code>,可以拿到8个index值,假设为<code>1,2300,222,11...</code>,我们就将这8个index为下标的位置,置为1.</p>
<p>当我们想要检索<code>huyanshi</code>是否存在时,再次用8个hash函数获得8个index,如果这8个index的位置都为1,那么这个元素就很<strong>可能</strong>存在.如果其中有一位为0,则该元素一定不存在.</p>
<p>布隆过滤器的原理比较简单，但是主要难点是在如何设计一个长度合理的数组，以及如何设计多个哈希函数可以将数据比较好地映射到整个数组中。</p>
<h5 id="如何选择哈希函数个数以及布隆过滤器长度"><a href="#如何选择哈希函数个数以及布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数以及布隆过滤器长度"></a>如何选择哈希函数个数以及布隆过滤器长度</h5><p>很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p>如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：<br>$$<br>m = -(n * lnp) / (ln2)^2<br>$$</p>
<p>$$<br>k = (m /n) * ln2<br>$$</p>
<p>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>缓存击穿指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要击穿到后端数据库系统进行查询，使数据库压力过大，甚至使数据库服务被压死。<strong>这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key</strong>。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库。</p>
<p>以上这些解决方案都已经有了比较成熟的第三方包可以调用。</p>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5b604b9ef265da0f62639001" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5b604b9ef265da0f62639001</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/43263751" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/43263751</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>Token的安全存储与传输</title>
    <url>/2020/04/23/token-storage-and-transport/</url>
    <content><![CDATA[<h2 id="Token是什么"><a href="#Token是什么" class="headerlink" title="Token是什么"></a>Token是什么</h2><p>究竟什么才算是Token，我一直没有找到比较好的定义，但是回过头来看一下它的翻译，才明白，原来名字就是定义了，Token就是令牌。</p>
<p>那么什么是令牌呢？</p>
<a id="more"></a>

<p>先看一下我们现实生活中的令牌。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587640464/%E5%9B%BE%E7%89%871_pntvdk.jpg" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587640464/%E5%9B%BE%E7%89%871_pntvdk.jpg"></p>
<p>为什么它是个令牌呢？因为六扇门可以验证其真实性，同时六扇门可以从中获取持有该令牌的人的身份。</p>
<p>从这里我们就可以给Token下一个大致的定义：</p>
<ul>
<li><p>可以被某个服务认证其真实性。</p>
</li>
<li><p>该服务可以从中获取用户的信息。</p>
</li>
</ul>
<p>也就是说SessionID是Token，JWT也是Token。</p>
<h2 id="基于Token的认证流程"><a href="#基于Token的认证流程" class="headerlink" title="基于Token的认证流程"></a>基于Token的认证流程</h2><p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587640876/computer_network/%E5%9B%BE%E7%89%871_m5icmc.png" alt="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1587640876/computer_network/%E5%9B%BE%E7%89%871_m5icmc.png"></p>
<p>大致就分为几步：</p>
<ul>
<li>用户发送登陆请求到服务器，携带用户名和密码登陆。</li>
<li>服务器收到请求后验证其正确性，如果认证成功，就返回一个Token给前端</li>
<li>前端收到Token之后存储下来，接下来每个请求都带上Token</li>
<li>服务器从请求中拿出Token，验证其有效性以及对应的用户信息或者权限等，如果认为可以发起这个请求再进行处理。</li>
</ul>
<p>这几个步骤看起来很简单，但是可以有很多的升级版，比如</p>
<ul>
<li><p>第一步的登陆用OAuth协议去做，那就是我们常见的<strong>第三方登陆</strong>，如果对OAuth有疑惑的可以看一下<a href="https://sunra.top/2020/04/11/design-of-OAuth/">OAuth协议设计</a>。</p>
</li>
<li><p>第二步如果选择将信息存储在服务器Session，并返回一个SessionID，那么Token就是SessionID，如果服务器不进行任何存储，而是选择将部分用户信息加密签名丢回给前端，那就可以用JWT。</p>
</li>
<li><p>第三步中Token的存储有很多方案，比如Cookie，LocalStorage，SessionStorage等，甚至是USB Token，从安全，性能，成本等方面考虑这些方案的优缺点是什么。</p>
</li>
<li><p>还有虽然我们可以通过签名的方式保证Token的<strong>不可篡改</strong>，但是整个过程中如何保证我们的Token不被窃听？</p>
</li>
</ul>
<p>除此之外，我们还可以考虑一下为什么第二步有时候返回两个token，如果看了上面提到的OAuth协议设计应该对这个问题会有答案。</p>
<h2 id="Token的几个存储方案比较"><a href="#Token的几个存储方案比较" class="headerlink" title="Token的几个存储方案比较"></a>Token的几个存储方案比较</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie是大家最熟悉的前端存储方案。大家对它的一些特性很熟悉，比如同源限制，自动携带等等。那这里就主要说它的几个安全方面的配置：</p>
<ul>
<li>http-only：这个参数限定只能通过请求自动携带的方式获取cookie，没办法通过脚本去获取，这样一来就可以有效避免cookie被xss攻击，及时你的页面被不小心注入脚本，也无法获取你的cookie。</li>
<li>same-site：这个属性规定，只有请求是从同源页面发起才能获取cookie。这个主要是用来防御csrf的，因为如果只要是同源请求就可以自由携带cookie的话，很容易就遭受csrf攻击，比如在token失效之前打开了攻击者页面，该页面自动向后台发送请求，就会携带cookie。</li>
<li>secure：这个参数可以让cookie只会被https请求携带，https应该是是目前最好用的几种防止中间人攻击的方式之一，可以有效防止你的token被窃听。</li>
</ul>
<h3 id="其他前端存储方案"><a href="#其他前端存储方案" class="headerlink" title="其他前端存储方案"></a>其他前端存储方案</h3><p>SessionStorage：sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；</p>
<p>LocalStorage：在同源的所有标签页和窗口之间共享数据，保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</p>
<p>IndexDB：类似LocalStorage，只不过容量大很多</p>
<h3 id="硬件级别的Token保护：USB-Token"><a href="#硬件级别的Token保护：USB-Token" class="headerlink" title="硬件级别的Token保护：USB Token"></a>硬件级别的Token保护：USB Token</h3><p>将Token存储在独立的硬件上，重要请求需要用户自主填写Token。</p>
<p>USB Key中也可以存储数字证书，这个最常见的应该就是网银的U盾了。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>SessionStorage安全性较高，能比较好防御CSRF，但是对XSS无用，且局限较大。</p>
<p>LocalStorage和IndexDB受同源保护，但是一旦被注入脚本也很危险。</p>
<p>USB Key安全性较高，属于物理级别的防御，但是有一定的成本。</p>
<p>Cookie最方便，但是默认状态下最不安全，需要将http-only，same-site，secure等开启才能有较高的安全性。</p>
<h2 id="Token的安全传输与HTTPS"><a href="#Token的安全传输与HTTPS" class="headerlink" title="Token的安全传输与HTTPS"></a>Token的安全传输与HTTPS</h2><p>准确地讲HTTPS是协议栈。</p>
<p>最上层是HTTP，接着是SSL/TLS，接着是TCP。</p>
<p>HTTP的数据包在进入TCP发送缓存之前被SSL/TLS加密就叫做HTTPS。</p>
<p>所以想要搞明白HTTPS，就要搞明白HTTP。而HTTP协议本身并不复杂，它的复杂体现在各种header上，这些header都是 一些应用上的设计，所以这一层叫应用层。</p>
<p>想要搞懂HTTP，最好是搞懂TCP。</p>
<p>我整理了几篇关于TCP和HTTPS的博客，它们是我在学习是一些疑惑的解答。</p>
<p>在看的时候如果带着我的这些问题可能会更好：</p>
<ul>
<li><p>HTTP协议是什么？用于获取万维网服务器资源的协议，基于TCP，熟知端口是80 。</p>
</li>
<li><p>TCP协议是什么？传输层可靠传输协议，缓存上层协议不断发送的数据然后打包发送给不可靠的IP协议，通过一系列措施进行可靠传输，流量控制和拥塞控制，最重要的是面向连接的特性，这也是加密数据不会混淆的重要基础。</p>
</li>
<li><p>SSL/TLS如何加密数据？用对称秘钥。</p>
</li>
<li><p>对称秘钥如何生成？为什么不用非对称？对称秘钥就是每次TCP握手阶段用非对称秘钥生成的。</p>
</li>
<li><p>如何保证公钥的真实性？证书。</p>
</li>
<li><p>如何验证证书的有效性？根证书，证书链。</p>
</li>
</ul>
<p>这里是链接地址：</p>
<p><a href="https://sunra.top/2020/04/18/TCP/">TCP详解</a></p>
<p><a href="https://sunra.top/2020/04/19/https/">HTTPS详解</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/11/06/topological-sort/</url>
    <content><![CDATA[<p>今天看了一篇关于拓扑排序的思路和应用的文章，自己手动实现记录一下。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>算法是构建在具体的数据结构之上的。针对这个问题，我们先来看下，如何将问题背景抽象成具体的数据结构？</p>
<p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。</p>
<p>如果 a 先于 b 执行，也就是说 b 依赖于 a，那么就在顶点 a 和顶点 b 之间，构建一条从 a 指向 b 的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 a-&gt;b-&gt;c-&gt;a 这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。</p>
<a id="more"></a>

<p>首先我们定义下图的数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(s, t) &#123; <span class="comment">// s-&gt;t</span></span><br><span class="line">        <span class="keyword">this</span>.adj[s].push(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h2><p>Kahn 算法实际上用的是贪心算法思想，思路非常简单、好懂。</p>
<p>定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。所以，如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p>
<p>我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(s, t) &#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[s].push(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topoSortByKahn() &#123;</span><br><span class="line">        <span class="keyword">let</span> inDegree = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v).fill(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.adj.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.adj[i].length; j++) &#123;</span><br><span class="line">                inDegree[<span class="keyword">this</span>.adj[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> queue = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                queue.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> i = queue.unshift();</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.adj[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">let</span> k = <span class="keyword">this</span>.adj[i][j];</span><br><span class="line">                inDegree[k]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[k] === <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.push(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">topoSortByDFS() &#123;</span><br><span class="line">    <span class="keyword">let</span> inverseAdj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v).fill([]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.adj[i].length; j++) &#123;</span><br><span class="line">            inverseAdj[<span class="keyword">this</span>.adj[i][j]].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.v).fill(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">vertex</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> w = inverseAdj[vertex][i];</span><br><span class="line">            <span class="keyword">if</span> (visited[w]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[w] = <span class="literal">true</span>;</span><br><span class="line">            dfs(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法包含两个关键部分。</p>
<p>第一部分是通过邻接表构造逆邻接表。邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s。在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行。为什么这么转化呢？这个跟我们这个算法的实现思想有关。</p>
<p>第二部分是这个算法的核心，也就是递归处理每个顶点。<strong>对于顶点 vertex 来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己</strong>。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 丑数总结</title>
    <url>/2021/04/11/ugly-number/</url>
    <content><![CDATA[<p>最近leetcode的每日一题开始了丑数的系列，做了几道，来总结一下。</p>
<a id="more"></a>

<h2 id="丑数I-Easy"><a href="#丑数I-Easy" class="headerlink" title="丑数I - Easy"></a>丑数I - Easy</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/ugly-number/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/ugly-number/</a></p>
<p>这个题目没什么好说的，大家看下题目应该就知道怎么做了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isUgly = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> factor <span class="keyword">of</span> factors) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % factor === <span class="number">0</span>) &#123;</span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="丑数II-Medium"><a href="#丑数II-Medium" class="headerlink" title="丑数II - Medium"></a>丑数II - Medium</h2><p>题目链接</p>
<p><a href="https://leetcode-cn.com/problems/ugly-number-ii/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/ugly-number-ii/</a></p>
<p>这个题目就有点意思了。</p>
<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>要得到从小到大的第 n 个丑数，可以使用最小堆实现。</p>
<p>初始时堆为空。首先将最小的丑数 1 加入堆。</p>
<p>每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。</p>
<p>上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。</p>
<p>在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">const</span> heap = <span class="keyword">new</span> MinHeap();</span><br><span class="line">    seen.add(<span class="number">1</span>);</span><br><span class="line">    heap.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ugly = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ugly = heap.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> factor <span class="keyword">of</span> factors) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = ugly * factor;</span><br><span class="line">            <span class="keyword">if</span> (!seen.has(next)) &#123;</span><br><span class="line">                seen.add(next);</span><br><span class="line">                heap.insert(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最小堆的实现大家可以看我另一篇博客：<a href="https://sunra.top/2020/11/11/heap-and-dijkstra/">https://sunra.top/2020/11/11/heap-and-dijkstra/</a></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>方法一使用最小堆，会预先存储较多的丑数，导致空间复杂度较高，维护最小堆的过程也导致时间复杂度较高。可以使用动态规划的方法进行优化。</p>
<p>定义数组dp，其中dp[i] 表示第 i 个丑数，第 n 个丑数即为dp[n]。</p>
<p>由于最小的丑数是 1，因此dp[1]=1。</p>
<p>如何得到其余的丑数呢？定义三个指针 p2,p3,p5 ，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 1。</p>
<p>当2≤i≤n 时，令 dp[i]=min(dp[p2]×2,dp[p3]×3,dp[p5 ]×5)，然后分别比较dp[p2],dp[p3],dp[p5] 是否相等，如果相等则将对应的指针加 1。</p>
<blockquote>
<p>这段话可能有些抽象</p>
<p>换个说法就是，px的值是表示的是px前面位置的数乘以x的结果已经在dp列表中了。</p>
<p>举个例子，</p>
<p>p2 = 3,说明dp[1], dp[2] 分别乘以2的结果已经在dp中了</p>
<p>p3 = 2,说明dp[1] 分别乘以3的结果已经在dp中了</p>
<p>p5 = 1,说明dp[0] 分别乘以5的结果已经在dp中了</p>
<p>在这个情况下，我要去求dp[i]，我就要从dp[p2] * 2, dp[p3] * 3, dp[p5] * 5中去找一个。</p>
<p>为什么不去找dp[p2 - 1] * 2呢？因为整个值已经在dp中了，而且肯定小于等于dp[i - 1]</p>
<p>为什么不去找dp[p2 + 1] * 2呢？因为我们要找最小值，这个值肯定大于dp[p2] * 2;</p>
<p>为什么不去找dp[p3] * 2呢？因为p2和p3之间可能还有其他值乘以2的结果还没在dp中，也就是说可能存在一个p2 &lt; j &lt; p3，dp[j] * 2 还不在dp中，而且 dp[p2] * 2 &lt; dp[j] * 2 &lt; dp[p3] * 2。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.min(num2, num3), num5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] === num2) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] === num3) &#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] === num5) &#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>并查集算法</title>
    <url>/2020/06/08/union-find-algorithm/</url>
    <content><![CDATA[<p>首先上一道leetcode的题目：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/satisfiability-of-equality-equations/</a></p>
<p>这道题我们看到之后很容易的思路就是先把所有相等的关系找个数据结构保存下来，然后依次判断不等式的两方是否同时存在于刚才的结构中。</p>
<p>这个过程的第一步就是并集，把相关的数据放在一个集合中，第二步就是查找，在这个集合中查找相关性是否成立，这个查找的过程中可以进行一定的优化，也就是并集查找中的路径压缩。这里推荐这篇博客：<a href="https://blog.csdn.net/liujian20150808/article/details/50848646" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liujian20150808/article/details/50848646</a></p>
<a id="more"></a>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>用集合中的某个元素来代表这个集合，该元素称为集合的<code>代表元</code>。<br>一个集合内的所有元素组织成以代表元为根的树形结构。<br>对于每一个元素 parent[x]指向x在树形结构上的父亲节点。如果x是根节点，则令parent[x] = x。<br>对于查找操作，假设需要确定x所在的的集合，也就是确定集合的代表元。可以沿着parent[x]不断在树形结构中向上移动，直到到达根节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了加快查找速度，查找时将x到根节点路径上的所有点的parent设为根节点，该优化方法称为压缩路径。</span><br><span class="line"></span><br><span class="line">使用该优化后，平均复杂度可视为Ackerman函数的反函数，实际应用中可粗略认为其是一个常数。</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找的同时进行路径压缩</span></span><br><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span> (<span class="params">parent, index</span>) </span>&#123;</span><br><span class="line">    index = index.charCodeAt() - <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] != index) &#123;</span><br><span class="line">        parent[index] = parent[parent[index]];</span><br><span class="line">        index = parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新并集</span></span><br><span class="line"><span class="keyword">var</span> union = <span class="function"><span class="keyword">function</span> (<span class="params">parent, index1, index2</span>) </span>&#123;</span><br><span class="line">    parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> equationsPossible = <span class="function"><span class="keyword">function</span>(<span class="params">equations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parent = [];</span><br><span class="line">    <span class="comment">//初始化并集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据等式生成并集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equations[i].indexOf(<span class="string">'=='</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> variables = equations[i].split(<span class="string">'=='</span>);</span><br><span class="line">            union(parent, variables[<span class="number">0</span>], variables[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次根据不等式去并集中查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equations[i].indexOf(<span class="string">'!='</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> variables = equations[i].split(<span class="string">'!='</span>);</span><br><span class="line">            <span class="keyword">if</span> (find(parent, variables[<span class="number">0</span>]) == find(parent, variables[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从我目前的理解来看，并查集适用于<strong>将一组数据分成一块块相互连接的数据</strong>的情况，比如上面这种，根据等式关系将所有数据划分为一块块数据集，每一块数据集内部的数据都是相等的。</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://leetcode-cn.com/problems/redundant-connection/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/redundant-connection/</a></p>
<p>在一棵树中，边的数量比节点的数量少 11。如果一棵树有 NN 个节点，则这棵树有 N-1N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 NN。</p>
<p><strong>树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边</strong>。</p>
<p>可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p>
<ul>
<li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li>
</ul>
<ul>
<li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findRedundantConnection = <span class="function"><span class="keyword">function</span>(<span class="params">edges</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodesCount = edges.length;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="built_in">Array</span>(nodesCount + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> edge = edges[i];</span><br><span class="line">        <span class="keyword">const</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class="line">            union(parent, node1, node2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">parent, index1, index2</span>) =&gt;</span> &#123;</span><br><span class="line">    parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">parent, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[index] !== index) &#123;</span><br><span class="line">        parent[index] = parent[parent[index]];</span><br><span class="line">        index = parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/</a></p>
<p>根据可以移除石头的规则：如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。可以发现：一定可以把一个连通图里的所有顶点根据这个规则删到只剩下一个顶点。</p>
<p>为什么这么说呢？既然这些顶点在一个连通图里，可以通过遍历的方式（深度优先遍历或者广度优先遍历）遍历到这个连通图的所有顶点。那么就可以按照遍历的方式 逆向 移除石头，最后只剩下一块石头。所以：最多可以移除的石头的个数 = 所有石头的个数 - 连通分量的个数。</p>
<p>题目没有让我们给出具体移除石头的方案，可以考虑使用并查集。</p>
<p><strong>并查集里如何区分横纵坐标</strong><br>然而会遇到这样一个问题：石头的位置是「有序数对（二维）」，并查集的底层是「一维数组」，我们在并查集里应该如何区分横纵坐标呢？<br> ，可以把其中一个坐标 映射 到另一个与 [0, 10000] 不重合的区间，可以的做法是把横坐标全部减去 10001 或者全部加上 10001</p>
<p>在并查集里我们需要维护连通分量的个数，新创建顶点的时候连通分量加 11；合并不在同一个连通分量中的两个并查集的时候，连通分量减 11。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeStones = <span class="function"><span class="keyword">function</span>(<span class="params">stones</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> find = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!parent.has(x)) &#123;</span><br><span class="line">            parent.set(x, x);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent.get(x) != x) &#123;</span><br><span class="line">            parent.set(x, find(parent.get(x)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.get(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> union = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">const</span> rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX !== rootY) &#123;</span><br><span class="line">            parent.set(rootX, rootY);</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stones.forEach(<span class="function">(<span class="params">stone</span>) =&gt;</span> &#123;</span><br><span class="line">        union(stone[<span class="number">0</span>] + <span class="number">10001</span>, stone[<span class="number">1</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> stones.length - count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>v-charts</title>
    <url>/2020/03/13/v-charts/</url>
    <content><![CDATA[<p>Echarts是百度提供的一个用于在web端快速绘制图表的工具，它是通过js在canvas中进行图表的绘制，所以只要你的项目能够支持js，那就可以使用echarts。</p>
<p>Echarts有着丰富且详细的文档，可以让我们去定制自己喜欢的图表样式。但是这篇博客主要讲的是如何在vue项目中使用v-charts。</p>
<a id="more"></a>

<p>v-charts是对echarts的有一次封装，在保留了echart原有的所有设置的同时，可以让我们的代码风格更加接近vue，而不是像原生echarts一样完全是js代码。</p>
<p>但是在使用过程中我却遇到了一些问题，主要还是因为v-charts的文档有些模糊，这里记录一下遇到的问题。</p>
<p>首先给出二者的文档</p>
<p><a href="https://www.echartsjs.com/zh/option.html#title" rel="external nofollow noopener noreferrer" target="_blank">Echarts文档</a>， <a href="https://v-charts.js.org/#/props" rel="external nofollow noopener noreferrer" target="_blank">v-charts文档</a></p>
<h2 id="三点配置项使用总述"><a href="#三点配置项使用总述" class="headerlink" title="三点配置项使用总述"></a>三点配置项使用总述</h2><p>对于v-charts的文档，我最疑惑的地方就是它是如何将echart中那么多的配置项结合起来的。在v-chart的文档的图表属性一节中只是简单地说明了它封装过的几个属性，其他所有的属性都是一笔带过，说我们可以去看echarts的文档，但是如何设置它没有封装的属性却没有说清楚，这里总结一下。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a><a href="https://v-charts.js.org/#/props?id=公有属性" rel="external nofollow noopener noreferrer" target="_blank">属性</a></h3><p>所有图表都具有的属性，例如 <code>width</code>, <code>events</code> 等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ve-line :data=&quot;chartData&quot; width=&quot;100px&quot; :events=&quot;chartEvents&quot;&gt;&lt;/ve-line&gt;</span><br></pre></td></tr></table></figure>

<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a><a href="https://v-charts.js.org/#/props?id=基本属性" rel="external nofollow noopener noreferrer" target="_blank">基本属性</a></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>简介</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>数据，<a href="https://v-charts.js.org/#/data" rel="external nofollow noopener noreferrer" target="_blank">参考文档</a></td>
<td>object</td>
<td>-</td>
</tr>
<tr>
<td>settings</td>
<td>配置项</td>
<td>object</td>
<td>-</td>
</tr>
<tr>
<td>width</td>
<td>宽度</td>
<td>string</td>
<td>auto</td>
</tr>
<tr>
<td>height</td>
<td>高度</td>
<td>string</td>
<td>400px</td>
</tr>
<tr>
<td>events</td>
<td>事件绑定，<a href="https://v-charts.js.org/#/event" rel="external nofollow noopener noreferrer" target="_blank">参考文档</a></td>
<td>object</td>
<td>-</td>
</tr>
<tr>
<td>init-options</td>
<td>init 附加参数，<a href="http://echarts.baidu.com/api.html#echarts.init" rel="external nofollow noopener noreferrer" target="_blank">参考文档</a></td>
<td>object</td>
<td>-</td>
</tr>
<tr>
<td>tooltip-visible</td>
<td>是否显示提示框</td>
<td>boolean</td>
<td>true</td>
</tr>
<tr>
<td>legend-visible</td>
<td>是否显示图例</td>
<td>boolean</td>
<td>true</td>
</tr>
<tr>
<td>theme</td>
<td>自定义主题</td>
<td>object</td>
<td>-</td>
</tr>
<tr>
<td>theme-name</td>
<td>自定义主题名称</td>
<td>string</td>
<td>-</td>
</tr>
<tr>
<td>judge-width</td>
<td>是否处理生成图表时的宽度问题</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>width-change-delay</td>
<td>容器宽度变化的延迟</td>
<td>number</td>
<td>300</td>
</tr>
<tr>
<td>resizeable</td>
<td>是否处理窗口 resize 事件</td>
<td>boolean</td>
<td>true</td>
</tr>
<tr>
<td>cancel-resize-check</td>
<td>是否禁用 resize 时的容器检测</td>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>resize-delay</td>
<td>窗口 resize 事件回调的延迟</td>
<td>number</td>
<td>200</td>
</tr>
<tr>
<td>change-delay</td>
<td>属性修改触发图表重绘回调的延迟</td>
<td>number</td>
<td>0</td>
</tr>
<tr>
<td>set-option-opts</td>
<td>echarts setOption 的第二个参数, <a href="http://echarts.baidu.com/api.html#echartsInstance.setOption" rel="external nofollow noopener noreferrer" target="_blank">参考文档</a></td>
<td>boolean object</td>
<td>true</td>
</tr>
<tr>
<td>not-set-unchange</td>
<td>未发生变化时不参加 setOption 的属性</td>
<td>array</td>
<td>-</td>
</tr>
<tr>
<td>log</td>
<td>在控制台打印内部生成的echarts options</td>
<td>boolean</td>
<td>false</td>
</tr>
</tbody></table>
<p>上面这些内容来自v-charts的文档，意思是这些属性都可以直接在组件上通过vue特有的双向绑定的方法进行设置。</p>
<p>需要注意的一点事，<strong>setting中具体可以设置什么内容也是v-charts封装好的，需要去查v-charts文档中对应的每个类型的图表，才能知道这种类型的图表可以设置什么属性。</strong></p>
<h4 id="extend-属性"><a href="#extend-属性" class="headerlink" title="extend 属性"></a><a href="https://v-charts.js.org/#/props?id=extend-属性" rel="external nofollow noopener noreferrer" target="_blank">extend 属性</a></h4><p>为了能够更方便的设置属性配置项等，可以通过extend属性实现对已配置好的内部属性进行单独的设置， extend为对象类型，对象内的属性可以是函数，也可以对象，也可以是其他类型的值</p>
<ul>
<li>当属性为函数时，设置的是函数的返回值</li>
<li>当属性为对象时，如果在options中对应的属性为对象(eg: tooltip)或包含对象的数组(eg: series)， 对应的配置会被合并，否则将直接覆盖对应的配置</li>
</ul>
<p>具体使用方法可以参考属性配置<a href="https://v-charts.js.org/#/props-demo2" rel="external nofollow noopener noreferrer" target="_blank">示例</a></p>
<h4 id="echarts-options-属性"><a href="#echarts-options-属性" class="headerlink" title="echarts options 属性"></a><a href="https://v-charts.js.org/#/props?id=echarts-options-属性" rel="external nofollow noopener noreferrer" target="_blank">echarts options 属性</a></h4><p>与echarts配置项对应的属性也被加到了组件上，用于直接<strong>覆盖</strong>options原有的对应属性，使用方式可参考<a href="http://echarts.baidu.com/option.html" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">grid:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">colors:</span> <span class="string">array,</span></span><br><span class="line"><span class="attr">visualMap:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">dataZoom:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">toolbox:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">legend:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">xAxis:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">yAxis:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">radar:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">tooltip:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">axisPointer:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">brush:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">geo:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">timeline:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">graphic:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">series:</span> <span class="string">[object,</span> <span class="string">array],</span></span><br><span class="line"><span class="attr">backgroundColor:</span> <span class="string">[object,</span> <span class="string">string],</span></span><br><span class="line"><span class="attr">textStyle:</span> <span class="string">object,</span></span><br><span class="line"><span class="attr">animation:</span> <span class="string">object</span></span><br></pre></td></tr></table></figure>

<p>如果某属性加上去之后没有生效，很可能是没有引入相应的模块，模块的位置可以参考此<a href="https://github.com/ecomfe/echarts/blob/master/index.js" rel="external nofollow noopener noreferrer" target="_blank">文件</a></p>
<p>这两部分的文档会给我们产生一个误导，就是我们可以给chart组件绑定一个extend，以及一个options，但其实不是这样的，<strong>这两部分中提到的所有属性都是通过“：extend”进行绑定的</strong>，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ve-line :extend=&quot;extend&quot;&gt;&lt;/ve-line&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	data () &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			extend: &#123;</span><br><span class="line">				grid: [object, array]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>最后一点，也是隐藏的最深的一点，在echarts的文档中，有的属性既不是extend，也没有写在v-charts的setting文档中</strong>，这些就是echarts文档中series中规定的属性，比如折线图，echarts中有的属性是规定在<a href="https://www.echartsjs.com/zh/option.html#series" rel="external nofollow noopener noreferrer" target="_blank">这里</a>，这些属性也是可以通过设置在settings.series中生效的。</p>
<h2 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h2><p>这里只展示两个在v-charts文档中无法直接找到的设置的例子，可以设置折线图的分割线样式，填充面样式以及柱状图的颜色渐变样式，熟练之后，结合v-charts，echarts的文档可以很快地配置各种属性。</p>
<h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lineChartSetting: &#123;</span><br><span class="line">        area: <span class="literal">true</span>,  <span class="comment">// 填充折线下方</span></span><br><span class="line">        scale: [<span class="literal">true</span>],</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">          color: <span class="string">'#52B8DF'</span>   <span class="comment">//折线的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      extend: &#123;</span><br><span class="line">        series: &#123;</span><br><span class="line">          symbol: <span class="string">'none'</span>,  <span class="comment">// 不显示这线上的拐点</span></span><br><span class="line">          areaStyle: &#123;  <span class="comment">// 设置折线下方填充部分的样式为过渡色</span></span><br><span class="line">            color: &#123;</span><br><span class="line">              type: <span class="string">'linear'</span>,</span><br><span class="line">              x: <span class="number">0</span>,</span><br><span class="line">              y: <span class="number">0</span>,</span><br><span class="line">              x2: <span class="number">0</span>,</span><br><span class="line">              y2: <span class="number">1</span>,</span><br><span class="line">              colorStops: [</span><br><span class="line">                &#123;</span><br><span class="line">                  offset: <span class="number">0</span>,</span><br><span class="line">                  color: <span class="string">'rgba(82, 184, 223,0.4)'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  offset: <span class="number">1</span>,</span><br><span class="line">                  color: <span class="string">'rgba(82, 184, 223,0.1)'</span></span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              globalCoord: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        legend: &#123;</span><br><span class="line">          show: <span class="literal">false</span>  <span class="comment">//不显示图例</span></span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          show: <span class="literal">true</span>  <span class="comment">// 鼠标悬停时不显示详细信息</span></span><br><span class="line">        &#125;,</span><br><span class="line">        yAxis: &#123;  <span class="comment">// y轴样式</span></span><br><span class="line">          splitLine: &#123;  <span class="comment">//y轴分割线样式</span></span><br><span class="line">            show: <span class="literal">true</span>,  <span class="comment">// 显示分割线</span></span><br><span class="line">            lineStyle: &#123;</span><br><span class="line">              color: [<span class="string">'rgba(82, 184, 223, 0.2)'</span>]  <span class="comment">// 分割线颜色</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          axisLabel: &#123;</span><br><span class="line">            color: <span class="string">'#52B8DF'</span>  <span class="comment">// y轴刻度的字体颜色</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">          axisLabel: &#123;</span><br><span class="line">            color: <span class="string">'#52B8DF'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="histogram"><a href="#histogram" class="headerlink" title="histogram"></a>histogram</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.chartSettings = &#123;</span><br><span class="line">      metrics: [<span class="string">'访问用户'</span>, <span class="string">'下单用户'</span>],</span><br><span class="line">      dimension: [<span class="string">'日期'</span>],</span><br><span class="line">      itemStyle: &#123;  <span class="comment">// 柱状图柱体颜色渐变</span></span><br><span class="line">        normal: &#123;</span><br><span class="line">          color: <span class="keyword">new</span> echarts.graphic.LinearGradient(</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            [</span><br><span class="line">              &#123; <span class="attr">offset</span>: <span class="number">0</span>, <span class="attr">color</span>: <span class="string">'rgba(3, 252, 173,0.5)'</span> &#125;,</span><br><span class="line">              &#123; <span class="attr">offset</span>: <span class="number">1</span>, <span class="attr">color</span>: <span class="string">'rgba(3, 252, 173,0.1)'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.extend = &#123;</span><br><span class="line">      yAxis: &#123;</span><br><span class="line">        splitLine: &#123;</span><br><span class="line">          show: <span class="literal">true</span>,</span><br><span class="line">          lineStyle: &#123;</span><br><span class="line">            color: [<span class="string">'rgba(255, 255, 255, 0.2)'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        axisLabel: &#123;</span><br><span class="line">          color: <span class="string">'#52B8DF'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      xAxis: &#123;</span><br><span class="line">        axisLabel: &#123;</span><br><span class="line">          color: <span class="string">'#52B8DF'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Virtual Dom</title>
    <url>/2020/07/17/virtual-dom/</url>
    <content><![CDATA[<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><p>DOM就是文档对象模型，什么是文档对象模型？这就需要好好说说了。</p>
<p>HTML的文档<strong>document页面是一切的基础，没有它dom就无从谈起。</strong></p>
<p>当创建好一个页面并加载到浏览器时，DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。</p>
<p>在这个文档对象里，所有的元素呈现出一种层次结构，就是说<strong>除了顶级元素html外，其他所有元素都被包含在另外的元素中。</strong></p>
<a id="more"></a>

<p>假如有这么一段html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>我的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么它的树就应该是下面这样的一颗倒长的树。</p>
<p>一颗家谱树，而家谱树本身就是一种模型，其典型用法是表示表示人类家族谱系。</p>
<p>它很容易表明家族成员之间的关系，把复杂的关系简明地表示出来，因此这种模型非常适合表示一份html的文档：</p>
<p><img src="https://pic4.zhimg.com/50/v2-69d53b19c03ddc8bd3bc047f328de929_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic4.zhimg.com/80/v2-69d53b19c03ddc8bd3bc047f328de929_720w.jpg?source=1940ef5c" alt="img"></p>
<p>文档对象模型就是基于这样的文档视图结构的一种模型所有的html页面都逃不开这个模型，也可以把它称为节点树更为准确。</p>
<h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>再来复习一下，什么是虚拟DOM。</p>
<p><strong>虚拟DOM的定义是用一个javascript对象通过对象属性的方式去描述一个dom节点。</strong></p>
<p>举个例子：</p>
<p>我们现在有一个a标签，如果用普通的写法是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://xxx&quot;&gt;链接&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>将a标签通过js对象来描述的话，是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;  tag: "a",  attrs: &#123;    href: "http://xxx"  &#125;,  text: "链接",  children: []&#125;</span><br></pre></td></tr></table></figure>

<p>一个真实的dom节点就这样通过js对象描述出来了。</p>
<h2 id="为什么需要虚拟DOM？"><a href="#为什么需要虚拟DOM？" class="headerlink" title="为什么需要虚拟DOM？"></a>为什么需要虚拟DOM？</h2><p>我们可以看下a标签在浏览器下的输出，仅仅是一个空的a标签，就存在300+个属性。浏览器上面的真实DOM，除了一些基本的属性以外，还有很多为了支持标签本身特性而存在的很多属性和方法，这些属性和方法都是在浏览器底层去使用的，而对js来说真正有用的属性可能不到10个。</p>
<p>因此，前端很多时候对于dom操作都是极力避免的，如果确实需要，则希望将操作次数减到最少。由此产生了虚拟DOM，利用js去描述一个dom节点，只保留一些必要的、足够表达这个节点的属性。<strong>更新js对象比直接更新dom节点要节省很多的时间。</strong></p>
<p>我们可以用js来模拟dom节点的更新，每当dom更新之后，我们先比对虚拟dom，找出需要更新的地方，然后最后再统一更新真实dom。</p>
<h2 id="为什么DOM更新慢？"><a href="#为什么DOM更新慢？" class="headerlink" title="为什么DOM更新慢？"></a>为什么DOM更新慢？</h2><p>更新<code>DOM</code>并不慢，就像更新任何<code>JavaScript</code>对象一样。</p>
<p>那究竟是什么让更新真正的<code>DOM</code>变慢？</p>
<p>是绘制。</p>
<p>布局过程中，绘制占用了大部分时间。</p>
<p>结合下图，以及此<a href="https://juejin.im/post/5d1492bbe51d4556bc066fb5" rel="external nofollow noopener noreferrer" target="_blank">文章</a>，你会明白，更新 <code>DOM</code> 的真正问题是屏幕的绘制。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/30/16c41e724e5da108?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>负责在浏览器屏幕上显示或呈现网页的渲染引擎解析<code>HTML</code>页面以创建<code>DOM</code>。它还解析<code>CSS</code>并将<code>CSS</code>应用于<code>HTML</code>，从而创建渲染树，此过程称为<strong><code>attachment</code></strong>。</p>
<p>所以，当我们这样做时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'elementId'</span>).innerHTML=<span class="string">"New Value"</span></span><br></pre></td></tr></table></figure>

<p>发生以下事情：</p>
<ol>
<li>浏览器必须解析<code>HTML</code></li>
<li>它删除了<code>elementId</code> 的子元素</li>
<li>使用”New Value”更新<code>DOM</code></li>
<li>重新计算父和子的<code>CSS</code></li>
<li>更新布局，即每个元素在屏幕上的精确坐标</li>
<li>遍历渲染树并在浏览器显示上绘制它</li>
</ol>
<p>重新计算CSS和更改布局使用复杂的算法，它们会影响性能。</p>
<p>因此，更新真正的<code>DOM</code>并不仅仅涉及更新<code>DOM</code>，而是涉及许多其他过程。</p>
<p>此外，上述每个步骤都针对真实<code>DOM</code>的每次更新运行，即如果我们更新真实<code>DOM</code> 10次，则上述步骤中的每一个将重复10次。这就是为什么更新 <code>DOM</code> 很慢的原因。</p>
<h2 id="Vue中的Virtual-DOM"><a href="#Vue中的Virtual-DOM" class="headerlink" title="Vue中的Virtual DOM"></a>Vue中的Virtual DOM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们打开vue源码文件的VNode类，这个类就是Vue用来描述真实dom节点的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> child (): Component | void &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面有一些常用的属性：tag表示标签名，text表示节点的文本内容，elm表示虚拟节点对应的真实dom节点等等。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>vue通过VNode可以描述6种节点类型：</p>
<ul>
<li>注释节点</li>
<li>文本节点</li>
<li>克隆节点</li>
<li>元素节点</li>
<li>组件节点</li>
<li>函数式组件节点</li>
</ul>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>有兴趣的可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/V2PLADamTyE4krSNuG6leQ" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/V2PLADamTyE4krSNuG6leQ</a></p>
<p>参考文章：</p>
<p><a href="https://www.zhihu.com/question/34219998" rel="external nofollow noopener noreferrer" target="_blank">什么是DOM</a></p>
<p><a href="https://mp.weixin.qq.com/s/V2PLADamTyE4krSNuG6leQ" rel="external nofollow noopener noreferrer" target="_blank">从Vue角度理解虚拟DOM</a></p>
<p><a href="https://juejin.im/post/5d3ff99fe51d4561fb04beea" rel="external nofollow noopener noreferrer" target="_blank">重新认识虚拟DOM</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟局域网与子网</title>
    <url>/2021/01/23/vlan-and-subnet/</url>
    <content><![CDATA[<p>VLAN（Virtual LAN），翻译成中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p>
<p>而子网也是通过路由器进行划分的一个个网络。</p>
<p>那二者的区别是什么呢？最本质上的区别就是，根据网络分层模型，<strong>VLAN主要用于划分数据链路层的广播域，而子网划分是通过IP地址在划分网络层</strong>，如果是用CIDR进行的子网划分，那么如果两个IP地址通过子网掩码计算出来的结果是相同的，那就是同一个子网。</p>
<a id="more"></a>

<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><h3 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h3><p>在讲VLAN之前让我们先复习一下广播域的概念。广播域，指的是广播帧（目标MAC地址全部为1）所能传递到的范围，亦即能够直接通信的范围。严格地说，并不仅仅是广播帧，多播帧（Multicast Frame）和目标不明的单播帧（Unknown Unicast Frame）也能在同一个广播域中畅行无阻。</p>
<p>本来，二层交换机只能构建单一的广播域，不过使用VLAN功能后，它能够将网络分割成多个广播域。</p>
<h3 id="为什么需要分割广播域呢？"><a href="#为什么需要分割广播域呢？" class="headerlink" title="为什么需要分割广播域呢？"></a><strong>为什么需要分割广播域呢</strong>？</h3><p>那是因为，如果仅有一个广播域，有可能会影响到网络整体的传输性能。</p>
<p>读到这里，你也许会问：广播信息真是那么频繁出现的吗？</p>
<p>答案是：是的！实际上广播帧会非常频繁地出现。利用TCP/IP协议栈通信时，除了前面出现的ARP外，还有可能需要发出DHCP、RIP等很多其他类型的广播信息。</p>
<p>ARP广播，是在需要与其他主机通信时发出的。当客户机请求DHCP服务器分配IP地址时，就必须发出DHCP的广播。而使用RIP作为路由协议时，每隔30秒路由器都会对邻近的其他路由器广播一次路由信息。RIP以外的其他路由协议使用多播传输路由信息，这也会被交换机转发（Flooding）。除了TCP/IP以外，NetBEUI、IPX和Apple Talk等协议也经常需要用到广播。例如在Windows下双击打开“网络计算机”时就会发出广播（多播）信息。（Windows XP除外……）</p>
<p>总之，广播就在我们身边。下面是一些常见的广播通信：</p>
<p> ■ ARP请求：建立IP地址和MAC地址的映射关系。</p>
<p> ■ RIP：一种路由协议。</p>
<p> ■ DHCP：用于自动设定IP地址的协议。</p>
<p> ■ NetBEUI：Windows下使用的网络协议。</p>
<p> ■ IPX：Novell Netware使用的网络协议。</p>
<p> ■ Apple Talk：苹果公司的Macintosh计算机使用的网络协议。</p>
<p>如果整个网络只有一个广播域，那么一旦发出广播信息，就会传遍整个网络，并且对网络中的主机带来额外的负担。因此，在设计LAN时，需要注意如何才能有效地分割广播域。</p>
<h3 id="广播域的分割与VLAN的必要性"><a href="#广播域的分割与VLAN的必要性" class="headerlink" title="广播域的分割与VLAN的必要性"></a>广播域的分割与VLAN的必要性</h3><p>分割广播域时，一般都必须使用到路由器。使用路由器后，可以以路由器上的网络接口（LAN Interface）为单位分割广播域。</p>
<p>但是，通常情况下路由器上不会有太多的网络接口，其数目多在1～4个左右。随着宽带连接的普及，宽带路由器（或者叫IP共享器）变得较为常见，但是需要注意的是，它们上面虽然带着多个（一般为4个左右）连接LAN一侧的网络接口，但那实际上是路由器内置的交换机，并不能分割广播域。</p>
<p>况且使用路由器分割广播域的话，所能分割的个数完全取决于路由器的网络接口个数，使得用户无法自由地根据实际需要分割广播域。</p>
<p>与路由器相比，二层交换机一般带有多个网络接口。因此如果能使用它分割广播域，那么无疑运用上的灵活性会大大提高。</p>
<p>用于在二层交换机上分割广播域的技术，就是VLAN。通过利用VLAN，我们可以自由设计广播域的构成，提高网络设计的自由度。</p>
<h3 id="如何划分VLAN"><a href="#如何划分VLAN" class="headerlink" title="如何划分VLAN"></a>如何划分VLAN</h3><p>关于如何实现VLAN划分，可以看<a href="https://cloud.tencent.com/developer/article/1412795" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a></p>
<p>其实无论是哪种划分方法，就是找一种方式存储地址的映射和转发关系，这一点由于NAT的思想有点类似。</p>
<h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>关于子网的划分以及子网与内网的区别，可以看我的另一篇博客：<a href="https://sunra.top/2020/03/21/ip_address/">https://sunra.top/2020/03/21/ip_address/</a></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟世界的创世哲学——冯诺依曼体系</title>
    <url>/2021/04/07/von-neumann-system/</url>
    <content><![CDATA[<p>越是我们习以为常的事情中，可能往往蕴藏着伟大的哲学，越是简单的事情当中，可能往往蕴藏着巨大的智慧。</p>
<p>今天我们就来讲一讲支撑起整个计算机虚拟世界，支撑起整个互联网，支撑起我们耳熟能详的腾讯，阿里，微软，谷歌这些互联网巨头的基础——冯诺依曼体系。</p>
<p>我们一起看看它有多简单，但同时又是多么的伟大，一起感受其中的哲学。</p>
<a id="more"></a>

<h2 id="冯诺依曼体系是什么"><a href="#冯诺依曼体系是什么" class="headerlink" title="冯诺依曼体系是什么"></a>冯诺依曼体系是什么</h2><p>我们现在常说，有两个世界，一个是现实世界，一个是虚拟世界，现实世界是大自然的产物，是造物主的杰作，它自带无穷无尽的规律，比如同性相斥，异性相吸，万有引力，光速不变等等。但是这些规律不是我们制造的，只是我们发现的。</p>
<p>而虚拟世界不同，我们就是虚拟世界的造物主，虚拟世界的规则是我们制定的而不是发现的，而这个世界最基础的规则之一就是冯诺依曼体系。</p>
<p>当我们去审视整个信息科技时，仅把它形容为一座大厦显得如此不贴切，甚至你也不能用“一个城市”去形容它，事实上，它更像是一个无中生有的全新世界：<strong>是冯诺依曼体系从虚无中造出了虚拟世界</strong>。</p>
<p>用道家的话“道生一，一生二，二生三，三生万物”，这个冯诺依曼体系就是这个道，我们平时所接触的具体的信息时代的产物就是这个万物。</p>
<h3 id="为解决一切问题而生"><a href="#为解决一切问题而生" class="headerlink" title="为解决一切问题而生"></a>为解决一切问题而生</h3><p><strong>冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用“计算”来解决的问题。这是一个多么伟大的而又令人着迷的出发点</strong>。</p>
<p>“计算”的边界在哪里？今天我们还没有人能够真正说得清。计算能不能解决“智能”的问题？通过计算能力，计算机是否终有一天可以获得和人类一样的智能？</p>
<p>今天人工智能热潮的兴起，证明对于这个问题我们很乐观：计算终将解决智能的问题。尽管我们不能确定什么时候能够达到，但是让人欣慰的是，我们一直在进步 —— 如果人类智能无法完成进一步的进化，那么我们就一直一直在前进，最终无限逼近甚至超越人类智能。</p>
<h3 id="冯诺依曼体系的规格"><a href="#冯诺依曼体系的规格" class="headerlink" title="冯诺依曼体系的规格"></a>冯诺依曼体系的规格</h3><p>为了实现“解决一切可以用‘计算’来解决的问题”这个目标，冯·诺依曼引入了五类基础零部件：</p>
<ul>
<li><p>运算器</p>
</li>
<li><p>控制器</p>
</li>
<li><p>存储器</p>
</li>
<li><p>输入设备</p>
</li>
<li><p>输出设备</p>
</li>
</ul>
<p>中央处理器就是我们平时所说的CPU，它内部集成了运算器，控制器，等等，</p>
<p>冯诺依曼体系中的存储器指的是我们CPU可以直接读取的存储器，指的是内存，分为两部分，RAM和ROM，其中ROM是只读的，也就是出场后就不能改了，一般用于存储我们的BIOS，也就是我们按下开机键，CPU就会从这里读取系统启动程序，RAM则是我们平时所说的内存，比如电脑卡了你会说内存不够了，其实指的就是这个RAM。</p>
<p>而输入输出设备就是我们平时的鼠标键盘显示器等等，不过要注意一点，<strong>那就是我们的硬盘，U盘，其实对于冯诺依曼体系而言，并不是存储器，而是输入输出设备</strong>。</p>
<h2 id="冯诺依曼体系是如何解决一切问题的"><a href="#冯诺依曼体系是如何解决一切问题的" class="headerlink" title="冯诺依曼体系是如何解决一切问题的"></a>冯诺依曼体系是如何解决一切问题的</h2><p>这一部分内容涉及到了软件开发领域的另一个核心问题，需求分析。</p>
<p>但这个问题的解决思路并不仅仅适用于软件开发领域，它的思路更像是哲学，一种信息时代的哲学，也就是遇到一个问题，我要怎么分析出它的解决方案。</p>
<p>比如现在，我的需求就是，我需要一种机制，可以解决一切问题（现在是不是更加感受到冯诺依曼体系的伟大之处？从无到有，并且能解决一切，所以说它从虚无中创造了虚拟世界）。</p>
<p>让我们一起分析一下。</p>
<p>首先，需求可以大致分为两部分，一部分是变化的需求，另一部分是稳定的需求。</p>
<p>对于这个问题，需求的变化点在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，需求的稳定之处在于，电脑的核心能力是固定的，怎么表达电脑的核心能力？</p>
<p>我们取个巧，我们都知道电脑又叫计算机，它的核心能力是什么？就是计算。</p>
<p>什么是计算？就是针对一个输入进行变化，变为另一个输出，就像我们数学中的函数一样，实际上我们平时编码的东西也叫作函数。</p>
<p><strong>到这里，我们分析出来了，我们需要一个计算的地方，就称之为运算器</strong>。</p>
<p>接下来，第二个问题，我们函数的输入和输出可以是任何数据，文本，图片，视频，等等，对于计算机而言，它们都是二进制，只不过我们通过一系列手段赋予了二进制特殊的意义，比如110…..110这段二进制，让记事本读取就是一段文本，让爱奇艺读取就是一段视频。</p>
<p>我们可以把函数抽象为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y = F(x)</span><br></pre></td></tr></table></figure>

<p><strong>第二个问题来了，x，y在哪里</strong>，这个问题就引申出了<strong>存储器</strong>的设计。</p>
<p>然后就是F是如何表达的，F是否能表达一切，就是是否能解决一切的关键。</p>
<p>逻辑上来看，无论多复杂的自定义函数，都可以通过下面这些元素的组合来定义：</p>
<ul>
<li><p>内置函数，比如整数或小数运算（加减乘除、sin/cos 等）；</p>
</li>
<li><p>循环和条件分支；</p>
</li>
<li><p>子函数（也是自定义函数）。</p>
</li>
</ul>
<p>这样一来，对于任意的一个具体的计算（自定义函数）来说，都可以用一组指令序列来表达。</p>
<p>那么函数 F 物理上在哪里？以指令序列形式存放在存储里面。所以，存储不只存放计算所要操作的数据，也存放“计算”本身。</p>
<p>而这也是冯诺依曼体系的伟大创举，因为在此之前，函数是没法存储在之前的计算机体系中的。</p>
<p>只是，存储里面存放的“计算”只是数据，需要有人理解并执行这些数据背后的计算行为，才变成真正意义的“计算”。这个执行者，就是中央处理器（CPU）。</p>
<p>它支持很多计算指令，包括执行内置函数、循环和条件分支、执行子函数等，而这就需要用到了<strong>控制器</strong>，帮助我们去执行存储的指令。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1617794617/origin-of-ray/cf77b8fbe8a559cecbb264c390bc7337_l2phvp.png" alt></p>
<p>只是如果电脑只有“中央处理器 + 存储”，那它就如同一个人只有头脑而没有四肢五官，尽管很可能很聪明，但是这种聪明无法展现出来，因为它没法和现实世界发生交互。</p>
<p>交互，抽象来看就是输入和输出。对人来说，输入靠的是五官：眼睛看、耳朵听、鼻子闻、舌头尝，以及肌肤接触产生的触觉。输出靠语言（说话）和各种动作，如微笑、眨眼、皱眉、手势等等。</p>
<p>输入设备可以是鼠标键盘，也可以是触摸板，摄像头，等等，只要信息是向计算机流的，就算是输入设备。</p>
<p>输出设备可以是屏幕，音响，也可以是灯光，打印机等等。</p>
<p>也就是说，除了纯正的“计算”能力外，中央处理器还要有“数据交换”能力（或者叫 IO 能力）。最终，电脑可以被看做由 “中央处理器 + 存储 + 一系列的输入输出设备” 构成</p>
<p><strong>输入输出设备从根本上解决的问题是什么？是电脑无限可能的扩展能力</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们为了从虚无中创造一个世界，那就必须让这个世界有能力去解决一切问题。</p>
<p>要解决一切，就要将所有问题抽象为最基础的几个问题，这几个基础的问题就是稳定的地方，而变化的地方在于，如何用这几个简单的问题组合出丰富的世界，去描述丰富的世界</p>
<p>解决一切问题的方法就是将问题抽象为一个个函数<code>y=F(x)</code>。</p>
<p>这就类似于现实世界我们要解决一个问题，就要知道我们有什么，这就是x，我们要什么，这就是y，F就是我们如何利用已有的去获得想要的。</p>
<p>现实世界的x，y都有自己的物质载体，虚拟世界也要有，于是就有了<strong>存储器</strong>。</p>
<p>现实世界的F是我们的做事方法，这个方法可能是很多的小步骤去组合完成的，在虚拟世界，这些小步骤就是简单地加减，我们需要<strong>运算器</strong>去做这些事，而我们需要有顺序地去做这些事，于是需要<strong>控制器</strong>。</p>
<p>最终，为了让我们的表达能力更丰富，我们需要更加丰富多彩的<strong>输入输出设备</strong>，来描述我们的世界，描述我们不同的问题，是输入设备将现实世界的信息转化为二进制交给了存储器，CPU从存储器读取二进制计算，然后再返回给存储器，最终输出设备讲这些二进制再解释为现实世界的信息。</p>
<p>整个问题不仅仅是冯诺依曼体系，还包括如何进行需求分析。</p>
]]></content>
  </entry>
  <entry>
    <title>VPN 与 代理</title>
    <url>/2020/04/30/vpn-and-proxy/</url>
    <content><![CDATA[<p>谈起VPN我们很多人的第一反应都是翻墙，这其实也是VPN一个比较有名的原因。<strong>VPN其实会为你直接分配一个外网的IP，只是这个IP只在这条专线的另一头的代理服务器上有效</strong>，VPN的优点和用法并不在于翻墙，而是数据的加密，而且由于其流量特征明显，它用来翻墙的表现其实也不是很好。<strong>SS等代理则是帮你进行请求的转发，前提是你能找到一台在墙内能访问的服务器</strong>，并且该服务器愿意帮你转发流量。我们就从翻墙开始讲VPN到底是什么。它和代理有什么区别。</p>
<a id="more"></a>

<h2 id="什么是“墙”"><a href="#什么是“墙”" class="headerlink" title="什么是“墙”"></a>什么是“墙”</h2><p>我们平时说的墙其实指的是防火墙，它是运行在我们国内网络与国外网络之间的网关上的一套软硬件的合集，它会通过dns劫持或者通过IP地址过滤等方式让我们的请求无法正确通过防火墙。</p>
<p>防火墙是指设置在不同网络（如可信任的企业内部网和不可信的公共网）或网络安全域之间的一系列部件的组合。它是不同网络或网络安全域之间信息的唯一出入口，通过监测、限制、更改跨越防火墙的数据流，尽可能地对外部屏蔽网络内部的信息、结构和运行状况，有选择地接受外部访问，对内部强化设备监管、控制对服务器与外部网络的访问，在被保护网络和外部网络之间架起一道屏障，以防止发生不可预测的、潜在的破坏性侵入。</p>
<p><a href="http://www.nowamagic.net/academy/tag/防火墙" rel="external nofollow noopener noreferrer" target="_blank">防火墙</a>有两种，硬件防火墙和软件防火墙，他们都能起到保护作用并筛选出网络上的攻击者。</p>
<p>防火墙技术经历了包过滤、应用代理网关、再到状态检测三个阶段。</p>
<p>包过滤技术是一种简单、有效的安全控制技术，它通过在网络间相互连接的设备上加载允许、禁止来自某些特定的源地址、目的地址、TCP端口号等规则，对通过设备的数据包进行检查，限制数据包进出内部网络。包过滤的最大优点是对用户透明，传输性能高。但由于安全控制层次在网络层、传输层，安全控制的力度也只限于源地址、目的地址和端口号，因而只能进行较为初步的安全控制，对于恶意的拥塞攻击、内存覆盖攻击或病毒等高层次的攻击手段，则无能为力。</p>
<p>状态检测是比包过滤更为有效的安全控制方法。对新建的应用连接，状态检测检查预先设置的安全规则，允许符合规则的连接通过，并在内存中记录下该连接的相关信息，生成状态表。对该连接的后续数据包，只要符合状态表，就可以通过。这种方式的好处在于：由于不需要对每个数据包进行规则检查，而是一个连接的后续数据包（通常是大量的数据包）通过散列算法，直接进行状态检查，从而使得性能得到了较大提高；而且，由于状态表是动态的，因而可以有选择地、动态地开通1024号以上的端口，使得安全性得到进一步地提高。</p>
<h4 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h4><p>包过滤防火墙一般在路由器上实现，用以过滤用户定义的内容，如IP地址。包过滤防火墙的工作原理是：系统在网络层检查数据包，与应用层无关。这样系统就具有很好的传输性能，可扩展能力强。但是，包过滤防火墙的安全性有一定的缺陷，因为系统对应用层信息无感知，也就是说，防火墙不理解通信的内容，所以可能被黑客所攻破。</p>
<p>包过滤防火墙工作在网络层，对数据包的源及目地IP具有识别和控制作用，对于传输层，也只能识别数据包是TCP还是UDP及所用的端口信息。现在的路由器、Switch Router以及某些操作系统已经具有用Packet Filter控制的能力。 </p>
<p>由于只对<a href="http://www.nowamagic.net/academy/tag/数据包" rel="external nofollow noopener noreferrer" target="_blank">数据包</a>的IP地址、TCP/UDP协议和端口进行分析，包过滤防火墙的处理速度较快，并且易于配置。 </p>
<p>包过滤防火墙具有根本的缺陷： </p>
<ol>
<li>不能防范黑客攻击。包过滤防火墙的工作基于一个前提，就是网管知道哪些IP是可信网络，哪些是不可信网络的IP地址。但是随着远程办公等新应用的出现，网管不可能区分出可信网络与不可信网络的界限，对于黑客来说，只需将源IP包改成合法IP即可轻松通过包过滤防火墙，进入内网，而任何一个初级水平的黑客都能进行IP地址欺骗。 </li>
<li>不支持应用层协议。假如内网用户提出这样一个需求，只允许内网员工访问外网的网页（使用HTTP协议），不允许去外网下载电影（一般使用FTP协议）。包过滤防火墙无能为力，因为它不认识数据包中的应用层协议，访问控制粒度太粗糙。 </li>
<li>不能处理新的安全威胁。它不能跟踪TCP状态，所以对TCP层的控制有漏洞。如当它配置了仅允许从内到外的TCP访问时，一些以TCP应答包的形式从外部对内网进行的攻击仍可以穿透防火墙。 </li>
</ol>
<p>综上可见，包过滤防火墙技术面太过初级，就好比一位保安只能根据访客来自哪个省市来判断是否允许他（她）进入一样，难以履行保护内网安全的职责。 </p>
<h4 id="应用网关防火墙"><a href="#应用网关防火墙" class="headerlink" title="应用网关防火墙"></a>应用网关防火墙</h4><p>应用网关防火墙检查所有应用层的信息包，并将检查的内容信息放入决策过程，从而提高网络的安全性。然而，应用网关防火墙是通过打破客户机/服务器模式实现的。每个客户机/服务器通信需要两个连接：一个是从客户端到防火墙，另一个是从防火墙到服务器。另外，每个代理需要一个不同的应用进程，或一个后台运行的服务程序，对每个新的应用必须添加针对此应用的服务程序，否则不能使用该服务。所以，应用网关防火墙具有可伸缩性差的缺点。</p>
<p>应用代理网关防火墙彻底隔断内网与外网的直接通信，内网用户对外网的访问变成防火墙对外网的访问，然后再由防火墙转发给内网用户。所有通信都必须经应用层代理软件转发，访问者任何时候都不能与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。 </p>
<p>应用代理网关的优点是可以检查应用层、传输层和网络层的协议特征，对数据包的检测能力比较强。 </p>
<p>缺点也非常突出，主要有： </p>
<ul>
<li>难于配置。由于每个应用都要求单独的代理进程，这就要求网管能理解每项应用协议的弱点，并能合理的配置安全策略，由于配置繁琐，难于理解，容易出现配置失误，最终影响内网的安全防范能力。 </li>
<li>处理速度非常慢。断掉所有的连接，由防火墙重新建立连接，理论上可以使应用代理防火墙具有极高的安全性。但是实际应用中并不可行，因为对于内网的每个Web访问请求，应用代理都需要开一个单独的代理进程，它要保护内网的Web服务器、数据库服务器、文件服务器、邮件服务器，及业务程序等，就需要建立一个个的服务代理，以处理客户端的访问请求。这样，应用代理的处理延迟会很大，内网用户的正常Web访问不能及时得到响应。 </li>
</ul>
<p>总之，应用代理防火墙不能支持大规模的并发连接，在对速度敏感的行业使用这类防火墙时简直是灾难。另外，防火墙核心要求预先内置一些已知应用程序的代理，使得一些新出现的应用在代理防火墙内被无情地阻断，不能很好地支持新应用。 </p>
<p>在IT领域中，新应用、新技术、新协议层出不穷，代理防火墙很难适应这种局面。因此，在一些重要的领域和行业的核心业务应用中，代理防火墙正被逐渐疏远。 </p>
<p>但是，自适应代理技术的出现让应用代理防火墙技术出现了新的转机，它结合了代理防火墙的安全性和包过滤防火墙的高速度等优点，在不损失安全性的基础上将代理防火墙的性能提高了10倍。 </p>
<h4 id="状态检测防火墙"><a href="#状态检测防火墙" class="headerlink" title="状态检测防火墙"></a>状态检测防火墙</h4><p>状态检测防火墙基本保持了简单包过滤防火墙的优点，性能比较好，同时对应用是透明的，在此基础上，对于安全性有了大幅提升。这种防火墙摒弃了简单包过滤防火墙仅仅考察进出网络的数据包，不关心数据包状态的缺点，在防火墙的核心部分建立状态连接表，维护了连接，将进出网络的数据当成一个个的事件来处理。可以这样说，状态检测包过滤防火墙规范了网络层和传输层行为，而应用代理型防火墙则是规范了特定的应用协议上的行为。</p>
<p>我们知道，Internet上传输的数据都必须遵循TCP/IP协议，根据TCP协议，每个可靠连接的建立需要经过“客户端同步请求”、“服务器应答”、“客户端再应答”三个阶段，我们最常用到的Web浏览、文件下载、收发邮件等都要经过这三个阶段。这反映出数据包并不是独立的，而是前后之间有着密切的状态联系，基于这种状态变化，引出了状态检测技术。</p>
<p>状态检测防火墙摒弃了包过滤防火墙仅考查数据包的IP地址等几个参数，而不关心数据包连接状态变化的缺点，在防火墙的核心部分建立状态连接表，并将进出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。状态监测对每一个包的检查不仅根据规则表，更考虑了数据包是否符合会话所处的状态，因此提供了完整的对传输层的控制能力。</p>
<p>网关防火墙的一个挑战就是能处理的流量，状态检测技术在大为提高安全防范能力的同时也改进了流量处理速度。状态监测技术采用了一系列优化技术，使防火墙性能大幅度提升，能应用在各类网络环境中，尤其是在一些规则复杂的大型网络上。</p>
<p>任何一款高性能的防火墙，都会采用状态检测技术。</p>
<h4 id="复合型防火墙"><a href="#复合型防火墙" class="headerlink" title="复合型防火墙"></a>复合型防火墙</h4><p>复合型防火墙是指综合了状态检测与透明代理的新一代的防火墙，进一步基于ASIC架构，把防病毒、内容过滤整合到防火墙里，其中还包括VPN、IDS功能，多单元融为一体，是一种新突破。常规的防火墙并不能防止隐蔽在网络流量里的攻击，在网络界面对应用层扫描，把防病毒、内容过滤与防火墙结合起来，这体现了网络与信息安全的新思路。它在网络边界实施OSI第七层的内容扫描，实现了实时在网络边缘布署病毒防护、内容过滤等应用层服务措施。</p>
<h4 id="四类防火墙的对比"><a href="#四类防火墙的对比" class="headerlink" title="四类防火墙的对比"></a>四类防火墙的对比</h4><ul>
<li>包过滤防火墙：包过滤防火墙不检查数据区，包过滤防火墙不建立连接状态表，前后报文无关，应用层控制很弱。</li>
<li>应用网关防火墙：不检查IP、TCP报头，不建立连接状态表，网络层保护比较弱。</li>
<li>状态检测防火墙：不检查数据区，建立连接状态表，前后报文相关，应用层控制很弱。</li>
<li>复合型防火墙：可以检查整个数据包内容，根据需要建立连接状态表，网络层保护强，应用层控制细，会话控制较弱。</li>
</ul>
<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我个人感觉代理更像是一种概念，它可以帮你做一些额外的事情，这些事情有可能是你无法做到的，比如访问国外资源，有可能是你委托它做的，比如帮你缓存最近访问过的信息。</p>
<p>代理也可以工作在不同的网络层次，比如在应用层你可以将某个应用产生的HTTP请求导向某个指定的端口，也可以将整个系统产生的IP数据包导向某个服务器。</p>
<p><strong>所以从这个角度讲，防火墙也算是代理的一种。</strong></p>
<p>代理也分为<a href="https://sunra.top/2019/08/07/nginx_and_cors/">正向代理和反向代理</a>。也有很多的功能，只不过这些功能都不是其本质，其本质就是帮你做了一些事情，只要符合这个本质就叫做代理，至于怎么做，在那个层面做，做了什么可以细分出很多不同种类的代理。</p>
<h3 id="代理的几种常见的功能"><a href="#代理的几种常见的功能" class="headerlink" title="代理的几种常见的功能"></a>代理的几种常见的功能</h3><ul>
<li>突破IP限制。这是我们最常听的功能，所谓的IP限制就是对于某些指定IP的请求进行限制，最出名的就是我们的防火长城，但是我们也明白，<strong>我们不可能搞个超大的内网出来，和国外的任何网络都不连接，那么就一定有某台服务器是可以在墙内访问的。我们只需要找到这台服务器</strong>，假设为A，在上面搭建一个服务，然后将本地的一些对墙外服务访问的IP请求连带头部再本地加密之后作为请求体再生成一个新的IP数据报发送给这个服务，防火墙只能看到这个数据报的头部是发送给A的就放行，就算拿出内容来也无法分析其行为，因为内容也被加密过。这个请求到了A之后被我们的服务解密出来，发现它是访问另一个服务，就帮我们去请求，并将请求结果再次封装发送回来，我们本地的服务再进行解密。</li>
<li>访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源 的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类<a href="https://baike.baidu.com/item/FTP/13839" rel="external nofollow noopener noreferrer" target="_blank">FTP</a>下载上传，以及各类资料查询共享等服务。</li>
<li>突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国 外的代理服务器试试。</li>
<li>提高访问速度：通常代理服务器都设置一个较大的硬盘<a href="https://baike.baidu.com/item/缓冲区" rel="external nofollow noopener noreferrer" target="_blank">缓冲区</a>，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>
</ul>
<p>工作在不同层次的代理利用的协议也都不同，比如有专门针对HTTP的HTTP代理，也有更低层次的，比如SOCKS代理。</p>
<h2 id="什么是VPN"><a href="#什么是VPN" class="headerlink" title="什么是VPN"></a>什么是VPN</h2><p><strong>vpn在很多人心目中就是用来翻墙的工具，其实不是</strong>。vpn最主要的功能，并不是用来翻墙，只是它可以达到翻墙的目的。vpn–虚拟专用网络，<strong>它的功能是：在公用网络上建立专用网络，进行加密通讯</strong>。在企业网络和高校的网络中应用很广泛。你接入vpn，其实就是接入了一个专有网络，你的网络访问都从这个出口出去，你和vpn之间的通信是否加密，取决于你连接vpn的方式或者协议。</p>
<p>实际上<strong>一旦你成功连接上一个VPN，你就会被分配一个该虚拟专用网的IP地址</strong>，如果你发现自己能访问谷歌，但是IP地址还是本地的，那说明你只是通过代理进行了流量转发，但是如果你发现自己的IP地址都已经被改了，那说明你通过VPN加入了一个虚拟专线，并获得了一个该网络的内部IP，只不过这个IP只在这条专线上有效，所以你所有的流量都要先发送到这个内网，在经内网转发。</p>
<p>所以理论上如果你的公司内网无法访问某个网站，而你又让VPN全局代理你的流量，那么你也无法访问该网站。</p>
<p><strong>我们平时经常听的SS和SSR其实算不上VPN，ss和ssr它的原理都是一样的，就是socks5代理</strong>。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了翻墙。</p>
<h3 id="vpn和ss-ssr的区别和优缺点"><a href="#vpn和ss-ssr的区别和优缺点" class="headerlink" title="vpn和ss/ssr的区别和优缺点"></a>vpn和ss/ssr的区别和优缺点</h3><p>通过上面的介绍，其实基本已经能看出vpn和ss/ssr的区别了，那么他们到底孰优孰劣。</p>
<p>因为v<strong>pn是走的专用通道，它是用来给企业传输加密数据用的，所以vpn的流量特征很明显</strong>，以openvpn为例，更详细的在这里不说了，流量特征明显，防火墙直接分析你的流量，如果特征匹配，直接封掉。目前就翻墙来说，PPTP类型的vpn基本死的差不多了，L2TP大部分地区干扰严重很不稳定。</p>
<p><strong>ss/ssr的目的就是用来翻墙的，而vpn的目的是用来加密企业数据的，对于vpn来说安全是第一位的，而对于ss/ssr来说穿透防火墙是第一位，抗干扰性强，而且对流量做了混淆，所有流量在通过防火墙的时候，基本上都被识别为普通流量</strong>，也就是说你翻墙了，但是政府是检测不到你在翻墙的。两者的出发点和着重点就不同，ss/ssr更注重流量的混淆加密。如果要安全匿名上网，可以用vpn+tor或者ss/ssr+tor。</p>
<p>而安全性方面还要补充的一点就是，国内vpn服务商，政府是很容易拿到他们的服务器日志的，如果他们真的这样做了，你翻墙做了什么，一览无余。</p>
<h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h2><p>在计算机网络中，网关的定义是两个不同网络之间的路由器，也就是某个局域网的出口，比如我们每个人家里都会有一个路由器，这个路由器上连接着很多设备，这些设备都拥有者路由器分配的一个内网IP，我们所有的请求都需要首先经过这个路由器才能到达这个内网之外，那么这些设备的网关就是这个路由器。</p>
<p>网关一开始最基本的功能应该就是进行协议的转化，比如我们通过HTTP请求去请求一个FTP服务器上的资源，就要先将请求发送给FTP服务器的网关，网关将该请求解析为FTP协议，获取文件后再将文件封装进HTTP的返回体中返回给客户端。</p>
<p>API应该也算是一种网关，一开始我们的HTTP请求其实只是负责去获取WEB资源，但是我们可以通过自己实现的API去将这个请求转向不同的服务或者进行不同的处理。</p>
<p>网关应该也算是代理的一种，只不过网关是某个服务或者局域网的统一入口，你可以集成很多功能在网关上，比如流量控制，负载均衡，反向代理等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，代理其实就是帮你做一些事情，无论是帮你做了一层缓存，帮你做了流量转发，还是帮你加密数据，其实都算是代理，从这个角度将HTTPS其实也算是一个本地的代理，他会将你的HTTP数据先加密一次然后丢给IP层。如果防火墙只通过分析你的请求内容进行过滤，那么HTTPS代理可以帮你很好地翻墙。</p>
<p>VPN又叫做虚拟专用网，其实它是为了帮助你访问一个内网数据，一旦你连接VPN成功，你的IP地址就会被分配成该内网的IP，这个IP也只在这个内网有效，不过别担心，如果你选择了全局代理，你所有的流量都会本VPN的客户端封装好转发向该内网的代理服务器，到了代理服务器再解包看看其真实的请求进行转发，所以说VPN也使用了代理服务器，只不过它是一种正向代理。</p>
<p>我们平时用的SS和SSR其实只是一种代理，算不上VPN，它最基本的原理就是进行流量转发，因为我们不可能完全与外网一点联系都没有，只要找到了一台没有被墙的服务器，我们就可以把所有流量发送给这台服务器，让它代理我们进行请求的发送。</p>
<p>从翻墙的角度将，VPN和代理都可以进行翻墙，但是不同点在于VPN通过隧道技术在你和代理服务器之间建立了一条专用的通道，然后直接分配给你一个IP，你这个IP只有该代理服务器认识，你所有的流量都是发送给该代理服务器，代理服务器收到之后再利用分配给你的IP进行数据的访问，感觉就像你的电脑连接在公司内网一样。但是SS这种代理只是帮你进行代理的转发，你的IP地址没有改变，只是你需要先找到一台可以在国内访问的服务器，租下来，然后在上面启动服务帮助你转发流量。</p>
<p>网关应该算是一种加强版的代理，集成了很多功能，比如协议的转换，负载均衡等等。</p>
<p>以上就是作者对于网关，VPN，代理等之间的关系的理解。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>VPN简介与举例</title>
    <url>/2021/01/08/vpn/</url>
    <content><![CDATA[<p>最近看了篇关于VPN原理的文章，发现它的连接建立过程与HTTPS有点相似，并且都是对通信进行了数据加密。</p>
<p>在这里记录下VPN的连接建立过程，想要比较与HTTPS的区别的可以看我的另外一篇博客：<a href="https://sunra.top/2020/04/19/https/。">https://sunra.top/2020/04/19/https/。</a></p>
<a id="more"></a>

<h2 id="VPN是用来做什么的"><a href="#VPN是用来做什么的" class="headerlink" title="VPN是用来做什么的"></a>VPN是用来做什么的</h2><p>有的公司有多个数据中心，需要将多个数据中心连接起来，或者需要办公室和数据中心连接起来。这该怎么办呢？</p>
<ul>
<li><p>第一种方式是走公网，但是公网太不安全，你的隐私可能会被别人偷窥。</p>
</li>
<li><p>第二种方式是租用专线的方式把它们连起来，这是土豪的做法，需要花很多钱。</p>
</li>
<li><p>第三种方式是用 VPN 来连接，这种方法比较折中，安全又不贵。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/9f/68/9f797934cb5cf40543b716d97e214868.jpg" alt></p>
<p>VPN，全名 <strong>Virtual Private Network</strong>，<strong>虚拟专用网</strong>，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。</p>
<h2 id="VPN是如何工作的"><a href="#VPN是如何工作的" class="headerlink" title="VPN是如何工作的"></a>VPN是如何工作的</h2><p>VPN 通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议：乘客协议、隧道协议和承载协议。</p>
<p>我们以 IPsec 协议为例来说明。</p>
<p><img src="https://static001.geekbang.org/resource/image/a7/f1/a7c0a7fd2334d7145d093cf24bc6d7f1.jpg" alt></p>
<p>在最前面的时候说了，直接使用公网太不安全，所以接下来我们来看一种十分安全的 VPN，IPsec VPN。这是基于 IP 协议的安全隧道协议，为了保证在公网上面信息的安全，因而采取了一定的机制保证安全性。</p>
<ul>
<li><p>机制一：<strong>私密性</strong>，防止信息泄露给未经授权的个人，通过加密把数据从明文变成无法读懂的密文，从而确保数据的私密性。在讲 HTTPS 的时候，说过加密可以分为对称加密和非对称加密。对称加密速度快一些。而 VPN 一旦建立，需要传输大量数据，因而我们采取对称加密。但是同样，对称加密还是存在加密密钥如何传输的问题，这里需要用到因特网密钥交换（IKE，Internet Key Exchange）协议。</p>
</li>
<li><p>机制二：<strong>完整性</strong>，数据没有被非法篡改，通过对数据进行 hash 运算，产生类似于指纹的数据摘要，以保证数据的完整性。</p>
</li>
<li><p>机制三：<strong>真实性</strong>，数据确实是由特定的对端发出，通过身份认证可以保证数据的真实性。</p>
</li>
</ul>
<p>那如何保证对方就是真正的那个人呢？</p>
<p>第一种方法就是预共享密钥，也就是双方事先商量好一个暗号，比如“天王盖地虎，宝塔镇河妖”，对上了，就说明是对的。</p>
<p>另外一种方法就是用数字签名来验证。咋签名呢？当然是使用私钥进行签名，私钥只有我自己有，所以如果对方能用我的数字证书里面的公钥解开，就说明我是我。</p>
<p>基于以上三个特性，组成了 IPsec VPN 的协议簇。这个协议簇内容比较丰富</p>
<p><img src="https://static001.geekbang.org/resource/image/34/af/34a952bd1abeec19460b8d5dca5cd0af.jpg" alt></p>
<p>在这个协议簇里面，有两种协议，这两种协议的区别在于封装网络包的格式不一样。</p>
<ul>
<li><p>一种协议称为 <strong>AH</strong>（Authentication Header），只能进行数据摘要 ，不能实现数据加密。</p>
</li>
<li><p>还有一种 <strong>ESP</strong>（Encapsulating Security Payload），能够进行数据加密和数据摘要。</p>
</li>
</ul>
<p>在这个协议簇里面，还有两类算法，分别是<strong>加密算法和摘要算法</strong>。</p>
<p>这个协议簇还包含两大组件，一个用于 VPN 的双方要进行对称密钥的交换的 <strong>IKE 组件</strong>，另一个是 VPN 的双方要对连接进行维护的 <strong>SA（Security Association）组件</strong>。</p>
<h2 id="IPsec-VPN-的建立过程"><a href="#IPsec-VPN-的建立过程" class="headerlink" title="IPsec VPN 的建立过程"></a>IPsec VPN 的建立过程</h2><p>下面来看 IPsec VPN 的建立过程，这个过程分两个阶段。</p>
<p><strong>第一个阶段，建立 IKE 自己的 SA</strong>。这个 SA 用来维护一个通过身份认证和安全保护的通道，为第二个阶段提供服务。在这个阶段，通过 DH（Diffie-Hellman）算法计算出一个对称密钥 K。</p>
<p>DH 算法是一个比较巧妙的算法。客户端和服务端约定两个公开的质数 p 和 q，然后客户端随机产生一个数 a 作为自己的私钥，服务端随机产生一个 b 作为自己的私钥，客户端可以根据 p、q 和 a 计算出公钥 A，服务端根据 p、q 和 b 计算出公钥 B，然后双方交换公钥 A 和 B。</p>
<p>到此客户端和服务端可以根据已有的信息，各自独立算出相同的结果 K，就是对称密钥。但是这个过程，对称密钥从来没有在通道上传输过，只传输了生成密钥的材料，通过这些材料，截获的人是无法算出的。</p>
<p>有了这个对称密钥 K，接下来是<strong>第二个阶段，建立 IPsec SA</strong>。在这个 SA 里面，双方会生成一个随机的对称密钥 M，由 K 加密传给对方，然后使用 M 进行双方接下来通信的数据。对称密钥 M 是有过期时间的，会过一段时间，重新生成一次，从而防止被破解。</p>
<p>IPsec SA 里面有以下内容：</p>
<ul>
<li><p>SPI（Security Parameter Index），用于标识不同的连接；</p>
</li>
<li><p>双方商量好的加密算法、哈希算法和封装模式；</p>
</li>
<li><p>生存周期，超过这个周期，就需要重新生成一个 IPsec SA，重新生成对称密钥。</p>
</li>
</ul>
<p>当 IPsec 建立好，接下来就可以开始打包封装传输了。</p>
<p>在 IP 头里面，会指定上一层的协议为 TCP。ESP 要对 IP 包进行封装，因而 IP 头里面的上一层协议为 ESP。在 ESP 的正文里面，ESP 的头部有双方商讨好的 SPI，以及这次传输的序列号。接下来全部是加密的内容。可以通过对称密钥进行解密，解密后在正文的最后，指明了里面的协议是什么。如果是 IP，则需要先解析 IP 头，然后解析 TCP 头，这是从隧道出来后解封装的过程。有了 IPsec VPN 之后，客户端发送的明文的 IP 包，都会被加上 ESP 头和 IP 头，在公网上传输，由于加密，可以保证不被窃取，到了对端后，去掉 ESP 的头，进行解密。</p>
<h2 id="与HTTPS的相同点与不同点"><a href="#与HTTPS的相同点与不同点" class="headerlink" title="与HTTPS的相同点与不同点"></a>与HTTPS的相同点与不同点</h2><p>二者的相同点都分为两个过程：</p>
<p>HTTPS的公私钥是事先已经在CA申请好的，公钥会随着证书一起发送给对方，私钥留在自己这里，然后第二个阶段利用生成的三个随即字符生成对称秘钥，用对称秘钥来加密HTTP信息；</p>
<p>而IPSec VPN是第一阶段先自己生成一个临时私钥，然后双方交换临时公钥和各自生成的一个随即字符串，通过DH算法各自计算出一个对称秘钥K，只不过二者计算出来的这个对称密钥匙K相同的，第二个阶段在用K生成另一个有时效的对称秘钥M来加密信息。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（三）组件化原理</title>
    <url>/2020/09/08/vue-component/</url>
    <content><![CDATA[<p>Vue.js 另一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p>
<p>我们在用 Vue.js 开发实际项目的时候，就是像搭积木一样，编写一堆组件拼装生成页面。在 Vue.js 的官网中，也是花了大篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。</p>
<p>接下来我们会用 Vue-cli 初始化的代码为例，来分析一下 Vue 组件初始化的一个过程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 这里的 h 是 createElement 方法</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h1><p><a href="https://sunra.top/2020/08/31/vue-data-driven/">数据驱动那篇博客</a>我们在分析 <code>createElement</code> 的实现的时候，它最终会调用 <code>_createElement</code> 方法，其中有一段逻辑是对参数 <code>tag</code> 的判断，如果是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 <code>createComponent</code> 方法创建一个组件 VNode。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> Ctor</span><br><span class="line">  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">    <span class="comment">// platform built-in elements</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      config.parsePlatformTagName(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">    <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">    <span class="comment">// parent normalizes children</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = createComponent(tag, data, context, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们这一章传入的是一个 App 对象，它本质上是一个 <code>Component</code> 类型，那么它会走到上述代码的 else 逻辑，直接通过 <code>createComponent</code> 方法来创建 <code>vnode</code>。所以接下来我们来看一下 <code>createComponent</code> 方法的实现，它定义在 <code>src/core/vdom/create-component.js</code> 文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if at this stage it's not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Ctor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      warn(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">      <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">      <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">  <span class="comment">// component constructor creation</span></span><br><span class="line">  resolveConstructorOptions(Ctor)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data.model)) &#123;</span><br><span class="line">    transformModel(Ctor.options, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional component</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.on</span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    <span class="comment">// abstract components do not keep anything</span></span><br><span class="line">    <span class="comment">// other than props &amp; listeners &amp; slot</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// work around flow</span></span><br><span class="line">    <span class="keyword">const</span> slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">  installComponentHooks(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weex specific: invoke recycle-list optimized @render function for</span></span><br><span class="line">  <span class="comment">// extracting cell-slot template.</span></span><br><span class="line">  <span class="comment">// https://github.com/Hanks10100/weex-native-directive/tree/master/component</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderRecyclableComponentTemplate(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>createComponent</code> 的逻辑也会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里针对组件渲染这个 case 主要就 3 个关键步骤：</p>
<p>构造子类构造函数，安装组件钩子函数和实例化 <code>vnode</code>。</p>
<h2 id="构造子类构造函数"><a href="#构造子类构造函数" class="headerlink" title="构造子类构造函数"></a>构造子类构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">  Ctor = baseCtor.extend(Ctor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在编写一个组件的时候，通常都是创建一个普通对象，还是以我们的 App.vue 为例，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 export 的是一个对象，所以 <code>createComponent</code> 里的代码逻辑会执行到 <code>baseCtor.extend(Ctor)</code>，在这里 <code>baseCtor</code> 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 <code>src/core/global-api/index.js</code> 中的 <code>initGlobalAPI</code> 函数有这么一段逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></span><br><span class="line"><span class="comment">// components with in Weex's multi-instance scenarios.</span></span><br><span class="line">Vue.options._base = Vue</span><br></pre></td></tr></table></figure>

<p>细心的同学会发现，这里定义的是 <code>Vue.options</code>，而我们的 <code>createComponent</code> 取的是 <code>context.$options</code>，实际上在 <code>src/core/instance/init.js</code> 里 Vue 原型上的 <code>_init</code> 函数中有这么一段逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样就把 Vue 上的一些 <code>option</code> 扩展到了 vm.$options 上，所以我们也就能通过 <code>vm.$options._base</code> 拿到 Vue 这个构造函数了。<code>mergeOptions</code> 的实现我们会在后续章节中具体分析，现在只需要理解它的功能是把 Vue 构造函数的 <code>options</code> 和用户传入的 <code>options</code> 做一层合并，到 <code>vm.$options</code> 上。</p>
<p>在了解了 <code>baseCtor</code> 指向了 Vue 之后，我们来看一下 <code>Vue.extend</code> 函数的定义，在 <code>src/core/global-api/extend.js</code> 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class inheritance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> Super = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> SuperId = Super.cid</span><br><span class="line">  <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name = extendOptions.name || Super.options.name</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</span><br><span class="line">    validateComponentName(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init(options)</span><br><span class="line">  &#125;</span><br><span class="line">  Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">  Sub.prototype.constructor = Sub</span><br><span class="line">  Sub.cid = cid++</span><br><span class="line">  Sub.options = mergeOptions(</span><br><span class="line">    Super.options,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  Sub[<span class="string">'super'</span>] = Super</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">  <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">  <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line">  <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">    initProps(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">    initComputed(Sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">  Sub.extend = Super.extend</span><br><span class="line">  Sub.mixin = Super.mixin</span><br><span class="line">  Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">  <span class="comment">// can have their private assets too.</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    Sub[type] = Super[type]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    Sub.options.components[name] = Sub</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">  <span class="comment">// later at instantiation we can check if Super's options have</span></span><br><span class="line">  <span class="comment">// been updated.</span></span><br><span class="line">  Sub.superOptions = Super.options</span><br><span class="line">  Sub.extendOptions = extendOptions</span><br><span class="line">  Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cache constructor</span></span><br><span class="line">  cachedCtors[SuperId] = Sub</span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Vue.extend</code> 的作用就是构造一个 <code>Vue</code> 的子类，它使用一种非常经典的原型继承的方式把一个纯对象转换一个继承于 <code>Vue</code> 的构造器 <code>Sub</code> 并返回，然后对 <code>Sub</code> 这个对象本身扩展了一些属性，如扩展 <code>options</code>、添加全局 API 等；并且对配置中的 <code>props</code> 和 <code>computed</code> 做了初始化工作；最后对于这个 <code>Sub</code> 构造函数做了缓存，避免多次执行 <code>Vue.extend</code> 的时候对同一个子组件重复构造。</p>
<p>这样当我们去实例化 <code>Sub</code> 的时候，就会执行 <code>this._init</code> 逻辑再次走到了 <code>Vue</code> 实例的初始化逻辑，实例化子组件的逻辑在之后的章节会介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安装组件钩子函数"><a href="#安装组件钩子函数" class="headerlink" title="安装组件钩子函数"></a>安装组件钩子函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">installComponentHooks(data)</span><br></pre></td></tr></table></figure>

<p>我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 <a href="https://github.com/snabbdom/snabbdom" rel="external nofollow noopener noreferrer" target="_blank">snabbdom</a>，它的一个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  init (vnode: VNodeWithData, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      vnode.componentInstance &amp;&amp;</span><br><span class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">      vnode.data.keepAlive</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    updateChildComponent(</span><br><span class="line">      child,</span><br><span class="line">      options.propsData, <span class="comment">// updated props</span></span><br><span class="line">      options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">      vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">      options.children <span class="comment">// new children</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">'mounted'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">        <span class="comment">// vue-router#1212</span></span><br><span class="line">        <span class="comment">// During updates, a kept-alive component's child components may</span></span><br><span class="line">        <span class="comment">// change, so directly walking the tree here may call activated hooks</span></span><br><span class="line">        <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></span><br><span class="line">        <span class="comment">// be processed after the whole patch process ended.</span></span><br><span class="line">        queueActivatedComponent(componentInstance)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroy (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class="line">        componentInstance.$destroy()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hooksToMerge = <span class="built_in">Object</span>.keys(componentVNodeHooks)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span> (<span class="params">data: VNodeData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hooksToMerge[i]</span><br><span class="line">    <span class="keyword">const</span> existing = hooks[key]</span><br><span class="line">    <span class="keyword">const</span> toMerge = componentVNodeHooks[key]</span><br><span class="line">    <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params">f1: any, f2: any</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> merged = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// flow complains about extra args which is why we use any</span></span><br><span class="line">    f1(a, b)</span><br><span class="line">    f2(a, b)</span><br><span class="line">  &#125;</span><br><span class="line">  merged._merged = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 <code>patch</code> 过程中会详细介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 <code>data.hook</code> 中，那么通过执行 <code>mergeHook</code> 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。</p>
<h2 id="实例化-VNode"><a href="#实例化-VNode" class="headerlink" title="实例化 VNode"></a>实例化 VNode</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">  <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">  data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">  &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">  asyncFactory</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> vnode</span><br></pre></td></tr></table></figure>

<p>最后一步非常简单，通过 <code>new VNode</code> 实例化一个 <code>vnode</code> 并返回。需要注意的是和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>children</code> 的，这点很关键，在之后的 <code>patch</code> 过程中我们会再提。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节我们分析了 <code>createComponent</code> 的实现，了解到它在渲染一个组件的时候的 3 个关键逻辑：构造子类构造函数，安装组件钩子函数和实例化 <code>vnode</code>。<code>createComponent</code> 后返回的是组件 <code>vnode</code>，它也一样走到 <code>vm._update</code> 方法，进而执行了 <code>patch</code> 函数，我们在上一章对 <code>patch</code> 函数做了简单的分析，那么下一节我们会对它做进一步的分析。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（二） 数据驱动原理</title>
    <url>/2020/08/31/vue-data-driven/</url>
    <content><![CDATA[<p>本文主要讲的是Vue数据驱动的源码分析，即我们定义在data中的变量是如何渲染到页面上的。</p>
<p>我们以带compiler版本的vue源码进行分析，来解释页面渲染过程中是如何将数据渲染到页面上的。</p>
<a id="more"></a>

<h2 id="Mount函数"><a href="#Mount函数" class="headerlink" title="Mount函数"></a>Mount函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">  <span class="regexp">//</span>获取简单版本的mount函数后，覆盖它</span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)  <span class="comment">//查找挂载点el</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;  <span class="comment">//el不可以是body或者document，因为接下来的逻辑中会直接把挂载点的标签给替换掉</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;  <span class="comment">//判断是否声明了render函数</span></span><br><span class="line">    <span class="keyword">let</span> template = options.template   <span class="comment">//如果没有则找到template</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;  <span class="comment">//如果有template，则处理一下</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;  <span class="comment">//如果没有，就把template赋值为el所在的标签</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;  <span class="comment">//判断是否有template，如果有则根据template生成render函数，这也是runtime版本特有的</span></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)  <span class="comment">// 最终再call一次简单版本的mount函数,定义在platform/web/runtime/index中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先是判断是否由render函数，如果没有判断是否有template，再根据template生成render函数，总之，vue的mount阶段只认render函数。</p>
<p>我们再来看一下最后调用的mount函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// platform/web/runtime/index.js</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">  <span class="regexp">//</span>挂载函数，new Vue的初始化动作完成之后就会调用</span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步很简单，找到挂载点el，然后执行mountComponent函数。</p>
<h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params">  <span class="regexp">//</span>在vm.$mount函数中调用</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode  <span class="comment">//判断是否有render函数</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;  <span class="comment">//开发环境且启用了一些性能埋点的设置</span></span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//定义updateComponent函数,調用上面声明的_update,第一个参数是_render返回的组件,_render定义在core/instance/render.js中</span></span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></span><br><span class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;  <span class="comment">//创建一个watcher，并传入刚才定义好的updateComponent，这个watcher是一个渲染watcher</span></span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一步中会创建渲染Watcher，那我们再看一下Watcher是什么？</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  teardown () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在构造函数中会调用get方法，而该方法会首先pushTarget，也就是上篇博客<a href="https://sunra.top/2020/08/25/vue-reactive/">响应式原理</a>中讲的那样，将this赋值给一个全局的变量Dep.target，然后调用传入的updateComponent函数，该函数会调用render函数，渲染过程中用到的data[keyUsed]都会触发其getter，从而把Dep.target加入到data[keyUesd]的subs中。</p>
<h2 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h2><p>我们在回过头来看一下updateComponent函数中调用的_render函数</p>
<p>它是被initRender函数挂载到了Vue的原型上的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">        _parentVnode.data.scopedSlots,</span><br><span class="line">        vm.$slots</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)  <span class="comment">//调用render函数，上下文指向_renderProxy，该值定义在init。js，在production下就是this，在其他环境下如果浏览器支持Proxy则是Proxy, $createElement则是定义在core\vdom\create-element.js</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">      vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;  <span class="comment">// 一个模板不可以同时拥有两个根节点</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">          <span class="string">'should return a single root node.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="renderProxy的值从何而来"><a href="#renderProxy的值从何而来" class="headerlink" title="_renderProxy的值从何而来"></a>_renderProxy的值从何而来</h3><p>这段代码是_init函数中定义的，也就是说prod环境下这个proxy就是自己</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      initProxy(vm) <span class="comment">//初始化_renderProxy</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那为什么非prod下需要设置一层代理，这层代理又是做什么的呢？</p>
<p>这个问题就不展示源码了，简单来说这层代理的作用就是一些错误的提示，所以在prod下就不需要这层代理了。</p>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="$createElement"></a>$createElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wrapper function for providing a more flexible interface</span></span><br><span class="line"><span class="comment">// without getting yelled at by flow</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;  <span class="comment">// 这里就是判断一下第三个参数是不是数组，或者Primitive，如果是，说明第三个参数传入的其实是children，则把后面的参数依次向前</span></span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | Function | Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;  <span class="comment">// vnode不能是响应式的</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">'@binding'</span> <span class="keyword">in</span> data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Avoid using non-primitive value as key, '</span> +</span><br><span class="line">        <span class="string">'use string/number value instead.'</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">'function'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  normalizeChildren与simpleNormalizeChildren的区别就是，前者会递归去normalize，而后者只会遍历第一层，</span></span><br><span class="line"><span class="comment">  这里的normalizationType是由render函数的源头决定的，如果render函数是用户自定义的，就是ALWAYS_NORMALIZE</span></span><br><span class="line"><span class="comment">  如果是通过template之类编译出来的就是SIMPLE_NORMALIZE</span></span><br><span class="line"><span class="comment">  经过这一步之后所有的children就会存储在一个一维数组里面</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;  </span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="comment">//判断当前节点的标签是否是原生html保留标签</span></span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h2><p>上面通过_render函数可以获得一个vnode，拿到这个vnode之后我们可以继续执行传入watcher中的updateComponent函数，也就是</p>
<p><code>vm._update(vm._render(), hydrating)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle.js</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123; <span class="comment">// 判断是否是初次渲染</span></span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      <span class="comment">// 初次渲染第一个参数是一个真实的dom节点</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)  <span class="comment">//_patch方法定义在platform/web/runtime/index.js中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      <span class="comment">// 如果是update，那第一个参数就是vnode了</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="_patch"></a>_patch</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platforms/web/runtime/index.js</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop  <span class="comment">//patch方法，在core/instance/index中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//platforms/web/runtime/patch.js</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.concat(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里利用了函数柯里化的技巧，有效避免了各种if-else </span></span><br><span class="line"><span class="comment">第一个参数是，原生dom的各种操作，第二个中定义了更新过程中的各种钩子函数</span></span><br><span class="line"><span class="comment">这些钩子函数是由baseModules结合平台相关的platformModules组合而成的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>

<p>这个createPatchFunction非常复杂，定义了大量的辅助函数，最终返回的是patch函数，这里只展示分析patch函数，其他辅助函数简单提一下它的用途。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// mounting to a real element</span></span><br><span class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">          <span class="comment">// a successful hydration.</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                <span class="string">'full client-side render.'</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">          <span class="comment">// create an empty node and replace it</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replacing existing element</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create new node</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// destroy old node</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（五） diff算法解析</title>
    <url>/2020/09/29/vue-diff/</url>
    <content><![CDATA[<p>上篇关于<a href="https://sunra.top/2020/09/25/vue-watcher/">Vue Watcher原理分析的文章中</a>，在解释了Vue watcher的源码之后，将watcher分为了三类，分别是userWatcher，computeWatcher，以及renderWatcher。</p>
<p>这三者的主要不同之一就是求Watcher.value时的不同，userWatcher的value就是我们的观察对象，computeWatcher的value求值是通过我们在computed属性中定义的handler，而renderWatcher的value就是更新视图的结果。</p>
<p>上篇博客中主要讲的是前两者，对于renderWatcher的具体的更新视图的流程没有详细解释，也就是update，这其中最主要的逻辑就是vue的diff算法。</p>
<p>这篇博客就来讲一下vue的diff算法，并通过这个算法来讲一下啊我们平时写vue时的一点相关的注意事项。</p>
<a id="more"></a>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们直接看renderWatcher中的求值函数是什么，对于这一段是怎么来的，可以看我的上篇关于<a href="https://sunra.top/2020/08/31/vue-data-driven/">vue数据驱动原理</a>的博客</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;  <span class="comment">//创建一个watcher，并传入刚才定义好的updateComponent，这个watcher是一个渲染watcher</span></span><br><span class="line">    before () &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">            callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码就是组件在初始化过程中创建的渲染Wacher，其中第二个参数就是求值函数，也就是视图更新的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//定义updateComponent函数,調用上面声明的_update,第一个参数是_render返回的组件,_render定义在core/instance/render.js中</span></span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说视图更新函数就是重新调用render函数生成vnode，并把新的vnode更新到视图上。</p>
<p>我们现在主要的关注点就是这个update，也就是我们的diff算法</p>
<h3 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode <span class="comment">// _vnode存储的就是vnode update之前的节点，第一次进入本方法，_vnode是空</span></span><br><span class="line">    <span class="comment">// 这一步是将vm赋值给activeInstance，等会调用patch的时候作为当前vnode的父节点</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123; <span class="comment">// 判断是否是初次渲染</span></span><br><span class="line">        <span class="comment">// initial render</span></span><br><span class="line">        <span class="comment">// 初次渲染第一个参数是一个真实的dom节点</span></span><br><span class="line">        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)  <span class="comment">//_patch方法定义在platform/web/runtime/index.js中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updates</span></span><br><span class="line">        <span class="comment">// 如果是update，那第一个参数就是vnode了</span></span><br><span class="line">        vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">        prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">        vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">        vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要就是一个回溯算法，首先将之前全局的activeInstance保存到函数闭包中，并将activeInstance置为当前的节点，这个时候去调用patch如果更新子节点就可以用全局的activeInstance作为父节点，更新完成之后再将闭包中的之前的instance回复回来。</p>
<h3 id="patch"><a href="#patch" class="headerlink" title="__patch__"></a><code>__patch__</code></h3><p>现在就是我们最主要的逻辑了，patch，也就是我们的diff算法是如何更新节点的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果定义了oldVnode但是没有定义vnode，说明是要移除旧的节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">        <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">        isInitialPatch = <span class="literal">true</span></span><br><span class="line">        createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是原生的dom节点</span></span><br><span class="line">        <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// patch existing root node</span></span><br><span class="line">            patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">                <span class="comment">// mounting to a real element</span></span><br><span class="line">                <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">                <span class="comment">// a successful hydration.</span></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">                    oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">                    hydrating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">                        warn(</span><br><span class="line">                            <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                            <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                            <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                            <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                            <span class="string">'full client-side render.'</span></span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">                <span class="comment">// create an empty node and replace it</span></span><br><span class="line">                oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// replacing existing element</span></span><br><span class="line">            <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">            <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create new node</span></span><br><span class="line">            createElm(</span><br><span class="line">                vnode,</span><br><span class="line">                insertedVnodeQueue,</span><br><span class="line">                <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">                <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">                <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">                oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">                nodeOps.nextSibling(oldElm)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">                <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">                <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">                <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">                        cbs.destroy[i](ancestor)</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor.elm = vnode.elm</span><br><span class="line">                    <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                            cbs.create[i](emptyNode, ancestor)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// #6513</span></span><br><span class="line">                        <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">                        <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">                        <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">                        <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                            <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                                insert.fns[i]()</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        registerRef(ancestor)</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor = ancestor.parent</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// destroy old node</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">                removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">                invokeDestroyHook(oldVnode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看似很长，其实总结起来就是以下几步：</p>
<ul>
<li>如果定义了oldVnode但是没有定义vnode，说明是要移除旧的节点。</li>
<li>如果定义了vnode但是没有定义oldVnode，直接创建新节点就好。</li>
<li>如果不是原生标签并且是相同的节点，就执行patchVnode算法，去进行进一步的patch，这里为什么明明是相同的却还要patch呢？主要是因为这个相同节点的判断是一个初步的判断，类似于布隆过滤器，我说相同不一定相同，但是我说不同就是一定不同，而且就算二者真的相同，子节点也可能不同，这个待会在讲，这个也是diff最核心的部分。</li>
<li>如果不是相同节点，那就做三件事：创建新节点，更新旧节点的父节点，销毁旧节点。</li>
</ul>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>我们再来详细讲一下上面的第三点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            checkDuplicateKeys(ch)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是patchVnode的核心代码，也是分为以下几步：</p>
<ul>
<li>如果没定义text属性，说明不是文本节点。<ul>
<li>这个时候如果新旧节点都有children，那就执行updateChildren</li>
<li>如果只有新节点有，就把新节点的children直接挂载</li>
<li>如果只有旧节点有，那就把所有旧节点的children删除</li>
<li>如果旧节点是文本节点，那就把旧节点的文本置为空字符串</li>
</ul>
</li>
<li>如果定义了，说明新节点是文本节点，直接把旧节点的text属性置为新节点的text</li>
</ul>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>现在我们进入和diff算法最核心的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span> <span class="comment">// 旧子节点队列的头指针</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span> <span class="comment">//新子节点队列的头指针</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">// 旧子节点队列的尾指针</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">//旧子节点的头指针指向节点</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]  <span class="comment">//旧子节点的尾指针指向的节点</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">//新子节点队列的尾指针</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]  <span class="comment">//新子节点队列的头指针指向的节点</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]  <span class="comment">//新子节点队列的尾指针指向的节点</span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        <span class="comment">// 如果新旧的头指针指向的节点相同，则递归patch二者的子节点队列，并把二者头指针向后移动</span></span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        <span class="comment">// 如果新旧的尾指针指向的节点相同，则递归patch二者的子节点队列，并把二者尾指针向前移动</span></span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// 如果旧节点头指针指向的节点与新节点尾指针指向的节点相同，则递归patch二者的子节点队列，把旧节点头指针指向的节点移动到旧节点尾指针指向的节点之前</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// 如果旧节点尾指针指向的节点与新节点头指针指向的节点相同，则递归patch二者的子节点队列，把旧节点尾指针指向的节点移动到旧节点头指针指向的节点之前</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果新旧子节点的头尾四次比较都没有一次成功的，它第一步做的其实根据key是创建一个hash，用于快速找到是否存在一个不是头尾的旧节点可以直接移动过来</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        idxInOld = isDef(newStartVnode.key)</span><br><span class="line">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">        <span class="comment">//如果找不到，就创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 找到了，如果是相同节点，则pathc二者子节点队列，然后把找到的旧节点移动到旧节点头指针指向的节点之后</span></span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果结束条件是旧节点队列遍历完，那就把新节点还未遍历完的直接插入</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      <span class="comment">//如果施新节点遍历完成导致的结束遍历，则把剩下的旧节点移除</span></span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来很长，其实也很容易懂，大家自己看一看，随便举个例子试一下就明白了。</p>
<p>这里比较重要的一点是对 <code>nodeOps.insertBefore</code>这个函数的理解，它的作用是将第一个参数中的第二个参数（第一个参数的子节点）移动到第三个参数前面，不是单纯的insert。</p>
<p>如果大家实在不明白，可以去看一下<a href="https://segmentfault.com/a/1190000020663531" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a>。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>通过上述的分析，我们对diff算法应该有了个大致的了解，但其实有一点我们还没有将，那就是sameVnode这个是怎么定义的。</p>
<p>还是直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到首先必须二者的key要相同，这个key就是我们平时列表渲染时传入的key，很多人都会直接用数组的index，其实这样做会有一些问题。</p>
<p>第一个问题就是如果我有三个相同的节点，现在reverse，如果我的key是index，那么所有的sameVnode都会判断失败，明明可以重用的节点却被销毁然后新建了，这对性能会有影响。</p>
<p>第二个问题是如果我要删除第一个节点，那么oldCh第二个节点的key就会与ch的第一个节点相同，这就可能导致我本来想删除第一个节点，却删除了最后一个节点。</p>
<p>所以说我们还是尽量不要用数组的index作为key。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 全局异常处理插件</title>
    <url>/2020/06/12/vue-global-error-catch/</url>
    <content><![CDATA[<p>这周查阅了一些关于vue全局异常处理的文章，自己几种方案并根据自己的需求进行了一定的改造，这里记录一下。</p>
<a id="more"></a>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (ret &amp;&amp; <span class="keyword">typeof</span> ret.then === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> ret.catch === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetPageStatus</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vm.loading) &#123;</span><br><span class="line">    vm.loading = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> ServiceError) &#123;</span><br><span class="line">    vm.$_warning(error.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reset = vm.resetPageStatus || resetPageStatus;</span><br><span class="line">  reset(vm);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerActionHandle</span>(<span class="params">actions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(actions).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = actions[key];</span><br><span class="line">    actions[key] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">let</span> ret = fn.apply(vm, args);</span><br><span class="line">      <span class="keyword">if</span> (isPromise(ret)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">          errorHandler(error, vm);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认错误处理</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> registerVuex = <span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance.$options[<span class="string">'store'</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> actions = instance.$options[<span class="string">'store'</span>][<span class="string">'_actions'</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (actions) &#123;</span><br><span class="line">      <span class="keyword">let</span> tempActions = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(actions).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        tempActions[key] = actions[key][<span class="number">0</span>];</span><br><span class="line">      &#125;);</span><br><span class="line">      registerActionHandle(tempActions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> registerVue = <span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance.$options.methods) &#123;</span><br><span class="line">    <span class="keyword">let</span> actions = instance.$options.methods || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (actions) &#123;</span><br><span class="line">      registerActionHandle(actions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> GlobalError = &#123;</span><br><span class="line">  install: <span class="function">(<span class="params">Vue, options</span>) =&gt;</span> &#123;</span><br><span class="line">    Vue.prototype.ServiceError = ServiceError;</span><br><span class="line">    Vue.config.errorHandler = errorHandler;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        registerVue(<span class="keyword">this</span>);</span><br><span class="line">        registerVuex(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.prototype.$<span class="keyword">throw</span> = errorHandler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> GlobalError;</span><br></pre></td></tr></table></figure>

<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个全局的异常处理只是一个初步的模板，主要做了几件事情：</p>
<ul>
<li>自定义了新的错误类型 ServiceError。</li>
<li>覆盖了Vue的全局异常处理接口（Vue.config.errorHandler），使用了自定义给的errorHandler。</li>
<li>组件加载之前利用beforeCreate hook，去遍历所有methods，如果是普通函数，则直接返回，如果是Promise函数，则在catch函数中调用自定义的errorHandler函数。</li>
</ul>
<p>通过以上几点，所有未被我们捕获并处理的异常都会走到errorHandler函数中。</p>
<p>那么这个errorHandler函数做了什么呢？</p>
<ul>
<li>判断是否是我们自定义的错误类型 ServiceError，如果是，则弹出ElementUI的message组件，内容就是ServiceError的errorMessage。</li>
<li>如果是普通的错误，简单在控制台打印。</li>
<li>最终查看页面是否有重置状态的函数，如果有则执行，否则执行默认的状态重置函数，目前该函数只是把loading状态取消。</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> GlobalErrorCatchPlugin <span class="keyword">from</span> <span class="string">'./plugins/globalErrorCatchPlugin'</span>;</span><br><span class="line">Vue.use(GlobalErrorCatchPlugin);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前只是一个比较简单的版本，目的只是为了如果发生了未被捕获的异常，不会让页面卡在loading状态，并且如果是自定义的错误，我们可以自定义去如何处理。</p>
<p>如果通过Axios去和后台通信，也可以把api单独声明为一个方法，这样整个方法一旦500，也不会影响接下来函数的执行，如：</p>
<p>原本需要这样写的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> searchTableDataWithDateAndStatusByPage () &#123;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.gridData = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> EvtHubInboundMessageGW.qureyEvents(<span class="keyword">this</span>.createSearchCondition(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">if</span> (response &amp;&amp; response.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gridData = response.data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'refresh failed'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$_warning(<span class="keyword">this</span>.$t(<span class="string">'tips.refreshFailed'</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>可以改成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> qureyEvents() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> EvtHubInboundMessageGW.qureyEvents(<span class="keyword">this</span>.createSearchCondition(<span class="literal">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> searchTableDataWithDateAndStatusByPage () &#123;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.gridData = [];</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="keyword">this</span>.queryEvents();</span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; response.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gridData = response.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$_warning(<span class="keyword">this</span>.$t(<span class="string">'tips.refreshFailed'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样不仅看起来舒服一点，没有那么多代码块的嵌套，而且就算this.$_warning(this.$t(‘tips.refreshFailed’)); 发生了error，errorHandler中也会帮我们把loading状态取消。</p>
<p>总之，是一次vue全局异常捕获的尝试，还在改进当中。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（六） Props属性解析</title>
    <url>/2020/10/01/vue-props/</url>
    <content><![CDATA[<p><code>Props</code> 作为组件的核心特性之一，也是我们平时开发 Vue 项目中接触最多的特性之一，它可以让组件的功能变得丰富，也是父子组件通讯的一个渠道。</p>
<p>在这里感谢<a href="https://www.imooc.com/t/3017249" rel="external nofollow noopener noreferrer" target="_blank">ustbhuangyi</a>大佬的慕课教程。</p>
<a id="more"></a>

<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>在初始化 <code>props</code> 之前，首先会对 <code>props</code> 做一次 <code>normalize</code>，它发生在 <code>mergeOptions</code> 的时候，在 <code>src/core/util/options.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parent: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  child: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  normalizeProps(child, vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span> (<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.props</span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> i, val, name</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    i = props.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">        name = camelize(val)</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="string">'props must be strings when using array syntax.'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key]</span><br><span class="line">      name = camelize(key)</span><br><span class="line">      res[name] = isPlainObject(val)</span><br><span class="line">        ? val</span><br><span class="line">        : &#123; <span class="attr">type</span>: val &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Invalid value for option "props": expected an Array or an Object, `</span> +</span><br><span class="line">      <span class="string">`but got <span class="subst">$&#123;toRawType(props)&#125;</span>.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  options.props = res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并配置我们在组件化章节讲过，它主要就是处理我们定义组件的对象 <code>option</code>，然后挂载到组件的实例 <code>this.$options</code> 中。</p>
<p>我们接下来重点看 <code>normalizeProps</code> 的实现，其实这个函数的主要目的就是把我们编写的 <code>props</code> 转成对象格式，因为实际上 <code>props</code> 除了对象格式，还允许写成数组格式。</p>
<p>当 <code>props</code> 是一个数组，每一个数组元素 <code>prop</code> 只能是一个 <code>string</code>，表示 <code>prop</code> 的 <code>key</code>，转成驼峰格式，<code>prop</code> 的类型为空。</p>
<p>当 <code>props</code> 是一个对象，对于 <code>props</code> 中每个 <code>prop</code> 的 <code>key</code>，我们会转驼峰格式，而它的 <code>value</code>，如果不是一个对象，我们就把它规范成一个对象。</p>
<p>如果 <code>props</code> 既不是数组也不是对象，就抛出一个警告。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'name'</span>, <span class="string">'nick-name'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 <code>normalizeProps</code> 后，会被规范成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.props = &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  nickName: &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    nickName: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 <code>normalizeProps</code> 后，会被规范成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options.props = &#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  nickName: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于对象形式的 <code>props</code> 可以指定每个 <code>prop</code> 的类型和定义其它的一些属性，推荐用对象形式定义 <code>props</code>。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>Props</code> 的初始化主要发生在 <code>new Vue</code> 中的 <code>initState</code> 阶段，在 <code>src/core/instance/state.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">            <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initProps</code> 主要做 3 件事情：校验、响应式和代理。</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>校验的逻辑很简单，遍历 <code>propsOptions</code>，执行 <code>validateProp(key, propsOptions, propsData, vm)</code> 方法。这里的 <code>propsOptions</code> 就是我们定义的 <code>props</code> 在规范后生成的 <code>options.props</code> 对象，<code>propsData</code> 是从父组件传递的 <code>prop</code> 数据。所谓校验的目的就是检查一下我们传递的数据是否满足 <code>prop</code>的定义规范。再来看一下 <code>validateProp</code> 方法，它定义在 <code>src/core/util/props.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  propOptions: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prop = propOptions[key]</span><br><span class="line">  <span class="keyword">const</span> absent = !hasOwn(propsData, key)</span><br><span class="line">  <span class="keyword">let</span> value = propsData[key]</span><br><span class="line">  <span class="comment">// boolean casting</span></span><br><span class="line">  <span class="keyword">const</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type)</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">      <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">      <span class="comment">// boolean has higher priority</span></span><br><span class="line">      <span class="keyword">const</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type)</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check default value</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = getPropDefaultValue(vm, prop, key)</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">const</span> prevShouldObserve = shouldObserve</span><br><span class="line">    toggleObserving(<span class="literal">true</span>)</span><br><span class="line">    observe(value)</span><br><span class="line">    toggleObserving(prevShouldObserve)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// skip validation for weex recycle-list child component props</span></span><br><span class="line">    !(__WEEX__ &amp;&amp; isObject(value) &amp;&amp; (<span class="string">'@binding'</span> <span class="keyword">in</span> value))</span><br><span class="line">  ) &#123;</span><br><span class="line">    assertProp(prop, key, value, vm, absent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>validateProp</code> 主要就做 3 件事情：处理 <code>Boolean</code> 类型的数据，处理默认数据，<code>prop</code> 断言，并最终返回 <code>prop</code> 的值。</p>
<p>先来看 <code>Boolean</code> 类型数据的处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prop = propOptions[key]</span><br><span class="line"><span class="keyword">const</span> absent = !hasOwn(propsData, key)</span><br><span class="line"><span class="keyword">let</span> value = propsData[key]</span><br><span class="line"><span class="comment">// boolean casting</span></span><br><span class="line"><span class="keyword">const</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type)</span><br><span class="line"><span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (absent &amp;&amp; !hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">    value = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">''</span> || value === hyphenate(key)) &#123;</span><br><span class="line">    <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">    <span class="comment">// boolean has higher priority</span></span><br><span class="line">    <span class="keyword">const</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type)</span><br><span class="line">    <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">      value = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过 <code>const booleanIndex = getTypeIndex(Boolean, prop.type)</code> 来判断 <code>prop</code> 的定义是否是 <code>Boolean</code> 类型的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = fn &amp;&amp; fn.toString().match(<span class="regexp">/^\s*function (\w+)/</span>)</span><br><span class="line">  <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getType(a) === getType(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTypeIndex</span> (<span class="params">type, expectedTypes</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(expectedTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameType(expectedTypes, type) ? <span class="number">0</span> : <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = expectedTypes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSameType(expectedTypes[i], type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getTypeIndex</code> 函数就是找到 <code>type</code> 和 <code>expectedTypes</code> 匹配的索引并返回。</p>
<p><code>prop</code> 类型定义的时候可以是某个原生构造函数，也可以是原生构造函数的数组，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    value: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>expectedTypes</code> 是单个构造函数，就执行 <code>isSameType</code> 去判断是否是同一个类型；如果是数组，那么就遍历这个数组，找到第一个同类型的，返回它的索引。</p>
<p>回到 <code>validateProp</code> 函数，通过 <code>const booleanIndex = getTypeIndex(Boolean, prop.type)</code> 得到 <code>booleanIndex</code>，如果 <code>prop.type</code> 是一个 <code>Boolean</code> 类型，则通过 <code>absent &amp;&amp; !hasOwn(prop, &#39;default&#39;)</code> 来判断如果父组件没有传递这个 <code>prop</code> 数据并且没有设置 <code>default</code> 的情况，则 <code>value</code> 为 false。</p>
<p>接着判断<code>value === &#39;&#39; || value === hyphenate(key)</code> 的情况，如果满足则先通过 <code>const stringIndex = getTypeIndex(String, prop.type)</code> 获取匹配 <code>String</code> 类型的索引，然后判断 <code>stringIndex &lt; 0 || booleanIndex &lt; stringIndex</code> 的值来决定 <code>value</code> 的值是否为 <code>true</code>。这块逻辑稍微有点绕，我们举 2 个例子来说明：</p>
<p>例如你定义一个组件 <code>Student</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  nickName: [<span class="built_in">Boolean</span>, <span class="built_in">String</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在父组件中引入这个组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;student name=&quot;Kate&quot; nick-name&gt;&lt;/student&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;student name=&quot;Kate&quot; nick-name=&quot;nick-name&quot;&gt;&lt;/student&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>第一种情况没有写属性的值，满足 <code>value === &#39;&#39;</code>，第二种满足 <code>value === hyphenate(key)</code> 的情况，另外 <code>nickName</code> 这个 <code>prop</code> 的类型是 <code>Boolean</code> 或者是 <code>String</code>，并且满足 <code>booleanIndex &lt; stringIndex</code>，所以对 <code>nickName</code> 这个 <code>prop</code> 的 <code>value</code> 为 <code>true</code>。</p>
<p>接下来看一下默认数据处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check default value</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  value = getPropDefaultValue(vm, prop, key)</span><br><span class="line">  <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">  <span class="comment">// make sure to observe it.</span></span><br><span class="line">  <span class="keyword">const</span> prevShouldObserve = shouldObserve</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">  observe(value)</span><br><span class="line">  toggleObserving(prevShouldObserve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>value</code> 的值为 <code>undefined</code> 的时候，说明父组件根本就没有传这个 <code>prop</code>，那么我们就需要通过 <code>getPropDefaultValue(vm, prop, key)</code> 获取这个 <code>prop</code> 的默认值。我们这里只关注 <code>getPropDefaultValue</code> 的实现，<code>toggleObserving</code> 和 <code>observe</code> 的作用我们之后会说。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropDefaultValue</span> (<span class="params">vm: ?Component, prop: PropOptions, key: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// no default, return undefined</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> def = prop.default</span><br><span class="line">  <span class="comment">// warn against non-factory defaults for Object &amp; Array</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; isObject(def)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Invalid default value for prop "'</span> + key + <span class="string">'": '</span> +</span><br><span class="line">      <span class="string">'Props with type Object/Array must use a factory function '</span> +</span><br><span class="line">      <span class="string">'to return the default value.'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// the raw prop value was also undefined from previous render,</span></span><br><span class="line">  <span class="comment">// return previous default value to avoid unnecessary watcher trigger</span></span><br><span class="line">  <span class="keyword">if</span> (vm &amp;&amp; vm.$options.propsData &amp;&amp;</span><br><span class="line">    vm.$options.propsData[key] === <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    vm._props[key] !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm._props[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// call factory function for non-Function types</span></span><br><span class="line">  <span class="comment">// a value is Function if its prototype is function even across different execution context</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> def === <span class="string">'function'</span> &amp;&amp; getType(prop.type) !== <span class="string">'Function'</span></span><br><span class="line">    ? def.call(vm)</span><br><span class="line">    : def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测如果 <code>prop</code> 没有定义 <code>default</code> 属性，那么返回 <code>undefined</code>，通过这块逻辑我们知道除了 <code>Boolean</code> 类型的数据，其余没有设置 <code>default</code> 属性的 <code>prop</code> 默认值都是 <code>undefined</code>。</p>
<p>接着是开发环境下对 <code>prop</code> 的默认值是否为对象或者数组类型的判断，如果是的话会报警告，因为对象和数组类型的 <code>prop</code>，他们的默认值必须要返回一个工厂函数。</p>
<p>接下来的判断是如果上一次组件渲染父组件传递的 <code>prop</code> 的值是 <code>undefined</code>，则直接返回 上一次的默认值 <code>vm._props[key]</code>，这样可以避免触发不必要的 <code>watcher</code> 的更新。</p>
<p>最后就是判断 <code>def</code> 如果是工厂函数且 <code>prop</code> 的类型不是 <code>Function</code> 的时候，返回工厂函数的返回值，否则直接返回 <code>def</code>。</p>
<p>至此，我们讲完了 <code>validateProp</code> 函数的 <code>Boolean</code> 类型数据的处理逻辑和默认数据处理逻辑，最后来看一下 <code>prop</code> 断言逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line"><span class="comment">// skip validation for weex recycle-list child component props</span></span><br><span class="line">!(__WEEX__ &amp;&amp; isObject(value) &amp;&amp; (<span class="string">'@binding'</span> <span class="keyword">in</span> value))</span><br><span class="line">) &#123;</span><br><span class="line">  assertProp(prop, key, value, vm, absent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发环境且非 <code>weex</code> 的某种环境下，执行 <code>assertProp</code> 做属性断言。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertProp</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prop: PropOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  value: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm: ?Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  absent: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.required &amp;&amp; absent) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Missing required prop: "'</span> + name + <span class="string">'"'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; !prop.required) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> type = prop.type</span><br><span class="line">  <span class="keyword">let</span> valid = !type || type === <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> expectedTypes = []</span><br><span class="line">  <span class="keyword">if</span> (type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(type)) &#123;</span><br><span class="line">      type = [type]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; type.length &amp;&amp; !valid; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> assertedType = assertType(value, type[i])</span><br><span class="line">      expectedTypes.push(assertedType.expectedType || <span class="string">''</span>)</span><br><span class="line">      valid = assertedType.valid</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      getInvalidTypeMessage(name, value, expectedTypes),</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> validator = prop.validator</span><br><span class="line">  <span class="keyword">if</span> (validator) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validator(value)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Invalid prop: custom validator check failed for prop "'</span> + name + <span class="string">'".'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertProp</code> 函数的目的是断言这个 <code>prop</code> 是否合法。</p>
<p>首先判断如果 <code>prop</code> 定义了 <code>required</code> 属性但父组件没有传递这个 <code>prop</code> 数据的话会报一个警告。</p>
<p>接着判断如果 <code>value</code> 为空且 <code>prop</code> 没有定义 <code>required</code> 属性则直接返回。</p>
<p>然后再去对 <code>prop</code> 的类型做校验，先是拿到 <code>prop</code> 中定义的类型 <code>type</code>，并尝试把它转成一个类型数组，然后依次遍历这个数组，执行 <code>assertType(value, type[i])</code> 去获取断言的结果，直到遍历完成或者是 <code>valid</code> 为 <code>true</code> 的时候跳出循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> simpleCheckRE = <span class="regexp">/^(String|Number|Boolean|Function|Symbol)$/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertType</span> (<span class="params">value: any, type: Function</span>): </span>&#123;</span><br><span class="line">  valid: boolean;</span><br><span class="line">  expectedType: string;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> valid</span><br><span class="line">  <span class="keyword">const</span> expectedType = getType(type)</span><br><span class="line">  <span class="keyword">if</span> (simpleCheckRE.test(expectedType)) &#123;</span><br><span class="line">    <span class="keyword">const</span> t = <span class="keyword">typeof</span> value</span><br><span class="line">    valid = t === expectedType.toLowerCase()</span><br><span class="line">    <span class="comment">// for primitive wrapper objects</span></span><br><span class="line">    <span class="keyword">if</span> (!valid &amp;&amp; t === <span class="string">'object'</span>) &#123;</span><br><span class="line">      valid = value <span class="keyword">instanceof</span> type</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expectedType === <span class="string">'Object'</span>) &#123;</span><br><span class="line">    valid = isPlainObject(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expectedType === <span class="string">'Array'</span>) &#123;</span><br><span class="line">    valid = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    valid = value <span class="keyword">instanceof</span> type</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    valid,</span><br><span class="line">    expectedType</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>assertType</code> 的逻辑很简单，先通过 <code>getType(type)</code> 获取 <code>prop</code> 期望的类型 <code>expectedType</code>，然后再去根据几种不同的情况对比 <code>prop</code> 的值 <code>value</code> 是否和 <code>expectedType</code> 匹配，最后返回匹配的结果。</p>
<p>如果循环结束后 <code>valid</code> 仍然为 <code>false</code>，那么说明 <code>prop</code> 的值 <code>value</code> 与 <code>prop</code> 定义的类型都不匹配，那么就会输出一段通过 <code>getInvalidTypeMessage(name, value, expectedTypes)</code> 生成的警告信息，就不细说了。</p>
<p>最后判断当 <code>prop</code> 自己定义了 <code>validator</code> 自定义校验器，则执行 <code>validator</code> 校验器方法，如果校验不通过则输出警告信息。</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>回到 <code>initProps</code> 方法，当我们通过 <code>const value = validateProp(key, propsOptions, propsData, vm)</code> 对 <code>prop</code> 做验证并且获取到 <code>prop</code> 的值后，接下来需要通过 <code>defineReactive</code> 把 <code>prop</code> 变成响应式。</p>
<p><code>defineReactive</code> 我们之前已经介绍过，这里要注意的是，在开发环境中我们会校验 <code>prop</code> 的 <code>key</code> 是否是 <code>HTML</code> 的保留属性，并且在 <code>defineReactive</code> 的时候会添加一个自定义 <code>setter</code>，当我们直接对 <code>prop</code> 赋值的时候会输出警告：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">  <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">      config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;hyphenatedKey&#125;</span>" is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(props, key, value, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">        <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">        <span class="string">`Instead, use a data or computed property based on the prop's `</span> +</span><br><span class="line">        <span class="string">`value. Prop being mutated: "<span class="subst">$&#123;key&#125;</span>"`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>prop</code> 的响应式有一点不同的是当 <code>vm</code> 是非根实例的时候，会先执行 <code>toggleObserving(false)</code>，它的目的是为了响应式的优化，我们先跳过，之后会详细说明。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在经过响应式处理后，我们会把 <code>prop</code> 的值添加到 <code>vm._props</code> 中，比如 key 为 <code>name</code> 的 <code>prop</code>，它的值保存在 <code>vm._props.name</code> 中，但是我们在组件中可以通过 <code>this.name</code> 访问到这个 <code>prop</code>，这就是代理做的事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static props are already proxied on the component's prototype</span></span><br><span class="line"><span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line"><span class="comment">// instantiation here.</span></span><br><span class="line"><span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">  proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>proxy</code> 函数实现了上述需求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问 <code>this.name</code> 的时候就相当于访问 <code>this._props.name</code>。</p>
<p>其实对于非根实例的子组件而言，<code>prop</code> 的代理发生在 <code>Vue.extend</code> 阶段，在 <code>src/core/global-api/extend.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._init(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">  <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">  <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line">  <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">    initProps(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">    initComputed(Sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = Comp.options.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的好处是不用为每个组件实例都做一层 <code>proxy</code>，是一种优化手段。</p>
<h2 id="Props-更新"><a href="#Props-更新" class="headerlink" title="Props 更新"></a>Props 更新</h2><p>我们知道，当父组件传递给子组件的 <code>props</code> 值变化，子组件对应的值也会改变，同时会触发子组件的重新渲染。那么接下来我们就从源码角度来分析这两个过程。</p>
<h3 id="子组件-props-更新"><a href="#子组件-props-更新" class="headerlink" title="子组件 props 更新"></a>子组件 props 更新</h3><p>首先，<code>prop</code> 数据的值变化在父组件，我们知道在父组件的 <code>render</code> 过程中会访问到这个 <code>prop</code> 数据，所以当 <code>prop</code> 数据变化一定会触发父组件的重新渲染，那么重新渲染是如何更新子组件对应的 <code>prop</code> 的值呢？</p>
<p>在父组件重新渲染的最后，会执行 <code>patch</code> 过程，进而执行 <code>patchVnode</code> 函数，<code>patchVnode</code> 通常是一个递归过程，当它遇到组件 <code>vnode</code> 的时候，会执行组件更新过程的 <code>prepatch</code> 钩子函数，在 <code>src/core/vdom/patch.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  oldVnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  vnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">  ownerArray,</span></span></span><br><span class="line"><span class="function"><span class="params">  index,</span></span></span><br><span class="line"><span class="function"><span class="params">  removeOnly</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepatch</code> 函数定义在 <code>src/core/vdom/create-component.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedComponentVNode) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">  <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">  updateChildComponent(</span><br><span class="line">    child,</span><br><span class="line">    options.propsData, <span class="comment">// updated props</span></span><br><span class="line">    options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">    vnode, <span class="comment">// new parent vnode</span></span><br><span class="line">    options.children <span class="comment">// new children</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部会调用 <code>updateChildComponent</code> 方法来更新 <code>props</code>，注意第二个参数就是父组件的 <code>propData</code>，那么为什么 <code>vnode.componentOptions.propsData</code> 就是父组件传递给子组件的 <code>prop</code> 数据呢（这个也同样解释了第一次渲染的 <code>propsData</code> 来源）？原来在组件的 <code>render</code> 过程中，对于组件节点会通过 <code>createComponent</code> 方法来创建组件 <code>vnode</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建组件 <code>vnode</code> 的过程中，首先从 <code>data</code> 中提取出 <code>propData</code>，然后在 <code>new VNode</code> 的时候，作为第七个参数 <code>VNodeComponentOptions</code> 中的一个属性传入，所以我们可以通过 <code>vnode.componentOptions.propsData</code> 拿到 <code>prop</code> 数据。</p>
<p>接着看 <code>updateChildComponent</code> 函数，它的定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  propsData: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  listeners: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentVnode: MountedComponentVNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderChildren: ?Array&lt;VNode&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// update props</span></span><br><span class="line">  <span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> props = vm._props</span><br><span class="line">    <span class="keyword">const</span> propKeys = vm.$options._propKeys || []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = propKeys[i]</span><br><span class="line">      <span class="keyword">const</span> propOptions: any = vm.$options.props <span class="comment">// wtf flow?</span></span><br><span class="line">      props[key] = validateProp(key, propOptions, propsData, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    toggleObserving(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// keep a copy of raw propsData</span></span><br><span class="line">    vm.$options.propsData = propsData</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点来看更新 <code>props</code> 的相关逻辑，这里的 <code>propsData</code> 是父组件传递的 <code>props</code> 数据，<code>vm</code> 是子组件的实例。<code>vm._props</code> 指向的就是子组件的 <code>props</code> 值，<code>propKeys</code> 就是在之前 <code>initProps</code> 过程中，缓存的子组件中定义的所有 <code>prop</code> 的 <code>key</code>。主要逻辑就是遍历 <code>propKeys</code>，然后执行 <code>props[key] = validateProp(key, propOptions, propsData, vm)</code> 重新验证和计算新的 <code>prop</code> 数据，更新 <code>vm._props</code>，也就是子组件的 <code>props</code>，这个就是子组件  <code>props</code> 的更新过程。</p>
<h3 id="子组件重新渲染"><a href="#子组件重新渲染" class="headerlink" title="子组件重新渲染"></a>子组件重新渲染</h3><p>其实子组件的重新渲染有 2 种情况，一个是 <code>prop</code> 值被修改，另一个是对象类型的 <code>prop</code> 内部属性的变化。</p>
<p>先来看一下 <code>prop</code> 值被修改的情况，当执行 <code>props[key] = validateProp(key, propOptions, propsData, vm)</code> 更新子组件 <code>prop</code> 的时候，会触发 <code>prop</code> 的 <code>setter</code> 过程，只要在渲染子组件的时候访问过这个 <code>prop</code> 值，那么根据响应式原理，就会触发子组件的重新渲染。</p>
<p>再来看一下当对象类型的 <code>prop</code> 的内部属性发生变化的时候，这个时候其实并没有触发子组件 <code>prop</code> 的更新。但是在子组件的渲染过程中，访问过这个对象 <code>prop</code>，所以这个对象 <code>prop</code> 在触发 <code>getter</code> 的时候会把子组件的 <code>render watcher</code> 收集到依赖中，然后当我们在父组件更新这个对象 <code>prop</code> 的某个属性的时候，会触发 <code>setter</code> 过程，也就会通知子组件 <code>render watcher</code> 的 <code>update</code>，进而触发子组件的重新渲染。</p>
<p>以上就是当父组件 <code>props</code> 更新，触发子组件重新渲染的 2 种情况。</p>
<h2 id="toggleObserving"><a href="#toggleObserving" class="headerlink" title="toggleObserving"></a>toggleObserving</h2><p>最后我们在来聊一下 <code>toggleObserving</code>，它的定义在 <code>src/core/observer/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldObserve: boolean = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span> (<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在当前模块中定义了 <code>shouldObserve</code> 变量，用来控制在 <code>observe</code> 的过程中是否需要把当前值变成一个 <code>Observer</code> 对象。</p>
<p>那么为什么在 <code>props</code> 的初始化和更新过程中，多次执行 <code>toggleObserving(false)</code> 呢，接下来我们就来分析这几种情况。</p>
<p>在 <code>initProps</code> 的过程中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line"><span class="comment">// root instance props should be converted</span></span><br><span class="line"><span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">  toggleObserving(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">  defineReactive(props, key, value)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">toggleObserving(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>对于非根实例的情况，我们会执行 <code>toggleObserving(false)</code>，然后对于每一个 <code>prop</code> 值，去执行 <code>defineReactive(props, key, value)</code> 去把它变成响应式。</p>
<p>回顾一下 <code>defineReactive</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常对于值 <code>val</code> 会执行 <code>observe</code> 函数，然后遇到 <code>val</code> 是对象或者数组的情况会递归执行 <code>defineReactive</code> 把它们的子属性都变成响应式的，但是由于 <code>shouldObserve</code> 的值变成了 <code>false</code>，这个递归过程被省略了。为什么会这样呢？</p>
<p>因为正如我们前面分析的，对于对象的 <code>prop</code> 值，子组件的 <code>prop</code> 值始终指向父组件的 <code>prop</code> 值，只要父组件的 <code>prop</code> 值变化，就会触发子组件的重新渲染，所以这个 <code>observe</code> 过程是可以省略的。</p>
<p>最后再执行 <code>toggleObserving(true)</code> 恢复 <code>shouldObserve</code> 为 <code>true</code>。</p>
<p>在 <code>validateProp</code> 的过程中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check default value</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  value = getPropDefaultValue(vm, prop, key)</span><br><span class="line">  <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">  <span class="comment">// make sure to observe it.</span></span><br><span class="line">  <span class="keyword">const</span> prevShouldObserve = shouldObserve</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">  observe(value)</span><br><span class="line">  toggleObserving(prevShouldObserve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是父组件没有传递 <code>prop</code> 值对默认值的处理逻辑，因为这个值是一个拷贝，所以我们需要 <code>toggleObserving(true)</code>，然后执行 <code>observe(value)</code> 把值变成响应式。</p>
<p>在 <code>updateChildComponent</code> 过程中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// update props</span></span><br><span class="line"><span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;</span><br><span class="line">  toggleObserving(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> props = vm._props</span><br><span class="line">  <span class="keyword">const</span> propKeys = vm.$options._propKeys || []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = propKeys[i]</span><br><span class="line">    <span class="keyword">const</span> propOptions: any = vm.$options.props <span class="comment">// wtf flow?</span></span><br><span class="line">    props[key] = validateProp(key, propOptions, propsData, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">  <span class="comment">// keep a copy of raw propsData</span></span><br><span class="line">  vm.$options.propsData = propsData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和 <code>initProps</code> 的逻辑一样，不需要对引用类型 <code>props</code> 递归做响应式处理，所以也需要 <code>toggleObserving(false)</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这一节的分析，我们了解了 <code>props</code> 的规范化、初始化、更新等过程的实现原理；也了解了 Vue 内部对 <code>props</code> 如何做响应式的优化；同时还了解到 <code>props</code> 的变化是如何触发子组件的更新。了解这些对我们平时对 <code>props</code> 的应用，遇到问题时的定位追踪会有很大的帮助。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（一） 响应式原理</title>
    <url>/2020/08/25/vue-reactive/</url>
    <content><![CDATA[<p>Vue是一个MVVM框架，最吸引人的地方就是它的响应式。</p>
<h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p>首先我们看一下官方文档中对响应式原理的解释。</p>
<h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="external nofollow noopener noreferrer" target="_blank"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters" rel="external nofollow noopener noreferrer" target="_blank">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 <a href="https://github.com/vuejs/vue-devtools" rel="external nofollow noopener noreferrer" target="_blank">vue-devtools</a> 来获取对检查数据更加友好的用户界面。</p>
<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<a id="more"></a>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1598358457/Blog/data_clskq8.png" alt></p>
<p>上图的过程大致上是这样的，当一个组件实例化的时候，会首先为所有data中的数据定义getter和setter，然后触发render函数，在渲染成virtual dom过程中，会触发渲染过程中使用到的那些数据的getter，而getter中会将这些数据加入到Watcher中，这一步叫做依赖收集，等到某个依赖的数据改变时会通知Watcher去重新触发render函数来重新渲染页面。</p>
<h3 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h3><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p>
<p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure>

<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。例如，对于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">'b'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(this.someObject,'b',2)</span><br></pre></td></tr></table></figure>

<p>有时你可能需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="keyword">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.someObject, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h4><p>Vue 不能检测以下数组的变动：</p>
<ol>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <a href="https://cn.vuejs.org/v2/api/#vm-set" rel="external nofollow noopener noreferrer" target="_blank"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">          obj:&#123;</span><br><span class="line">              a：<span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们写下这行代码时,vue将我们在data内定义的obj对象进行依赖追踪.</p>
<p>具体做法为执行<code>new Observer(obj)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经过上面的代码，我们的obj对象会变为以下的样子</span></span><br><span class="line">&#123;</span><br><span class="line">  obj:&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    __ob__:&#123; <span class="comment">//Observer 实例</span></span><br><span class="line">        dep:&#123;Dep 实例</span><br><span class="line">            subs:[ <span class="comment">//存放 Watcher 实例</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(),</span><br><span class="line">              <span class="keyword">new</span> Watcher(),</span><br><span class="line">              <span class="keyword">new</span> Watcher(),</span><br><span class="line">              <span class="keyword">new</span> Watcher(),</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Observe-实现"><a href="#Observe-实现" class="headerlink" title="Observe 实现"></a>Observe 实现</h3><h4 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">      <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">      ob.dep.depend();</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">      val = newVal</span><br><span class="line">      observe(newVal)</span><br><span class="line">      <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">      ob.dep.notify();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="observe函数"><a href="#observe函数" class="headerlink" title="observe函数"></a>observe函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*判断是否是一个对象*/</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span></span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span></span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that are attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatches updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span>  </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span></span><br><span class="line"><span class="comment">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment  <span class="comment">/*直接覆盖原型的方法来修改目标对象*/</span></span><br><span class="line">        : copyAugment   <span class="comment">/*定义（覆盖）目标对象或数组的某一个方法*/</span></span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">      <span class="comment">/*如果是数组则需要遍历数组的每一个成员进行observe*/</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*如果是对象则直接walk进行绑定*/</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*数组需要遍历每一个成员进行observe*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面牵扯到了 Dep，我们也把Dep实现下，</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(Dep.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs[i].fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><code>Observer 类</code> 主要做了以下事情</p>
<ol>
<li>遍历 data 下的每一个属性，若是对象，则 执行 new Observer() ,在对象上新增<code>__ob__</code>属性,该属性的值为 Observer 的实例</li>
<li>劫持对象属性的变化，在 getter 的时候，拿到 Observer 实例的dep实例，执行dep.depend()，代码如下</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">ob.dep.depend();</span><br></pre></td></tr></table></figure>

<p>看下 <code>dep.depend()</code>做了些啥</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.subs.push(Dep.target)</span><br></pre></td></tr></table></figure>

<p>将<code>Dep.target</code>添加到 订阅数组内（this.subs）</p>
<blockquote>
<p>也就是说，只要我们 Dep.target 赋值了，再执行 <code>dep.depend()</code>，那么该值就会被添加到 dep 的 subs 数组内，比如</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Dep.target =<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">dep.depend()</span><br><span class="line"><span class="comment">// test 函数就算 Dep 的订阅者了</span></span><br></pre></td></tr></table></figure>

<h3 id="Watcher-实现"><a href="#Watcher-实现" class="headerlink" title="Watcher 实现"></a>Watcher 实现</h3><p>这个watcher的实现是简化版，甚至将一些定义在其他函数中的逻辑直接放在了这里，只是为了更好理解。</p>
<p>具体的Watcher解释可以看我的另一篇博客<a href="https://sunra.top/2020/08/31/vue-data-driven/">Vue的数据驱动原理</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Dep = <span class="built_in">require</span>(<span class="string">'./Dep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, exp, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.exp = exp</span><br><span class="line">    <span class="keyword">this</span>.fn = fn</span><br><span class="line">    Dep.target = <span class="keyword">this</span><span class="comment">//将自己挂载到 Dep.target，调用 Dep.depend时会读取该变量</span></span><br><span class="line">    <span class="keyword">this</span>.vm[exp]  <span class="comment">// 这里源码其实是调用了mount函数，间接调用render函数，渲染时去使用数据。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Watcher</span><br></pre></td></tr></table></figure>

<p>根据一个小例子来理解 <code>Watcher</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Observer(obj)</span><br><span class="line"><span class="keyword">new</span> Watcher(obj, <span class="string">'a'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Watcher 回调执行'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">obj.a=<span class="string">'222'</span></span><br></pre></td></tr></table></figure>

<p>流程如下：</p>
<ol>
<li>先观测 obj 对象（<code>new Observer(obj)</code>）</li>
<li>实例化<code>Watcher</code>时,会执行<code>Dep.target = this</code>，然后执行<code>this.vm[exp]</code>,也就是取一次值，那么会触发 getter,将自身（Watcher实例）添加到dep的订阅者数组内</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">     <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">     ob.dep.depend();</span><br><span class="line">     <span class="keyword">return</span> val</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p>最后，改变数据时候，触发<code>setter</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">     <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">     val = newVal</span><br><span class="line">     observe(newVal)</span><br><span class="line">     <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">     ob.dep.notify();</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p>执行<code>ob.dep.notify()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">notify() &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++) &#123;</span><br><span class="line">     <span class="keyword">this</span>.subs[i].fn()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>遍历 订阅者（subs）执行回调函数，整个流程结束</p>
<h3 id="依赖收集过程"><a href="#依赖收集过程" class="headerlink" title="依赖收集过程"></a>依赖收集过程</h3><ul>
<li>通过observer函数，将data中的每个属性都添加getter和setter</li>
<li>添加新的Watcher，Watcher构造过程中，会首先将Dep.target赋值为自己，然后手动调用一遍getter，这样就能触发getter中将Dep.target加入到subs中的逻辑</li>
<li>一旦修改某个属性，会触发setter中的notify，通知所有添加进来的subs（也就是所有的Watcher实例）调用更新函数。</li>
</ul>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1598612680/Blog/Vue_kjy2w6.png" alt></p>
<h3 id="依赖注销过程"><a href="#依赖注销过程" class="headerlink" title="依赖注销过程"></a>依赖注销过程</h3><p>不知道大家有没有想过，上面说的过程都是讲的vue如何收集依赖，如何在依赖变化时触发渲染watcher的更新，但是我们也知道，由于v-if之类的存在，当条件为true的时候，我们可能会收集一些依赖，但是当这个条件为false时，这些依赖的变化就不应该触发重新渲染，那么就应该把这些依赖给注销。</p>
<p>那么vue是怎么做的呢？</p>
<p>我们已经知道，当数据发生变化的时候，会触发<code>dep.notify()</code>，从而触发所有订阅该dep的watcher的<code>update</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里就会重新调用<code>get</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中最后一步<code>cleanupDeps</code>其实就是用来清除无效依赖的，他其实是和<code>addDep</code>配合使用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>每次收集依赖的时候都会把dep的id保存到newDepIds数组中，等到触发更新后，会查找上次更新时所有的依赖（this.deps），如果不再newDepIds中，就会将这个dep移除</p>
<h2 id="Vue3响应式升级"><a href="#Vue3响应式升级" class="headerlink" title="Vue3响应式升级"></a>Vue3响应式升级</h2><p>Vue3中重新利用ES6的Proxy语法对响应式进行了更新，能够更好地处理上面说的数组更新。</p>
<p><a href="https://sunra.top/2020/07/08/es6-proxy/">https://sunra.top/2020/07/08/es6-proxy/</a></p>
<p>参考文章：</p>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" rel="external nofollow noopener noreferrer" target="_blank">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>
<p><a href="https://github.com/answershuto/learnVue/blob/master/docs/响应式原理.MarkDown" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/answershuto/learnVue/blob/master/docs/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown</a></p>
<p><a href="https://github.com/answershuto/learnVue/blob/master/docs/依赖收集.MarkDown" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/answershuto/learnVue/blob/master/docs/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86.MarkDown</a></p>
<p><a href="https://juejin.im/post/6844903901003513863" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/6844903901003513863</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（七）Compiler原理</title>
    <url>/2020/10/31/vue-slot/</url>
    <content><![CDATA[<p>前面的六篇博客已经帮助我们基本搞清楚了，vue的响应式原理，数据驱动，组件化和组件更新等概念和原理，而其中关于组件化和组件更新的部分，我们是在已有render函数的基础上来讲的，也就是说我们已经有了vnode，再去讨论的vnode如何渲染更新的。</p>
<p>这篇博客我们就回过头来看看vue的compiler是如何将template变成render函数的。</p>
<p><strong>了解编译的流程有什么好处呢？我个人觉得可以帮助我们对于一些vue自身的语法糖的原理有个更好的理解。</strong></p>
<p>由于Compiler的细节非常多，所以大概有个结论和印象即可，其中很多关于vue自身的语法处理也不会细讲，只会用slot来做个例子。</p>
<a id="more"></a>

<h2 id="Compiler入口"><a href="#Compiler入口" class="headerlink" title="Compiler入口"></a>Compiler入口</h2><p>对于compiler的入口，vue做了一系列柯里化的处理，来最终返回编译函数。</p>
<p>这样处理是为了将与平台有关的配置进行预处理，比如web编译和ssr的编译会有些许配置上的不同，而平台在编译过程中又不会发生改变，所以先通过柯里化将这些不同封装在函数闭包中，这样在不同组件执行compiler时就不需要一次次判断平台了。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>想要看看是怎么柯里化的，可以看看这一小节，不看也不影响我们理解编译的流程。</p>
<p>当我们使用 Runtime + Compiler 的 Vue.js，它的入口是 <code>src/platforms/web/entry-runtime-with-compiler.js</code>，看一下它对 <code>$mount</code> 函数的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段函数逻辑之前分析过，关于编译的入口就是在这里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; =  compileToFunctions(template, &#123;</span><br><span class="line">    shouldDecodeNewlines,</span><br><span class="line">    shouldDecodeNewlinesForHref,</span><br><span class="line">    delimiters: options.delimiters,</span><br><span class="line">    comments: options.comments</span><br><span class="line">  &#125;, <span class="keyword">this</span>)</span><br><span class="line">options.render = render</span><br><span class="line">options.staticRenderFns = staticRenderFns</span><br></pre></td></tr></table></figure>

<p><code>compileToFunctions</code> 方法就是把模板 <code>template</code> 编译生成 <code>render</code> 以及 <code>staticRenderFns</code>，它的定义在 <code>src/platforms/web/compiler/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; baseOptions &#125; <span class="keyword">from</span> <span class="string">'./options'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createCompiler &#125; <span class="keyword">from</span> <span class="string">'compiler/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; compile, compileToFunctions &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>compileToFunctions</code> 方法实际上是 <code>createCompiler</code> 方法的返回值，该方法接收一个编译配置参数，接下来我们来看一下 <code>createCompiler</code> 方法的定义，在 <code>src/compiler/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `createCompilerCreator` allows creating compilers that use alternative</span></span><br><span class="line"><span class="comment">// parser/optimizer/codegen, e.g the SSR optimizing compiler.</span></span><br><span class="line"><span class="comment">// Here we just export a default compiler using the default parts.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>createCompiler</code> 方法实际上是通过调用 <code>createCompilerCreator</code> 方法返回的，该方法传入的参数是一个函数，真正的编译过程都在这个 <code>baseCompile</code> 函数里执行，那么 <code>createCompilerCreator</code> 又是什么呢，它的定义在 <code>src/compiler/create-compiler.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompilerCreator</span> (<span class="params">baseCompile: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompiler</span> (<span class="params">baseOptions: CompilerOptions</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">      options?: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> finalOptions = <span class="built_in">Object</span>.create(baseOptions)</span><br><span class="line">      <span class="keyword">const</span> errors = []</span><br><span class="line">      <span class="keyword">const</span> tips = []</span><br><span class="line">      finalOptions.warn = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">        (tip ? tips : errors).push(msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="comment">// merge custom modules</span></span><br><span class="line">        <span class="keyword">if</span> (options.modules) &#123;</span><br><span class="line">          finalOptions.modules =</span><br><span class="line">            (baseOptions.modules || []).concat(options.modules)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge custom directives</span></span><br><span class="line">        <span class="keyword">if</span> (options.directives) &#123;</span><br><span class="line">          finalOptions.directives = extend(</span><br><span class="line">            <span class="built_in">Object</span>.create(baseOptions.directives || <span class="literal">null</span>),</span><br><span class="line">            options.directives</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy other options</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="string">'modules'</span> &amp;&amp; key !== <span class="string">'directives'</span>) &#123;</span><br><span class="line">            finalOptions[key] = options[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> compiled = baseCompile(template, finalOptions)</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        errors.push.apply(errors, detectErrors(compiled.ast))</span><br><span class="line">      &#125;</span><br><span class="line">      compiled.errors = errors</span><br><span class="line">      compiled.tips = tips</span><br><span class="line">      <span class="keyword">return</span> compiled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compile,</span><br><span class="line">      compileToFunctions: createCompileToFunctionFn(compile)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法返回了一个 <code>createCompiler</code> 的函数，它接收一个 <code>baseOptions</code> 的参数，返回的是一个对象，包括 <code>compile</code> 方法属性和 <code>compileToFunctions</code> 属性，这个 <code>compileToFunctions</code> 对应的就是 <code>$mount</code> 函数调用的 <code>compileToFunctions</code> 方法，它是调用 <code>createCompileToFunctionFn</code> 方法的返回值，我们接下来看一下 <code>createCompileToFunctionFn</code> 方法，它的定义在 <code>src/compiler/to-function/js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompileToFunctionFn</span> (<span class="params">compile: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: CompilerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">CompiledFunctionResult</span> </span>&#123;</span><br><span class="line">    options = extend(&#123;&#125;, options)</span><br><span class="line">    <span class="keyword">const</span> warn = options.warn || baseWarn</span><br><span class="line">    <span class="keyword">delete</span> options.warn</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return 1'</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.toString().match(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems you are using the standalone build of Vue.js in an '</span> +</span><br><span class="line">            <span class="string">'environment with Content Security Policy that prohibits unsafe-eval. '</span> +</span><br><span class="line">            <span class="string">'The template compiler cannot work in this environment. Consider '</span> +</span><br><span class="line">            <span class="string">'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> +</span><br><span class="line">            <span class="string">'templates into render functions.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check cache</span></span><br><span class="line">    <span class="keyword">const</span> key = options.delimiters</span><br><span class="line">      ? <span class="built_in">String</span>(options.delimiters) + template</span><br><span class="line">      : template</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile</span></span><br><span class="line">    <span class="keyword">const</span> compiled = compile(template, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check compilation errors/tips</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compiled.errors &amp;&amp; compiled.errors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Error compiling template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">          compiled.errors.map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">`- <span class="subst">$&#123;e&#125;</span>`</span>).join(<span class="string">'\n'</span>) + <span class="string">'\n'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiled.tips &amp;&amp; compiled.tips.length) &#123;</span><br><span class="line">        compiled.tips.forEach(<span class="function"><span class="params">msg</span> =&gt;</span> tip(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn code into functions</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> fnGenErrors = []</span><br><span class="line">    res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class="line">    res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createFunction(code, fnGenErrors)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check function generation errors.</span></span><br><span class="line">    <span class="comment">// this should only happen if there is a bug in the compiler itself.</span></span><br><span class="line">    <span class="comment">// mostly for codegen development use</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Failed to generate render function:\n\n`</span> +</span><br><span class="line">          fnGenErrors.map(<span class="function">(<span class="params">&#123; err, code &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;err.toString()&#125;</span> in\n\n<span class="subst">$&#123;code&#125;</span>\n`</span>).join(<span class="string">'\n'</span>),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们总算找到了 <code>compileToFunctions</code> 的最终定义，它接收 3 个参数、编译模板 <code>template</code>，编译配置 <code>options</code> 和 Vue 实例 <code>vm</code>。核心的编译过程就一行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compiled = compile(template, options)</span><br></pre></td></tr></table></figure>

<p><code>compile</code> 函数在执行 <code>createCompileToFunctionFn</code> 的时候作为参数传入，它是 <code>createCompiler</code> 函数中定义的 <code>compile</code> 函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> finalOptions = <span class="built_in">Object</span>.create(baseOptions)</span><br><span class="line">  <span class="keyword">const</span> errors = []</span><br><span class="line">  <span class="keyword">const</span> tips = []</span><br><span class="line">  finalOptions.warn = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">    (tip ? tips : errors).push(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="comment">// merge custom modules</span></span><br><span class="line">    <span class="keyword">if</span> (options.modules) &#123;</span><br><span class="line">      finalOptions.modules =</span><br><span class="line">        (baseOptions.modules || []).concat(options.modules)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// merge custom directives</span></span><br><span class="line">    <span class="keyword">if</span> (options.directives) &#123;</span><br><span class="line">      finalOptions.directives = extend(</span><br><span class="line">        <span class="built_in">Object</span>.create(baseOptions.directives || <span class="literal">null</span>),</span><br><span class="line">        options.directives</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy other options</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key !== <span class="string">'modules'</span> &amp;&amp; key !== <span class="string">'directives'</span>) &#123;</span><br><span class="line">        finalOptions[key] = options[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> compiled = baseCompile(template, finalOptions)</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    errors.push.apply(errors, detectErrors(compiled.ast))</span><br><span class="line">  &#125;</span><br><span class="line">  compiled.errors = errors</span><br><span class="line">  compiled.tips = tips</span><br><span class="line">  <span class="keyword">return</span> compiled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compile</code> 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compiled = baseCompile(template, finalOptions)</span><br></pre></td></tr></table></figure>

<p><code>baseCompile</code> 在执行 <code>createCompilerCreator</code> 方法时作为参数传入</p>
<h3 id="baseCompile"><a href="#baseCompile" class="headerlink" title="baseCompile"></a>baseCompile</h3><p>这个函数就是我们实际去进行编译将template转化为render的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line">  optimize(ast, options)</span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>它分为三个步骤：</p>
<ul>
<li>将template转化为ast树</li>
<li>对ast树进行优化，为一些节点添加一些属性用于后面的渲染优化，如一些肯定不会发生变化的节点加上一个属性表明它是静态节点。</li>
<li>根据优化后的ast树生成代码，这个代码就可以用来生成vnode</li>
</ul>
<h2 id="通过一个例子来看编译的流程"><a href="#通过一个例子来看编译的流程" class="headerlink" title="通过一个例子来看编译的流程"></a>通过一个例子来看编译的流程</h2><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>编译过程首先就是对模板做解析，生成 AST，它是一种抽象语法树，是对源代码的抽象语法结构的树状表现形式。在很多编译技术中，如 babel 编译 ES6 的代码都会先生成 AST。</p>
<p>这个过程是比较复杂的，它会用到大量正则表达式对字符串解析，如果对正则不是很了解，建议先去补习正则表达式的知识。为了直观地演示 <code>parse</code> 的过程，我们先来看一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">:class</span>=<span class="string">"bindCls"</span> <span class="attr">class</span>=<span class="string">"list"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in data"</span> @<span class="attr">click</span>=<span class="string">"clickItem(index)"</span>&gt;</span>&#123;&#123;item&#125;&#125;:&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过 <code>parse</code> 过程后，生成的 AST 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ast = &#123;</span><br><span class="line">  <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'tag'</span>: <span class="string">'ul'</span>,</span><br><span class="line">  <span class="string">'attrsList'</span>: [],</span><br><span class="line">  <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">    <span class="string">':class'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">    <span class="string">'class'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'v-if'</span>: <span class="string">'isShow'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'if'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">  <span class="string">'ifConditions'</span>: [&#123;</span><br><span class="line">    <span class="string">'exp'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">    <span class="string">'block'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">'parent'</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">'staticClass'</span>: <span class="string">'list'</span>,</span><br><span class="line">  <span class="string">'classBinding'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">  <span class="string">'children'</span>: [&#123;</span><br><span class="line">    <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'tag'</span>: <span class="string">'li'</span>,</span><br><span class="line">    <span class="string">'attrsList'</span>: [&#123;</span><br><span class="line">      <span class="string">'name'</span>: <span class="string">'@click'</span>,</span><br><span class="line">      <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">      <span class="string">'@click'</span>: <span class="string">'clickItem(index)'</span>,</span><br><span class="line">      <span class="string">'v-for'</span>: <span class="string">'(item,index) in data'</span></span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="string">'parent'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">    <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'events'</span>: &#123;</span><br><span class="line">      <span class="string">'click'</span>: &#123;</span><br><span class="line">        <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'hasBindings'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'for'</span>: <span class="string">'data'</span>,</span><br><span class="line">    <span class="string">'alias'</span>: <span class="string">'item'</span>,</span><br><span class="line">    <span class="string">'iterator1'</span>: <span class="string">'index'</span>,</span><br><span class="line">    <span class="string">'children'</span>: [</span><br><span class="line">      <span class="string">'type'</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">'expression'</span>: <span class="string">'_s(item)+":"+_s(index)'</span></span><br><span class="line">      <span class="string">'text'</span>: <span class="string">'&#123;&#123;item&#125;&#125;:&#123;&#123;index&#125;&#125;'</span>,</span><br><span class="line">      <span class="string">'tokens'</span>: [</span><br><span class="line">        &#123;<span class="string">'@binding'</span>:<span class="string">'item'</span>&#125;,</span><br><span class="line">        <span class="string">':'</span>,</span><br><span class="line">        &#123;<span class="string">'@binding'</span>:<span class="string">'index'</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，生成的 AST 是一个树状结构，每一个节点都是一个 <code>ast element</code>，除了它自身的一些属性，还维护了它的父子关系，如 <code>parent</code> 指向它的父节点，<code>children</code> 指向它的所有子节点。先对 AST 有一些直观的印象，那么接下来我们来分析一下这个 AST 是如何得到的。</p>
<h3 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h3><p>当我们的模板 <code>template</code> 经过 <code>parse</code> 过程后，会输出生成 AST 树，那么接下来我们需要对这颗树做优化，<code>optimize</code> 的逻辑是远简单于 <code>parse</code> 的逻辑，所以理解起来会轻松很多。</p>
<p>为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 <code>patch</code> 的过程跳过对他们的比对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ast = &#123;</span><br><span class="line">  <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'tag'</span>: <span class="string">'ul'</span>,</span><br><span class="line">  <span class="string">'attrsList'</span>: [],</span><br><span class="line">  <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">    <span class="string">':class'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">    <span class="string">'class'</span>: <span class="string">'list'</span>,</span><br><span class="line">    <span class="string">'v-if'</span>: <span class="string">'isShow'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'if'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">  <span class="string">'ifConditions'</span>: [&#123;</span><br><span class="line">    <span class="string">'exp'</span>: <span class="string">'isShow'</span>,</span><br><span class="line">    <span class="string">'block'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">'parent'</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">'staticClass'</span>: <span class="string">'list'</span>,</span><br><span class="line">  <span class="string">'classBinding'</span>: <span class="string">'bindCls'</span>,</span><br><span class="line">  <span class="string">'static'</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">'staticRoot'</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">'children'</span>: [&#123;</span><br><span class="line">    <span class="string">'type'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'tag'</span>: <span class="string">'li'</span>,</span><br><span class="line">    <span class="string">'attrsList'</span>: [&#123;</span><br><span class="line">      <span class="string">'name'</span>: <span class="string">'@click'</span>,</span><br><span class="line">      <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'attrsMap'</span>: &#123;</span><br><span class="line">      <span class="string">'@click'</span>: <span class="string">'clickItem(index)'</span>,</span><br><span class="line">      <span class="string">'v-for'</span>: <span class="string">'(item,index) in data'</span></span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="string">'parent'</span>: <span class="comment">// ul ast element</span></span><br><span class="line">    <span class="string">'plain'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'events'</span>: &#123;</span><br><span class="line">      <span class="string">'click'</span>: &#123;</span><br><span class="line">        <span class="string">'value'</span>: <span class="string">'clickItem(index)'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'hasBindings'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'for'</span>: <span class="string">'data'</span>,</span><br><span class="line">    <span class="string">'alias'</span>: <span class="string">'item'</span>,</span><br><span class="line">    <span class="string">'iterator1'</span>: <span class="string">'index'</span>,</span><br><span class="line">    <span class="string">'static'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'staticRoot'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'children'</span>: [</span><br><span class="line">      <span class="string">'type'</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">'expression'</span>: <span class="string">'_s(item)+":"+_s(index)'</span></span><br><span class="line">      <span class="string">'text'</span>: <span class="string">'&#123;&#123;item&#125;&#125;:&#123;&#123;index&#125;&#125;'</span>,</span><br><span class="line">      <span class="string">'tokens'</span>: [</span><br><span class="line">        &#123;<span class="string">'@binding'</span>:<span class="string">'item'</span>&#125;,</span><br><span class="line">        <span class="string">':'</span>,</span><br><span class="line">        &#123;<span class="string">'@binding'</span>:<span class="string">'index'</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'static'</span>: <span class="literal">false</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="codegen"><a href="#codegen" class="headerlink" title="codegen"></a>codegen</h3><p>编译的最后一步就是把优化后的 AST 树转换成可执行的代码。</p>
<p>为了方便理解，我们还是用之前的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">:class</span>=<span class="string">"bindCls"</span> <span class="attr">class</span>=<span class="string">"list"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in data"</span> @<span class="attr">click</span>=<span class="string">"clickItem(index)"</span>&gt;</span>&#123;&#123;item&#125;&#125;:&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它经过编译，执行 <code>const code = generate(ast, options)</code>，生成的 <code>render</code> 代码串如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (isShow) ?</span><br><span class="line">    _c(<span class="string">'ul'</span>, &#123;</span><br><span class="line">        staticClass: <span class="string">"list"</span>,</span><br><span class="line">        class: bindCls</span><br><span class="line">      &#125;,</span><br><span class="line">      _l((data), <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _c(<span class="string">'li'</span>, &#123;</span><br><span class="line">          on: &#123;</span><br><span class="line">            <span class="string">"click"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$event</span>) </span>&#123;</span><br><span class="line">              clickItem(index)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [_v(_s(item) + <span class="string">":"</span> + _s(index))])</span><br><span class="line">      &#125;)</span><br><span class="line">    ) : _e()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>_c</code> 函数定义在 <code>src/core/instance/render.js</code> 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>而 <code>_l</code>、<code>_v</code> 定义在 <code>src/core/instance/render-helpers/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installRenderHelpers</span> (<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">  target._o = markOnce</span><br><span class="line">  target._n = toNumber</span><br><span class="line">  target._s = toString</span><br><span class="line">  target._l = renderList</span><br><span class="line">  target._t = renderSlot</span><br><span class="line">  target._q = looseEqual</span><br><span class="line">  target._i = looseIndexOf</span><br><span class="line">  target._m = renderStatic</span><br><span class="line">  target._f = resolveFilter</span><br><span class="line">  target._k = checkKeyCodes</span><br><span class="line">  target._b = bindObjectProps</span><br><span class="line">  target._v = createTextVNode</span><br><span class="line">  target._e = createEmptyVNode</span><br><span class="line">  target._u = resolveScopedSlots</span><br><span class="line">  target._g = bindObjectListeners</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义，<code>_c</code> 就是执行 <code>createElement</code> 去创建 VNode，而 <code>_l</code> 对应 <code>renderList</code> 渲染列表；<code>_v</code> 对应 <code>createTextVNode</code> 创建文本 VNode；<code>_e</code> 对于 <code>createEmptyVNode</code>创建空的 VNode。 </p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>通过刚才的例子，我们可以对整个编译的流程以及每一步的结果有个初步的了解。</p>
<p>如果有兴趣可以看下vue的源码，由于源码非常多，这里只是简单分析下。</p>
<h3 id="parse-1"><a href="#parse-1" class="headerlink" title="parse"></a>parse</h3><p>首先来看一下 <code>parse</code> 的定义，在 <code>src/compiler/parser/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ASTElement</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  getFnsAndConfigFromOptions(options)</span><br><span class="line"></span><br><span class="line">  parseHTML(template, &#123;</span><br><span class="line">    <span class="comment">// options ...</span></span><br><span class="line">    start (tag, attrs, unary) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = createASTElement(tag, attrs)</span><br><span class="line">      processElement(element)</span><br><span class="line">      treeManagement()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    end () &#123;</span><br><span class="line">      treeManagement()</span><br><span class="line">      closeElement()</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    chars (text: string) &#123;</span><br><span class="line">      handleText()</span><br><span class="line">      createChildrenASTOfText()</span><br><span class="line">    &#125;,</span><br><span class="line">    comment (text: string) &#123;</span><br><span class="line">      createChildrenASTOfComment()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> astRootElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parse</code> 函数的代码很长，贴一遍对同学的理解没有好处，我先把它拆成伪代码的形式，方便同学们对整体流程先有一个大致的了解。接下来我们就来分解分析每段伪代码的作用。</p>
<h4 id="从-options-中获取方法和配置"><a href="#从-options-中获取方法和配置" class="headerlink" title="从 options 中获取方法和配置"></a>从 options 中获取方法和配置</h4><p>对应伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getFnsAndConfigFromOptions(options)</span><br></pre></td></tr></table></figure>

<p><code>parse</code> 函数的输入是 <code>template</code> 和 <code>options</code>，输出是 AST 的根节点。<code>template</code> 就是我们的模板字符串，而 <code>options</code> 实际上是和平台相关的一些配置，它的定义在 <code>src/platforms/web/compiler/options</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  isPreTag,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  getTagNamespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules <span class="keyword">from</span> <span class="string">'./modules/index'</span></span><br><span class="line"><span class="keyword">import</span> directives <span class="keyword">from</span> <span class="string">'./directives/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; genStaticKeys &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isUnaryTag, canBeLeftOpenTag &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseOptions: CompilerOptions = &#123;</span><br><span class="line">  expectHTML: <span class="literal">true</span>,</span><br><span class="line">  modules,</span><br><span class="line">  directives,</span><br><span class="line">  isPreTag,</span><br><span class="line">  isUnaryTag,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  canBeLeftOpenTag,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  staticKeys: genStaticKeys(modules)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些属性和方法之所以放到 <code>platforms</code> 目录下是因为它们在不同的平台（web 和 weex）的实现是不同的。</p>
<p>我们用伪代码 <code>getFnsAndConfigFromOptions</code> 表示了这一过程，它的实际代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">warn = options.warn || baseWarn</span><br><span class="line"></span><br><span class="line">platformIsPreTag = options.isPreTag || no</span><br><span class="line">platformMustUseProp = options.mustUseProp || no</span><br><span class="line">platformGetTagNamespace = options.getTagNamespace || no</span><br><span class="line"></span><br><span class="line">transforms = pluckModuleFunction(options.modules, <span class="string">'transformNode'</span>)</span><br><span class="line">preTransforms = pluckModuleFunction(options.modules, <span class="string">'preTransformNode'</span>)</span><br><span class="line">postTransforms = pluckModuleFunction(options.modules, <span class="string">'postTransformNode'</span>)</span><br><span class="line"></span><br><span class="line">delimiters = options.delimiters</span><br></pre></td></tr></table></figure>

<p>这些方法和配置都是后续解析时候需要的，可以不用去管它们的具体作用，我们先往后看。</p>
<h4 id="解析-HTML-模板"><a href="#解析-HTML-模板" class="headerlink" title="解析 HTML 模板"></a>解析 HTML 模板</h4><p>对应伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parseHTML(template, options)</span><br></pre></td></tr></table></figure>

<p>对于 <code>template</code> 模板的解析主要是通过 <code>parseHTML</code> 函数，它的定义在 <code>src/compiler/parser/html-parser</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span> (<span class="params">html, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTag</span><br><span class="line">  <span class="keyword">while</span> (html) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lastTag || !isPlainTextElement(lastTag))&#123;</span><br><span class="line">      <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">'&lt;'</span>)</span><br><span class="line">      <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(matchComment) &#123;</span><br><span class="line">           advance(commentLength)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(matchDoctype) &#123;</span><br><span class="line">           advance(doctypeLength)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(matchEndTag) &#123;</span><br><span class="line">           advance(endTagLength)</span><br><span class="line">           parseEndTag()</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(matchStartTag) &#123;</span><br><span class="line">           parseStartTag()</span><br><span class="line">           handleStartTag()</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      handleText()</span><br><span class="line">      advance(textLength)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       handlePlainTextElement()</span><br><span class="line">       parseEndTag()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>parseHTML</code> 的逻辑也非常复杂，因此我也用了伪代码的方式表达，整体来说它的逻辑就是循环解析 <code>template</code> ，用正则做各种匹配，对于不同情况分别进行不同的处理，直到整个 template 被解析完毕。<br>在匹配的过程中会利用 <code>advance</code> 函数不断前进整个模板字符串，直到字符串末尾。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  index += n</span><br><span class="line">  html = html.substring(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个匹配过程分为以下几步：</p>
<ul>
<li>找到第一个左尖括号的位置，如果是0，表明这是个标签的，进入标签的处理流程，如果不是，说明这个尖括号处在某个字符串中，进入handlePlainTextElement（）流程</li>
<li>如果是个标签，判断是否是注释节点，如果是注释节点，跳过注释部分</li>
<li>如果是doctype，跳过</li>
<li>如果是结束标签，也就是说这种，则前进标签长度，并处理闭合标签</li>
<li>如果是开始标签，则前进标签长度，执行handleStartTag（），这个函数首先是创建一个ast的node出来，第二就是把当前标签压栈，并赋值给lastTag，为什么要压栈呢？是为了在上一步处理闭合标签时如果标签相同从栈里弹出来，最终html编译完成之后栈为空才说明所有标签闭合的。</li>
</ul>
<p>当然这个流程是一个非常简单的介绍，里面隐藏了非常多的细节，有兴趣可以自己去看看源码。</p>
<h3 id="optimize-1"><a href="#optimize-1" class="headerlink" title="optimize"></a>optimize</h3><p>来看一下 <code>optimize</code> 方法的定义，在 <code>src/compiler/optimizer.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Goal of the optimizer: walk the generated template AST tree</span></span><br><span class="line"><span class="comment"> * and detect sub-trees that are purely static, i.e. parts of</span></span><br><span class="line"><span class="comment"> * the DOM that never needs to change.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Once we detect these sub-trees, we can:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Hoist them into constants, so that we no longer need to</span></span><br><span class="line"><span class="comment"> *    create fresh nodes for them on each re-render;</span></span><br><span class="line"><span class="comment"> * 2. Completely skip them in the patching process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">optimize</span> (<span class="params">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class="string">''</span>)</span><br><span class="line">  isPlatformReservedTag = options.isReservedTag || no</span><br><span class="line">  <span class="comment">// first pass: mark all non-static nodes.</span></span><br><span class="line">  markStatic(root)</span><br><span class="line">  <span class="comment">// second pass: mark static roots.</span></span><br><span class="line">  markStaticRoots(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genStaticKeys</span> (<span class="params">keys: string</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeMap(</span><br><span class="line">    <span class="string">'type,tag,attrsList,attrsMap,plain,parent,children,attrs'</span> +</span><br><span class="line">    (keys ? <span class="string">','</span> + keys : <span class="string">''</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在编译阶段可以把一些 AST 节点优化成静态节点，所以整个 <code>optimize</code> 的过程实际上就干 2 件事情，<code>markStatic(root)</code> 标记静态节点 ，<code>markStaticRoots(root, false)</code> 标记静态根。</p>
<h4 id="标记静态节点"><a href="#标记静态节点" class="headerlink" title="标记静态节点"></a>标记静态节点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStatic</span> (<span class="params">node: ASTNode</span>) </span>&#123;</span><br><span class="line">  node.static = isStatic(node)</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// do not make component slot content static. this avoids</span></span><br><span class="line">    <span class="comment">// 1. components not able to mutate slot nodes</span></span><br><span class="line">    <span class="comment">// 2. static slot content fails for hot-reloading</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !isPlatformReservedTag(node.tag) &amp;&amp;</span><br><span class="line">      node.tag !== <span class="string">'slot'</span> &amp;&amp;</span><br><span class="line">      node.attrsMap[<span class="string">'inline-template'</span>] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = node.children[i]</span><br><span class="line">      markStatic(child)</span><br><span class="line">      <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">        node.static = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.ifConditions) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> block = node.ifConditions[i].block</span><br><span class="line">        markStatic(block)</span><br><span class="line">        <span class="keyword">if</span> (!block.static) &#123;</span><br><span class="line">          node.static = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span> (<span class="params">node: ASTNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123; <span class="comment">// expression</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123; <span class="comment">// text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !!(node.pre || (</span><br><span class="line">    !node.hasBindings &amp;&amp; <span class="comment">// no dynamic bindings</span></span><br><span class="line">    !node.if &amp;&amp; !node.for &amp;&amp; <span class="comment">// not v-if or v-for or v-else</span></span><br><span class="line">    !isBuiltInTag(node.tag) &amp;&amp; <span class="comment">// not a built-in</span></span><br><span class="line">    isPlatformReservedTag(node.tag) &amp;&amp; <span class="comment">// not a component</span></span><br><span class="line">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.keys(node).every(isStaticKey)</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行 <code>node.static = isStatic(node)</code></p>
<p><code>isStatic</code> 是对一个 AST 元素节点是否是静态的判断，如果是表达式，就是非静态；如果是纯文本，就是静态；对于一个普通元素，如果有 pre 属性，那么它使用了 <code>v-pre</code> 指令，是静态，否则要同时满足以下条件：没有使用 <code>v-if</code>、<code>v-for</code>，没有使用其它指令（不包括 <code>v-once</code>），非内置组件，是平台保留的标签，非带有 <code>v-for</code> 的 <code>template</code> 标签的直接子节点，节点的所有属性的 <code>key</code> 都满足静态 key；这些都满足则这个 AST 节点是一个静态节点。</p>
<p>如果这个节点是一个普通元素，则遍历它的所有 <code>children</code>，递归执行 <code>markStatic</code>。因为所有的 <code>elseif</code> 和 <code>else</code> 节点都不在 <code>children</code> 中， 如果节点的 <code>ifConditions</code> 不为空，则遍历 <code>ifConditions</code> 拿到所有条件中的 <code>block</code>，也就是它们对应的 AST 节点，递归执行 <code>markStatic</code>。在这些递归过程中，一旦子节点有不是 <code>static</code> 的情况，则它的父节点的 <code>static</code> 均变成 false。</p>
<h4 id="标记静态根"><a href="#标记静态根" class="headerlink" title="标记静态根"></a>标记静态根</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span> (<span class="params">node: ASTNode, isInFor: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.static || node.once) &#123;</span><br><span class="line">      node.staticInFor = isInFor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For a node to qualify as a static root, it should have children that</span></span><br><span class="line">    <span class="comment">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class="line">    <span class="comment">// outweigh the benefits and it's better off to just always render it fresh.</span></span><br><span class="line">    <span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">      node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">      node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">    )) &#123;</span><br><span class="line">      node.staticRoot = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.staticRoot = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.ifConditions) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class="line">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>markStaticRoots</code> 第二个参数是 <code>isInFor</code>，对于已经是 <code>static</code> 的节点或者是 <code>v-once</code> 指令的节点，<code>node.staticInFor = isInFor</code>。<br>接着就是对于 <code>staticRoot</code> 的判断逻辑，从注释中我们可以看到，对于有资格成为 <code>staticRoot</code> 的节点，除了本身是一个静态节点外，必须满足拥有 <code>children</code>，并且 <code>children</code> 不能只是一个文本节点，不然的话把它标记成静态根节点的收益就很小了。</p>
<p>接下来和标记静态节点的逻辑一样，遍历 <code>children</code> 以及 <code>ifConditions</code>，递归执行 <code>markStaticRoots</code>。</p>
<h3 id="codegen-1"><a href="#codegen-1" class="headerlink" title="codegen"></a>codegen</h3><p><code>generate</code> 函数的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ast: ASTElement | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CodegenResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line">  <span class="keyword">const</span> code = ast ? genElement(ast, state) : <span class="string">'_c("div")'</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    staticRenderFns: state.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generate</code> 函数首先通过 <code>genElement(ast, state)</code> 生成 <code>code</code>，再把 <code>code</code> 用 <code>with(this){return ${code}}}</code> 包裹起来。这里的 <code>state</code> 是 <code>CodegenState</code> 的一个实例，稍后我们在用到它的时候会介绍它。先来看一下 <code>genElement</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genElement</span> (<span class="params">el: ASTElement, state: CodegenState</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genStatic(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genOnce(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genFor(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    <span class="keyword">return</span> genIf(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">'template'</span> &amp;&amp; !el.slotTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> genChildren(el, state) || <span class="string">'void 0'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    <span class="keyword">let</span> code</span><br><span class="line">    <span class="keyword">if</span> (el.component) &#123;</span><br><span class="line">      code = genComponent(el.component, el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = el.plain ? <span class="literal">undefined</span> : genData(el, state)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> children = el.inlineTemplate ? <span class="literal">null</span> : genChildren(el, state, <span class="literal">true</span>)</span><br><span class="line">      code = <span class="string">`_c('<span class="subst">$&#123;el.tag&#125;</span>'<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        data ? <span class="string">`,<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">''</span> <span class="regexp">//</span> data</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">''</span> <span class="regexp">//</span> children</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// module transforms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class="line">      code = state.transforms[i](el, code)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本就是判断当前 AST 元素节点的属性执行不同的代码生成函数。</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>上面的源码分析部分省略了很多很多的细节，有的是html解析相关的，如parseHTML函数只写了伪代码，有的是vue语法糖处理相关的，如codegen只写了genIF，genSlot，具体做了什么没有说，这里我们就用slot举个例子，其他的有需要大家可以自己看。</p>
<p>还是先从编译说起，我们知道编译是发生在调用 <code>vm.$mount</code> 的时候，所以编译的顺序是先编译父组件，再编译子组件。</p>
<p>首先编译父组件，在 <code>parse</code> 阶段，会执行 <code>processSlot</code> 处理 <code>slot</code>，它的定义在 <code>src/compiler/parser/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processSlot</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">    el.slotName = getBindingAttr(el, <span class="string">'name'</span>)</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; el.key) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`\`key\` does not work on &lt;slot&gt; because slots are abstract outlets `</span> +</span><br><span class="line">        <span class="string">`and can possibly expand into multiple elements. `</span> +</span><br><span class="line">        <span class="string">`Use the key on a wrapping element instead.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> slotScope</span><br><span class="line">    <span class="keyword">if</span> (el.tag === <span class="string">'template'</span>) &#123;</span><br><span class="line">      slotScope = getAndRemoveAttr(el, <span class="string">'scope'</span>)</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; slotScope) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`the "scope" attribute for scoped slots have been deprecated and `</span> +</span><br><span class="line">          <span class="string">`replaced by "slot-scope" since 2.5. The new "slot-scope" attribute `</span> +</span><br><span class="line">          <span class="string">`can also be used on plain elements in addition to &lt;template&gt; to `</span> +</span><br><span class="line">          <span class="string">`denote scoped slots.`</span>,</span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      el.slotScope = slotScope || getAndRemoveAttr(el, <span class="string">'slot-scope'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((slotScope = getAndRemoveAttr(el, <span class="string">'slot-scope'</span>))) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; el.attrsMap[<span class="string">'v-for'</span>]) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Ambiguous combined usage of slot-scope and v-for on &lt;<span class="subst">$&#123;el.tag&#125;</span>&gt; `</span> +</span><br><span class="line">          <span class="string">`(v-for takes higher priority). Use a wrapper &lt;template&gt; for the `</span> +</span><br><span class="line">          <span class="string">`scoped slot to make it clearer.`</span>,</span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      el.slotScope = slotScope</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> slotTarget = getBindingAttr(el, <span class="string">'slot'</span>)</span><br><span class="line">    <span class="keyword">if</span> (slotTarget) &#123;</span><br><span class="line">      el.slotTarget = slotTarget === <span class="string">'""'</span> ? <span class="string">'"default"'</span> : slotTarget</span><br><span class="line">      <span class="comment">// preserve slot as an attribute for native shadow DOM compat</span></span><br><span class="line">      <span class="comment">// only for non-scoped slots.</span></span><br><span class="line">      <span class="keyword">if</span> (el.tag !== <span class="string">'template'</span> &amp;&amp; !el.slotScope) &#123;</span><br><span class="line">        addAttr(el, <span class="string">'slot'</span>, slotTarget)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当解析到标签上有 <code>slot</code> 属性的时候，会给对应的 AST<br>元素节点添加 <code>slotTarget</code> 属性，然后在 <code>codegen</code> 阶段，在 <code>genData</code> 中会处理 <code>slotTarget</code>，相关代码在 <code>src/compiler/codegen/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.slotTarget &amp;&amp; !el.slotScope) &#123;</span><br><span class="line">  data += <span class="string">`slot:<span class="subst">$&#123;el.slotTarget&#125;</span>,`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会给 <code>data</code> 添加一个 <code>slot</code> 属性，并指向 <code>slotTarget</code>，之后会用到。在我们的例子中，父组件最终生成的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">'div'</span>,</span><br><span class="line">    [_c(<span class="string">'app-layout'</span>,</span><br><span class="line">      [_c(<span class="string">'h1'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"slot"</span>:<span class="string">"header"</span>&#125;,<span class="attr">slot</span>:<span class="string">"header"</span>&#125;,</span><br><span class="line">         [_v(_s(title))]),</span><br><span class="line">       _c(<span class="string">'p'</span>,[_v(_s(msg))]),</span><br><span class="line">       _c(<span class="string">'p'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"slot"</span>:<span class="string">"footer"</span>&#125;,<span class="attr">slot</span>:<span class="string">"footer"</span>&#125;,</span><br><span class="line">         [_v(_s(desc))]</span><br><span class="line">         )</span><br><span class="line">       ])</span><br><span class="line">     ],</span><br><span class="line">   <span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编译子组件，同样在 <code>parser</code> 阶段会执行 <code>processSlot</code> 处理函数，它的定义在 <code>src/compiler/parser/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processSlot</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.tag === <span class="string">'slot'</span>) &#123;</span><br><span class="line">    el.slotName = getBindingAttr(el, <span class="string">'name'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到 <code>slot</code> 标签的时候会给对应的 AST 元素节点添加 <code>slotName</code> 属性，然后在 <code>codegen</code> 阶段，会判断如果当前 AST 元素节点是 <code>slot</code> 标签，则执行 <code>genSlot</code> 函数，它的定义在 <code>src/compiler/codegen/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genSlot</span> (<span class="params">el: ASTElement, state: CodegenState</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> slotName = el.slotName || <span class="string">'"default"'</span></span><br><span class="line">  <span class="keyword">const</span> children = genChildren(el, state)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">`_t(<span class="subst">$&#123;slotName&#125;</span><span class="subst">$&#123;children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span></span><br><span class="line">  <span class="keyword">const</span> attrs = el.attrs &amp;&amp; <span class="string">`&#123;<span class="subst">$&#123;el.attrs.map(a =&gt; <span class="string">`<span class="subst">$&#123;camelize(a.name)&#125;</span>:<span class="subst">$&#123;a.value&#125;</span>`</span>).join(<span class="string">','</span>)&#125;</span>&#125;`</span></span><br><span class="line">  <span class="keyword">const</span> bind = el.attrsMap[<span class="string">'v-bind'</span>]</span><br><span class="line">  <span class="keyword">if</span> ((attrs || bind) &amp;&amp; !children) &#123;</span><br><span class="line">    res += <span class="string">`,null`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (attrs) &#123;</span><br><span class="line">    res += <span class="string">`,<span class="subst">$&#123;attrs&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bind) &#123;</span><br><span class="line">    res += <span class="string">`<span class="subst">$&#123;attrs ? <span class="string">''</span> : <span class="string">',null'</span>&#125;</span>,<span class="subst">$&#123;bind&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res + <span class="string">')'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不考虑 <code>slot</code> 标签上有 <code>attrs</code> 以及 <code>v-bind</code> 的情况，那么它生成的代码实际上就只有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> slotName = el.slotName || <span class="string">'"default"'</span></span><br><span class="line"><span class="keyword">const</span> children = genChildren(el, state)</span><br><span class="line"><span class="keyword">let</span> res = <span class="string">`_t(<span class="subst">$&#123;slotName&#125;</span><span class="subst">$&#123;children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>slotName</code> 从 AST 元素节点对应的属性上取，默认是 <code>default</code>，而 <code>children</code> 对应的就是 <code>slot</code> 开始和闭合标签包裹的内容。来看一下我们例子的子组件最终生成的代码，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;</span><br><span class="line">    staticClass:<span class="string">"container"</span></span><br><span class="line">    &#125;,[</span><br><span class="line">      _c(<span class="string">'header'</span>,[_t(<span class="string">"header"</span>)],<span class="number">2</span>),</span><br><span class="line">      _c(<span class="string">'main'</span>,[_t(<span class="string">"default"</span>,[_v(<span class="string">"默认内容"</span>)])],<span class="number">2</span>),</span><br><span class="line">      _c(<span class="string">'footer'</span>,[_t(<span class="string">"footer"</span>)],<span class="number">2</span>)</span><br><span class="line">      ]</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译章节我们了解到，<code>_t</code> 函数对应的就是 <code>renderSlot</code> 方法，它的定义在 <code>src/core/instance/render-heplpers/render-slot.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for rendering &lt;slot&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  fallback: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  bindObject: ?Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scopedSlotFn = <span class="keyword">this</span>.$scopedSlots[name]</span><br><span class="line">  <span class="keyword">let</span> nodes</span><br><span class="line">  <span class="keyword">if</span> (scopedSlotFn) &#123; <span class="comment">// scoped slot</span></span><br><span class="line">    props = props || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (bindObject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !isObject(bindObject)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'slot v-bind without argument expects an Object'</span>,</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      props = extend(extend(&#123;&#125;, bindObject), props)</span><br><span class="line">    &#125;</span><br><span class="line">    nodes = scopedSlotFn(props) || fallback</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> slotNodes = <span class="keyword">this</span>.$slots[name]</span><br><span class="line">    <span class="comment">// warn duplicate slot usage</span></span><br><span class="line">    <span class="keyword">if</span> (slotNodes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; slotNodes._rendered) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Duplicate presence of slot "<span class="subst">$&#123;name&#125;</span>" found in the same render tree `</span> +</span><br><span class="line">          <span class="string">`- this will likely cause render errors.`</span>,</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      slotNodes._rendered = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    nodes = slotNodes || fallback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> target = props &amp;&amp; props.slot</span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$createElement(<span class="string">'template'</span>, &#123; <span class="attr">slot</span>: target &#125;, nodes)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>render-slot</code> 的参数 <code>name</code> 代表插槽名称 <code>slotName</code>，<code>fallback</code> 代表插槽的默认内容生成的 <code>vnode</code> 数组。先忽略 <code>scoped-slot</code>，只看默认插槽逻辑。如果 <code>this.$slot[name]</code> 有值，就返回它对应的 <code>vnode</code> 数组，否则返回 <code>fallback</code>。那么这个 <code>this.$slot</code> 是哪里来的呢？我们知道子组件的 <code>init</code> 时机是在父组件执行 <code>patch</code> 过程的时候，那这个时候父组件已经编译完成了。并且子组件在 <code>init</code> 过程中会执行 <code>initRender</code> 函数，<code>initRender</code> 的时候获取到 <code>vm.$slot</code>，相关代码在 <code>src/core/instance/render.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = vm.$vnode = options._parentVnode <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vm.$slots</code> 是通过执行 <code>resolveSlots(options._renderChildren, renderContext)</code> 返回的，它的定义在 <code>src/core/instance/render-helpers/resolve-slots.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for resolving raw children VNodes into a slot object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveSlots</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: ?Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123; [key: string]: <span class="built_in">Array</span>&lt;VNode&gt; &#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> slots = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!children) &#123;</span><br><span class="line">    <span class="keyword">return</span> slots</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = children[i]</span><br><span class="line">    <span class="keyword">const</span> data = child.data</span><br><span class="line">    <span class="comment">// remove slot attribute if the node is resolved as a Vue slot node</span></span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data.attrs.slot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// named slots should only be respected if the vnode was rendered in the</span></span><br><span class="line">    <span class="comment">// same context.</span></span><br><span class="line">    <span class="keyword">if</span> ((child.context === context || child.fnContext === context) &amp;&amp;</span><br><span class="line">      data &amp;&amp; data.slot != <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = data.slot</span><br><span class="line">      <span class="keyword">const</span> slot = (slots[name] || (slots[name] = []))</span><br><span class="line">      <span class="keyword">if</span> (child.tag === <span class="string">'template'</span>) &#123;</span><br><span class="line">        slot.push.apply(slot, child.children || [])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        slot.push(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (slots.default || (slots.default = [])).push(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ignore slots that contains only whitespace</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> slots) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slots[name].every(isWhitespace)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> slots[name]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slots</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolveSlots</code> 方法接收 2 个参数，第一个参数 <code>chilren</code> 对应的是父 <code>vnode</code> 的 <code>children</code>，在我们的例子中就是 <code>&lt;app-layout&gt;</code> 和 <code>&lt;/app-layout&gt;</code> 包裹的内容。第二个参数 <code>context</code> 是父 <code>vnode</code> 的上下文，也就是父组件的 <code>vm</code> 实例。</p>
<p><code>resolveSlots</code> 函数的逻辑就是遍历 <code>chilren</code>，拿到每一个 <code>child</code> 的 <code>data</code>，然后通过 <code>data.slot</code> 获取到插槽名称，这个 <code>slot</code> 就是我们之前编译父组件在 <code>codegen</code> 阶段设置的 <code>data.slot</code>。接着以插槽名称为 <code>key</code> 把 <code>child</code> 添加到 <code>slots</code> 中，如果 <code>data.slot</code> 不存在，则是默认插槽的内容，则把对应的 <code>child</code> 添加到 <code>slots.defaults</code> 中。这样就获取到整个 <code>slots</code>，它是一个对象，<code>key</code> 是插槽名称，<code>value</code> 是一个 <code>vnode</code> 类型的数组，因为它可以有多个同名插槽。</p>
<p>这样我们就拿到了 <code>vm.$slots</code> 了，回到 <code>renderSlot</code> 函数，<code>const slotNodes = this.$slots[name]</code>，我们也就能根据插槽名称获取到对应的 <code>vnode</code> 数组了，这个数组里的 <code>vnode</code> 都是在父组件创建的，这样就实现了在父组替换子组件插槽的内容了。</p>
<p>对应的 <code>slot</code> 渲染成 <code>vnodes</code>，作为当前组件渲染 <code>vnode</code> 的 <code>children</code>，之后的渲染过程之前分析过，不再赘述。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-test-utils</title>
    <url>/2020/01/03/vue-test-utils/</url>
    <content><![CDATA[<p>Vue-test-utils 是官方提供的内置在vue中的一个测试工具，它可以加载某个vue实例并可以提取，替换其中的方法，属性，事件等。</p>
<p>其实熟悉了Vue框架之后，再来看vue-test-util工具会很容易，因为二者之间的许多概念是相同的。</p>
<p>这篇博客基于vue-test-utils，vue的官方文档，对于部分官方文档中有歧义的地方进行了尝试，也参考了一些博客之后进行了解释。主要是用于概念的理解以及基本的几个用法的解释。</p>
<a id="more"></a>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h2><ul>
<li><p>参数</p>
<ul>
<li>component: Component</li>
<li>options: Options</li>
</ul>
</li>
<li><p>返回值：Wrapper</p>
</li>
<li><p>options</p>
<ul>
<li><p>context：Object</p>
<p>将上下文传递给函数式组件，该选项只能用于<a href="[https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6](https://cn.vuejs.org/v2/guide/render-function.html#函数式组件)">函数式组件</a> </p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar.vue'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">  context: &#123;</span><br><span class="line">    props: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    children: [Foo, Bar]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.is(Component)).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>slots:  Array<component>|Component|string</component></p>
<p>为组件提供一个 slot 内容的对象。该对象中的键名就是相应的 slot 名，键值可以是一个组件、一个组件数组、一个字符串模板或文本。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bazComponent = &#123;</span><br><span class="line">  name: <span class="string">'baz-component'</span>,</span><br><span class="line">  template: <span class="string">'&lt;p&gt;baz&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(Component, &#123;</span><br><span class="line">  slots: &#123;</span><br><span class="line">    <span class="keyword">default</span>: [Foo, <span class="string">'&lt;my-component /&gt;'</span>, <span class="string">'text'</span>],</span><br><span class="line">    fooBar: Foo, <span class="comment">// 将会匹配 `&lt;slot name="FooBar" /&gt;`.</span></span><br><span class="line">    foo: <span class="string">'&lt;div /&gt;'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span>,</span><br><span class="line">    baz: bazComponent,</span><br><span class="line">    qux: <span class="string">'&lt;my-component /&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">expect(wrapper.find(<span class="string">'div'</span>)).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>这里官方文档的描述太过简单，可能会产生歧义，如果大家对这段内容有疑惑，可以查看<a href="https://alexjover.com/blog/test-vue-js-slots-in-jest/" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a></p>
</li>
<li><p>scopedSlots</p>
<p>提供一个该组件所有<a href="[https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD](https://cn.vuejs.org/v2/guide/components-slots.html#作用域插槽)">作用域插槽</a>的对象。每个键对应到插槽的名字。</p>
<p>你可以使用 slot-scope 特性设置 prop 的名称：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shallowMount(Component, &#123;</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    foo: <span class="string">'&lt;p slot-scope="foo"&gt;&#123;&#123;foo.index&#125;&#125;,&#123;&#123;foo.text&#125;&#125;&lt;/p&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>否则插槽被计算的时候可以通过 <code>props</code> 对象使用 prop：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shallowMount(Component, &#123;</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'&lt;p&gt;&#123;&#123;props.index&#125;&#125;,&#123;&#123;props.text&#125;&#125;&lt;/p&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你也可以传递一个函数将 prop 作为参数带入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shallowMount(Component, &#123;</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$createElement(<span class="string">'div'</span>, props.index)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者你可以使用 JSX。如果你在一个方法里撰写 JSX，babel-plugin-transform-vue-jsx 会自动注入 <code>this.$createElement</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shallowMount(Component, &#123;</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    foo(props) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>stubs:<code>{ [name: string]: Component | boolean } | Array</code></p>
<p>将子组件存根。可以是一个要存根的组件名的数组或对象。如果 <code>stubs</code> 是一个数组，则每个存根都是一个 <code>&lt;${component name}-stub&gt;</code>。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line">mount(Component, &#123;</span><br><span class="line">  stubs: [<span class="string">'registered-component'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">shallowMount(Component, &#123;</span><br><span class="line">  stubs: &#123;</span><br><span class="line">    <span class="comment">// 使用一个特定的实现作为存根</span></span><br><span class="line">    <span class="string">'registered-component'</span>: Foo,</span><br><span class="line">    <span class="comment">// 使用创建默认的实现作为存根。</span></span><br><span class="line">    <span class="comment">// 这里默认存根的组件名是 `another-component`。</span></span><br><span class="line">    <span class="comment">// 默认存根是 `&lt;$&#123;the component name of default stub&#125;-stub&gt;`。</span></span><br><span class="line">    <span class="string">'another-component'</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>mocks: Object</p>
<p>为实例添加额外的属性。在伪造全局注入的时候有用。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $route = &#123; <span class="attr">path</span>: <span class="string">'http://www.example-path.com'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(Component, &#123;</span><br><span class="line">  mocks: &#123;</span><br><span class="line">    $route</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.vm.$route.path).toBe($route.path)</span><br></pre></td></tr></table></figure>
</li>
<li><p>localVue: Vue</p>
<p>通过 [<code>./createLocalVue.md</code>] 创建的一个 <code>Vue</code> 的本地拷贝，用于挂载该组件的时候。在这份拷贝上安装插件可以防止原始的 <code>Vue</code> 被污染。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createLocalVue, mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localVue = createLocalVue()</span><br><span class="line">localVue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">  localVue,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.vm.$route).toBeInstanceOf(<span class="built_in">Object</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>attachToDocument: Boolean</p>
<p>当设为 <code>true</code> 时，组件在渲染时将会挂载到 DOM 上。</p>
<p>如果添加到了 DOM 上，你应该在测试的最后调用 <code>wrapper.destroy()</code> 将元素从文档中移除并销毁组件实例。</p>
</li>
<li><p>attrs: Object</p>
<p>设置组件实例的 <code>$attrs</code> 对象。</p>
</li>
<li><p>propsData</p>
<p>在组件被挂载时设置组件实例的 prop。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">  props: [<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    msg: <span class="string">'aBC'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.text()).toBe(<span class="string">'aBC'</span>)</span><br></pre></td></tr></table></figure>

<p>提示</p>
<p>值得注意的是 <code>propsData</code> 实际上是一个 <a href="https://cn.vuejs.org/v2/api/#propsData" rel="external nofollow noopener noreferrer" target="_blank">Vue API</a>，不是 Vue Test Utils 的挂载选项。它会被 <a href="https://cn.vuejs.org/v2/api/#extends" rel="external nofollow noopener noreferrer" target="_blank"><code>extends</code></a> 处理。请查阅<a href="https://vue-test-utils.vuejs.org/zh/api/options.html#其它选项" rel="external nofollow noopener noreferrer" target="_blank">其它选项</a>。</p>
</li>
<li><p>listeners： Object</p>
<p>设置组件实例的 <code>$listeners</code> 对象。</p>
</li>
<li><p>parentComponent: Object</p>
<p>用来作为被挂载组件的父级组件。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(Component, &#123;</span><br><span class="line">  parentComponent: Foo</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.vm.$parent.$options.name).toBe(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>provide: Object</p>
<p>为组件传递用于注入的属性。可查阅 <a href="https://cn.vuejs.org/v2/api/#provide-inject" rel="external nofollow noopener noreferrer" target="_blank">provie/inject</a> 了解更多。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  inject: [<span class="string">'foo'</span>],</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123;this.foo()&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(Component, &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'fooValue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">expect(wrapper.text()).toBe(<span class="string">'fooValue'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它选项</p>
<p>当 <code>mount</code> 和 <code>shallowMount</code> 的选项包含了挂载选项之外的选项时，则会将它们通过<a href="https://vuejs.org/v2/api/#extends" rel="external nofollow noopener noreferrer" target="_blank">扩展</a>覆写到其组件选项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; foo() &#125;&#125;&#123;&#123; bar() &#125;&#125;&#123;&#123; baz() &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bar() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'b'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Component, options)</span><br><span class="line">expect(wrapper.text()).toBe(<span class="string">'aBC'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ShallowMount"><a href="#ShallowMount" class="headerlink" title="ShallowMount"></a>ShallowMount</h2><p>用法与mount相同，只不过会将所有子组件给stub，类似mount的options中的stub属性把所有子组件填写后的效果</p>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>将一个对象渲染成为一个字符串并返回一个 <a href="https://github.com/cheeriojs/cheerio" rel="external nofollow noopener noreferrer" target="_blank">cheerio 包裹器</a>。</p>
<p>Cheerio 是一个类似 jQuery 的库，可以在 Node.js 中游览 DOM 对象。它的 API 和 Vue Test Utils 的 <a href="https://vue-test-utils.vuejs.org/zh/api/wrapper/" rel="external nofollow noopener noreferrer" target="_blank"><code>Wrapper</code></a> 类似。</p>
<p><code>render</code> 在底层使用 <a href="https://ssr.vuejs.org/zh/basic.html" rel="external nofollow noopener noreferrer" target="_blank"><code>vue-server-renderer</code></a> 将一个组件渲染为静态的 HTML。</p>
<p><code>render</code> 被包含在了 <code>@vue/server-test-utils</code> 包之中。</p>
<h2 id="renderToString"><a href="#renderToString" class="headerlink" title="renderToString"></a>renderToString</h2><p>将一个组件渲染为 HTML。</p>
<p><code>renderToString</code> 在底层使用 <a href="https://ssr.vuejs.org/en/basic.html" rel="external nofollow noopener noreferrer" target="_blank"><code>vue-server-renderer</code></a> 将一个组件渲染为 HTML。</p>
<h2 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h2><p>很多方法的参数中都包含选择器。一个选择器可以是一个 CSS 选择器、一个 Vue 组件或是一个查找选项对象</p>
<h2 id="createLocalVue"><a href="#createLocalVue" class="headerlink" title="createLocalVue"></a>createLocalVue</h2><ul>
<li><strong>返回值：</strong><ul>
<li><code>{Component}</code></li>
</ul>
</li>
<li><strong>用法：</strong></li>
</ul>
<p><code>createLocalVue</code> 返回一个 Vue 的类供你添加组件、混入和安装插件而不会污染全局的 Vue 类。</p>
<p>可通过 <code>options.localVue</code> 来使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createLocalVue, shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localVue = createLocalVue()</span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(Foo, &#123;</span><br><span class="line">  localVue,</span><br><span class="line">  mocks: &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">expect(wrapper.vm.foo).toBe(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freshWrapper = shallowMount(Foo)</span><br><span class="line">expect(freshWrapper.vm.foo).toBe(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="createWrapper-node-options"><a href="#createWrapper-node-options" class="headerlink" title="createWrapper(node [, options])"></a>createWrapper(node [, options])</h2><ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><p><code>{vm|HTMLElement} node</code></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;Object&#125; options</span><br></pre></td></tr></table></figure>

<ul>
<li><code>{Boolean} attachedToDocument</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值：</strong></p>
<ul>
<li><code>{Wrapper}</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
</li>
</ul>
<p><code>createWrapper</code> 为一个被挂载的 Vue 实例或一个 HTML 元素创建一个 <code>Wrapper</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWrapper &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Constructor = Vue.extend(Foo)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Constructor().$mount()</span><br><span class="line"><span class="keyword">const</span> wrapper = createWrapper(vm)</span><br><span class="line">expect(wrapper.vm.foo).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h1><p>上述的API都是为了创建一个vue实例的wrapper，那么创建完成之后，这个wrapper自身也是有很多接口的。</p>
<p>具体就在这里不重复了，大致的作用类似与options对wrapper的配置，wrapper的方法可以在wrapper实例产生之后去更改和获取某些属性，如setMethods可以改变vue中的methods，trigger可以触发某个组件上的指定事件。</p>
<p>这里我们就举个例子通过不同的方式来测试vue中的methods来说明它的用法：</p>
<ul>
<li><p>第一种就是官方文档的示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Foo)</span><br><span class="line"><span class="keyword">const</span> clickMethodStub = sinon.stub()</span><br><span class="line"></span><br><span class="line">wrapper.setMethods(&#123; <span class="attr">clickMethod</span>: clickMethodStub &#125;)</span><br><span class="line">wrapper.find(<span class="string">'button'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">expect(clickMethodStub.called).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>这里要注意，不同版本的setMethods不太一样，有的版本它是一个同步方法，佐伊上述写法是对的，但是有的版本是异步方法，就需要等待它生效才可以，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(Foo)</span><br><span class="line"><span class="keyword">const</span> clickMethodStub = sinon.stub()</span><br><span class="line"></span><br><span class="line">wrapper.setMethods(&#123; <span class="attr">clickMethod</span>: clickMethodStub &#125;)</span><br><span class="line"><span class="keyword">await</span> Vue.nextTick();</span><br><span class="line">wrapper.find(<span class="string">'button'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">expect(clickMethodStub.called).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方法是在创建wrapper时传入一个options，这里利用的是mount会将options中的其他选项通过extend扩展如wrapper中的特性，具体代码可以参考options中的其他选项部分的代码。</p>
</li>
</ul>
<p>上述两种方式都可以结合sinon去mock一个vue实例中的方法用于测试。</p>
<p>当然也有其他的方式可以传入一个方法进入wrapper中，如options中的context和provide等。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue源码学习（四） Watcher原理解析</title>
    <url>/2020/09/25/vue-watcher/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着对vue源码的阅读，逐渐发现Watcher无处不在，无论是响应式原理，还是计算属性，侦听属性都用到了Watcher，几乎Vue大部分的特性都离不开Watcher。</p>
<p>甚至给我一种感觉，Vue往大了说，就是如何建立数据和Watcher的关系，数据变化时如何触发Watcher的更新，以及如何更新Watcher.value。</p>
<p>这个如何更新就决定了这个Watcher是什么，如果是更新视图，那就是渲染Watcher，如果是computeWatcher，那就是更新计算属性。</p>
<a id="more"></a>

<h2 id="源码及注释"><a href="#源码及注释" class="headerlink" title="源码及注释"></a>源码及注释</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  warn,</span><br><span class="line">  remove,</span><br><span class="line">  isObject,</span><br><span class="line">  parsePath,</span><br><span class="line">  _Set <span class="keyword">as</span> <span class="built_in">Set</span>,</span><br><span class="line">  handleError,</span><br><span class="line">  noop</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; traverse &#125; <span class="keyword">from</span> <span class="string">'./traverse'</span></span><br><span class="line"><span class="keyword">import</span> &#123; queueWatcher &#125; <span class="keyword">from</span> <span class="string">'./scheduler'</span></span><br><span class="line"><span class="keyword">import</span> Dep, &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">'./dep'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type &#123; SimpleSet &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;  <span class="comment">// Watcher所在的vm实例</span></span><br><span class="line">  expression: string;  <span class="comment">// 用于求值Watcher的value属性，可以是函数或者表达式</span></span><br><span class="line">  cb: <span class="built_in">Function</span>;  <span class="comment">// 每次重新求值（value）后回调函数</span></span><br><span class="line">  id: number;  <span class="comment">// Watcher的id，唯一标识</span></span><br><span class="line">  deep: boolean;  <span class="comment">// 是否是深度检测变化</span></span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;  <span class="comment">// 是否在构造函数执行时就进行一次求职，也就是通过experssion计算一次value值</span></span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;  <span class="comment">// 与lazy配合使用</span></span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;  <span class="comment">//当前watcher的依赖，通过addDeps不断增加，但是每次重新计算value时会将不在newDepIds中的注销</span></span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;  <span class="comment">//每次addDeps时增加，重新计算最后清空</span></span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;  <span class="comment">// 将experssion转化为函数</span></span><br><span class="line">  value: any;  <span class="comment">//当前watcher的value，对于computed来讲，就是计算结果，对于渲染watcher来说就是渲染结果</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// 这段代码就说明每个vue实例上的_watcher其实就是渲染watcher</span></span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vue实例上的_watchers是当前实例所有的watcher，第一个一般就是渲染watcher</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一步就是判断是不是lazy，如果是就暂不求值，计算属性这里为true，渲染watcher这里是false</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 收集依赖到newDeps，并将id记录下来，这个newDeps每次重新计算value都会赋值给dep然后被清空</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="comment">// 根据newDeps来判断是否仍然需要订阅原有的某个dep，如果不需要则通过removeSub取消订阅</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将deps置为newDeps后清空newDeps</span></span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前是激活态，</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// 重新计算value</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="comment">//新计算出来的值与旧的值不同（这个判断主要是为了避免计算属性依赖的值变了但其实计算结果没变）</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  teardown () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">      <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">      <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>一般情况下watcher与dep是配合使用的，所以这里放出dep的源码可以和上面的watcher源码相互印证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="响应式原理（renderWatcher）"><a href="#响应式原理（renderWatcher）" class="headerlink" title="响应式原理（renderWatcher）"></a>响应式原理（renderWatcher）</h3><p>这个可以看我的另一篇<a href="https://sunra.top/2020/08/25/vue-reactive/">关于响应式原理的博客</a></p>
<h3 id="计算属性原理（computeWatcher）"><a href="#计算属性原理（computeWatcher）" class="headerlink" title="计算属性原理（computeWatcher）"></a>计算属性原理（computeWatcher）</h3><h4 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)  <span class="comment">//初始化数据</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，是先进行了响应式的处理<code>observe(vm._data = {}, true /* asRootData */)</code>，才进行的initComputed，因为计算属性用的也是watcher，也需要定义响应式数据来进行依赖收集。</p>
<p>这样看来其实计算属性的依赖收集就是简化版的响应式，响应式原理中的依赖收集是通过render时调用数据的getter，而计算属性则是函数自身就调用了依赖数的getter。</p>
<h4 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef.get)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，其实就是首先对于每个计算属性，定义一个watcher，由于<code>lazy</code>是true，所以在构造函数中并不会求值。</p>
<p><code>defineComputed</code>中则是在vm上挂载计算属性，它的getter返回的是watcher的value。</p>
<p>如果dirty时true的话要调用<code>watcher.evaluate()</code>重新计算watcher.value, <code>dirty</code>在每次update之后都会置为true，在重新计算后会置为false，而这个计算过程回去会调用get方法，会先putshTarget，然后执行计算属性的函数，这样computedWatcher就会订阅函数中使用到的data的变化。</p>
<p>同时它的getter也会进行依赖的收集，当Dep.target不为空时，说明当前有渲染watcher在构建，那就要把自身的watcher加入到当前vue的watchers中，这一步其实并不是让渲染watcher去订阅computeWatcher的变化，而是去订阅computeWatcher依赖的data的变化。</p>
<h3 id="侦听属性（userWatcher）"><a href="#侦听属性（userWatcher）" class="headerlink" title="侦听属性（userWatcher）"></a>侦听属性（userWatcher）</h3><p>userWatcher的过程相比上面两个而言是比较简单的，搞懂了上面两个，最后一个就很容易明白了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步其实就是把watcher中的每一个值建立watcher</p>
<p><code>vm.$watcher</code>的定义为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以看到，会把这个watcher的user置为true，代表了这个watcher是userWatcher。</p>
<p>如果immediate是true就会立即执行一次回调函数，也就是我们在watcher中定义的函数。</p>
<p>接下来的逻辑就是创建了一个新的watcher，这里我们再回过头去看watcher的定义就好。</p>
<p>有一点要注意的是，一般我们定义watcher的时候都是通过键值对的方式，这个时候expOrFn就是键名，这个时候Watcher中会通过<code>paresPath</code>的方式根据路径去找到对应的data，此时watcher.getter其实就是返回对应data的函数。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3 初探（二） 新特性</title>
    <url>/2021/01/20/vue3-feature-2/</url>
    <content><![CDATA[<p>这篇博客我们继续来看Vue3的一些新特性，包括Teleport，片段，触发组件选项。</p>
<p>大部分内容来自官方文档，对部分难理解的部分进行了解释与总结。</p>
<a id="more"></a>

<h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>Vue 鼓励我们通过将 UI 和相关行为封装到组件中来构建 UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。</p>
<p>然而，有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。</p>
<p>也就是说我们希望<strong>有一种组件，它在逻辑上属于A组件的子组件，可以与A进行正常的父子组件可以进行的操作，但是实际上他又渲染为B组件的子组件</strong>。</p>
<p>一个常见的场景是创建一个包含全屏模式的组件。在大多数情况下，你希望模态的逻辑存在于组件中，但是模态的定位很快就很难通过 CSS 来解决，或者需要更改组件组合。</p>
<p>考虑下面的 HTML 结构。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Tooltips with Vue 3 Teleport<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">modal-button</span>&gt;</span><span class="tag">&lt;/<span class="name">modal-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让我们来看看 <code>modal-button</code> 组件：</p>
<p>该组件将有一个 <code>button</code> 元素来触发模态的打开，以及一个具有类 <code>.modal</code> 的 <code>div</code> 元素，它将包含模态的内容和一个用于自关闭的按钮。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'modal-button'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click="modalOpen = true"&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal!</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;div v-if="modalOpen" class="modal"&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        I'm a modal! </span></span><br><span class="line"><span class="string">        &lt;button @click="modalOpen = false"&gt;</span></span><br><span class="line"><span class="string">          Close</span></span><br><span class="line"><span class="string">        &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      modalOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当在初始的 HTML 结构中使用这个组件时，我们可以看到一个问题——模态是在深度嵌套的 <code>div</code> 中渲染的，而模态的 <code>position:absolute</code> 以父级相对定位的 <code>div</code> 作为引用。</p>
<p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下呈现 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<p>让我们修改 <code>modal-button</code> 以使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “<strong>Teleport</strong> 这个 HTML <strong>到</strong>该‘<strong>body</strong>’标签”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">'modal-button'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click="modalOpen = true"&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal! (With teleport!)</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;teleport to="body"&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if="modalOpen" class="modal"&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          I'm a teleported modal! </span></span><br><span class="line"><span class="string">          (My parent is "body")</span></span><br><span class="line"><span class="string">          &lt;button @click="modalOpen = false"&gt;</span></span><br><span class="line"><span class="string">            Close</span></span><br><span class="line"><span class="string">          &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      modalOpen: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因此，一旦我们单击按钮打开模式，Vue 将正确地将模态内容渲染为 <code>body</code> 标签的子级。</p>
<h3 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h3><p>如果 <code>&lt;teleport&gt;</code> 包含 Vue 组件，则它仍将是 <code>&lt;teleport&gt;</code> 父组件的逻辑子组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Root instance&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;parent-component /&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'parent-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;This is a parent component&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;teleport to="#endofbody"&gt;</span></span><br><span class="line"><span class="string">      &lt;child-component name="John" /&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'name'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，即使在不同的地方渲染 <code>child-component</code>，它仍将是 <code>parent-component</code> 的子级，并将从中接收 <code>name</code> prop。</p>
<p>这也意味着来自父组件的注入按预期工作，并且子组件将嵌套在 Vue Devtools 中的父组件之下，而不是放在实际内容移动到的位置。</p>
<h2 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h2><p>在 Vue 3 中，组件现在正式支持多根节点组件，即片段！</p>
<h3 id="2-x-语法"><a href="#2-x-语法" class="headerlink" title="2.x 语法"></a>2.x 语法</h3><p>在 2.x 中，不支持多根组件，当用户意外创建多根组件时会发出警告，因此，为了修复此错误，许多组件被包装在一个 <code>&lt;div&gt;</code> 中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Layout.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-语法"><a href="#3-x-语法" class="headerlink" title="3.x 语法"></a>3.x 语法</h3><p>在 3.x 中，组件现在可以有多个根节点！但是，这确实要求开发者明确定义属性应该分布在哪里。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Layout.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="非Prop的Attribute的继承"><a href="#非Prop的Attribute的继承" class="headerlink" title="非Prop的Attribute的继承"></a>非Prop的Attribute的继承</h3><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 <a href="https://vue3js.cn/docs/zh/guide/component-props" rel="external nofollow noopener noreferrer" target="_blank">props</a> 或 <a href="https://vue3js.cn/docs/zh/guide/component-custom-events.html#defining-custom-events" rel="external nofollow noopener noreferrer" target="_blank">emits</a> 定义的 attribute。常见的示例包括 <code>class</code>、<code>style</code> 和 <code>id</code> 属性。</p>
<h4 id="Attribute-继承"><a href="#Attribute-继承" class="headerlink" title="Attribute 继承"></a>Attribute 继承</h4><p>当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。例如，在 <code>&lt;date-picker&gt;</code> 组件的实例中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">'date-picker'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="date-picker"&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="datetime" /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们需要通过 <code>data status</code> property 定义 <code>&lt;date-picker&gt;</code> 组件的状态，它将应用于根节点 (即 <code>div.date-picker</code>)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 具有非prop attribute的Date-picker组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">date-picker</span> <span class="attr">data-status</span>=<span class="string">"activated"</span>&gt;</span><span class="tag">&lt;/<span class="name">date-picker</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染 date-picker 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"date-picker"</span> <span class="attr">data-status</span>=<span class="string">"activated"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样的规则适用于事件监听器</p>
<h4 id="多个根节点上的-Attribute-继承"><a href="#多个根节点上的-Attribute-继承" class="headerlink" title="多个根节点上的 Attribute 继承"></a>多个根节点上的 Attribute 继承</h4><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 <code>$attrs</code>，将发出运行时警告。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-layout</span> <span class="attr">id</span>=<span class="string">"custom-layout"</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这将发出警告</span></span><br><span class="line">app.component(<span class="string">'custom-layout'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;header&gt;...&lt;/header&gt;</span></span><br><span class="line"><span class="string">    &lt;main&gt;...&lt;/main&gt;</span></span><br><span class="line"><span class="string">    &lt;footer&gt;...&lt;/footer&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有警告，$attrs被传递到&lt;main&gt;元素</span></span><br><span class="line">app.component(<span class="string">'custom-layout'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;header&gt;...&lt;/header&gt;</span></span><br><span class="line"><span class="string">    &lt;main v-bind="$attrs"&gt;...&lt;/main&gt;</span></span><br><span class="line"><span class="string">    &lt;footer&gt;...&lt;/footer&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'myEvent'</span>)</span><br></pre></td></tr></table></figure>

<p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"doSomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>@myEvent</code> 将会变成 <code>@myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你始终使用 <strong>kebab-case 的事件名</strong></p>
<h3 id="定义自定义事件"><a href="#定义自定义事件" class="headerlink" title="定义自定义事件"></a>定义自定义事件</h3><p>可以通过 <code>emits</code> 选项在组件上定义已发出的事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">'custom-form'</span>, &#123;</span><br><span class="line">  emits: [<span class="string">'in-focus'</span>, <span class="string">'submit'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当在 <code>emits</code> 选项中定义了原生事件 (如 <code>click</code>) 时，将使用组件中的事件<strong>替代</strong>原生事件侦听器。</p>
<h3 id="验证抛出的事件"><a href="#验证抛出的事件" class="headerlink" title="验证抛出的事件"></a>验证抛出的事件</h3><p>与 prop 类型验证类似，如果使用对象语法而不是数组语法定义发出的事件，则可以验证它。</p>
<p>要添加验证，将为事件分配一个函数，该函数接收传递给 <code>$emit</code> 调用的参数，并返回一个布尔值以指示事件是否有效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">'custom-form'</span>, &#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    <span class="comment">// 没有验证</span></span><br><span class="line">    click: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证submit 事件</span></span><br><span class="line">    submit: <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (email &amp;&amp; password) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(<span class="string">'Invalid submit event payload!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'submit'</span>, &#123; email, password &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 <code>v-model</code> 绑定</h3><p>通过利用以特定 prop 和事件为目标的能力，正如我们之前在 <a href="https://vue3js.cn/docs/zh/guide/component-custom-events.html#v-model-参数" rel="external nofollow noopener noreferrer" target="_blank"><code>v-model</code> 参数</a>中所学的那样，我们现在可以在单个组件实例上创建多个 v-model 绑定。</p>
<p>每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user-name</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:first-name</span>=<span class="string">"firstName"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:last-name</span>=<span class="string">"lastName"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">user-name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'user-name'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    firstName: <span class="built_in">String</span>,</span><br><span class="line">    lastName: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input </span></span><br><span class="line"><span class="string">      type="text"</span></span><br><span class="line"><span class="string">      :value="firstName"</span></span><br><span class="line"><span class="string">      @input="$emit('update:firstName', $event.target.value)"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="text"</span></span><br><span class="line"><span class="string">      :value="lastName"</span></span><br><span class="line"><span class="string">      @input="$emit('update:lastName', $event.target.value)"&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自定义v-model修饰符"><a href="#自定义v-model修饰符" class="headerlink" title="自定义v-model修饰符"></a>自定义v-model修饰符</h3><p>在 2.x 中，我们对组件 <code>v-model</code> 上的 <code>.trim</code> 等修饰符提供了硬编码支持。但是，如果组件可以支持自定义修饰符，则会更有用。在 3.x 中，添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件：</p>
<p>让我们创建一个示例自定义修饰符 <code>capitalize</code>，它将 <code>v-model</code> 绑定提供的字符串的第一个字母大写。</p>
<p>添加到组件 <code>v-model</code> 的修饰符将通过 <code>modelModifiers</code> prop 提供给组件。在下面的示例中，我们创建了一个组件，其中包含默认为空对象的 <code>modelModifiers</code> prop。</p>
<p>请注意，当组件的 <code>created</code> 生命周期钩子触发时，<code>modelModifiers</code> prop 包含 <code>capitalize</code>，其值为 <code>true</code>——因为它被设置在 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;bar&quot;</code>。</p>
<p>现在我们已经设置了 prop，我们可以检查 <code>modelModifiers</code> 对象键并编写一个处理器来更改发出的值。在下面的代码中，每当 <code>&lt;input/&gt;</code> 元素触发 <code>input</code> 事件时，我们都将字符串大写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-model.capitalize</span>=<span class="string">"myText"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  &#123;&#123; myText &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      myText: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: <span class="built_in">String</span>,</span><br><span class="line">    modelModifiers: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    emitValue(e) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = e.target.value</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.modelModifiers.capitalize) &#123;</span><br><span class="line">        value = value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'update:modelValue'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;input</span></span><br><span class="line"><span class="string">    type="text"</span></span><br><span class="line"><span class="string">    :value="modelValue"</span></span><br><span class="line"><span class="string">    @input="emitValue"&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>对于带参数的 <code>v-model</code> 绑定，生成的 prop 名称将为 <code>arg + &quot;Modifiers&quot;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-model:foo.capitalize</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'foo'</span>, <span class="string">'fooModifiers'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input type="text" </span></span><br><span class="line"><span class="string">      :value="foo"</span></span><br><span class="line"><span class="string">      @input="$emit('update:foo', $event.target.value)"&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.fooModifiers) <span class="comment">// &#123; capitalize: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3 初探（三）全局API</title>
    <url>/2021/01/26/vue3-feature-3/</url>
    <content><![CDATA[<p>Vue2时代的全局API全部都是挂载在Vue原型上的，所以任何对全局API的修改都会作用到所有的Vue实例。这可能是我们所不希望的，同时这种修改又是不可逆的。</p>
<p>所以为了应对这种情况，Vue3将全局API改造，引入了APP的概念，每个实例都是一个APP，全局API是作用在APP上的。</p>
<a id="more"></a>

<p>Vue 2.x 有许多全局 API 和配置，这些 API 和配置可以全局改变 Vue 的行为。例如，要创建全局组件，可以使用 <code>Vue.component</code> 这样的 API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">'&lt;button @click="count++"&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>类似地，使用全局指令的声明方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然这种声明方式很方便，但它也会导致一些问题。</p>
<p>从技术上讲，Vue 2 没有“app”的概念，我们定义的应用只是通过 <code>new Vue()</code> 创建的根 Vue 实例。从同一个 Vue 构造函数<strong>创建的每个根实例共享相同的全局配置</strong>，因此：</p>
<ul>
<li>在测试期间，<strong>全局配置很容易意外地污染其他测试用例。用户需要仔细存储原始全局配置</strong>，并在每次测试后恢复 (例如重置 <code>Vue.config.errorHandler</code>)。有些 API <strong>像 <code>Vue.use</code> 以及 <code>Vue.mixin</code> 甚至连恢复效果的方法都没有</strong>，这使得涉及插件的测试特别棘手。实际上，vue-test-utils 必须实现一个特殊的 API <code>createLocalVue</code> 来处理此问题：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createLocalVue, mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建扩展的 `Vue` 构造函数</span></span><br><span class="line"><span class="keyword">const</span> localVue = createLocalVue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 “local” Vue构造函数上 “全局” 安装插件</span></span><br><span class="line">localVue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 `localVue` 来挂载选项</span></span><br><span class="line">mount(Component, &#123; localVue &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局配置使得在同一页面上的多个“app”之间共享同一个 Vue 副本非常困难，但全局配置不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这会影响两个根实例</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app-1'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> app2 = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app-2'</span> &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>为了避免这些问题，在 Vue 3 中我们引入…</p>
<h2 id="一个新的全局-API：createApp"><a href="#一个新的全局-API：createApp" class="headerlink" title="一个新的全局 API：createApp"></a>一个新的全局 API：<code>createApp</code></h2><p>调用 <code>createApp</code> 返回一个应用实例，这是 Vue 3 中的新概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>应用实例暴露当前全局 API 的子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上，以下是当前全局 API 及其相应实例 API 的表：</p>
<table>
<thead>
<tr>
<th>2.x 全局 API</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config</td>
<td>app.config</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><em>removed</em> (<a href="https://vue3js.cn/docs/zh/guide/migration/global-api.html#config-productiontip-removed" rel="external nofollow noopener noreferrer" target="_blank">见下方</a>)</td>
</tr>
<tr>
<td>Vue.config.ignoredElements</td>
<td>app.config.isCustomElement (<a href="https://vue3js.cn/docs/zh/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement" rel="external nofollow noopener noreferrer" target="_blank">见下方</a>)</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use (<a href="https://vue3js.cn/docs/zh/guide/migration/global-api.html#a-note-for-plugin-authors" rel="external nofollow noopener noreferrer" target="_blank">见下方</a>)</td>
</tr>
</tbody></table>
<p>所有其他不全局改变行为的全局 API 现在被命名为 exports</p>
<h2 id="插件使用者须知"><a href="#插件使用者须知" class="headerlink" title="插件使用者须知"></a>插件使用者须知</h2><p>插件开发者通常使用 <code>Vue.use</code>。例如，官方的 <code>vue-router</code> 插件是如何在浏览器环境中自行安装的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inBrowser = <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line"><span class="comment">/* … */</span></span><br><span class="line"><span class="keyword">if</span> (inBrowser &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  <span class="built_in">window</span>.Vue.use(VueRouter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>use</code> 全局 API 在 Vue 3 中不再使用，此方法将停止工作并停止调用 <code>Vue.use()</code> 现在将触发警告，于是，开发者必须在应用程序实例上显式指定使用此插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(MyApp)</span><br><span class="line">app.use(VueRouter)</span><br></pre></td></tr></table></figure>

<h2 id="挂载-App-实例"><a href="#挂载-App-实例" class="headerlink" title="挂载 App 实例"></a>挂载 App 实例</h2><p>使用 <code>createApp(/* options */)</code> 初始化后，应用实例 <code>app</code> 可用于挂载具有 <code>app.mount(domTarget)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> MyApp <span class="keyword">from</span> <span class="string">'./MyApp.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(MyApp)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>经过所有这些更改，我们在指南开头的组件和指令将被改写为如下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(MyApp)</span><br><span class="line"></span><br><span class="line">app.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  template: <span class="string">'&lt;button @click="count++"&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  mounted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在所有应用实例都挂载了，与其组件树一起，将具有相同的 “button-counter” 组件 和 “focus” 指令不污染全局环境</span></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在应用之间共享配置"><a href="#在应用之间共享配置" class="headerlink" title="在应用之间共享配置"></a>在应用之间共享配置</h2><p>在应用之间共享配置 (如组件或指令) 的一种方法是创建工厂功能，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./Bar.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMyApp = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = createApp(options)</span><br><span class="line">  app.directive(<span class="string">'focus'</span> <span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMyApp(Foo).mount(<span class="string">'#foo'</span>)</span><br><span class="line">createMyApp(Bar).mount(<span class="string">'#bar'</span>)</span><br></pre></td></tr></table></figure>

<p>现在，Foo 和 Bar 实例及其后代中都可以使用 <code>focus</code> 指令。</p>
<h2 id="Webpack-Treeshacking"><a href="#Webpack-Treeshacking" class="headerlink" title="Webpack Treeshacking"></a>Webpack Treeshacking</h2><p>在 Vue 3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，全局 API 现在只能作为 ES 模块构建的命名导出进行访问。例如，我们之前的片段现在应该如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> &#123; MyComponent &#125; <span class="keyword">from</span> <span class="string">'./MyComponent.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'an async feature'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(MyComponent)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行一些DOM相关的任务</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> nextTick()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行你的断言</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>直接调用 <code>Vue.nextTick()</code> 将导致臭名昭著的 <code>undefined is not a function</code> 错误。</p>
<p>通过这一更改，如果模块绑定器支持 tree-shaking，则 Vue 应用程序中未使用的全局 api 将从最终捆绑包中消除，从而获得最佳的文件大小。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3 初探（四）模板指令</title>
    <url>/2021/01/31/vue3-template-directives/</url>
    <content><![CDATA[<p>继续看一下Vue3的迁移文档</p>
<a id="more"></a>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><h3 id="2-x-语法"><a href="#2-x-语法" class="headerlink" title="2.x 语法"></a>2.x 语法</h3><p>在 2.x 中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:value</span>=<span class="string">"pageTitle"</span> @<span class="attr">input</span>=<span class="string">"pageTitle = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要将属性或事件名称更改为其他名称，则需要在 <code>ChildComponent</code> 组件中添加 <code>model</code> 选项：</p>
<ul>
<li>在子组件中通过model.prop配置，修改v-model所绑定的prop属性。比如下面的例子中v-model属性绑定的prop就从value变为title。</li>
<li>在子组件中通过model.event配置，可以修改v-model所绑定的值在子组件中发生变化时需要传递到父组件时触发的事件。比如下面的例子中，触发的事件由默认input变为change。</li>
<li>由于通过model.prop配置改变了v-model所绑定的prop为title，所以value可以当做一个普通的prop传入。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'title'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 这将允许 `value` 属性用于其他用途</span></span><br><span class="line">    value: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">// 使用 `title` 代替 `value` 作为 model 的 prop</span></span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'Default title'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在这个例子中 <code>v-model</code> 的简写（这里的简写指的是，通过以下写法，可以省略上面在子组件中的特殊配置）如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title</span>=<span class="string">"pageTitle"</span> @<span class="attr">change</span>=<span class="string">"pageTitle = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-v-bind-sync"><a href="#使用-v-bind-sync" class="headerlink" title="使用 v-bind.sync"></a>使用 <code>v-bind.sync</code></h4><p>在某些情况下，我们可能需要对某一个 prop 进行“双向绑定”(除了前面用 <code>v-model</code> 绑定 prop 的情况)。为此，我们建议使用 <code>update:myPropName</code> 抛出事件。例如，对于在上一个示例中带有 <code>title</code> prop 的 <code>ChildComponent</code>，我们可以通过下面的方式将分配新 value 的意图传达给父级：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newValue)</span><br></pre></td></tr></table></figure>

<p>如果需要的话，父级可以监听该事件并更新本地 data property。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title</span>=<span class="string">"pageTitle"</span> @<span class="attr">update:title</span>=<span class="string">"pageTitle = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了方便起见，我们可以使用 <code>.sync</code> 修饰符来缩写，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title.sync</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-语法"><a href="#3-x-语法" class="headerlink" title="3.x 语法"></a>3.x 语法</h3><p>在 3.x 中，自定义组件上的 <code>v-model</code> 相当于传递了 <code>modelValue</code> prop 并接收抛出的 <code>update:modelValue</code> 事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:modelValue</span>=<span class="string">"pageTitle"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">update:modelValue</span>=<span class="string">"pageTitle = $event"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-model-参数"><a href="#v-model-参数" class="headerlink" title="v-model 参数"></a><code>v-model</code> 参数</h4><p>若需要更改 <code>model</code> 名称，而不是更改组件内的 <code>model</code> 选项，那么现在我们可以将一个 <em>argument</em> 传递给 <code>model</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model:title</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title</span>=<span class="string">"pageTitle"</span> @<span class="attr">update:title</span>=<span class="string">"pageTitle = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这也可以作为 <code>.sync</code> 修饰符的替代，而且允许我们在自定义组件上使用多个 <code>v-model</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model:title</span>=<span class="string">"pageTitle"</span> <span class="attr">v-model:content</span>=<span class="string">"pageContent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写： --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">"pageTitle"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">update:title</span>=<span class="string">"pageTitle = $event"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:content</span>=<span class="string">"pageContent"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">update:content</span>=<span class="string">"pageContent = $event"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a><code>v-model</code> 修饰符</h4><p>除了像 <code>.trim</code> 这样的 2.x 硬编码的 <code>v-model</code> 修饰符外，现在 3.x 还支持自定义修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model.capitalize</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>详情可以看另一篇博客：<a href="https://sunra.top/2021/01/20/vue3-feature-2/">https://sunra.top/2021/01/20/vue3-feature-2/</a> 中关于自定义事件的内容</p>
<h2 id="Key-attribute"><a href="#Key-attribute" class="headerlink" title="Key attribute"></a>Key attribute</h2><ul>
<li>新增v-if, v-else, v-else-if的各分支项,key将不再是必须的，因为现在 Vue 会自动生成唯一的key<ul>
<li><strong>非兼容</strong>：如果你手动提供 <code>key</code>，那么每个分支必须使用唯一的 <code>key</code>。你不能通过故意使用相同的 <code>key</code> 来强制重用分支。</li>
</ul>
</li>
<li><strong>非兼容</strong>：<code>&lt;template v-for&gt;</code> 的 <code>key</code> 应该设置在 <code>&lt;template&gt;</code> 标签上 (而不是设置在它的子节点上)。</li>
</ul>
<h3 id="在条件分支中"><a href="#在条件分支中" class="headerlink" title="在条件分支中"></a>在条件分支中</h3><p>Vue 2.x 建议在 <code>v-if</code>/<code>v-else</code>/<code>v-else-if</code> 的分支中使用 <code>key</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"condition"</span> <span class="attr">key</span>=<span class="string">"yes"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"no"</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个示例在 Vue 3.x 中仍能正常工作。但是我们不再建议在 <code>v-if</code>/<code>v-else</code>/<code>v-else-if</code> 的分支中继续使用 <code>key</code> attribute，因为没有为条件分支提供 <code>key</code> 时，也会自动生成唯一的 <code>key</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"condition"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>非兼容变更体现在如果你手动提供了 <code>key</code>，那么每个分支都必须使用一个唯一的 <code>key</code>。因此大多数情况下都不需要设置这些 <code>key</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"condition"</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x (recommended solution: remove keys) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"condition"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x (alternate solution: make sure the keys are always unique) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"condition"</span> <span class="attr">key</span>=<span class="string">"a"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="结合-lt-template-v-for-gt"><a href="#结合-lt-template-v-for-gt" class="headerlink" title="结合 &lt;template v-for&gt;"></a>结合 <code>&lt;template v-for&gt;</code></h3><p>在 Vue 2.x 中 <code>&lt;template&gt;</code> 标签不能拥有 <code>key</code>。不过你可以为其每个子节点分别设置 <code>key</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Vue 3.x 中 <code>key</code> 则应该被设置在 <code>&lt;template&gt;</code> 标签上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类似地，当使用 <code>&lt;template v-for&gt;</code> 时存在使用 <code>v-if</code> 的子节点，<code>key</code> 应改为设置在 <code>&lt;template&gt;</code> 标签上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"item.isVisible"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"item.isVisible"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-if-与-v-for-的优先级对比"><a href="#v-if-与-v-for-的优先级对比" class="headerlink" title="v-if 与 v-for 的优先级对比"></a>v-if 与 v-for 的优先级对比</h2><ul>
<li><strong>非兼容</strong>：两者作用于同一个元素上时，<code>v-if</code> 会拥有比 <code>v-for</code> 更高的优先级。</li>
</ul>
<h2 id="v-bind-合并行为"><a href="#v-bind-合并行为" class="headerlink" title="v-bind 合并行为"></a>v-bind 合并行为</h2><h3 id="2-x-语法-1"><a href="#2-x-语法-1" class="headerlink" title="2.x 语法"></a>2.x 语法</h3><p>在 2.x，如果一个元素同时定义了 <code>v-bind=&quot;object&quot;</code> 和一个相同的单独的 property，那么这个单独的 property 总是会覆盖 <code>object</code> 中的绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-语法-1"><a href="#3-x-语法-1" class="headerlink" title="3.x 语法"></a>3.x 语法</h3><p>在 3.x，如果一个元素同时定义了 <code>v-bind=&quot;object&quot;</code> 和一个相同的单独的 property，那么声明绑定的顺序决定了它们如何合并。换句话说，相对于假设开发者总是希望单独的 property 覆盖 <code>object</code> 中定义的内容，现在开发者对自己所希望的合并行为有了更好的控制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-for-中的-Ref-数组非兼容"><a href="#v-for-中的-Ref-数组非兼容" class="headerlink" title="v-for 中的 Ref 数组非兼容"></a>v-for 中的 Ref 数组<strong>非兼容</strong></h2><p>在 Vue 2 中，在 <code>v-for</code> 里使用的 <code>ref</code> attribute 会用 ref 数组填充相应的 <code>$refs</code> property。当存在嵌套的 <code>v-for</code> 时，这种行为会变得不明确且效率低下。</p>
<p>在 Vue 3 中，这样的用法将不再在 <code>$ref</code> 中自动创建数组。要从单个绑定获取多个 ref，请将 <code>ref</code> 绑定到一个更灵活的函数上 (这是一个新特性)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:ref</span>=<span class="string">"setItemRef"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结合选项式 API:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setItemRef(el) &#123;</span><br><span class="line">      <span class="keyword">this</span>.itemRefs.push(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.itemRefs = []</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.itemRefs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合组合式 API:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onBeforeUpdate, onUpdated &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">let</span> itemRefs = []</span><br><span class="line">    <span class="keyword">const</span> setItemRef = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs.push(el)</span><br><span class="line">    &#125;</span><br><span class="line">    onBeforeUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      itemRefs = []</span><br><span class="line">    &#125;)</span><br><span class="line">    onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(itemRefs)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      itemRefs,</span><br><span class="line">      setItemRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>itemRefs</code> 不必是数组：它也可以是一个对象，其 ref 会通过迭代的 key 被设置。</li>
<li>如果需要，<code>itemRef</code> 也可以是响应式的且可以被监听。</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3初探（一）组合式API</title>
    <url>/2021/01/16/vue3_composition_api/</url>
    <content><![CDATA[<p>Vue3发布也有一段时间了，虽然还在beta测试，但是有些特性也可以事先了解下，这次就先看一下最重要的几个特性之一的组合式API，一种类似React Hooks的东西。</p>
<p>如果你了解Vue2或者说看过我以前关于Vue2源码的分析，有一个结论我现在就可以抛出：</p>
<p>就是Vue3的组合式API本身并没有用什么本质上的新特性，还是响应式原理那一套东西，只不过是提供了一种新的语法可以让你将强相关的一些列的data，prop，compute，method，生命周期函数封装到一起，最后将需要暴露出去的data也好，compute也好通过一个对象return出去，剩下的就和vue2没什么区别，你可以直接使用this去调用或者使用。</p>
<p>文章主要内容来自于<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E5%90%88%E5%BC%8F-api" rel="external nofollow noopener noreferrer" target="_blank">Vue3迁移指南-组合式API</a>，中间会根据自己的思路重新整理并解释。</p>
<a id="more"></a>

<h2 id="为什么需要组合式API"><a href="#为什么需要组合式API" class="headerlink" title="为什么需要组合式API"></a>为什么需要组合式API</h2><p>通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。</p>
<p>但是当我们的组件变得非常复杂的时候，<strong>我们在平时实际工作中很经常会遇到这种情况，我们需要watch一个prop的变化，然后改变某个data，而这个data有可能导致某个计算属性的改变，这其中可能还会涉及其他的计算属性和data，也可能会用到很多函数</strong>。</p>
<p>如果只是一个prop引起的一系列变化还好，但一般情况下我们的组件不只有一个prop，<strong>每个prop的变化都会引起一系列函数调用的时候，所有的函数，计算属性等混在一起就会让人理不清头绪</strong>。</p>
<p>如果我们有比较好的编码习惯，可以人为的给代码分块，也就是把功能相关的函数放在一起，比如文档中举的例子，相同颜色的函数是功能相关的：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1610755208/Blog/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2_zgpjgf.png" alt></p>
<p>但这样还是不够清晰，于是Vue3想了个办法，组合式API，提供了一种新的语法，可以让我们将功能相关的数据和函数放在一起。</p>
<h2 id="Vue2的写法"><a href="#Vue2的写法" class="headerlink" title="Vue2的写法"></a>Vue2的写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      repositories: [], <span class="comment">// 1</span></span><br><span class="line">      filters: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">      searchQuery: <span class="string">''</span> <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;, <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    user: <span class="string">'getUserRepositories'</span> <span class="comment">// 1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getUserRepositories () &#123;</span><br><span class="line">      <span class="comment">// 使用 `this.user` 获取用户仓库</span></span><br><span class="line">    &#125;, <span class="comment">// 1</span></span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.getUserRepositories() <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><p>既然我们知道了<strong>为什么</strong>，我们就可以知道<strong>怎么做</strong>。为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在 Vue 组件中，我们将此位置称为 <code>setup</code></p>
<p>新的 <code>setup</code> 组件选项在<strong>创建组件之前</strong>执行，一旦 <code>props</code> 被解析，并充当合成 API 的入口点。</p>
<blockquote>
<p>由于在执行 <code>setup</code> 时尚未创建组件实例，因此在 <code>setup</code> 选项中没有 <code>this</code>。这意味着，除了 <code>props</code> 之外，你将无法访问组件中声明的任何属性——<strong>本地状态</strong>、<strong>计算属性</strong>或<strong>方法</strong>。</p>
</blockquote>
<p><code>setup</code> 选项应该是一个接受 <code>props</code> 和 <code>context</code> 的函数，我们将在<a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#参数" rel="external nofollow noopener noreferrer" target="_blank">稍后</a>讨论。此外，我们从 <code>setup</code> 返回的所有内容都将暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
<p>我们先看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的组件内</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">let</span> repositories = []</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories <span class="comment">// 返回的函数与方法的行为相同</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子的setup中接受参数是props，利用prop中的数据去获取仓库数据，然后赋值给repositories。</p>
<p>这是我们的出发点，但它还不能工作，<strong>因为我们的 <code>repositories</code> 变量是非响应式的</strong>。这意味着从用户的角度来看，仓库列表将保持为空，因为vue的MVVM是基于响应式对象的，如果repositories是非响应式的，那就意味着它不会触发任何视图的更新。</p>
<h3 id="带-ref-的响应式变量"><a href="#带-ref-的响应式变量" class="headerlink" title="带 ref 的响应式变量"></a>带 <code>ref</code> 的响应式变量</h3><p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref</code> 接受参数并返回它包装在具有 <code>value</code> property 的对象中，然后可以使用该 property 访问或更改响应式变量的值：</p>
<blockquote>
<p>注意，ref返回的是个对象，入参是放到了返回对象的value中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在对象中包装值似乎不必要，但在 JavaScript 中保持不同数据类型的行为统一是必需的。<strong>这是因为在 JavaScript 中，<code>Number</code> 或 <code>String</code> 等基本类型是通过值传递的，而不是通过引用传递的：</strong></p>
<p>回到我们的例子，让我们创建一个响应式的 <code>repositories</code> 变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in our component</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成！现在，每当我们调用 <code>getUserRepositories</code> 时，<code>repositories</code> 都将发生变化，视图将更新以反映更改。我们的组件现在应该如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">    <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      repositories.value = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      repositories,</span><br><span class="line">      getUserRepositories</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      filters: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">      searchQuery: <span class="string">''</span> <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;, <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    user: <span class="string">'getUserRepositories'</span> <span class="comment">// 1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.getUserRepositories() <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经将第一个逻辑关注点中的几个部分移到了 <code>setup</code> 方法中，它们彼此非常接近。剩下的就是在 <code>mounted</code> 钩子中调用 <code>getUserRepositories</code>，并设置一个监听器，以便在 <code>user</code> prop 发生变化时执行此操作。</p>
<p>我们将从生命周期钩子开始。</p>
<h3 id="生命周期钩子注册内部-setup"><a href="#生命周期钩子注册内部-setup" class="headerlink" title="生命周期钩子注册内部 setup"></a>生命周期钩子注册内部 <code>setup</code></h3><p>为了使组合式 API 的特性与选项式 API 相比更加完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。这要归功于从 Vue 导出的几个新函数。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来像 <code>onMounted</code>。</p>
<p>这些函数接受在组件调用钩子时将执行的回调。</p>
<p>让我们将其添加到 <code>setup</code> 函数中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in our component</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories) <span class="comment">// on `mounted` call `getUserRepositories`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要对 <code>user</code> prop 所做的更改做出反应。为此，我们将使用独立的 <code>watch</code> 函数。</p>
<h3 id="watch-响应式更改"><a href="#watch-响应式更改" class="headerlink" title="watch 响应式更改"></a><code>watch</code> 响应式更改</h3><p>就像我们如何使用 <code>watch</code> 选项在组件内的 <code>user</code> property 上设置侦听器一样，我们也可以使用从 Vue 导入的 <code>watch</code> 函数执行相同的操作。它接受 3 个参数：</p>
<ul>
<li>一个<strong>响应式引用</strong>或我们想要侦听的 getter 函数</li>
<li>一个回调</li>
<li>可选的配置选项</li>
</ul>
<p><strong>下面让我们快速了解一下它是如何工作的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">watch(counter, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The new counter value is: '</span> + counter.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例如，每当 <code>counter</code> 被修改时 <code>counter.value=5</code>，watch 将触发并执行回调 (第二个参数)，在本例中，它将把 <code>&#39;The new counter value is:5&#39;</code> 记录到我们的控制台中。</p>
<p><strong>以下是等效的选项式 API：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    counter(newValue, oldValue) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The new counter value is: '</span> + <span class="keyword">this</span>.counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在我们将其应用到我们的示例中：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch, toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="comment">// 使用 `toRefs` 创建对prop的 `user` property 的响应式引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 更新 `prop.user` 到 `user.value` 访问引用值</span></span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(user.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在用户 prop 的响应式引用上设置一个侦听器</span></span><br><span class="line">  watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能已经注意到<strong>在我们的 <code>setup</code> 的顶部使用了 <code>toRefs</code></strong>。这是为了确保我们的侦听器能够对 <code>user</code> prop 所做的更改做出反应。</p>
<h3 id="独立的-computed-属性"><a href="#独立的-computed-属性" class="headerlink" title="独立的 computed 属性"></a>独立的 <code>computed</code> 属性</h3><p>与 <code>ref</code> 和 <code>watch</code> 类似，也可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性。让我们回到我们的 counter 例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function"><span class="params">()</span> =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>computed</code> 函数返回一个作为 <code>computed</code> 的第一个参数传递的 getter 类回调的输出的一个<em>只读</em>的<strong>响应式引用</strong>。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像使用 <code>ref</code> 一样使用 <code>.value</code> property。</p>
<p>让我们将搜索功能移到 <code>setup</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch, toRefs, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in our component</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="comment">// 使用 `toRefs` 创建对 props 的 `user` property 的响应式引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 更新 `props.user ` 到 `user.value` 访问引用值</span></span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(user.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在用户 prop 的响应式引用上设置一个侦听器</span></span><br><span class="line">  watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> searchQuery = ref(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> repositoriesMatchingSearchQuery = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repositories.value.filter(</span><br><span class="line">      repository =&gt; repository.name.includes(searchQuery.value)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories,</span><br><span class="line">    searchQuery,</span><br><span class="line">    repositoriesMatchingSearchQuery</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其他的<strong>逻辑关注点</strong>我们也可以这样做，但是你可能已经在问这个问题了——<em>这不就是把代码移到 <code>setup</code> 选项并使它变得非常大吗</em>？嗯，那是真的。这就是为什么在继续其他任务之前，我们将首先将上述代码提取到一个独立的<strong>组合式函数</strong>。让我们从创建 <code>useUserRepositories</code> 开始：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/composables/useUserRepositories.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">'@/api/repositories'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useUserRepositories</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = ref([])</span><br><span class="line">  <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    repositories.value = <span class="keyword">await</span> fetchUserRepositories(user.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories)</span><br><span class="line">  watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是搜索功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/composables/useRepositoryNameSearch.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useRepositoryNameSearch</span>(<span class="params">repositories</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> searchQuery = ref(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> repositoriesMatchingSearchQuery = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repositories.value.filter(<span class="function"><span class="params">repository</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> repository.name.includes(searchQuery.value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    searchQuery,</span><br><span class="line">    repositoriesMatchingSearchQuery</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在在单独的文件中有了这两个功能，我们就可以开始在组件中使用它们了。以下是如何做到这一点：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> useUserRepositories <span class="keyword">from</span> <span class="string">'@/composables/useUserRepositories'</span></span><br><span class="line"><span class="keyword">import</span> useRepositoryNameSearch <span class="keyword">from</span> <span class="string">'@/composables/useRepositoryNameSearch'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      searchQuery,</span><br><span class="line">      repositoriesMatchingSearchQuery</span><br><span class="line">    &#125; = useRepositoryNameSearch(repositories)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 因为我们并不关心未经过滤的仓库</span></span><br><span class="line">      <span class="comment">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span></span><br><span class="line">      repositories: repositoriesMatchingSearchQuery,</span><br><span class="line">      getUserRepositories,</span><br><span class="line">      searchQuery,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      filters: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue使用注意事项总结（持续更新）</title>
    <url>/2019/08/28/vue_attention/</url>
    <content><![CDATA[<p>Vue是我们经常使用的前端框架，虽然它使用起来很简单，官方文档也比较清晰，但是还是有不全面的地方导致我们可能会踩坑。</p>
<a id="more"></a>

<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>我们在使用Vue + ElementUI时经常会用到表单，也会用带表单的验证功能，但是在使用的时候需要注意官方文档上没有提到的一点，就是如果el-form-item的prop属性值与el-form-item中包裹的表单项v-model绑定的值完全相同，否则通过el-form的rules属性绑定进来的校验规则中的校验器会无法获取表单项的数据，就会导致校验总是无法通过</p>
<h3 id="子组件上使用v-model来进行父子组件通信"><a href="#子组件上使用v-model来进行父子组件通信" class="headerlink" title="子组件上使用v-model来进行父子组件通信"></a>子组件上使用v-model来进行父子组件通信</h3><p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" rel="external nofollow noopener noreferrer" target="_blank">vue文档关于如何在自定义组件上使用v-model</a></p>
<p>简单来说在自定义组件上使用v-model绑定的值会传到子组件中的props：value中，而且会自动监听该自定义组件的input事件，通过input事件返回的值会自动赋值给父组件中绑定到自定义组件的值</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 混入</title>
    <url>/2019/09/04/vue_mixin/</url>
    <content><![CDATA[<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>
<a id="more"></a>

<p>首先粘贴一份官方教程以及我对这份教程的理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></span><br></pre></td></tr></table></figure>

<p>在这份示例代码中，首先定义了一个混入，该混入包括一个created以及一个method，然后在需要使用该段代码的组件中利用mixins将该混入导入，这样就可以在该组件中使用混入中的所有内容。</p>
<p>这一点其实有点像Java中的继承，混入就类似于父类，组件就相当于子类，组件中具有混入的所有行为，包括函数，生命周期，事件监听等，同时我们又可以在组件中重写混入中的内容。</p>
<h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span>,</span><br><span class="line">      foo: <span class="string">'abc'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'goodbye'</span>,</span><br><span class="line">      bar: <span class="string">'def'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// =&gt; &#123; message: "goodbye", foo: "abc", bar: "def" &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'混入对象的钩子被调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'组件钩子被调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; "混入对象的钩子被调用"</span></span><br><span class="line"><span class="comment">// =&gt; "组件钩子被调用"</span></span><br></pre></td></tr></table></figure>

<p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from mixin'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflicting: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'from self'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.foo() <span class="comment">// =&gt; "foo"</span></span><br><span class="line">vm.bar() <span class="comment">// =&gt; "bar"</span></span><br><span class="line">vm.conflicting() <span class="comment">// =&gt; "from self"</span></span><br></pre></td></tr></table></figure>

<h2 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h2><p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  myOption: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></table></figure>

<h2 id="extend-component-mixin-extends"><a href="#extend-component-mixin-extends" class="headerlink" title="extend/component/mixin/extends"></a>extend/component/mixin/extends</h2><p>还是一开始那个例子，不过为了不引起混淆，我们现在的对象名不叫做myMixin，改名叫做myOption。</p>
<h3 id="new-Vue（）和component"><a href="#new-Vue（）和component" class="headerlink" title="new Vue（）和component"></a>new Vue（）和component</h3><p>new Vue(myOption)：实际上就是实例化了一个component</p>
<p>而Vue.component则是用于注册或者获取全局component的方法，就是讲通过Vue.extend生成的扩展实例构造器注册为一个组件，该组件可以在所有晚于该组件注册的组件中使用，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'global-component'</span>, Vue.extend(myOption));</span><br><span class="line"><span class="comment">//传入一个选项对象（自动调用 Vue.extend）,等价于上行代码.</span></span><br><span class="line">Vue.component(<span class="string">'global-component'</span>, myOption);</span><br><span class="line"><span class="comment">// 获取注册的组件（始终返回构造器）</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'global-component'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> MyComponent = Vue.extend(myOption);</span><br><span class="line"><span class="comment">//基于基础组件MyComponent,再扩展新逻辑.</span></span><br><span class="line"><span class="keyword">new</span> MyComponent(&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'onCreated-2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他自定义逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -&gt; onCreated-1</span></span><br><span class="line"><span class="comment">// -&gt; onCreated-2</span></span><br></pre></td></tr></table></figure>

<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><p>合并的规则与extend相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    mixins: [myOption],</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'onCreated-2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他自定义逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -&gt; onCreated-1</span></span><br><span class="line"><span class="comment">// -&gt; onCreated-2</span></span><br></pre></td></tr></table></figure>

<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>这和 mixins 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。同时extends接受的是一个对象而不是数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    extends: myOption,</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'onCreated-2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他自定义逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// -&gt; onCreated-1</span></span><br><span class="line"><span class="comment">// -&gt; onCreated-2</span></span><br></pre></td></tr></table></figure>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>extend &gt; extends &gt; mixins</p>
<p>参考文章：</p>
<p><a href="https://segmentfault.com/a/1190000010095089" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000010095089</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue骨架屏实现方案</title>
    <url>/2019/08/26/vue_skeleton_screen/</url>
    <content><![CDATA[<p>vue作为现在前端最主流的框架之一，拥有者大量的使用者，从学生的练习项目到企业的大型项目，vue都有值得称道的地方。但是一旦项目变得庞大起来，任何项目都会变得卡顿，这里就整理了关于优化vue用户体验的方案之一——骨架屏的实现方案。严格来说骨架屏的也算是优化首屏体验的一种方式。</p>
<a id="more"></a>

<h2 id="骨架屏介绍"><a href="#骨架屏介绍" class="headerlink" title="骨架屏介绍"></a>骨架屏介绍</h2><p>骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径。可以看一下下面Facebook的骨架屏实现，可以看到在页面完全渲染完成之前，用户会看到一个样式简单，描绘了当前页面的大致框架的骨架屏页面，然后骨架屏中各个占位部分被实际资源完全替换，这个过程中用户会觉得内容正在逐渐加载即将呈现，降低了用户的焦躁情绪，使得加载过程主观上变得流畅。</p>
<h2 id="骨架屏的生成方法"><a href="#骨架屏的生成方法" class="headerlink" title="骨架屏的生成方法"></a>骨架屏的生成方法</h2><h3 id="Vue-server-renderer"><a href="#Vue-server-renderer" class="headerlink" title="Vue-server-renderer"></a>Vue-server-renderer</h3><p>手写HTML、CSS的方式为目标页定制骨架屏，主要思路就是使用 vue-server-renderer这个本来用于服务端渲染的插件，用来把我们写的<code>.vue</code>文件处理为<code>HTML</code>，插入到页面模板的挂载点中，完成骨架屏的注入。这种方式不甚文明，如果页面样式改变了，还得改一遍骨架屏，增加了维护成本。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>使用过vue的都清楚，vue项目打包过后都有一个入口的html文件，在那个文件中只有一个id为app的div，而其他所有的js文件其实都是动态地计算和生成HTML标签插入到id为app的div中。</p>
<p>而我们去请求vue页面的时候都是先将index.html文件加载进来之后通过html文件中的script标签将对应的js代码引入进来，如果这些js文件过大导致下载过慢或者js运行时间太长都会导致页面长时间白屏。</p>
<p>所以自然而然就会想到这种解决方案，先修改index.html文件，在id为app的div中加入原生的html作为骨架屏先展示，当js运算完成之后在替换div中的内容</p>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>但是手动在div#app中写入骨架屏明显是不合理的。</p>
<p>既然我们是一个vue项目，骨架屏当然也需要是一个vue文件，它能够在构件时自动注入到div#app中</p>
<h5 id="新建一个用于存储骨架屏文件的vue，如Skeleton-vue"><a href="#新建一个用于存储骨架屏文件的vue，如Skeleton-vue" class="headerlink" title="新建一个用于存储骨架屏文件的vue，如Skeleton.vue"></a>新建一个用于存储骨架屏文件的vue，如Skeleton.vue</h5><h5 id="新建一个入口文件，如skeleton-entry-js"><a href="#新建一个入口文件，如skeleton-entry-js" class="headerlink" title="新建一个入口文件，如skeleton.entry.js"></a>新建一个入口文件，如skeleton.entry.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton <span class="keyword">from</span> <span class="string">'./Skeleton.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Skeleton</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;skeleton /&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="使用vue-server-renderer插件"><a href="#使用vue-server-renderer插件" class="headerlink" title="使用vue-server-renderer插件"></a>使用vue-server-renderer插件</h5><p>该插件本来是用于服务端渲染（服务端根据不同的请求生成不同的html页面返回前端，浏览器直接进行渲染，与之相对的是前端渲染，前端首先拿到部分页面，再从后台拿到数据，然后在前端组装页面），但是我们在这里使用它将vue文件处理成html和css字符串的功能。流程如下：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1566827650/Vue/360%E6%88%AA%E5%9B%BE17860606373553_rnx8aj.png" alt></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="新建webpack-skeleton-conf-js"><a href="#新建webpack-skeleton-conf-js" class="headerlink" title="新建webpack.skeleton.conf.js"></a>新建webpack.skeleton.conf.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>)</span><br><span class="line"><span class="keyword">const</span> VueSSRServerPlugin = <span class="built_in">require</span>(<span class="string">'vue-server-renderer/server-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    skeleton: <span class="string">'./src/skeleton.entry.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'vue-style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    whitelist: <span class="regexp">/\.css$/</span></span><br><span class="line">  &#125;),</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRServerPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'skeleton.json'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以下命令后会在dist文件夹下生成skeleton.json，该文件记录了skeleton.vue以及其引用的样式。这个文件会提供给vue-server-renderer使用</p>
<h5 id="在根目录下新建skeleton-js，用于向index-html中插入骨架屏"><a href="#在根目录下新建skeleton-js，用于向index-html中插入骨架屏" class="headerlink" title="在根目录下新建skeleton.js，用于向index.html中插入骨架屏"></a>在根目录下新建skeleton.js，用于向index.html中插入骨架屏</h5><h3 id="使用图片作为骨架屏"><a href="#使用图片作为骨架屏" class="headerlink" title="使用图片作为骨架屏"></a>使用图片作为骨架屏</h3><p>这种方案比第一种还简单，只需要UI人员绘制一张图片即可，但是这种方式比第一种更加难以维护。</p>
<h3 id="自动生成骨架屏"><a href="#自动生成骨架屏" class="headerlink" title="自动生成骨架屏"></a>自动生成骨架屏</h3><p>自动生成并自动插入静态骨架屏 这种方法跟第一种方法类似，不过是自动生成骨架屏，可以关注下饿了么开源的插件 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Fpage-skeleton-webpack-plugin" rel="external nofollow noopener noreferrer" target="_blank">page-skeleton-webpack-plugin</a>，它根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中，不过要注意的是这个插件目前只支持history方式的路由，不支持hash方式，且目前只支持首页的骨架屏，并没有组件级的局部骨架屏实现。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>Page Skeleton 是一款 webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。</p>
<ul>
<li>支持多种加载动画</li>
<li>针对移动端 web 页面</li>
<li>支持多路由</li>
<li>可定制化，可以通过配置项对骨架块形状颜色进行配置，同时也可以在预览页面直接修改骨架页面源码</li>
<li>几乎可以零配置使用</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>npm install –save-dev page-skeleton-webpack-plugin</p>
<p>npm install –save-dev html-webpack-plugin</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="修改build-webpack-base-config-js"><a href="#修改build-webpack-base-config-js" class="headerlink" title="修改build/webpack.base.config.js"></a>修改build/webpack.base.config.js</h5><p>这个文件配置的是webpack打包时的配置，既webpack打包的loader，插件，生成文件的路径等，这个文件会被webpack.dev.config.js和webpack.prod.config.js文件引用，用于开发环境和生产环境的打包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; SkeletonPlugin &#125; = <span class="built_in">require</span>(<span class="string">'page-skeleton-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  entry: <span class="string">'index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">    filename: <span class="string">'index.bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugin: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       <span class="comment">// Your HtmlWebpackPlugin config</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> SkeletonPlugin(&#123;</span><br><span class="line">      pathname: path.resolve(__dirname, <span class="string">`<span class="subst">$&#123;customPath&#125;</span>`</span>), <span class="comment">// 用来存储 shell 文件的地址</span></span><br><span class="line">      staticDir: path.resolve(__dirname, <span class="string">'./dist'</span>), <span class="comment">// 最好和 `output.path` 相同</span></span><br><span class="line">      routes: [<span class="string">'/'</span>, <span class="string">'/search'</span>], <span class="comment">// 将需要生成骨架屏的路由添加到数组中</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于插件是根据<code>process.env.NODE_ENV</code> 环境变量来选择不同的操作，因此需要在<code>package.json</code> 文件中 <code>scrpt</code>选项显示配置环境变量如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development node server.js"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"rm -rf dist &amp;&amp; cross-env NODE_ENV=production webpack --progress --hide-modules"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的cross-env也是一个插件，可以动态修改NODE_ENV变量的值</p>
<h5 id="修改-HTML-Webpack-Plugin-插件的模板"><a href="#修改-HTML-Webpack-Plugin-插件的模板" class="headerlink" title="修改 HTML Webpack Plugin 插件的模板"></a>修改 HTML Webpack Plugin 插件的模板</h5><p>在根元素内部添加<!-- shell --></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- shell --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="写入骨架页面"><a href="#写入骨架页面" class="headerlink" title="写入骨架页面"></a>写入骨架页面</h5><ol>
<li><p>在开发页面中通过 Ctrl|Cmd + enter 呼出插件交互界面，或者在在浏览器的 JavaScript 控制台内输入<code>toggleBar</code> 呼出交互界面。</p>
</li>
<li><p>点击交互界面中的按钮，进行骨架页面的预览，这一过程可能会花费 20s 左右时间，当插件准备好骨架页面后，会自动通过浏览器打开预览页面</p>
</li>
<li><p>扫描预览页面中的二维码，可在手机端预览骨架页面，可以在预览页面直接编辑源码，通过点击右上角写入按钮，将骨架页面写入到 shell.html 文件中。</p>
</li>
<li><p>通过 webpack 重新打包应用，当页面重新启动后，就能够在获取到数据前看到应用的骨架结构了。</p>
</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>这里可能会遇到一个问题，那就是开发环境可以显示，但是生产环境没有生成插入骨架屏，原因可能是在webpack.prod.config,js中存在一个配置会消除所有注释，这个配置会将<!--shell-->标签删除，所以找不到骨架屏的插入点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: config.build.index,</span><br><span class="line">      template: <span class="string">'index.html'</span>,</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        <span class="comment">// removeComments: true,  移除注释</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        <span class="comment">// more options:</span></span><br><span class="line">        <span class="comment">// https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// necessary to consistently work with multiple chunks via CommonsChunkPlugin</span></span><br><span class="line">      chunksSortMode: <span class="string">'dependency'</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="使用vue-skeleton-webpack-plugin插件"><a href="#使用vue-skeleton-webpack-plugin插件" class="headerlink" title="使用vue-skeleton-webpack-plugin插件"></a>使用vue-skeleton-webpack-plugin插件</h3><p>它将插入骨架屏的方式由手动改为自动，原理在构建时使用 Vue 预渲染功能，将骨架屏组件的渲染结果 HTML 片段插入 HTML 页面模版的挂载点中，将样式内联到 <code>head</code> 标签中。这个插件可以给单页面的不同路由设置不同的骨架屏，也可以给多页面设置，同时为了开发时调试方便，会将骨架屏作为路由写入router中</p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>npm install vue-skeleton-webpack-plugin</p>
<h5 id="创建骨架屏组件-src-keleton-vue"><a href="#创建骨架屏组件-src-keleton-vue" class="headerlink" title="创建骨架屏组件 src/keleton.vue"></a>创建骨架屏组件 src/keleton.vue</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;skeleton&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;skeleton-head&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;skeleton-body&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;skeleton-name&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;skeleton-title&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;skeleton-content&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;skeleton&apos;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.skeleton &#123;</span><br><span class="line">  padding: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton .skeleton-head,</span><br><span class="line">.skeleton .skeleton-name,</span><br><span class="line">.skeleton .skeleton-title,</span><br><span class="line">.skeleton .skeleton-content,</span><br><span class="line">.skeleton .skeleton-content &#123;</span><br><span class="line">  background: rgb(194, 207, 214);</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-head &#123;</span><br><span class="line">  width: 33px;</span><br><span class="line">  height: 33px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-body &#123;</span><br><span class="line">  margin-left: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-name&#123;</span><br><span class="line">  width: 150px;</span><br><span class="line">  height: 30px;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-title &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.skeleton-content &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 30px;</span><br><span class="line">  margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="创建骨架屏的入口文件-src-entry-skeleton-js"><a href="#创建骨架屏的入口文件-src-entry-skeleton-js" class="headerlink" title="创建骨架屏的入口文件 src/entry-skeleton.js"></a>创建骨架屏的入口文件 src/entry-skeleton.js</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton <span class="keyword">from</span> <span class="string">'./Skeleton'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Skeleton</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;skeleton id="skeleton1" style="display:none"/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="创建骨架屏的webpack配置文件"><a href="#创建骨架屏的webpack配置文件" class="headerlink" title="创建骨架屏的webpack配置文件"></a>创建骨架屏的webpack配置文件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) </span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>) </span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>) </span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> sourceMapEnabled = isProduction</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  : config.dev.cssSourceMap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> skeletonWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  devtool: <span class="literal">false</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: resolve(<span class="string">'../src/entry-skeleton.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: <span class="built_in">Object</span>.assign(&#123;&#125;, baseWebpackConfig.output, &#123;</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    whitelist: <span class="regexp">/\.css$/</span></span><br><span class="line">  &#125;),</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// important: enable extract-text-webpack-plugin </span></span><br><span class="line"><span class="comment">// 重点配置</span></span><br><span class="line">skeletonWebpackConfig.module.rules[<span class="number">0</span>].options.loaders = utils.cssLoaders(&#123;</span><br><span class="line">  sourceMap: sourceMapEnabled,</span><br><span class="line">  extract: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = skeletonWebpackConfig</span><br></pre></td></tr></table></figure>

<h5 id="分别在webpack-prod-conf-js和webpack-dev-conf-js-plugins中引入插件"><a href="#分别在webpack-prod-conf-js和webpack-dev-conf-js-plugins中引入插件" class="headerlink" title="分别在webpack.prod.conf.js和webpack.dev.conf.js plugins中引入插件"></a>分别在webpack.prod.conf.js和webpack.dev.conf.js plugins中引入插件</h5><p>首先需要引入vue-skeleton-webpack-plugin插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SkeletonWebpackPlugin = <span class="built_in">require</span>(<span class="string">'vue-skeleton-webpack-plugin'</span>)</span><br></pre></td></tr></table></figure>

<p>使用插件，在plugins数组中添加一项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SkeletonWebpackPlugin(&#123;</span><br><span class="line">      webpackConfig: <span class="built_in">require</span>(<span class="string">'./webpack.skeleton.conf'</span>),</span><br><span class="line">      quiet: <span class="literal">true</span>,</span><br><span class="line">      minimize: <span class="literal">true</span>,</span><br><span class="line">      router: &#123;</span><br><span class="line">        mode: <span class="string">'history'</span>,</span><br><span class="line">        routes: [</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">'/client/a/Quiksns/comment'</span>,    <span class="comment">//对应使用路由</span></span><br><span class="line">            skeletonId: <span class="string">'skeleton1'</span>    <span class="comment">// 所用骨架屏的id标识</span></span><br><span class="line">          &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure>

<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>启动vue项目后在浏览器输入 <a href="http://localhost:8080/client/a/Quiksns/comment" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/client/a/Quiksns/comment</a></p>
<p>我们可以看到在页面加载出来之前会有一个骨架屏出现，如果页面加载太快看不清楚也可以使用chrome Devtools 的 performance选项卡去录制操作（注意勾选screenshot选项），我们就可以看到每一帧的页面情况。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1567216104/Vue/skeleton_yuefj7.png" alt></p>
<p>参考文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/35505062" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/35505062</a></p>
<p><a href="https://www.cnblogs.com/FarmanKKK/p/9712913.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/FarmanKKK/p/9712913.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex 源码解析</title>
    <url>/2020/09/12/vuex/</url>
    <content><![CDATA[<h1 id="Vuex-初始化"><a href="#Vuex-初始化" class="headerlink" title="Vuex 初始化"></a>Vuex 初始化</h1><p>这一节我们主要来分析 Vuex 的初始化过程，它包括安装、Store 实例化过程 2 个方面。</p>
<p>安装过程比较简单，下图是一个简单的关于实例化的思维导图。</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1600494852/Blog/vuex_frzgmi.png" alt></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>当我们在代码中通过 <code>import Vuex from &#39;vuex&#39;</code> 的时候，实际上引用的是一个对象，它的定义在 <code>src/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">  version: <span class="string">'__VERSION__'</span>,</span><br><span class="line">  mapState,</span><br><span class="line">  mapMutations,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  createNamespacedHelpers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Vue-Router 一样，Vuex 也同样存在一个静态的 <code>install</code> 方法，它的定义在 <code>src/store.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue</span><br><span class="line">  applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>install</code> 的逻辑很简单，把传入的 <code>_Vue</code> 赋值给 <code>Vue</code> 并执行了 <code>applyMixin(Vue)</code> 方法，它的定义在 <code>src/mixin.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">    <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">    <span class="keyword">const</span> _init = Vue.prototype._init</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">      options.init = options.init</span><br><span class="line">        ? [vuexInit].concat(options.init)</span><br><span class="line">        : vuexInit</span><br><span class="line">      _init.call(<span class="keyword">this</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">'function'</span></span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store = options.parent.$store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>applyMixin</code> 就是这个 <code>export default function</code>，它还兼容了 Vue 1.0 的版本，这里我们只关注 Vue 2.0 以上版本的逻辑，它其实就全局混入了一个 <code>beforeCreate</code> 钩子函数，它的实现非常简单，就是把 <code>options.store</code> 保存在所有组件的 <code>this.$store</code> 中，这个 <code>options.store</code> 就是我们在实例化 <code>Store</code> 对象的实例，稍后我们会介绍，这也是为什么我们在组件中可以通过 <code>this.$store</code> 访问到这个实例。</p>
<h2 id="Store-实例化"><a href="#Store-实例化" class="headerlink" title="Store 实例化"></a>Store 实例化</h2><p>我们在 <code>import Vuex</code> 之后，会实例化其中的 <code>Store</code> 对象，返回 <code>store</code> 实例并传入 <code>new Vue</code> 的 <code>options</code> 中，也就是我们刚才提到的 <code>options.store</code>.</p>
<p>举个简单的例子，如下： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters, </span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  modules</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Store</code> 对象的构造函数接收一个对象参数，它包含 <code>actions</code>、<code>getters</code>、<code>state</code>、<code>mutations</code>、<code>modules</code> 等 Vuex 的核心概念，它的定义在 <code>src/store.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// Auto install if it is not done yet and `window` has `Vue`.</span></span><br><span class="line">    <span class="comment">// To allow users to avoid auto-installation in some cases,</span></span><br><span class="line">    <span class="comment">// this code should be placed here. See #731</span></span><br><span class="line">    <span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">      install(<span class="built_in">window</span>.Vue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      assert(Vue, <span class="string">`must call Vue.use(Vuex) before creating a store instance.`</span>)</span><br><span class="line">      assert(<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>, <span class="string">`vuex requires a Promise polyfill in this browser.`</span>)</span><br><span class="line">      assert(<span class="keyword">this</span> <span class="keyword">instanceof</span> Store, <span class="string">`Store must be called with the new operator.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      plugins = [],</span><br><span class="line">      strict = <span class="literal">false</span></span><br><span class="line">    &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store internal state</span></span><br><span class="line">    <span class="keyword">this</span>._committing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>._actionSubscribers = []</span><br><span class="line">    <span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">    <span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>._subscribers = []</span><br><span class="line">    <span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params">type, payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch.call(store, type, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params">type, payload, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> commit.call(store, type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strict mode</span></span><br><span class="line">    <span class="keyword">this</span>.strict = strict</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init root module.</span></span><br><span class="line">    <span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line">    <span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">    installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the store vm, which is responsible for the reactivity</span></span><br><span class="line">    <span class="comment">// (also registers _wrappedGetters as computed properties)</span></span><br><span class="line">    resetStoreVM(<span class="keyword">this</span>, state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply plugins</span></span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Vue.config.devtools) &#123;</span><br><span class="line">      devtoolPlugin(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把 <code>Store</code> 的实例化过程拆成 3 个部分，分别是初始化模块，安装模块和初始化 <code>store._vm</code>，接下来我们来分析这 3 部分的实现。</p>
<h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><p>在分析模块初始化之前，我们先来了解一下模块对于 Vuex 的意义：由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，<code>store</code> 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 <code>store</code> 分割成模块（module）。每个模块拥有自己的 <code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>，甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<p>所以从数据结构上来看，模块的设计就是一个树型结构，<code>store</code> 本身可以理解为一个 <code>root module</code>，它下面的 <code>modules</code> 就是子模块，Vuex 需要完成这颗树的构建，构建过程的入口就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br></pre></td></tr></table></figure>

<p><code>ModuleCollection</code> 的定义在 <code>src/module/module-collection.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleCollection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (rawRootModule) &#123;</span><br><span class="line">    <span class="comment">// register root module (Vuex.Store options)</span></span><br><span class="line">    <span class="keyword">this</span>.register([], rawRootModule, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> (path) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">    &#125;, <span class="keyword">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getNamespace (path) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key)</span><br><span class="line">      <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">    &#125;, <span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update (rawRootModule) &#123;</span><br><span class="line">    update([], <span class="keyword">this</span>.root, rawRootModule)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  register (path, rawModule, runtime = <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      assertRawModule(path, rawModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newModule = <span class="keyword">new</span> Module(rawModule, runtime)</span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.root = newModule</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">      parent.addChild(path[path.length - <span class="number">1</span>], newModule)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register nested modules</span></span><br><span class="line">    <span class="keyword">if</span> (rawModule.modules) &#123;</span><br><span class="line">      forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.register(path.concat(key), rawChildModule, runtime)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unregister (path) &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> key = path[path.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (!parent.getChild(key).runtime) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    parent.removeChild(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ModuleCollection</code> 实例化的过程就是执行了 <code>register</code> 方法，<br><code>register</code> 接收 3 个参数，其中 <code>path</code> 表示路径，因为我们整体目标是要构建一颗模块树，<code>path</code> 是在构建树的过程中维护的路径；<code>rawModule</code> 表示定义模块的原始配置；<code>runtime</code> 表示是否是一个运行时创建的模块。</p>
<p><code>register</code> 方法首先通过 <code>const newModule = new Module(rawModule, runtime)</code> 创建了一个 <code>Module</code> 的实例，<code>Module</code> 是用来描述单个模块的类，它的定义在 <code>src/module/module.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (rawModule, runtime) &#123;</span><br><span class="line">    <span class="keyword">this</span>.runtime = runtime</span><br><span class="line">    <span class="comment">// Store some children item</span></span><br><span class="line">    <span class="keyword">this</span>._children = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// Store the origin module object which passed by programmer</span></span><br><span class="line">    <span class="keyword">this</span>._rawModule = rawModule</span><br><span class="line">    <span class="keyword">const</span> rawState = rawModule.state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the origin module's state</span></span><br><span class="line">    <span class="keyword">this</span>.state = (<span class="keyword">typeof</span> rawState === <span class="string">'function'</span> ? rawState() : rawState) || &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> namespaced () &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>._rawModule.namespaced</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addChild (key, <span class="built_in">module</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._children[key] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeChild (key) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._children[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChild (key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._children[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update (rawModule) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rawModule.namespaced = rawModule.namespaced</span><br><span class="line">    <span class="keyword">if</span> (rawModule.actions) &#123;</span><br><span class="line">      <span class="keyword">this</span>._rawModule.actions = rawModule.actions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rawModule.mutations) &#123;</span><br><span class="line">      <span class="keyword">this</span>._rawModule.mutations = rawModule.mutations</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rawModule.getters) &#123;</span><br><span class="line">      <span class="keyword">this</span>._rawModule.getters = rawModule.getters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEachChild (fn) &#123;</span><br><span class="line">    forEachValue(<span class="keyword">this</span>._children, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEachGetter (fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.getters) &#123;</span><br><span class="line">      forEachValue(<span class="keyword">this</span>._rawModule.getters, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEachAction (fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.actions) &#123;</span><br><span class="line">      forEachValue(<span class="keyword">this</span>._rawModule.actions, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forEachMutation (fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._rawModule.mutations) &#123;</span><br><span class="line">      forEachValue(<span class="keyword">this</span>._rawModule.mutations, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下 <code>Module</code> 的构造函数，对于每个模块而言，<code>this._rawModule</code> 表示模块的配置，<code>this._children</code> 表示它的所有子模块，<code>this.state</code> 表示这个模块定义的 <code>state</code>。</p>
<p>回到 <code>register</code>，那么在实例化一个 <code>Module</code> 后，判断当前的 <code>path</code> 的长度如果为 0，则说明它是一个根模块，所以把 <code>newModule</code> 赋值给了 <code>this.root</code>，否则就需要建立父子关系了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="keyword">this</span>.get(path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">parent.addChild(path[path.length - <span class="number">1</span>], newModule)</span><br></pre></td></tr></table></figure>

<p>我们先大体上了解它的逻辑：首先根据路径获取到父模块，然后再调用父模块的 <code>addChild</code> 方法建立父子关系。</p>
<p><code>register</code> 的最后一步，就是遍历当前模块定义中的所有 <code>modules</code>，根据 <code>key</code> 作为 <code>path</code>，递归调用 <code>register</code> 方法，这样我们再回过头看一下建立父子关系的逻辑，首先执行了 <code>this.get(path.slice(0, -1)</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> (path) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params"><span class="built_in">module</span>, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.getChild(key)</span><br><span class="line">  &#125;, <span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的 <code>path</code> 是它的父模块的 <code>path</code>，然后从根模块开始，通过 <code>reduce</code> 方法一层层去找到对应的模块，查找的过程中，执行的是 <code>module.getChild(key)</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getChild (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._children[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是返回当前模块的 <code>_children</code> 中对应 <code>key</code> 的模块，那么每个模块的 <code>_children</code> 是如何添加的呢，是通过执行 <code>parent.addChild(path[path.length - 1], newModule)</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addChild (key, <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>._children[key] = <span class="built_in">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说对于 <code>root module</code> 的下一层 <code>modules</code> 来说，它们的 <code>parent</code> 就是 <code>root module</code>，那么他们就会被添加的 <code>root module</code> 的 <code>_children</code> 中。每个子模块通过路径找到它的父模块，然后通过父模块的 <code>addChild</code> 方法建立父子关系，递归执行这样的过程，最终就建立一颗完整的模块树。</p>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>初始化模块后，执行安装模块的相关逻辑，它的目标就是对模块中的 <code>state</code>、<code>getters</code>、<code>mutations</code>、<code>actions</code> 做初始化工作，它的入口代码是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state</span><br><span class="line">installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br></pre></td></tr></table></figure>

<p>来看一下 <code>installModule</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>installModule</code> 方法支持 5 个参数，<code>store</code> 表示 <code>root store</code>；<code>state</code> 表示 <code>root state</code>；<code>path</code> 表示模块的访问路径；<code>module</code> 表示当前的模块，<code>hot</code> 表示是否是热更新。</p>
<p>接下来看函数逻辑，这里涉及到了命名空间的概念，默认情况下，模块内部的 <code>action</code>、<code>mutation</code> 和 <code>getter</code> 是注册在全局命名空间的——这样使得多个模块能够对同一 <code>mutation</code> 或 <code>action</code> 作出响应。如果我们希望模块具有更高的封装度和复用性，可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 <code>getter</code>、<code>action</code> 及 <code>mutation</code> 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回到 <code>installModule</code> 方法，我们首先根据 <code>path</code> 获取 <code>namespace</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br></pre></td></tr></table></figure>

<p><code>getNamespace</code> 的定义在 <code>src/module/module-collection.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getNamespace (path) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">return</span> path.reduce(<span class="function">(<span class="params">namespace, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span> = <span class="built_in">module</span>.getChild(key)</span><br><span class="line">    <span class="keyword">return</span> namespace + (<span class="built_in">module</span>.namespaced ? key + <span class="string">'/'</span> : <span class="string">''</span>)</span><br><span class="line">  &#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 <code>root module</code> 开始，通过 <code>reduce</code> 方法一层层找子模块，如果发现该模块配置了 <code>namespaced</code> 为 true，则把该模块的 <code>key</code> 拼到 <code>namesapce</code> 中，最终返回完整的 <code>namespace</code> 字符串。</p>
<p>回到 <code>installModule</code> 方法，接下来把 <code>namespace</code> 对应的模块保存下来，为了方便以后能根据 <code>namespace</code> 查找模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">  store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来判断非 <code>root module</code> 且非 <code>hot</code> 的情况执行一些逻辑，我们稍后再看。</p>
<p>接着是很重要的逻辑，构造了一个本地上下文环境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</span><br></pre></td></tr></table></figure>

<p>来看一下 <code>makeLocalContext</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalContext</span> (<span class="params">store, namespace, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> noNamespace = namespace === <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = &#123;</span><br><span class="line">    dispatch: noNamespace ? store.dispatch : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">      <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">        type = namespace + type</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._actions[type]) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local action type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> store.dispatch(type, payload)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    commit: noNamespace ? store.commit : <span class="function">(<span class="params">_type, _payload, _options</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> args = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line">      <span class="keyword">const</span> &#123; payload, options &#125; = args</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = args</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!options || !options.root) &#123;</span><br><span class="line">        type = namespace + type</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !store._mutations[type]) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown local mutation type: <span class="subst">$&#123;args.type&#125;</span>, global type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      store.commit(type, payload, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and state object must be gotten lazily</span></span><br><span class="line">  <span class="comment">// because they will be changed by vm update</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(local, &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="keyword">get</span>: noNamespace</span><br><span class="line">        ? () =&gt; store.getters</span><br><span class="line">        : () =&gt; makeLocalGetters(store, namespace)</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; getNestedState(store.state, path)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>makeLocalContext</code> 支持 3 个参数相关，<code>store</code> 表示 <code>root store</code>；<code>namespace</code> 表示模块的命名空间，<code>path</code> 表示模块的 <code>path</code>。</p>
<p>该方法定义了 <code>local</code> 对象，对于 <code>dispatch</code> 和 <code>commit</code> 方法，如果没有 <code>namespace</code>，它们就直接指向了 <code>root store</code> 的 <code>dispatch</code> 和 <code>commit</code> 方法，否则会创建方法，把 <code>type</code> 自动拼接上 <code>namespace</code>，然后执行 <code>store</code> 上对应的方法。</p>
<p>对于 <code>getters</code> 而言，如果没有 <code>namespace</code>，则直接返回 <code>root store</code> 的 <code>getters</code>，否则返回 <code>makeLocalGetters(store, namespace)</code> 的返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeLocalGetters</span> (<span class="params">store, namespace</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gettersProxy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> splitPos = namespace.length</span><br><span class="line">  <span class="built_in">Object</span>.keys(store.getters).forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// skip if the target getter is not match this namespace</span></span><br><span class="line">    <span class="keyword">if</span> (type.slice(<span class="number">0</span>, splitPos) !== namespace) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extract local getter type</span></span><br><span class="line">    <span class="keyword">const</span> localType = type.slice(splitPos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a port to the getters proxy.</span></span><br><span class="line">    <span class="comment">// Define as getter property because</span></span><br><span class="line">    <span class="comment">// we do not want to evaluate the getters in this time.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(gettersProxy, localType, &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; store.getters[type],</span><br><span class="line">      enumerable: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return gettersProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>makeLocalGetters</code> 首先获取了 <code>namespace</code> 的长度，然后遍历 <code>root store</code> 下的所有 <code>getters</code>，先判断它的类型是否匹配 <code>namespace</code>，只有匹配的时候我们从 <code>namespace</code> 的位置截取后面的字符串得到 <code>localType</code>，接着用 <code>Object.defineProperty</code> 定义了 <code>gettersProxy</code>，获取 <code>localType</code> 实际上是访问了 <code>store.getters[type]</code>。</p>
<p>回到 <code>makeLocalContext</code> 方法，再来看一下对 <code>state</code> 的实现，它的获取则是通过 <code>getNestedState(store.state, path)</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNestedState</span> (<span class="params">state, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.length</span><br><span class="line">    ? path.reduce(<span class="function">(<span class="params">state, key</span>) =&gt;</span> state[key], state)</span><br><span class="line">    : state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getNestedState</code> 逻辑很简单，从 <code>root state</code> 开始，通过 <code>path.reduce</code> 方法一层层查找子模块 <code>state</code>，最终找到目标模块的 <code>state</code>。</p>
<p>那么构造完 <code>local</code> 上下文后，我们再回到 <code>installModule</code> 方法，接下来它就会遍历模块中定义的 <code>mutations</code>、<code>actions</code>、<code>getters</code>，分别执行它们的注册工作，它们的注册逻辑都大同小异。</p>
<ul>
<li><code>registerMutation</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先遍历模块中的 <code>mutations</code> 的定义，拿到每一个 <code>mutation</code> 和 <code>key</code>，并把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerMutation</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_mutations[types]</code> 添加 <code>wrappedMutationHandler</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_mutations</code> 可以对应多个方法。</p>
<ul>
<li><code>registerAction</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">  <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">  registerAction(store, type, handler, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span> (<span class="params">payload, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload, cb)</span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">'vuex:error'</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先遍历模块中的 <code>actions</code> 的定义，拿到每一个 <code>action</code> 和 <code>key</code>，并判断 <code>action.root</code>，如果否的情况把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerAction</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_actions[types]</code> 添加 <code>wrappedActionHandler</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_actions</code> 可以对应多个方法。</p>
<ul>
<li><code>registerGetter</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">  registerGetter(store, namespacedType, getter, local)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span> (<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先遍历模块中的 <code>getters</code> 的定义，拿到每一个 <code>getter</code> 和 <code>key</code>，并把 <code>key</code> 拼接上 <code>namespace</code>，然后执行 <code>registerGetter</code> 方法。该方法实际上就是给 <code>root store</code> 上的 <code>_wrappedGetters[key]</code> 指定 <code>wrappedGetter</code> 方法，该方法的具体实现我们之后会提到。注意，同一 <code>type</code> 的 <code>_wrappedGetters</code> 只能定义一个。</p>
<p>再回到 <code>installModule</code> 方法，最后一步就是遍历模块中的所有子 <code>modules</code>，递归执行 <code>installModule</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">  installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之前我们忽略了非 <code>root module</code> 下的 <code>state</code> 初始化逻辑，现在来看一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">  <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">  <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">  store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们提到过 <code>getNestedState</code> 方法，它是从 <code>root state</code> 开始，一层层根据模块名能访问到对应 <code>path</code> 的 <code>state</code>，那么它每一层关系的建立实际上就是通过这段 <code>state</code> 的初始化逻辑。<code>store._withCommit</code> 方法我们之后再介绍。</p>
<p>所以 <code>installModule</code> 实际上就是完成了模块下的 <code>state</code>、<code>getters</code>、<code>actions</code>、<code>mutations</code> 的初始化工作，并且通过递归遍历的方式，就完成了所有子模块的安装工作。</p>
<h3 id="初始化-store-vm"><a href="#初始化-store-vm" class="headerlink" title="初始化 store._vm"></a>初始化 <code>store._vm</code></h3><p><code>Store</code> 实例化的最后一步，就是执行初始化 <code>store._vm</code> 的逻辑，它的入口代码是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resetStoreVM(<span class="keyword">this</span>, state)</span><br></pre></td></tr></table></figure>

<p>来看一下 <code>resetStoreVM</code> 的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldVm = store._vm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    computed[key] = <span class="function"><span class="params">()</span> =&gt;</span> fn(store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: true // for local getters</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // use a Vue instance to store the state tree</span><br><span class="line">  // suppress warnings just in case the user has added</span><br><span class="line">  // some funky global mixins</span><br><span class="line">  const silent = Vue.config.silent</span><br><span class="line">  Vue.config.silent = true</span><br><span class="line">  store._vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.config.silent = silent</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new vm</span></span><br><span class="line">  <span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldVm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        oldVm._data.$$state = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resetStoreVM</code> 的作用实际上是想建立 <code>getters</code> 和 <code>state</code> 的联系，因为从设计上  <code>getters</code> 的获取就依赖了 <code>state</code> ，并且希望它的依赖能被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。因此这里利用了 Vue 中用 <code>computed</code> 计算属性来实现。</p>
<p><code>resetStoreVM</code> 首先遍历了 <code>_wrappedGetters</code> 获得每个 <code>getter</code> 的函数 <code>fn</code> 和 <code>key</code>，然后定义了 <code>computed[key] = () =&gt; fn(store)</code>。我们之前提到过 <code>_wrappedGetters</code> 的初始化过程，这里 <code>fn(store)</code> 相当于执行如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rawGetter(</span><br><span class="line">    local.state, <span class="comment">// local state</span></span><br><span class="line">    local.getters, <span class="comment">// local getters</span></span><br><span class="line">    store.state, <span class="comment">// root state</span></span><br><span class="line">    store.getters <span class="comment">// root getters</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的就是 <code>rawGetter</code> 的执行函数，<code>rawGetter</code> 就是用户定义的 <code>getter</code> 函数，它的前 2 个参数是 <code>local state</code> 和 <code>local getters</code>，后 2 个参数是 <code>root state</code> 和 <code>root getters</code>。</p>
<p>接着实例化一个 Vue 实例 <code>store._vm</code>，并把 <code>computed</code> 传入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    $$state: state</span><br><span class="line">  &#125;,</span><br><span class="line">  computed</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们发现 <code>data</code> 选项里定义了 <code>$$state</code> 属性，而我们访问 <code>store.state</code> 的时候，实际上会访问 <code>Store</code> 类上定义的 <code>state</code> 的 <code>get</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> state () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实际上就访问了 <code>store._vm._data.$$state</code>。那么 <code>getters</code> 和 <code>state</code> 是如何建立依赖逻辑的呢，我们再看这段代码逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">    <span class="comment">// use computed to leverage its lazy-caching mechanism</span></span><br><span class="line">    computed[key] = <span class="function"><span class="params">()</span> =&gt;</span> fn(store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; store._vm[key],</span><br><span class="line">      enumerable: true // for local getters</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>当我根据 <code>key</code> 访问 <code>store.getters</code> 的某一个 <code>getter</code> 的时候，实际上就是访问了 <code>store._vm[key]</code>，也就是 <code>computed[key]</code>，在执行 <code>computed[key]</code> 对应的函数的时候，会执行 <code>rawGetter(local.state,...)</code> 方法，那么就会访问到 <code>store.state</code>，进而访问到 <code>store._vm._data.$$state</code>，这样就建立了一个依赖关系。当 <code>store.state</code> 发生变化的时候，下一次再访问 <code>store.getters</code> 的时候会重新计算。</p>
<p>我们再来看一下 <code>strict mode</code> 的逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">  enableStrictMode(store)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  store._vm.$watch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data.$$state &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      assert(store._committing, <span class="string">`Do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">sync</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当严格模式下，<code>store._vm</code> 会添加一个 <code>wathcer</code> 来观测 <code>this._data.$$state</code> 的变化，也就是当 <code>store.state</code> 被修改的时候, <code>store._committing</code> 必须为 true，否则在开发阶段会报警告。<code>store._committing</code> 默认值是 <code>false</code>，那么它什么时候会 true 呢，<code>Store</code> 定义了 <code>_withCommit</code> 实例方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="keyword">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它就是对 <code>fn</code> 包装了一个环境，确保在 <code>fn</code> 中执行任何逻辑的时候 <code>this._committing = true</code>。所以外部任何非通过 Vuex 提供的接口直接操作修改 <code>state</code> 的行为都会在开发阶段触发警告。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么至此，Vuex 的初始化过程就分析完毕了，除了安装部分，我们重点分析了 <code>Store</code> 的实例化过程。我们要把 <code>store</code> 想象成一个数据仓库，为了更方便的管理仓库，我们把一个大的 <code>store</code> 拆成一些 <code>modules</code>，整个 <code>modules</code> 是一个树型结构。每个 <code>module</code> 又分别定义了 <code>state</code>，<code>getters</code>，<code>mutations</code>、<code>actions</code>，我们也通过递归遍历模块的方式都完成了它们的初始化。为了 <code>module</code> 具有更高的封装度和复用性，还定义了 <code>namespace</code> 的概念。最后我们还定义了一个内部的 <code>Vue</code> 实例，用来建立 <code>state</code> 到 <code>getters</code> 的联系，并且可以在严格模式下监测 <code>state</code> 的变化是不是来自外部，确保改变 <code>state</code> 的唯一途径就是显式地提交 <code>mutation</code>。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack 构建流程简介</title>
    <url>/2020/07/04/webpack-build-flow/</url>
    <content><![CDATA[<h2 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h2><ul>
<li>Entry: 入口，webpack执行构建的第一入口，可以抽象理解为input</li>
<li>Module: 模块， 在webpack里面一切皆是模块，一个模块对应一个文件，webpack会从配置的Entry开始，递归找到所有依赖的模块。</li>
<li>Chunk：代码块, 一个chunk是由多个模块组合而成，用于代码合并与分割。</li>
<li>Loader: 模块转换器，用于将模块的元内容按照需求转换成新内容。</li>
<li>Plugin: 扩展插件，在webpack构建流程中的特定时机会广播对应的事件，插件可以监听这些事件，在特定的时机做对应的事情。</li>
</ul>
<a id="more"></a>

<h3 id="webpack-中，module，chunk-和-bundle-的区别是什么？"><a href="#webpack-中，module，chunk-和-bundle-的区别是什么？" class="headerlink" title="webpack 中，module，chunk 和 bundle 的区别是什么？"></a>webpack 中，module，chunk 和 bundle 的区别是什么？</h3><p>先上一篇<a href="https://juejin.im/post/5cede821f265da1bbd4b5630" rel="external nofollow noopener noreferrer" target="_blank">参考文章</a>中的图片</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1593818010/Webpack/16b0153001913dc5_cemufu.webp" alt></p>
<p>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 <strong>module</strong> ；</p>
<p>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 <strong>chunk</strong> 文件，webpack 会对这个 chunk 文件进行一些操作；</p>
<p>webpack 处理好 chunk 文件后，最后会输出 <strong>bundle</strong> 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</p>
<p>一般来说一个 chunk 对应一个 bundle，比如上图中的 <code>utils.js -&gt; chunks 1 -&gt; utils.bundle.js</code>；但也有例外，比如说上图中，我就用 <code>MiniCssExtractPlugin</code> 从 chunks 0 中抽离出了 <code>index.bundle.css</code> 文件。</p>
<h2 id="webpack构建流程分析"><a href="#webpack构建流程分析" class="headerlink" title="webpack构建流程分析"></a>webpack构建流程分析</h2><p>Webpack 源码是一个插件的架构，很多功能都是通过诸多的内置插件实现的。Webpack为此专门自己写一个插件系统，叫 <code>Tapable</code> 主要提供了注册和调用插件的功能。</p>
<h3 id="webpack的流程"><a href="#webpack的流程" class="headerlink" title="webpack的流程"></a>webpack的流程</h3><p>webpack是一个串行的过程，从启动到结束会依次执行以下流程</p>
<ul>
<li>初始化参数： 从shell参数和配置文件合并参数，得出最终的参数</li>
<li>开始编译：从上一步获得的参数初始化compiler对象，加载所有的插件，通过run方法执行编译。</li>
<li>确定入口：根据配置文件的entry找出所有入口文件。</li>
<li>编译模块：从入口文件开始，调用所有配置的loader对模块进行翻译成compliation，然后递归所有依赖的模块，然后重复编译。得到每个模块翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出资源：根据入口和模块的依赖关系，组装成一个个包含多个模块的chunk，然后将chunk转换成一个单独的文件加入输出列表，这是可以修改输出内容的最后机会</li>
<li>输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统上。</li>
</ul>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1593818451/Webpack/172256efb94eec6d_nipzbn.webp" alt="img"></p>
<p>WebPack 编译流程图 原图出自：<a href="https://blog.didiyun.com/index.php/2019/03/01/webpack/" rel="external nofollow noopener noreferrer" target="_blank">blog.didiyun.com/index.php/2…</a></p>
<p>在以上过程中，webpack会在特定的时间点广播特定的事件，插件通过监听到感兴趣的事件后执行特定的逻辑，并且改变webpack的运行结果。</p>
<p><a href="https://juejin.im/post/5dcaa685f265da4d2375a162#heading-2" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>会从源码级别讲解流程，有兴趣或者有需要可以回头看。</p>
<h3 id="理解事件流机制-Tabable"><a href="#理解事件流机制-Tabable" class="headerlink" title="理解事件流机制 Tabable"></a>理解事件流机制 Tabable</h3><p><code>webpack</code>本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable。</p>
<p><code>Webpack</code> 的 <code>Tapable</code> 事件流机制保证了插件的有序性，将各个插件串联起来， Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webapck机制中，去改变webapck的运作，使得整个系统扩展性良好。</p>
<p><code>Tapable</code>也是一个小型的 library，是<code>Webpack</code>的一个核心工具。类似于<code>node</code>中的<code>events</code>库，核心原理就是一个订阅发布模式。作用是提供类似的插件接口。</p>
<p>webpack中最核心的负责编译的<code>Compiler</code>和负责创建bundles的<code>Compilation</code>都是Tapable的实例，可以直接在 <code>Compiler</code> 和 <code>Compilation</code> 对象上广播和监听事件，方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广播事件</span></span><br><span class="line"><span class="comment">* event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line">compilation.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;&#125;);</span><br><span class="line">compilation.plugin(<span class="string">'event-name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Tapable</code>类暴露了<code>tap</code>、<code>tapAsync</code>和<code>tapPromise</code>方法，可以根据钩子的同步/异步方式来选择一个函数注入逻辑。</p>
<p><code>tap</code> 同步钩子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.hooks.compile.tap(<span class="string">'MyPlugin'</span>, params =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'以同步方式触及 compile 钩子。'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tapAsync</code> 异步钩子，通过<code>callback</code>回调告诉<code>Webpack</code>异步执行完毕 <code>tapPromise</code> 异步钩子，返回一个<code>Promise</code>告诉<code>Webpack</code>异步执行完毕</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compiler.hooks.run.tapAsync(<span class="string">'MyPlugin'</span>, (compiler, callback) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'以异步方式触及 run 钩子。'</span>)</span><br><span class="line">  callback()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">compiler.hooks.run.tapPromise(<span class="string">'MyPlugin'</span>, compiler =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">1000</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'以具有延迟的异步方式触及 run 钩子'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Tapable用法"><a href="#Tapable用法" class="headerlink" title="Tapable用法"></a>Tapable用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line"> SyncHook,</span><br><span class="line"> SyncBailHook,</span><br><span class="line"> SyncWaterfallHook,</span><br><span class="line"> SyncLoopHook,</span><br><span class="line"> AsyncParallelHook,</span><br><span class="line"> AsyncParallelBailHook,</span><br><span class="line"> AsyncSeriesHook,</span><br><span class="line"> AsyncSeriesBailHook,</span><br><span class="line"> AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1593818478/Webpack/1722383f5f4bb210_t1mdv0.webp" alt="tapable"></p>
<h4 id="简单实现一个-SyncHook"><a href="#简单实现一个-SyncHook" class="headerlink" title="简单实现一个 SyncHook"></a>简单实现一个 SyncHook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hook</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(args)&#123;</span><br><span class="line">        <span class="keyword">this</span>.taps = []</span><br><span class="line">        <span class="keyword">this</span>.interceptors = [] <span class="comment">// 这个放在后面用</span></span><br><span class="line">        <span class="keyword">this</span>._args = args </span><br><span class="line">    &#125;</span><br><span class="line">    tap(name,fn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.taps.push(&#123;name,fn&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHook</span> <span class="keyword">extends</span> <span class="title">Hook</span></span>&#123;</span><br><span class="line">    call(name,fn)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.taps.forEach(<span class="function"><span class="params">tap</span> =&gt;</span> tap.fn(name))</span><br><span class="line">            fn(<span class="literal">null</span>,name)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            fn(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="tapable是如何将webapck-webpack插件关联的？"><a href="#tapable是如何将webapck-webpack插件关联的？" class="headerlink" title="tapable是如何将webapck/webpack插件关联的？"></a>tapable是如何将webapck/webpack插件关联的？</h4><p><strong>Compiler.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; AsyncSeriesHook ,SyncHook &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">           run: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]), <span class="comment">//异步钩子</span></span><br><span class="line">           compile: <span class="keyword">new</span> SyncHook([<span class="string">"params"</span>]),<span class="comment">//同步钩子</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    run()&#123;</span><br><span class="line">      <span class="comment">//执行异步钩子</span></span><br><span class="line">      <span class="keyword">this</span>.hooks.run.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">         <span class="keyword">this</span>.compile(onCompiled);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    compile()&#123;</span><br><span class="line">      <span class="comment">//执行同步钩子 并传参</span></span><br><span class="line">      <span class="keyword">this</span>.hooks.compile.call(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Compiler</span><br></pre></td></tr></table></figure>

<p><strong>MyPlugin.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Compiler = <span class="built_in">require</span>(<span class="string">'./Compiler'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">    apply(compiler)&#123;<span class="comment">//接受 compiler参数</span></span><br><span class="line">        compiler.hooks.run.tap(<span class="string">"MyPlugin"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'开始编译...'</span>));</span><br><span class="line">        <span class="comment">// 在run阶段添加方法</span></span><br><span class="line">        compiler.hooks.complier.tapAsync(<span class="string">'MyPlugin'</span>, (name, age) =&gt; &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'编译中...'</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 在compier阶段添加方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里类似于webpack.config.js的plugins配置</span></span><br><span class="line"><span class="comment">//向 plugins 属性传入 new 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    plugins: [myPlugin]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> compiler = <span class="keyword">new</span> Compiler(options)</span><br><span class="line">compiler.run()</span><br></pre></td></tr></table></figure>

<p>想要深入了解<code>tapable</code>的文章可以看看这篇文章：</p>
<p><code>webpack4</code>核心模块<code>tapable</code>源码解析: <a href="https://www.cnblogs.com/tugenhua0707/p/11317557.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/tugenhua0707/p/11317557.html</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，webpack的打包分为几个阶段，类似于生命周期，每个生命周期开始和结束都可以发出事件，loader是编译阶段用于编译我们指定类型文件的。</p>
<p>所以就像前面所说，webpack的构建流程是基于事件的，对于webpack而言，它的事件发出和订阅都是依赖于Tapable类，我们的Plugin其实就是 一个个的Tapable类，而我们用到的compiler或者compilation就是内置的Plugin。</p>
<p>我么可以利用Tapable类的apply和plugin方法发出和订阅事件，由于complier本身是一个Tapable,所以它自身可以apply和plugin事件，而我们在complier的hooks上通过类似tap的方法添加函数，就相当于监听了该hooks发出的事件。</p>
<p>参考文章：</p>
<p><a href="https://juejin.im/post/5dcaa685f265da4d2375a162" rel="external nofollow noopener noreferrer" target="_blank">webpack构建流程分析</a></p>
<p><a href="https://juejin.im/post/5cede821f265da1bbd4b5630" rel="external nofollow noopener noreferrer" target="_blank">webpack 中那些最易混淆的 5 个知识点</a></p>
<p><a href="https://juejin.im/post/5ec169786fb9a043721b46ad" rel="external nofollow noopener noreferrer" target="_blank">揭秘webpack插件工作流程和原理</a></p>
<p><a href="https://www.jianshu.com/p/2995fbf92e66" rel="external nofollow noopener noreferrer" target="_blank">webpack插件编写及原理解析</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack Code Splitting</title>
    <url>/2020/01/12/webpack-code-splitting/</url>
    <content><![CDATA[<p>这几天在看webpack的教学视频时对代码分离产生了一点疑惑，于是去翻看了官方文档，现在将原文档的翻译以及我对其中一些内容的理解整理下来。</p>
<a id="more"></a>

<p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<p>常用的代码分离方法有三种：</p>
<ul>
<li>入口起点：使用 <a href="https://webpack.docschina.org/configuration/entry-context" rel="external nofollow noopener noreferrer" target="_blank"><code>entry</code></a> 配置手动地分离代码。</li>
<li>防止重复：使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" rel="external nofollow noopener noreferrer" target="_blank"><code>SplitChunksPlugin</code></a> 去重和分离 chunk。</li>
<li>动态导入：通过模块中的内联函数调用来分离代码。</li>
</ul>
<p>首先这里要解释一下bundle与chunk的区别与联系：</p>
<p>具体的解释可以看<a href="https://stackoverflow.com/questions/42523436/what-are-module-chunk-and-bundle-in-webpack" rel="external nofollow noopener noreferrer" target="_blank">这里</a>，但是总结来讲就是：</p>
<ol>
<li>模块就是模块可以是ESM模块也可以是commonJS或者AMD模块</li>
<li>打包过程中被操作的模块文件叫做chunk,例如异步加载一个模块就是一个chunk</li>
<li>bundle是最后打包后的文件,最终文件可以和chunk长的一模一样,但是大部分情况下他是多个chunk的集合</li>
</ol>
<h2 id="入口起点-entry-points"><a href="#入口起点-entry-points" class="headerlink" title="入口起点(entry points)"></a>入口起点(entry points)</h2><p>这是迄今为止最简单、最直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。先来看看如何从 main bundle 中分离 another module(另一个模块)：</p>
<p><strong>project</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- /dist</span><br><span class="line">|- /src</span><br><span class="line">  |- index.js</span><br><span class="line"><span class="addition">+ |- another-module.js</span></span><br><span class="line">|- /node_modules</span><br></pre></td></tr></table></figure>

<p><strong>another-module.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _.join([<span class="string">'Another'</span>, <span class="string">'module'</span>, <span class="string">'loaded!'</span>], <span class="string">' '</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>webpack.config.js</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">const path = require('path');</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: 'development',</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: './src/index.js',</span><br><span class="line"><span class="addition">+   another: './src/another-module.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: '[name].bundle.js',</span><br><span class="line">    path: path.resolve(__dirname, 'dist')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于上述配置文件中的 output.filename 中的 [name]，它的作用是可以让打包生成的文件名称是入口[文件名称.bundle.js]，这里还可以配置许多其他的配置，详细的配置可以看<a href="https://webpack.docschina.org/configuration/output/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>。</p>
<p>这将生成如下构建结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            Asset     Size   Chunks             Chunk Names</span><br><span class="line">another.bundle.js  550 KiB  another  [emitted]  another</span><br><span class="line">  index.bundle.js  550 KiB    index  [emitted]  index</span><br><span class="line">Entrypoint index = index.bundle.js</span><br><span class="line">Entrypoint another = another.bundle.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>正如前面提到的，这种方式存在一些隐患：</p>
<ul>
<li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。因为这里会把根据每个入口文件产生的依赖关系中的所有文件都打包到各自的同一个文件中。</li>
<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li>
</ul>
<p>这两点中的第一点，对我们的示例来说毫无疑问是个严重问题，因为我们在 <code>./src/index.js</code> 中也引入过 <code>lodash</code>，这样就造成在两个 bundle 中重复引用。我们可以通过使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" rel="external nofollow noopener noreferrer" target="_blank"><code>SplitChunksPlugin</code></a> 插件来移除重复模块。</p>
<h2 id="防止重复-prevent-duplication"><a href="#防止重复-prevent-duplication" class="headerlink" title="防止重复(prevent duplication)"></a>防止重复(prevent duplication)</h2><p><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" rel="external nofollow noopener noreferrer" target="_blank"><code>SplitChunksPlugin</code></a> 插件可以将公共的依赖模块提取到已有的 entry chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将前面示例中重复的 <code>lodash</code> 模块去除：</p>
<blockquote>
<p><code>CommonsChunkPlugin</code> 已经从 webpack v4（代号 legato）中移除。想要了解最新版本是如何处理 chunk，请查看 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" rel="external nofollow noopener noreferrer" target="_blank"><code>SplitChunksPlugin</code></a>。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  const path = require('path');</span><br><span class="line"></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    mode: 'development',</span><br><span class="line">    entry: &#123;</span><br><span class="line">      index: './src/index.js',</span><br><span class="line">      another: './src/another-module.js'</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: '[name].bundle.js',</span><br><span class="line">      path: path.resolve(__dirname, 'dist')</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="addition">+   optimization: &#123;</span></span><br><span class="line"><span class="addition">+     splitChunks: &#123;</span></span><br><span class="line"><span class="addition">+       chunks: 'all'</span></span><br><span class="line"><span class="addition">+     &#125;</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks" rel="external nofollow noopener noreferrer" target="_blank"><code>optimization.splitChunks</code></a> 配置选项，现在可以看到已经从 <code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中删除了重复的依赖项。需要注意的是，此插件将 <code>lodash</code> 这个沉重负担从主 bundle 中移除，然后分离到一个单独的 chunk 中。执行 <code>npm run build</code> 查看效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                          Asset      Size                 Chunks             Chunk Names</span><br><span class="line">              another.bundle.js  5.95 KiB                another  [emitted]  another</span><br><span class="line">                index.bundle.js  5.89 KiB                  index  [emitted]  index</span><br><span class="line">vendors~another~index.bundle.js   547 KiB  vendors~another~index  [emitted]  vendors~another~index</span><br><span class="line">Entrypoint index = vendors~another~index.bundle.js index.bundle.js</span><br><span class="line">Entrypoint another = vendors~another~index.bundle.js another.bundle.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以下是由社区提供，一些对于代码分离很有帮助的 plugin 和 loader：</p>
<ul>
<li><a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>mini-css-extract-plugin</code></a>：用于将 CSS 从主应用程序中分离。</li>
<li><a href="https://webpack.docschina.org/loaders/bundle-loader" rel="external nofollow noopener noreferrer" target="_blank"><code>bundle-loader</code></a>：用于分离代码和延迟加载生成的 bundle。</li>
<li><a href="https://github.com/gaearon/promise-loader" rel="external nofollow noopener noreferrer" target="_blank"><code>promise-loader</code></a>：类似于 <code>bundle-loader</code> ，但是使用了 promise API。</li>
</ul>
<h2 id="动态导入-dynamic-imports"><a href="#动态导入-dynamic-imports" class="headerlink" title="动态导入(dynamic imports)"></a>动态导入(dynamic imports)</h2><p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。第一种，也是推荐选择的方式是，使用符合 <a href="https://github.com/tc39/proposal-dynamic-import" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 提案</a> 的 <a href="https://webpack.docschina.org/api/module-methods#import-" rel="external nofollow noopener noreferrer" target="_blank"><code>import()</code> 语法</a> 来实现动态导入。第二种，则是 webpack 的遗留功能，使用 webpack 特定的 <a href="https://webpack.docschina.org/api/module-methods#require-ensure" rel="external nofollow noopener noreferrer" target="_blank"><code>require.ensure</code></a>。让我们先尝试使用第一种……</p>
<blockquote>
<p><code>import()</code> 调用会在内部用到 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="external nofollow noopener noreferrer" target="_blank">promises</a>。如果在旧版本浏览器中使用 <code>import()</code>，记得使用一个 polyfill 库（例如 <a href="https://github.com/stefanpenner/es6-promise" rel="external nofollow noopener noreferrer" target="_blank">es6-promise</a> 或 <a href="https://github.com/taylorhakes/promise-polyfill" rel="external nofollow noopener noreferrer" target="_blank">promise-polyfill</a>），来 shim <code>Promise</code>。</p>
</blockquote>
<p>在开始之前，我们先从配置中移除掉多余的 <a href="https://webpack.docschina.org/concepts/entry-points/" rel="external nofollow noopener noreferrer" target="_blank"><code>entry</code></a> 和 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>optimization.splitChunks</code></a>，因为接下来的演示中并不需要它们：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  const path = require('path');</span><br><span class="line"></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    mode: 'development',</span><br><span class="line">    entry: &#123;</span><br><span class="line"><span class="addition">+     index: './src/index.js'</span></span><br><span class="line"><span class="deletion">-     index: './src/index.js',</span></span><br><span class="line"><span class="deletion">-     another: './src/another-module.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: '[name].bundle.js',</span><br><span class="line"><span class="addition">+     chunkFilename: '[name].bundle.js',</span></span><br><span class="line">      path: path.resolve(__dirname, 'dist')</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="deletion">-   optimization: &#123;</span></span><br><span class="line"><span class="deletion">-     splitChunks: &#123;</span></span><br><span class="line"><span class="deletion">-       chunks: 'all'</span></span><br><span class="line"><span class="deletion">-     &#125;</span></span><br><span class="line"><span class="deletion">-   &#125;</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>注意，这里使用了 <code>chunkFilename</code>，它决定 non-entry chunk(非入口 chunk) 的名称。关于 <code>chunkFilename</code> 更多信息，请查看 <a href="https://webpack.docschina.org/configuration/output/#output-chunkfilename" rel="external nofollow noopener noreferrer" target="_blank">输出</a> 文档。更新我们的项目，移除现在不会用到的文件：</p>
<p><strong>project</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- /dist</span><br><span class="line">|- /src</span><br><span class="line">  |- index.js</span><br><span class="line"><span class="deletion">- |- another-module.js</span></span><br><span class="line">|- /node_modules</span><br></pre></td></tr></table></figure>

<p>现在，我们不再使用 statically import(静态导入) <code>lodash</code>，而是通过 dynamic import(动态导入) 来分离出一个 chunk：</p>
<p><strong>src/index.js</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- import _ from 'lodash';</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">- function component() &#123;</span></span><br><span class="line"><span class="addition">+ function getComponent() &#123;</span></span><br><span class="line"><span class="deletion">-   var element = document.createElement('div');</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-   // Lodash, now imported by this script</span></span><br><span class="line"><span class="deletion">-   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span></span><br><span class="line"><span class="addition">+   return import(/* webpackChunkName: "lodash" */ 'lodash').then((&#123; default: _ &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+     var element = document.createElement('div');</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+     element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+     return element;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+   &#125;).catch(error =&gt; 'An error occurred while loading the component');</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- document.body.appendChild(component());</span></span><br><span class="line"><span class="addition">+ getComponent().then(component =&gt; &#123;</span></span><br><span class="line"><span class="addition">+   document.body.appendChild(component);</span></span><br><span class="line"><span class="addition">+ &#125;)</span></span><br></pre></td></tr></table></figure>

<p>这里我们需要使用 <code>default</code> 的原因是，从 webpack v4 开始，在 import CommonJS 模块时，不会再将导入模块解析为 <code>module.exports</code> 的值，而是为 CommonJS 模块创建一个 artificial namespace object(人工命名空间对象)，关于其背后原因的更多信息，请阅读 <a href="https://medium.com/webpack/webpack-4-import-and-commonjs-d619d626b655" rel="external nofollow noopener noreferrer" target="_blank">webpack 4: import() 和 CommonJs</a>。</p>
<p>注意，在注释中我们提供了 <code>webpackChunkName</code>。这样会将拆分出来的 bundle 命名为 <code>lodash.bundle.js</code>，而不是 <code>[id].bundle.js</code>。想了解更多关于 <code>webpackChunkName</code> 和其他可用选项，请查看 <a href="https://webpack.docschina.org/api/module-methods/#import-" rel="external nofollow noopener noreferrer" target="_blank"><code>import()</code></a> 文档。让我们执行 webpack，看到 <code>lodash</code> 分离出一个单独的 bundle：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                   Asset      Size          Chunks             Chunk Names</span><br><span class="line">         index.bundle.js  7.88 KiB           index  [emitted]  index</span><br><span class="line">vendors~lodash.bundle.js   547 KiB  vendors~lodash  [emitted]  vendors~lodash</span><br><span class="line">Entrypoint index = index.bundle.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>由于 <code>import()</code> 会返回一个 promise，因此它可以和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="external nofollow noopener noreferrer" target="_blank"><code>async</code> 函数</a>一起使用。但是，需要使用像 Babel 这样的预处理器和 <a href="https://babel.docschina.org/docs/en/babel-plugin-syntax-dynamic-import/#installation" rel="external nofollow noopener noreferrer" target="_blank">Syntax Dynamic Import Babel Plugin</a>。下面是如何通过 async 函数简化代码：</p>
<p><strong>src/index.js</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- function getComponent() &#123;</span></span><br><span class="line"><span class="addition">+ async function getComponent() &#123;</span></span><br><span class="line"><span class="deletion">-   return import(/* webpackChunkName: "lodash" */ 'lodash').then(&#123; default: _ &#125; =&gt; &#123;</span></span><br><span class="line"><span class="deletion">-     var element = document.createElement('div');</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-     element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-     return element;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-   &#125;).catch(error =&gt; 'An error occurred while loading the component');</span></span><br><span class="line"><span class="addition">+   var element = document.createElement('div');</span></span><br><span class="line"><span class="addition">+   const &#123; default: _ &#125; = await import(/* webpackChunkName: "lodash" */ 'lodash');</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+   return element;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getComponent().then(component =&gt; &#123;</span><br><span class="line">    document.body.appendChild(component);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="预取-预加载模块-prefetch-preload-module"><a href="#预取-预加载模块-prefetch-preload-module" class="headerlink" title="预取/预加载模块(prefetch/preload module)"></a>预取/预加载模块(prefetch/preload module)</h2><p>webpack v4.6.0+ 添加了预取和预加载的支持。</p>
<p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器：</p>
<ul>
<li>prefetch(预取)：将来某些导航下可能需要的资源</li>
<li>preload(预加载)：当前导航下可能需要资源</li>
</ul>
<p>下面这个 prefetch 的简单示例中，有一个 <code>HomePage</code> 组件，其内部渲染一个 <code>LoginButton</code> 组件，然后在点击后按需加载 <code>LoginModal</code> 组件。</p>
<p><strong>LoginButton.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">'LoginModal'</span>);</span><br></pre></td></tr></table></figure>

<p>这会生成 `` 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件。</p>
<blockquote>
<p>只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。</p>
</blockquote>
<p>与 prefetch 指令相比，preload 指令有许多不同之处：</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li>
<li>浏览器支持程度不同。</li>
</ul>
<p>下面这个简单的 preload 示例中，有一个 <code>Component</code>，依赖于一个较大的 library，所以应该将其分离到一个独立的 chunk 中。</p>
<p>我们假想这里的图表组件 <code>ChartComponent</code> 组件需要依赖体积巨大的 <code>ChartingLibrary</code> 库。它会在渲染时显示一个 <code>LoadingIndicator(加载进度条)</code> 组件，然后立即按需导入 <code>ChartingLibrary</code>：</p>
<p><strong>ChartComponent.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPreload: true */</span> <span class="string">'ChartingLibrary'</span>);</span><br></pre></td></tr></table></figure>

<p>在页面中使用 <code>ChartComponent</code> 时，在请求 ChartComponent.js 的同时，还会通过 `` 请求 charting-library-chunk。假定 page-chunk 体积很小，很快就被加载好，页面此时就会显示 <code>LoadingIndicator(加载进度条)</code> ，等到 <code>charting-library-chunk</code> 请求完成，LoadingIndicator 组件才消失。启动仅需要很少的加载时间，因为只进行单次往返，而不是两次往返。尤其是在高延迟环境下。</p>
<blockquote>
<p>不正确地使用 webpackPreload 会有损性能，请谨慎使用。</p>
</blockquote>
<p>对于其他webpack支持的打包方法可以去看<a href="[https://webpack.docschina.org/api/module-methods/#es6-%E6%8E%A8%E8%8D%90-](https://webpack.docschina.org/api/module-methods/#es6-推荐-)">这篇文档</a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack Loader API</title>
    <url>/2020/02/22/webpack-loader-api/</url>
    <content><![CDATA[<p>Loader是Webpack中一个重要的概念，可以帮助我们在加载某些类型的文件时进行我们想要的操作，比如自动将所有JavaScript的function外部都加上try catch。</p>
<a id="more"></a>

<p>所谓 loader 只是一个导出为函数的 JavaScript 模块。<a href="https://github.com/webpack/loader-runner" rel="external nofollow noopener noreferrer" target="_blank">loader runner</a> 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 <code>this</code> 上下文将由 webpack 填充，并且 <a href="https://github.com/webpack/loader-runner" rel="external nofollow noopener noreferrer" target="_blank">loader runner</a> 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。</p>
<p>第一个 loader 的传入参数只有一个：资源文件(resource file)的内容。compiler 需要得到最后一个 loader 产生的处理结果。这个处理结果应该是 <code>String</code> 或者 <code>Buffer</code>（被转换为一个 string），代表了模块的 JavaScript 源码。另外还可以传递一个可选的 SourceMap 结果（格式为 JSON 对象）。</p>
<p>如果是单个处理结果，可以在<strong>同步模式</strong>中直接返回。如果有多个处理结果，则必须调用 <code>this.callback()</code>。在<strong>异步模式</strong>中，必须调用 <code>this.async()</code>，来指示 <a href="https://github.com/webpack/loader-runner" rel="external nofollow noopener noreferrer" target="_blank">loader runner</a> 等待异步结果，它会返回 <code>this.callback()</code> 回调函数，随后 loader 必须返回 <code>undefined</code> 并且调用该回调函数。</p>
<h2 id="最简单的Loader"><a href="#最简单的Loader" class="headerlink" title="最简单的Loader"></a>最简单的Loader</h2><h3 id="同步-loader"><a href="#同步-loader" class="headerlink" title="同步 loader"></a>同步 loader</h3><p>无论是 <code>return</code> 还是 <code>this.callback</code> 都可以同步地返回转换后的 <code>content</code> 内容：</p>
<p><strong>sync-loader.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>this.callback</code> 方法则更灵活，因为它允许传递多个参数，而不仅仅是<code>content</code>。</p>
<p>这里的content就是传入的源码。someSyncOperation是我们自定义的方法用于处理源码，最终将处理结果通过return返回。</p>
<p><strong>sync-loader-with-multiple-results.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, someSyncOperation(content), map, meta);</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 当调用 callback() 时总是返回 undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的map其实是scourceMap。</p>
<h3 id="异步-loader"><a href="#异步-loader" class="headerlink" title="异步 loader"></a>异步 loader</h3><p>对于异步 loader，使用 <a href="https://webpack.docschina.org/api/loaders#this-async" rel="external nofollow noopener noreferrer" target="_blank"><code>this.async</code></a> 来获取 <code>callback</code> 函数：</p>
<p><strong>async-loader.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();  <span class="comment">// 告知loader-runner这里需要等待该函数的返回结果</span></span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, map, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>async-loader-with-multiple-results.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, sourceMaps, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, sourceMaps, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>this.aysnc 告诉 <a href="https://github.com/webpack/loader-runner" rel="external nofollow noopener noreferrer" target="_blank">loader-runner</a> 这个 loader 将会异步地回调。返回 <code>this.callback</code>。所以其参数与this.callback是相同的。</p>
<h2 id="Loader-Context-常用的方法及参数"><a href="#Loader-Context-常用的方法及参数" class="headerlink" title="Loader Context 常用的方法及参数"></a>Loader Context 常用的方法及参数</h2><p>这里只对常用的方法及参数进行列举，解释以及加一些注意事项。更多的配置可以直接去看<a href="https://webpack.docschina.org/api/loaders/#this-version" rel="external nofollow noopener noreferrer" target="_blank">文档</a></p>
<p>loader context 表示在 loader 内使用 <code>this</code> 可以访问的一些方法或属性。</p>
<p>假设我们这样请求加载别的模块： 在 <code>/abc/file.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./loader1?xyz!loader2!./resource?rrr'</span>);</span><br></pre></td></tr></table></figure>

<p>上面这种引入方式是webpack提供的一种方法，这种引入方式指定了通过什么loader去加载最后的文件，loader是感叹号之前规定的，这种方法可以覆盖webpack.config中的配置。</p>
<p>具体可以看<a href="https://webpack.docschina.org/concepts/loaders/" rel="external nofollow noopener noreferrer" target="_blank">loader 概念文档</a></p>
<h3 id="this-query"><a href="#this-query" class="headerlink" title="this.query`"></a>this.query`</h3><ol>
<li>如果这个 loader 配置了 <a href="https://webpack.docschina.org/configuration/module/#useentry" rel="external nofollow noopener noreferrer" target="_blank"><code>options</code></a> 对象的话，<code>this.query</code> 就指向这个 option 对象。</li>
<li>如果 loader 中没有 <code>options</code>，而是以 query 字符串作为参数调用时，<code>this.query</code> 就是一个以 <code>?</code> 开头的字符串。</li>
</ol>
<p>在官方文档中提示我们最好使用loader-utils提供的getOptions方法去获取options，是因为如果options中的值不是单纯的string时，偶尔会有一些问题，具体的使用方法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack config</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: ...,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">            		loader: <span class="string">'loader.js'</span>,</span><br><span class="line">            		options: &#123;</span><br><span class="line">            			name: <span class="string">'Ray'</span></span><br><span class="line">        			&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader.js</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(options.name);  <span class="comment">//Ray</span></span><br><span class="line">	<span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-callback"><a href="#this-callback" class="headerlink" title="this.callback"></a><code>this.callback</code></h3><p>一个可以同步或者异步调用的可以返回多个结果的函数。预期的参数是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">  err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">  content: string | Buffer,</span><br><span class="line">  sourceMap?: SourceMap,</span><br><span class="line">  meta?: any</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数必须是 <code>Error</code> 或者 <code>null</code></li>
<li>第二个参数是一个 <code>string</code> 或者 <a href="https://nodejs.org/api/buffer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>Buffer</code></a>。</li>
<li>可选的：第三个参数必须是一个可以被<a href="https://github.com/mozilla/source-map" rel="external nofollow noopener noreferrer" target="_blank">这个模块</a>解析的 source map。</li>
<li>可选的：第四个选项，会被 webpack 忽略，可以是任何东西（例如一些元数据）。</li>
</ol>
<blockquote>
<p>可以将抽象语法树(abstract syntax tree - AST)（例如 <a href="https://github.com/estree/estree" rel="external nofollow noopener noreferrer" target="_blank"><code>ESTree</code></a>）作为第四个参数（<code>meta</code>），如果你想在多个 loader 之间共享通用的 AST，这样做有助于加速编译时间。</p>
</blockquote>
<p>如果这个函数被调用的话，你应该返回 undefined 从而避免含糊的 loader 结果。</p>
<h3 id="this-async"><a href="#this-async" class="headerlink" title="this.async"></a><code>this.async</code></h3><p>告诉 <a href="https://github.com/webpack/loader-runner" rel="external nofollow noopener noreferrer" target="_blank">loader-runner</a> 这个 loader 将会异步地回调。返回 <code>this.callback</code>。</p>
<h3 id="this-version"><a href="#this-version" class="headerlink" title="this.version"></a><code>this.version</code></h3><p><strong>loader API 的版本号。</strong>目前是 <code>2</code>。这对于向后兼容性有一些用处。通过这个版本号，你可以为不同版本间的破坏性变更编写不同的逻辑，或做降级处理。</p>
<h3 id="this-context"><a href="#this-context" class="headerlink" title="this.context"></a><code>this.context</code></h3><p><strong>模块所在的目录。</strong>可以用作解析其他模块路径的上下文。</p>
<p>在我们的例子中：这个属性为 <code>/abc</code>，因为 <code>resource.js</code> 在这个目录中</p>
<h3 id="this-rootContext"><a href="#this-rootContext" class="headerlink" title="this.rootContext"></a><code>this.rootContext</code></h3><p>从 webpack 4 开始，原先的 <code>this.options.context</code> 被改进为 <code>this.rootContext</code>。</p>
<h3 id="this-request"><a href="#this-request" class="headerlink" title="this.request"></a><code>this.request</code></h3><p>被解析出来的 request 字符串。</p>
<p>在我们的例子中：</p>
<p><code>&quot;/abc/loader1.js?xyz!/abc/node_modules/loader2/index.js!/abc/resource.js?rrr&quot;</code></p>
<p>这个结果是怎么来的呢？</p>
<p>首先因为我们的resource.js，loader1，loader2的根目录abc目录中，所以前面会添加”abc/“，而loader2前面没有相对路径，所以认为是node_modules中的模块，就会再补上一个”node_modules/“</p>
<h2 id="高级的Loader"><a href="#高级的Loader" class="headerlink" title="高级的Loader"></a>高级的Loader</h2><h3 id="“Raw”-loader"><a href="#“Raw”-loader" class="headerlink" title="“Raw” loader"></a>“Raw” loader</h3><p>默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 <code>raw</code>，loader 可以接收原始的 <code>Buffer</code>。每一个 loader 都可以用 <code>String</code> 或者 <code>Buffer</code> 的形式传递它的处理结果。Complier 将会把它们在 loader 之间相互转换。</p>
<p><strong>raw-loader.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  assert(content <span class="keyword">instanceof</span> Buffer);</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">  <span class="comment">// 返回值也可以是一个 `Buffer`</span></span><br><span class="line">  <span class="comment">// 即使不是 raw loader 也没问题</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="越过-loader-Pitching-loader"><a href="#越过-loader-Pitching-loader" class="headerlink" title="越过 loader(Pitching loader)"></a>越过 loader(Pitching loader)</h3><p>loader <strong>总是</strong>从右到左地被调用。有些情况下，loader 只关心 request 后面的<strong>元数据(metadata)</strong>，并且忽略前一个 loader 的结果。<strong>在实际（从右到左）执行 loader 之前，会先从左到右调用 loader 上的 <code>pitch</code> 方法</strong>。对于以下 <a href="https://webpack.docschina.org/configuration/module#rule-use" rel="external nofollow noopener noreferrer" target="_blank"><code>use</code></a> 配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'a-loader'</span>,</span><br><span class="line">          <span class="string">'b-loader'</span>,</span><br><span class="line">          <span class="string">'c-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将会发生这些步骤：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">|- a-loader `pitch`</span><br><span class="line">  |- b-loader `pitch`</span><br><span class="line">    |- c-loader `pitch`</span><br><span class="line">      |- requested module is picked up as a dependency</span><br><span class="line">    |- c-loader normal execution</span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure>

<p>那么，为什么 loader 可以利用 “跳跃(pitching)” 阶段呢？</p>
<p>首先，传递给 <code>pitch</code> 方法的 <code>data</code>，在执行阶段也会暴露在 <code>this.data</code> 之下，并且可以用于在循环时，捕获和共享前面的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content, <span class="keyword">this</span>.data.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span>(<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  data.value = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其次，如果某个 loader 在 <code>pitch</code> 方法中给出一个结果，那么这个过程会回过身来，并跳过剩下的 loader。在我们上面的例子中，如果 <code>b-loader</code> 的 <code>pitch</code> 方法返回了一些东西：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span>(<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someCondition()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'module.exports = require('</span> + <span class="built_in">JSON</span>.stringify(<span class="string">'-!'</span> + remainingRequest) + <span class="string">');'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的步骤将被缩短为：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">|- a-loader `pitch`</span><br><span class="line">  |- b-loader `pitch` returns a module</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack 性能优化方案</title>
    <url>/2020/02/08/webpack-performace-optimization/</url>
    <content><![CDATA[<p>webpack性能提升方案收集。</p>
<a id="more"></a>

<h2 id="DllPlugin-2020-02-08"><a href="#DllPlugin-2020-02-08" class="headerlink" title="DllPlugin(2020.02.08)"></a>DllPlugin(2020.02.08)</h2><p>我们在构建一个项目的过程中不可避免地会引入许多的第三方包，而这些第三方包在我们项目开发过程中不会有任何的变化，但是我们每次修改代码的时候去重新打包都会再次将这些代码分析一遍，非常影响效率。</p>
<p>那么有没有什么办法可以让这些第三方包只打包一次呢？</p>
<p>webpack官方就提供了一种解决方案。</p>
<p><code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。</p>
<h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a><code>DllPlugin</code></h3><p>这个插件是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 <code>manifest.json</code> 的文件，这个文件是用来让 <a href="https://webpack.docschina.org/plugins/dll-plugin#dllreferenceplugin" rel="external nofollow noopener noreferrer" target="_blank"><code>DLLReferencePlugin</code></a> 映射到相关的依赖上去的。</p>
<ul>
<li><code>context</code> (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))</li>
<li><code>name</code>: 暴露出的 DLL 的函数名 (<a href="https://github.com/webpack/webpack/blob/master/lib/TemplatedPathPlugin.js" rel="external nofollow noopener noreferrer" target="_blank">TemplatePaths</a>: <code>[hash]</code> &amp; <code>[name]</code> )</li>
<li><code>path</code>: manifest json 文件的<strong>绝对路径</strong> (输出文件)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllPlugin(options);</span><br></pre></td></tr></table></figure>

<p>在给定的 <code>path</code> 路径下创建一个名为 <code>manifest.json</code> 的文件。 这个文件包含了从 <code>require</code> 和 <code>import</code> 的request到模块 id 的映射。 <code>DLLReferencePlugin</code> 也会用到这个文件。</p>
<p>这个插件与 <a href="https://webpack.docschina.org/configuration/output/#output-library" rel="external nofollow noopener noreferrer" target="_blank"><code>output.library</code></a> 的选项相结合可以暴露出 (也叫做放入全局域) dll 函数。</p>
<h3 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a><code>DllReferencePlugin</code></h3><p>这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。</p>
<ul>
<li><code>context</code>: (<strong>绝对路径</strong>) manifest (或者是内容属性)中请求的上下文</li>
<li><code>manifest</code>: 包含 <code>content</code> 和 <code>name</code> 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径</li>
<li><code>content</code> (optional): 请求到模块 id 的映射 (默认值为 <code>manifest.content</code>)</li>
<li><code>name</code> (optional): dll 暴露的地方的名称 (默认值为 <code>manifest.name</code>) (可参考 <a href="https://webpack.docschina.org/configuration/externals/" rel="external nofollow noopener noreferrer" target="_blank"><code>externals</code></a>)</li>
<li><code>scope</code> (optional): dll 中内容的前缀</li>
<li><code>sourceType</code> (optional): dll 是如何暴露的 (<a href="https://webpack.docschina.org/configuration/output/#output-librarytarget" rel="external nofollow noopener noreferrer" target="_blank">libraryTarget</a>)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(options);</span><br></pre></td></tr></table></figure>

<p>通过引用 dll 的 manifest 文件来把依赖的名称映射到模块的 id 上，之后再在需要的时候通过内置的 <code>__webpack_require__</code> 函数来 <code>require</code> 他们</p>
<blockquote>
<p>与 <a href="https://webpack.docschina.org/configuration/output/#output-library" rel="external nofollow noopener noreferrer" target="_blank"><code>output.library</code></a> 保持 <code>name</code> 的一致性。</p>
</blockquote>
<h4 id="模式-Modes"><a href="#模式-Modes" class="headerlink" title="模式(Modes)"></a>模式(Modes)</h4><p>这个插件支持两种模式，分别是<em>作用域(scoped)</em>和<em>映射(mapped)</em>。</p>
<h5 id="作用域模式-Scoped-Mode"><a href="#作用域模式-Scoped-Mode" class="headerlink" title="作用域模式(Scoped Mode)"></a>作用域模式(Scoped Mode)</h5><p>dll 中的内容可以在模块前缀下才能被引用，举例来说，令<code>scope = &quot;xyz&quot;</code>的话，这个 dll 中的名为 <code>abc</code> 的文件可以通过 <code>require(&quot;xyz/abc&quot;)</code> 来获取</p>
<blockquote>
<p><a href="https://github.com/webpack/webpack/tree/master/examples/dll-user" rel="external nofollow noopener noreferrer" target="_blank">作用域的用例</a></p>
</blockquote>
<h5 id="映射模式-Mapped-Mode"><a href="#映射模式-Mapped-Mode" class="headerlink" title="映射模式(Mapped Mode)"></a>映射模式(Mapped Mode)</h5><p>dll 中的内容被映射到了当前目录下。如果一个被 <code>require</code> 的文件符合 dll 中的某个文件(解析之后)，那么这个dll中的这个文件就会被使用。</p>
<p>由于这是在解析了 dll 中每个文件之后才发生的，相同的路径必须能够确保这个 dll bundle 的使用者(不一定是人，可指某些代码)有权限访问。 举例来说， 假如一个 dll bundle 中含有 <code>loadash</code>库 以及 文件<code>abc</code>， 那么 <code>require(&quot;lodash&quot;)</code> 和 <code>require(&quot;./abc&quot;)</code> 都不会被编译进主要的 bundle文件，而是会被 dll 所使用。</p>
<h3 id="用法-Usage"><a href="#用法-Usage" class="headerlink" title="用法(Usage)"></a>用法(Usage)</h3><blockquote>
<p><code>DllReferencePlugin</code> 和 <code>DLL插件DllPlugin</code> 都是在_另外_的 webpack 设置中使用的。</p>
</blockquote>
<p><strong>webpack.vendor.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">  context: __dirname,</span><br><span class="line">  name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">  path: path.join(__dirname, <span class="string">'manifest.json'</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>webpack.app.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">  context: __dirname,</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'./manifest.json'</span>),</span><br><span class="line">  name: <span class="string">'./my-dll.js'</span>,</span><br><span class="line">  scope: <span class="string">'xyz'</span>,</span><br><span class="line">  sourceType: <span class="string">'commonjs2'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../../"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// mode: "development || "production",</span></span><br><span class="line">	resolve: &#123;</span><br><span class="line">		extensions: [<span class="string">".js"</span>, <span class="string">".jsx"</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">	entry: &#123;</span><br><span class="line">		alpha: [<span class="string">"./alpha"</span>, <span class="string">"./a"</span>, <span class="string">"module"</span>],</span><br><span class="line">		beta: [<span class="string">"./beta"</span>, <span class="string">"./b"</span>, <span class="string">"./c"</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">		filename: <span class="string">"MyDll.[name].js"</span>,</span><br><span class="line">		library: <span class="string">"[name]_[fullhash]"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">			path: path.join(__dirname, <span class="string">"dist"</span>, <span class="string">"[name]-manifest.json"</span>),</span><br><span class="line">			name: <span class="string">"[name]_[fullhash]"</span></span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先利用上述配置进行打包，会将entry中的模块进行打包，随后DllPlugin会将打包好的文件进行module id的映射，并将映射关系保存进manifest文件中</p>
<p>如根据上述配置，”./alpha”, “./a”, “module”三个包会被打包进 ./dist/MyDll.alpha.js中，同时这三个包的映射关系会被保存进 ./dist/alpha-manifest.json中。</p>
<p>同时打包好的文件会被暴露为output.library中规定的文件名被入口html引入。</p>
<p>而此时DllPlugin的name属性与libray是相同的，所以manifest中保存了这个library与三个模块之间的映射关系。</p>
<p>entry中的beta同理。</p>
<h4 id="webpack-config-js-1"><a href="#webpack-config-js-1" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../../"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	<span class="comment">// mode: "development || "production",</span></span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">			context: path.join(__dirname, <span class="string">".."</span>, <span class="string">"dll"</span>),</span><br><span class="line">			manifest: <span class="built_in">require</span>(<span class="string">"../dll/dist/alpha-manifest.json"</span>) <span class="comment">// eslint-disable-line</span></span><br><span class="line">		&#125;),</span><br><span class="line">		<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">			scope: <span class="string">"beta"</span>,</span><br><span class="line">			manifest: <span class="built_in">require</span>(<span class="string">"../dll/dist/beta-manifest.json"</span>), <span class="comment">// eslint-disable-line</span></span><br><span class="line">			extensions: [<span class="string">".js"</span>, <span class="string">".jsx"</span>]</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时再通过上述配置文件打包，当遇到了需要引入的模块时，就会先通过DllReferencePlugin插件就会去寻找前面打包好的manifest对应的模块，而不会去node_modules中去寻找，如果找不到才回去node_modules中寻找打包，这样就能有效提升第三方包的打包速度，只需要提前运行一次打包并生成dll，接下来的打包只需要去查看manifest就可以了。</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器渲染HTML过程</title>
    <url>/2020/05/14/what-does-browser-do-in-render/</url>
    <content><![CDATA[<h2 id="浏览器资源加载过程"><a href="#浏览器资源加载过程" class="headerlink" title="浏览器资源加载过程"></a>浏览器资源加载过程</h2><p>he<br>首先抛出两个问题：</p>
<ul>
<li>浏览器如何知道应该加载哪些资源？</li>
<li>浏览器是什么顺序来加载这些资源？</li>
</ul>
<p>当浏览器截获到一个页面，将会按顺序做下面四件事</p>
<ol>
<li>首先会将所有需要加载的资源进行分类。</li>
<li>然后根据浏览器相关的安全策略，来决定资源的加载权限。</li>
<li>接着对各个资源的加载优先级进行计算和排序。</li>
<li>最后一步，根据加载优先级顺序来加载资源。</li>
</ol>
<a id="more"></a>

<h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>chrome浏览器会将资源分为14类，如下表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>kMainResource</td>
<td>即主资源，html页面文件资源就属于该类型</td>
</tr>
<tr>
<td>kImage</td>
<td>各种图片资源</td>
</tr>
<tr>
<td>kCSSStyleSheet</td>
<td>顾名思义，就是层叠样式表css资源</td>
</tr>
<tr>
<td>kScript</td>
<td>脚本资源，例如js资源</td>
</tr>
<tr>
<td>kFont</td>
<td>字体资源，例如网页中常用的字体集.woff资源</td>
</tr>
<tr>
<td>kRaw</td>
<td>混合类型资源，最常见的ajax请求就属于这类资源</td>
</tr>
<tr>
<td>kSVGDocument</td>
<td>SVG可缩放矢量图形文件资源</td>
</tr>
<tr>
<td>kXSLStyleSheet</td>
<td>扩展样式表语言XSLT，是一种转换语言，关于该类型可以查阅w3c XSL来了解</td>
</tr>
<tr>
<td>kLinkPrefetch</td>
<td>HTML5页面的预读取资源(Link prefetch)，例如dns-prefetch。下面会有详细介绍</td>
</tr>
<tr>
<td>kTextTrack</td>
<td>video的字幕资源，- 即``标签</td>
</tr>
<tr>
<td>kImportResource</td>
<td>HTML Imports，将一个HTML文件导入到其他HTML文档中，例如``。详细了解请查阅相关文档。</td>
</tr>
<tr>
<td>kMedia</td>
<td>多媒体资源，video or audio都属于该类资源</td>
</tr>
<tr>
<td>kManifest</td>
<td>HTML5 应用程序缓存资源</td>
</tr>
<tr>
<td>kMock</td>
<td>预留的测试类型</td>
</tr>
</tbody></table>
<h3 id="安全策略检查"><a href="#安全策略检查" class="headerlink" title="安全策略检查"></a>安全策略检查</h3><p>网页安全政策（Content Security Policy，缩写 CSP）是由浏览器提供的一种白名单制度。开发者通过配置，来告诉浏览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用的应用就是通过限制非信任域名脚本的加载来预防XSS攻击。 可以通过两种方式来配置CSP。 第一种，就是通过页面HTTP请求头的Content-Security-Policy字段来限制。如下图所示，这是<a href="http://www.google.com页面的请求头：" rel="external nofollow noopener noreferrer" target="_blank">www.google.com页面的请求头：</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c40056914c841?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="流程">流程</p>
<p>第二种是，通过<code>标签来设置。</code>是以key-value的方式来进行配置的。下面以几个具体的应用例子来介绍。</p>
<ol>
<li>用于预防XSS:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; style-src nos.netease.com kaola.com;&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面的<code>script-src</code>代表脚本资源；<code>style-src</code>代表样式资源；<code>&#39;self&#39;</code>代表只信任当前域名下的外来资源，其他域下的资源全部会被拦截；<code>nos.netease.com kaola.com</code>代表信任nos.netease.com和kaola.com这两个域名下的资源。 所以上面的标签的意义就是：对于脚本资源只信任本域下的，对于样式资源，除了本域还会加载nos.netease.com和kaola.com这两个域名下的。</p>
<ol>
<li>用于站点请求协议升级过渡（http转https）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Secur****ity-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面的<code>upgrade-insecure-requests</code>的意义，就如同字面意思一样：升级所有非安全请求。当加了这个meta标签以后，浏览器会将https页面中的所有htttp请自动升级到https。例如，当我们需要进行全站http转https改造时，对于原有的大量http资源会直接强制以https或wss等SSL加密形式发送请求而不会报错。当然如果资源服务器不支持https等SSL加密，那么该资源还是不会载入。</p>
<ol>
<li>用于阻止Mixed Content：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;block-all-mixed-content&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>混合内容(Mixed Content)就是第2个例子所说的，在https站点中，进行的http请求。这类在安全链接中混合了非安全请求内容就叫混合内容。出现这类请求时，我们可以在浏览器控制台中找到对应的警告信息，如下图所示。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c40056936869b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="流程">流程</p>
<p>混合内容会降低HTTPS网站的安全性和用户体验。不过让人略感放心的是，浏览器对于可能对安全性造成较大威胁的资源类型的混合模式请求都会直接拦截报错，例如脚本资源，如下图所示。但对于图片、音频、视频等资源只会警告，但不会阻止其加载。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c40056950e6f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="流程">流程</p>
<p>对于安全性要求极高的网站，可以通过上面的标签来阻止所以类型的非安全链接请求，这样包括图片、音频、视频等资源也将会被拦截报错。 当然对于Content-Security-Policy的设置还有很多其他作用，大家可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/Using_Content_Security_Policy" rel="external nofollow noopener noreferrer" target="_blank">MDN</a>来做进一步了解。</p>
<h3 id="资源优先级计算"><a href="#资源优先级计算" class="headerlink" title="资源优先级计算"></a>资源优先级计算</h3><p>资源的优先级被分为<strong>5级</strong>。不同资料上，对这<strong>5级</strong>的命名描述上可能有所不同。主要是因为资料本身可能是从<strong>网络层面</strong>，<strong>浏览器内核</strong>或者<strong>用户端控制台显示</strong>这三个方向中的某一个来说的。这三个方向虽然对这<strong>5级</strong>的命名不同，但都是一一对应的。 <strong>网络层面</strong>，5级分别为：Highest、Medium、Low、Lowest、Idle; <strong>浏览器内核</strong>，5级分别为：VeryHigh、High、Medium、Low、VeryLow; <strong>用户端控制台显示</strong>，5级分别为：Highest、High、Medium、Low、Lowest;</p>
<p>下面是以<strong>浏览器内核</strong>作为研究方向，来介绍浏览器的资源优先级计算过程：</p>
<ul>
<li>第一步，根据资源的类型来设定默认优先级。 对于每一类资源浏览器都有一个默认的加载优先级规则：</li>
</ul>
<ol>
<li>html、css、font这三种类型的资源优先级最高；</li>
<li>然后是preload资源（通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" rel="external nofollow noopener noreferrer" target="_blank">``</a>标签预加载）、script、xhr请求；</li>
<li>接着是图片、语音、视频；</li>
<li>最低的是<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Link_prefetching_FAQ" rel="external nofollow noopener noreferrer" target="_blank">prefetch</a>预读取的资源。</li>
</ol>
<ul>
<li>第二步，根据一定的实际规则，对优先级进行调整。 初始优先级设置好以后，浏览器会根据资源的实际属性和位于文档中的位置等方面，对优先级进行调整，来确定出最终的加载优先级顺序。对于几个常见资源类型的调整规则如下：</li>
</ul>
<ol>
<li>对于<strong>XHR请求</strong>资源：将<strong>同步XHR请求</strong>的优先级调整为最高。 XHR请求可以分为同步请求和异步请求，浏览器会把同步请求的优先级提升到最高级，以便尽早获取数据、加快页面的显示。</li>
<li>对于<strong>图片</strong>资源：会根据图片是否在可见视图之内来改变优先级。 图片资源的默认优先级为Low。现代浏览器为了提高用户首屏的体验，在渲染时会计算图片资源是否在首屏可见视图之内，在的话，会将这部分视口可见图片(Image in viewport)资源的优先级提升为High。</li>
<li>对于<strong>脚本</strong>资源：浏览器会将根据脚本所处的位置和属性标签分为三类，分别设置优先级。 首先，对于添加了defer/async属性标签的脚本的优先级会全部降为Low。 然后，对于没有添加该属性的脚本，根据该脚本在文档中的位置是在浏览器展示的第一张图片之前还是之后，又可分为两类。在之前的<code>(标记early**)</code>它会被定为High优先级，在之后的<code>(标记late**)</code>会被设置为Medium优先级。</li>
</ol>
<h3 id="按照上面计算的安全策略和优先级来加载或阻塞资源。"><a href="#按照上面计算的安全策略和优先级来加载或阻塞资源。" class="headerlink" title="按照上面计算的安全策略和优先级来加载或阻塞资源。"></a>按照上面计算的安全策略和优先级来加载或阻塞资源。</h3><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><h3 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a><strong>关键渲染路径</strong></h3><p>提到页面渲染，有几个相关度非常高的概念，最重要的是关键渲染路径，其他几个概念都可以从它展开，下面稍作说明。</p>
<p><strong>关键渲染路径（Critical Rendering Path）</strong>是指与当前用户操作有关的内容。例如用户刚刚打开一个页面，首屏的显示就是当前用户操作相关的内容，具体就是浏览器收到 HTML、CSS 和 JavaScript 等资源并对其进行处理从而渲染出 Web 页面。</p>
<p>了解浏览器渲染的过程与原理，很大程度上是为了<strong>优化关键渲染路径</strong>，但优化应该是针对具体问题的解决方案，所以优化没有一定之规。例如为了保障<strong>首屏内容</strong>的最快速显示，通常会提到<strong>渐进式页面渲染</strong>，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。</p>
<p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面<a href="http://link.zhihu.com/?target=https%3A//developers.google.com/speed/docs/insights/mobile" rel="external nofollow noopener noreferrer" target="_blank">五件事情</a>上：</p>
<ol>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ol>
<p>本文讨论第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面<a href="http://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" rel="external nofollow noopener noreferrer" target="_blank">五个步骤</a>：</p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p>
<h3 id="阻塞渲染：CSS-与-JavaScript"><a href="#阻塞渲染：CSS-与-JavaScript" class="headerlink" title="阻塞渲染：CSS 与 JavaScript"></a><strong>阻塞渲染：CSS 与 JavaScript</strong></h3><p>谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。</p>
<p>同时，由于下面两点：</p>
<ol>
<li>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li>
<li>JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</li>
</ol>
<p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<ol>
<li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li>
<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>
<li>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</li>
</ol>
<p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<ol>
<li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li>
<li>JavaScript 应尽量少影响 DOM 的构建。</li>
</ol>
<p>浏览器的发展日益加快（目前的 Chrome 官方稳定版是 61），具体的渲染策略会不断进化，但了解这些原理后，就能想通它进化的逻辑。下面来看看 CSS 与 JavaScript 具体会怎样阻塞资源。</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a><strong>CSS</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red; &#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。</p>
<p>渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。</p>
<p>最容易想到的当然是<strong>精简 CSS 并尽快提供它</strong>。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;</span><br><span class="line">&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>第一个资源会加载并阻塞。<br>第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。<br>第三个资源提供了媒体查询，会在符合条件时阻塞渲染。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h3><p>JavaScript 的情况比 CSS 要更复杂一些。观察下面的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not go gentle into that good night,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage, rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not go gentle into that good night,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage, rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打算一次（加载、执行）。</p>
<p>所以实际工程中，我们常常将资源放到文档底部。</p>
<h3 id="改变阻塞模式：defer-与-async"><a href="#改变阻塞模式：defer-与-async" class="headerlink" title="改变阻塞模式：defer 与 async"></a><strong>改变阻塞模式：defer 与 async</strong></h3><p>为什么要将 script 加载的 defer 与 async 方式放到后面呢？因为这两种方式是的出现，全是由于前面讲的那些阻塞条件的存在。换句话说，defer 与 async 方式可以改变之前的那些阻塞情形。</p>
<p>首先，注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 按照从上到下的顺序输出 1 2 3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">"3"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a><strong>defer</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app1.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app2.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app3.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>
<p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a><strong>async</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ad.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"statistics.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>
<p>从上一段也能推出，多个 async-script 的执行顺序是不确定的。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true，下一节会继续这个话题。</p>
<h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement"></a><strong>document.createElement</strong></h3><p>使用 document.createElement 创建的 script 默认是异步的，示例如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。</p>
<p>如果使用 document.createElement 创建 link 标签会怎样呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">style.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">style.href = <span class="string">"index.css"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style); <span class="comment">// 阻塞？</span></span><br></pre></td></tr></table></figure>

<p>其实这只能通过试验确定，已知的是，Chrome 中已经<a href="http://link.zhihu.com/?target=https%3A//bugs.chromium.org/p/chromium/issues/detail%3Fid%3D571725" rel="external nofollow noopener noreferrer" target="_blank">不会阻塞渲染</a>，Firefox、IE 在以前是阻塞的，现在会怎样我没有试验。</p>
<h3 id="document-write-与-innerHTML"><a href="#document-write-与-innerHTML" class="headerlink" title="document.write 与 innerHTML"></a><strong>document.write 与 innerHTML</strong></h3><p>通过 document.write 添加的 link 或 script 标签都相当于添加在 document 中的标签，因为它操作的是 document stream（所以对于 loaded 状态的页面使用 document.write 会自动调用 document.open，这会覆盖原有文档内容）。即正常情况下， link 会阻塞渲染，script 会同步执行。不过这是不推荐的方式，Chrome 已经会显示警告，提示未来有可能禁止这样引入。如果给这种方式引入的 script 添加 async 属性，Chrome 会检查是否同源，对于非同源的 async-script 是不允许这么引入的。</p>
<p>如果使用 innerHTML 引入 script 标签，其中的 JavaScript 不会执行。当然，可以通过 eval() 来手工处理，不过不推荐。如果引入 link 标签，我试验过在 Chrome 中是可以起作用的。另外，outerHTML、insertAdjacentHTML() 应该也是相同的行为，我并没有试验。这三者应该用于文本的操作，即只使用它们添加 text 或普通 HTML Element。</p>
<h2 id="重排与重绘"><a href="#重排与重绘" class="headerlink" title="重排与重绘"></a>重排与重绘</h2><p>无论何时总会有一个初始化的页面布局伴随着一次绘制。（除非你希望你的页面是空白的:)）之后，每一次改变用于构建渲染树的信息都会导致以下至少一个的行为：</p>
<ol>
<li>部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为<strong>重排</strong>。注意这里至少会有一次重排-初始化页面布局。</li>
<li>由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为<strong>重绘</strong>。</li>
</ol>
<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓。</p>
<h3 id="什么情况会触发重排和重绘？"><a href="#什么情况会触发重排和重绘？" class="headerlink" title="什么情况会触发重排和重绘？"></a>什么情况会触发重排和重绘？</h3><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘。</p>
<ul>
<li>添加、删除、更新DOM节点</li>
<li>通过<code>display: none</code>隐藏一个DOM节点-触发重排和重绘</li>
<li>通过<code>visibility: hidden</code>隐藏一个DOM节点-只触发重绘，因为没有几何变化</li>
<li>移动或者给页面中的DOM节点添加动画</li>
<li>添加一个样式表，调整样式属性</li>
<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
</ul>
<p>参考链接：</p>
<p><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" rel="external nofollow noopener noreferrer" target="_blank">浏览器渲染过程</a></p>
<p><a href="https://juejin.im/post/5a4ed917f265da3e317df515" rel="external nofollow noopener noreferrer" target="_blank">浏览器资源加载</a></p>
<p><a href="https://juejin.im/entry/582f16fca22b9d006b7afd89" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/582f16fca22b9d006b7afd89</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
  <entry>
    <title>什么是 Serverless</title>
    <url>/2021/09/04/what-is-serverless/</url>
    <content><![CDATA[<p>什么是Serverless</p>
<p>Serverless，中文叫做无服务器。</p>
<p>无服务器是一种云原生开发模型，可使开发人员专注构建和运行应用，而无需管理服务器。</p>
<p>无服务器与其他云计算模型的区别在于，它是由云提供商负责管理云基础架构和应用扩展。无服务器应用部署在容器中，这些容器在被调用时会自动按需启动。</p>
<a id="more"></a>

<h2 id="X-aas"><a href="#X-aas" class="headerlink" title="(X)aas"></a>(X)aas</h2><p>IaaS、PaaS、SaaS、BaaS、FaaS，这些名词后面都带着aas三个字母，aas 是 As-a-Service，即为服务的意思。我们看下面这个架构图：</p>
<h3 id="IaaS、PaaS、SaaS"><a href="#IaaS、PaaS、SaaS" class="headerlink" title="IaaS、PaaS、SaaS"></a>IaaS、PaaS、SaaS</h3><p>云平台一般都会提供以上架构图中的三种云服务</p>
<p><strong>IaaS</strong>：Infrastructure as a Service（基础设施即服务</p>
<p>从上面的架构图可以看出，IaaS处于最底层，服务商提供底层/物理层基础设施资源（服务器，数据中心，环境控制，电源，服务器机房），客户自己部署和执行操作系统或应用程序等各种软件。</p>
<p>在标准的基础架构即服务（IaaS）云计算模型中，用户需要预先购买容量单元；也就是说，您要先向公共云提供商支付始终可用的服务器组件的费用，才能运行您的应用。 用户自行负责在需求高时扩展服务器容量，并在不再需要时缩减容量。即使在应用闲置不用期间，运行该应用所需的云基础架构也要保持就绪。</p>
<p><strong>PaaS</strong>：Platform as a Service（平台即服务）</p>
<p>PaaS处于中间层，服务商提供基础设施底层服务，提供操作系统（Windows，Linux）、数据库服务器、Web服务器、域控制器和其他中间件，以及服务模型中的备份服务等中件层服务。例如IIS，.NET，Apache，MySQL …，客户自己控制上层的应用程序部署与应用托管的环境。</p>
<p><strong>SaaS</strong>：Software as a Service（软件即服务）</p>
<p>SaaS处于最上层，服务商提供基于软件的解决方案，满足客户最终需求；如OA、CRM、MIS、ERP、HRM、CM、Office 365、iCloud、G Suite等应用，客户不需考虑任何形式的专业技术知识，获得完整的软件包，使他们的日常工作和生活变得更轻松。</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MzM1MDYxNmUzMTNmMDUxM2ZkMmZlNDYyYTA2ZTliZWVfbUxvQ3dseDRYend3d1hmWVpvdUpubGRPbms5a0JSZkhfVG9rZW46Ym94Y25ZOW9UQmI3eDY5d09ESzZGQ3F0WHgyXzE2MzA3NDA2ODQ6MTYzMDc0NDI4NF9WNA" alt="img"></p>
<h3 id="Baas，Faas"><a href="#Baas，Faas" class="headerlink" title="Baas，Faas"></a>Baas，Faas</h3><p>无服务器架构有事件触发应用代码运行时，公共云提供商才会为这一代码分配资源。该代码执行结束后，用户便不再付费。除了成本与效率上的优势外，无服务器也能将开发人员从应用扩展和服务器置备相关的琐碎日常任务中解放出来。</p>
<p>使用Serverless时，管理操作系统和文件系统、安全补丁、负载平衡、容量管理、扩展、日志和监控等例行任务都由云服务提供商分担。</p>
<p>在无服务器模型中，云提供商负责运行物理服务器并代表用户动态分配资源，用户则可以直接将代码部署到生产环境中。</p>
<p>无服务器计算产品通常分为两类，分别是后端即服务（BaaS）和功能即服务（FaaS）。  </p>
<p>BaaS 可让开发人员访问各种各样的第三方服务和应用。例如，云提供商可以提供认证服务、额外加密、云访问数据库以及高置信度使用数据。在 BaaS 中，无服务器功能通常通过应用编程接口（API）调用。也可以理解为BaaS = IaaS + PaaS + APIs + SDKs，即服务提供商提供了大量的功能，使用方只需要接入sdk，然后使用其api即可。</p>
<p>在大多数情况下，<strong>当开发人员提到无服务器时，他们所指的基本是</strong> <strong>FaaS</strong> <strong>模型</strong>。在 FaaS 下，开发人员仍然要编写自定义服务器端逻辑，但它可以在完全由云服务提供商管理的容器中运行。 </p>
<p>一般情况下，云平台的计算费用取决于调用次数，执行时长，内存消耗。所以如果这个函数的功能代码写得不好，调用次数非常多，执行时间特别长，或者消耗了大量的内存，那么价格就会很贵。</p>
<p>一般和BaaS结合，开发一些项目所需的特殊计算，只为实际计算量付费。</p>
<p>那么这种服务适合用于计算量偶尔比较高，但是一般情况没有计算量，或者计算量低的服务</p>
<p>Baas和Faas看起来介于Paas和Saas之间，可以让开发者只关注如何应用的逻辑，而Baas和Faas的区别在，Baas提供各种后台服务的接口，如认证服务等，像是一个个可以配置的插件，而Faas则就是简单的逻辑，你的代码对于数据库的crud可能只是简单的一行代码，无论后台是mysql还是sqlserver。</p>
]]></content>
  </entry>
  <entry>
    <title>Zap的使用与漏洞修复</title>
    <url>/2020/11/06/zap-and-express/</url>
    <content><![CDATA[<p>这周POC了几个渗透测试工具，分别是Burp Suite，OWASP Zap。</p>
<p>其中Burp的很多功能都是收费的，免费版基本只是用来做请求拦截的。</p>
<p>所以最后选择Zap对一个Express项目进行了扫描了漏洞修复，这里简单记录一下Zap的使用教程，以及Express的一些安全实践。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Zap的安装十分简单，直接去官网<a href="https://www.zaproxy.org/下载然后一步步安装就好。" rel="external nofollow noopener noreferrer" target="_blank">https://www.zaproxy.org/下载然后一步步安装就好。</a></p>
<h2 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h2><p>Zap的原理其实就是起了一个代理，然后我们通过配置浏览器的代理策略将需要测试的请求导向代理，Zap会记录并分析这些请求，并尝试进行攻击。</p>
<p>所以第一步就是配置代理，这一步可以去看官网的文档：<a href="https://www.zaproxy.org/docs/desktop/start/proxies/" rel="external nofollow noopener noreferrer" target="_blank">https://www.zaproxy.org/docs/desktop/start/proxies/</a></p>
<p>这里要注意一点，Zap2.9.0只支持chrome和firefox浏览器，而且<strong>对于chrome的支持应该只到79版本，笔者的86版本chrome一启动就会crash。</strong></p>
<p>关于firefox的代理配置，大家直接去看官网就行了，简直就是保姆级别的教程。</p>
<p>笔者这里需要提醒的一点是，文档中的一个提示，这个提示是关于localhost的配置，由于这个提示没有用特殊的格式，所以容易被忽略：</p>
<p><strong>Note:</strong> To proxy <code>localhost</code> (and related addresses) with newer Firefox versions (&gt;= 67) the preference <code>network.proxy.allow_hijacking_localhost</code> (accessible through the <code>about:config</code> page) must be set to <code>true</code>.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Zap-Hub"><a href="#Zap-Hub" class="headerlink" title="Zap Hub"></a>Zap Hub</h3><p>Zap Hub是zap提供的一个非常使用的工具集，它其实就是把Zap的客户端的功能都加了个入口添加在浏览器的两侧，可以让我们在测试过程中不需要来回切换浏览器和Zap。</p>
<p>当然我们不用Zap Hub也是可以的，但如果你想用却发现Zap Hub没有加载：</p>
<ul>
<li>检查下是不是Zap没有开Hub。</li>
<li>如果开了，看看Hub是不是被项目本身的一些安全策略给拦截了，比如CSP</li>
</ul>
<p>如果第一次加载Zap Hub，它还会提示你是否进入新手教程，这个教程做的非常详细，会指导你一步步操作，也比较啰嗦，如果急于使用，可以先看看我下面的截图说明：</p>
<p><img src="https://res.cloudinary.com/dvtfhjxi4/image/upload/v1604662591/Security/WeChat_Screenshot_20201106193621_gkboit.png" alt></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Zap客户端得功能和Hub没什么出入，知道了怎么用Hub，自然就会用客户端</p>
<p>但这里要提醒大家一点：<strong>一开始最好使用被动扫描的形式去扫面一个网站，只有你确认你可以对一个网站进行出动扫描，再去进行主动扫描，因为主动扫描会尝试各种方案去对目标网站进行攻击。</strong></p>
<h2 id="Express安全实践"><a href="#Express安全实践" class="headerlink" title="Express安全实践"></a>Express安全实践</h2><p>当我们完成对一个网站的扫描之后，就可以导出扫描报告，可以有很多种格式选择。</p>
<p>笔者导出报告之后，虽然没有几个漏洞，但是还是那些老生常谈的问题，XSS，SqlInjection，MIME嗅探等。</p>
<p>不过这也说明了这些问题的普遍性，甚至是防不胜防。</p>
<p>这里总结整理几点Express的安全实践：</p>
<h3 id="请勿使用不推荐或者存在漏洞的-Express-版本"><a href="#请勿使用不推荐或者存在漏洞的-Express-版本" class="headerlink" title="请勿使用不推荐或者存在漏洞的 Express 版本"></a>请勿使用不推荐或者存在漏洞的 Express 版本</h3><p>Express 2.x 和 3.x 不再得到维护。不会纠正这些版本中的安全问题和性能问题。请勿使用这些版本！如果您尚未迁移到 V4，请按照<a href="https://expressjs.com/zh-cn/guide/migrating-4.html" rel="external nofollow noopener noreferrer" target="_blank">迁移指南</a>进行迁移。</p>
<p>还请确保您未使用<a href="https://expressjs.com/zh-cn/advanced/security-updates.html" rel="external nofollow noopener noreferrer" target="_blank">安全性更新页面</a>中列出的任何存在漏洞的 Express 版本。如果在使用，请更新到某个稳定发行版，首选为最新版本。</p>
<h3 id="使用-TLS"><a href="#使用-TLS" class="headerlink" title="使用 TLS"></a>使用 TLS</h3><p>如果应用程序处理或传输敏感数据，请使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="external nofollow noopener noreferrer" target="_blank">传输层安全性</a> (TLS) 来保护连接和数据。这种技术用于加密数据，然后将其从客户机发送到服务器，以防止某些常见的（而且容易的）黑客攻击。虽然 Ajax 和 POST 请求可能不是很明显，似乎“隐藏”在浏览器中，但是其网络流量很容易受到<a href="https://en.wikipedia.org/wiki/Packet_analyzer" rel="external nofollow noopener noreferrer" target="_blank">包嗅探</a>攻击和<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="external nofollow noopener noreferrer" target="_blank">中间人攻击</a>。</p>
<p>您可能很熟悉安全套接字层 (SSL) 加密。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380515(v=vs.85" rel="external nofollow noopener noreferrer" target="_blank">TLS 就是下一代的 SSL</a>。换言之，如果您以前使用 SSL，请考虑升级到 TLS。一般而言，我们建议使用 Nginx 来处理 TLS。要获取在 Nginx（和其他服务器）上配置 TLS 的优秀参考信息，请参阅 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_Server_Configurations" rel="external nofollow noopener noreferrer" target="_blank">Recommended Server Configurations</a> (Mozilla Wiki)。</p>
<p>此外，可以使用一种方便的 <a href="https://letsencrypt.org/about/" rel="external nofollow noopener noreferrer" target="_blank">Let’s Encrypt</a> 工具来获取免费的 TLS 证书，这是由<a href="https://letsencrypt.org/isrg/" rel="external nofollow noopener noreferrer" target="_blank">因特网安全研究组 (ISRG)</a> 提供的免费、自动化的开放式认证中心 (CA)。</p>
<h3 id="使用-Helmet"><a href="#使用-Helmet" class="headerlink" title="使用 Helmet"></a>使用 Helmet</h3><p><a href="https://www.npmjs.com/package/helmet" rel="external nofollow noopener noreferrer" target="_blank">Helmet</a> 通过适当地设置 HTTP 头，帮助您保护应用程序避免一些众所周知的 Web 漏洞。</p>
<p>Helmet 实际上只使用以下九个较小中间件函数的集合，这些功能用于设置与安全相关的 HTTP 头：</p>
<ul>
<li><a href="https://github.com/helmetjs/csp" rel="external nofollow noopener noreferrer" target="_blank">csp</a> 用于设置 <code>Content-Security-Policy</code> 头，帮助抵御跨站点脚本编制攻击和其他跨站点注入攻击。</li>
<li><a href="https://github.com/helmetjs/hide-powered-by" rel="external nofollow noopener noreferrer" target="_blank">hidePoweredBy</a> 用于移除 <code>X-Powered-By</code> 头。</li>
<li><a href="https://github.com/helmetjs/hsts" rel="external nofollow noopener noreferrer" target="_blank">hsts</a> 用于设置 <code>Strict-Transport-Security</code> 头，实施安全的服务器连接 (HTTP over SSL/TLS)。</li>
<li><a href="https://github.com/helmetjs/ienoopen" rel="external nofollow noopener noreferrer" target="_blank">ieNoOpen</a> 用于为 IE8+ 设置 <code>X-Download-Options</code>。</li>
<li><a href="https://github.com/helmetjs/nocache" rel="external nofollow noopener noreferrer" target="_blank">noCache</a> 用于设置 <code>Cache-Control</code> 和 Pragma 头，以禁用客户端高速缓存。</li>
<li><a href="https://github.com/helmetjs/dont-sniff-mimetype" rel="external nofollow noopener noreferrer" target="_blank">noSniff</a> 用于设置 <code>X-Content-Type-Options</code>，以防止攻击者以 MIME 方式嗅探浏览器发出的响应中声明的 content-type。</li>
<li><a href="https://github.com/helmetjs/frameguard" rel="external nofollow noopener noreferrer" target="_blank">frameguard</a> 用于设置 <code>X-Frame-Options</code> 头，提供 <a href="https://www.owasp.org/index.php/Clickjacking" rel="external nofollow noopener noreferrer" target="_blank">clickjacking</a> 保护。</li>
<li><a href="https://github.com/helmetjs/x-xss-protection" rel="external nofollow noopener noreferrer" target="_blank">xssFilter</a> 用于设置 <code>X-XSS-Protection</code>，在最新的 Web 浏览器中启用跨站点脚本编制 (XSS) 过滤器。</li>
</ul>
<p>像安装其他模块一样安装 Helmet：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install --save helmet</span><br></pre></td></tr></table></figure>

<p>然后将其用于您的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> helmet = <span class="built_in">require</span>(<span class="string">'helmet'</span>);</span><br><span class="line">app.use(helmet());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="至少禁用-X-Powered-By-头"><a href="#至少禁用-X-Powered-By-头" class="headerlink" title="至少禁用 X-Powered-By 头"></a>至少禁用 X-Powered-By 头</h4><p>如果不希望使用 Helmet，那么至少应禁用 <code>X-Powered-By</code> 头。攻击者可能会使用该头（缺省情况下已启用）来检测运行 Express 的应用程序，然后发动针对特定目标的攻击。</p>
<p>所以，最佳实践是使用 <code>app.disable()</code> 方法禁用此头：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.disable(<span class="string">'x-powered-by'</span>);</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>helmet.js</code>，它会为您执行此功能。</p>
<h3 id="安全地使用-cookie"><a href="#安全地使用-cookie" class="headerlink" title="安全地使用 cookie"></a>安全地使用 cookie</h3><p>要确保 cookie 不会打开应用程序使其暴露在风险之中，请勿使用缺省会话 cookie 名称并相应地设置 cookie 安全选项。</p>
<p>有两个主要的中间件 cookie 会话模块：</p>
<ul>
<li><a href="https://www.npmjs.com/package/express-session" rel="external nofollow noopener noreferrer" target="_blank">express-session</a>，用于替换 Express 3.x 内置的 <code>express.session</code> 中间件。</li>
<li><a href="https://www.npmjs.com/package/cookie-session" rel="external nofollow noopener noreferrer" target="_blank">cookie-session</a>，用于替换 Express 3.x 内置的 <code>express.cookieSession</code> 中间件。</li>
</ul>
<p>这两个模块之间的主要差异是它们保存 cookie 会话数据的方式。<a href="https://www.npmjs.com/package/express-session" rel="external nofollow noopener noreferrer" target="_blank">express-session</a> 中间件将会话数据存储在服务器上；它仅将会话标识（而非会话数据）保存在 cookie 中。缺省情况下，它使用内存中存储，并不旨在用于生产环境。在生产环境中，需要设置可扩展的会话存储；请参阅<a href="https://github.com/expressjs/session#compatible-session-stores" rel="external nofollow noopener noreferrer" target="_blank">兼容的会话存储</a>列表。</p>
<p>相反，<a href="https://www.npmjs.com/package/cookie-session" rel="external nofollow noopener noreferrer" target="_blank">cookie-session</a> 中间件实现 cookie 支持的存储：它将整个会话序列化到 cookie 中，而不只是会话键。仅当会话数据相对较小，且易于编码为原语值（而不是对象）时，才使用此中间件。尽管假设浏览器支持每个 cookie 至少 4096 字节以确保不会超过限制，但是每个域的大小不会超过 4093 字节。另外请注意，客户机可以访问 cookie 数据，所以，如果有任何理由将其保持安全或隐藏状态，那么 express-session 可能是更好的选择。</p>
<h4 id="请勿使用缺省会话-cookie-名称"><a href="#请勿使用缺省会话-cookie-名称" class="headerlink" title="请勿使用缺省会话 cookie 名称"></a>请勿使用缺省会话 cookie 名称</h4><p>使用缺省会话 cookie 名称会使应用程序对攻击敞开大门。<code>X-Powered-By</code> 之类的值会造成问题：潜在攻击者可以利用这样的值对服务器采集“指纹”，并相应地确定攻击目标。</p>
<p>为避免此问题，请使用通用 cookie 名称；例如，使用 <a href="https://www.npmjs.com/package/express-session" rel="external nofollow noopener noreferrer" target="_blank">express-session</a> 中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line">app.set(<span class="string">'trust proxy'</span>, <span class="number">1</span>) <span class="comment">// trust first proxy</span></span><br><span class="line">app.use( session(&#123;</span><br><span class="line">   secret : <span class="string">'s3Cur3'</span>,</span><br><span class="line">   name : <span class="string">'sessionId'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="设置-cookie-安全性选项"><a href="#设置-cookie-安全性选项" class="headerlink" title="设置 cookie 安全性选项"></a>设置 cookie 安全性选项</h5><p>设置以下 cookie 选项来增强安全性：</p>
<ul>
<li><code>secure</code> - 确保浏览器只通过 HTTPS 发送 cookie。</li>
<li><code>httpOnly</code> - 确保 cookie 只通过 HTTP(S)（而不是客户机 JavaScript）发送，这有助于防御跨站点脚本编制攻击。</li>
<li><code>domain</code> - 表示 cookie 的域；用于和请求 URL 的服务器的域进行比较。如果匹配，那么接下来检查路径属性。</li>
<li><code>path</code> - 表示 cookie 的路径；用于和请求路径进行比较。如果路径和域都匹配，那么在请求中发送 cookie。</li>
<li><code>expires</code> - 用于为持久性 cookie 设置到期日期。</li>
</ul>
<p>以下是使用 <a href="https://www.npmjs.com/package/cookie-session" rel="external nofollow noopener noreferrer" target="_blank">cookie-session</a> 中间件的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'cookie-session'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expiryDate = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="built_in">Date</span>.now() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> ); <span class="comment">// 1 hour</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  name: <span class="string">'session'</span>,</span><br><span class="line">  keys: [<span class="string">'key1'</span>, <span class="string">'key2'</span>],</span><br><span class="line">  cookie: &#123; <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">            httpOnly: <span class="literal">true</span>,</span><br><span class="line">            domain: <span class="string">'example.com'</span>,</span><br><span class="line">            path: <span class="string">'foo/bar'</span>,</span><br><span class="line">            expires: expiryDate</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="确保依赖项的安全"><a href="#确保依赖项的安全" class="headerlink" title="确保依赖项的安全"></a>确保依赖项的安全</h3><p>npm本身带有依赖检查工具，<code>npm audit</code>，非常好用，这是文档，文档很短，使用起来也很简单：<a href="https://docs.npmjs.com/cli/v6/commands/npm-audit/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.npmjs.com/cli/v6/commands/npm-audit/</a></p>
]]></content>
      <categories>
        <category>Sundry</category>
      </categories>
  </entry>
</search>
